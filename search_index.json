[["index.html", "R 프로그래밍 3판 (draft) Preface 1판 서문 2판 서문 3판 서문 일러두기", " R 프로그래밍 3판 (draft) Kilhwan Kim 2024-11-21 Preface 1판 서문 이 책을 쓰게 된 동기를 설명하기에 앞서 개인적인 경력을 밝히는 것이 좋겠다. 저자는 경영과학과 산업공학을 전공하였기 때문에 대학과 대학원 시절 통계학에 대한 다양한 강의를 수강하였고, Minitab, SPSS, SAS 등의 통계 패키지도 접할 기회를 가졌다. 그러나 정작 졸업 후 경력의 대부분을 IT 업계에서 보내며 통계 분석과는 동떨어진 정보시스템 개발과 컨설팅 업무를 주로 수행하였다. 그러는 과정에서 저자는 C, Java, JavaScript 등의 다양한 프로그래밍 언어를 다루게 되었고 시스템 개발에 대한 폭넓은 이해를 하게 되었다. 세월이 흘러 저자는 박사과정에 진학하여 대학교에 교편을 잡게 되었고, 세상은 바야흐로 빅데이터의 시대로 접어들어 R이 데이터 분석의 강력한 수단으로 각광받게 되었다. 물론 R은 이전부터 통계 전문가들 사이에선 잘 알려져 있었지만, 지금처럼 많은 분야에서 주목받지는 못했다. 이러한 흐름에 맞추어 저자는 여러 해 동안 R을 이용한 통계 분석 및 데이터 마이닝을 공부해 왔고 관련된 강의와 연구 프로젝트도 수행하게 되었다. 이 책은 저자가 R을 공부할 때 느낀 불만족스러운 부분에서 시작되었다. 현재 국내에는 R을 이용하고자 하는 두 부류의 집단이 있는 것 같다. 한 부류는 통계학과 유사 학문을 전공한 사람들로 R에 대해서는 프로그래밍 언어적 측면보다는 데이터 분석 패키지로서 관심이 많다. 이 부류의 사람들은 즉각적인 데이터 분석을 위해 임의적인 방식으로 R의 명령어를 사용하는 것을 선호한다. 다른 부류는 IT 전문가로서 빅데이터 분석에 대한 시대적 요구가 커짐에 따라 R에 관심을 갖게 된 사람들이다. 이들은 통계나 수학적 배경 지식은 약하나 프로그래밍 언어에 대한 이해가 높은 사람들로서, R을 체계적인 방식으로 사용하여 시스템을 구축하는데 관심이 많다. 그런데 국내의 R 관련 서적들은 대부분 R을 통계 분석과 데이터 마이닝 알고리즘을 수행할 수 있는 단편적인 명령어 중심으로 소개하고 있다. R의 프로그래밍 언어로서의 측면을 체계적인 방식으로 다루는 책은 오히려 드문 편이다. 저자가 판단하기에 국내 서적 중 R의 프로그래밍 언어적 측면을 본격적으로 다룬 유일한 책이 Norman Matloff의 The Art of R Programming의 번역본이 아닐까 한다. 다행히 저자는 부족하나마 통계학과 데이터 마이닝에 대한 지식과 경험, 그리고 프로그래밍 언어에 대한 지식과 시스템 개발 경험을 두루 갖출 수 있었다. 물론 두 분야의 전문가가 보면 부족한 수준일 것이다. 그러나 이러한 양 분야의 지식과 경험이 저자에게 R을 매우 종합적으로 조망하게 해 주었다. 그 결과 R을 단순하게 통계 분석의 툴로서만 이용하는 사람들에게 R의 프로그래밍 언어적 특성을 체계적으로 알려주는 게 필요하다고 판단하게 되었다. 왜냐하면, 빅데이터 분석을 위해서는 선진 데이터 분석 알고리즘을 깊이 이해하고 적용하는 것만큼이나, 대규모 데이터를 시스템적으로 처리하는 프로그래밍 기술이 중요해지기 때문이다. 따라서 앞으로 데이터 분석가가 시스템 개발에 직접 참여하게 될 일들이 점차 많아질 것이고, 자신이 가장 익숙한 언어로 프로그램을 개발할 수 있는 능력은 중요한 핵심역량이 될 것이다. 이 책은 통계 및 데이터 마이닝을 공부하는 학생이나 전문가가 R의 프로그래밍 언어적 특성을 이해하는 것을 돕기 위해 집필되었다. 그러나 역으로 프로그래밍 언어에 익숙한 독자가 R의 특성을 파악하는 데에도 도움을 주리라 생각된다. 다른 프로그램 언어에 이미 익숙한 저자로서는 R을 공부할 때 답답했던 측면 중 하나가 R의 프로그램 언어적 특성을 명확하게 설명해 주는 자료가 흔치 않다는 점이었다. R이 기존의 프로그래밍 언어와 다르게 작동되는 부분을 만날 때마다 어리둥절함에 빠질 때가 많았기 때문이다. 이 책은 저자가 몸담고 있는 대학의 강의를 위해 준비했던 자료를 기반으로 원고가 작성되었다. 부족한 지식이나마 책으로 펼칠 수 있도록 격려해 주신 학과 교수님들과, 부족한 강의를 들으며 다양한 피드백을 해준 상명대학교 경영공학과 학생들에게 감사의 말씀을 전한다. 아울러 이 책을 준비할 때 물심양면 지원해준 가족에게도 감사의 말을 전한다. 2017년 2월 상명대학교 천안캠퍼스에서 김길환 2판 서문 1판이 출간된지 3년 반이 지났습니다. 1판을 작성하였을 때는 R의 버전이 3이었지만 현재 버전 4가 출시되어 사용되고 있습니다. R의 기본 기능은 크게 바뀌지 않았지만 데이터 프레임의 처리 방식 등에 근본적인 변화가 있었습니다. 아울러 Hadley Wickham의 tidyverse 패키지가 R 작업의 표준으로 자리잡아 가고 있습니다. 2판은 이러한 변화를 반영하였습니다. 기존의 데이터 변환과 관련된 내용을 모두 R의 기본 기능을 사용하는 방식에서 tidyverse 패키지를 사용하는 방식으로 바꾸었습니다. 그래픽과 시각화와 관련된 내용도 R의 기본 graphics 패키지 대신 ggplot2 패키지를 사용하도록 변경하였습니다. 현재까지 2판은 완성되지 않았습니다. 강의와 더불어 2판은 조금씩 수정돼 나갈 것입니다. 온라인 상에서 수정된 내용을 계속 확인하실 수 있습니다. 그러므로 2판의 서문도 계속 바뀌어져 나갈 것입니다. 2020년 8월 상명대학교 천안캠퍼스에서 2판 초안을 마무리하며 김길환 2판의 주요 개정 (2022년 7월 이후부터) 2022/8/3: R 4.2 버전의 변경 사항 반영: if 조건문에서 여러 논리값을 가지는 경우에 대한 내용 변경 Appendix에 R과 Python 연동 방안 추가 2022/8/31 윈도우즈에서 winget을 이용한 R 및 RStudio 설치 방법 추가 2022/10/12 readxl과 writexl을 이용한 Excel 데이터 읽고 쓰는 방법 추가 6.6 절 예제로 사용된 파일을 본문에 첨부 2023/3/13 dplyr 패키지의 slice 함수에 대한 설명 추가 2023/11/29 9 장에 데이터 열의 형식 바꾸기 추가 2023/12/14 B 장에 파일 및 폴더 관련 R 명령어 추가 3판 서문 3 판에서 가장 큰 변화는 책을 크게 R 프로그래밍 기초와 R 프로그래밍 응용 편으로 나눈 것입니다. R 프로그래밍 기초 편은 2 판의 구성과 동일합니다. 단지 바뀐 부분은 6.6과 6.7 절에서 Excel 파일과 관련 내용을 12.2.1 절로 옮긴 것뿐입니다. R 프로그래밍 응용 편은 이 판에서 새롭게 추가된 부분으로, R을 이용하여 데이터를 수집하고 분석하는 방법을 다룹니다. R 프로그래밍 응용 편의 장들은 하나씩 작성 중이기 때문에 작성이 완료될 때마다 추가될 예정입니다. 2024/10/28 12 장 R 데이터 수집 초안 공개 2024/11/03 13 장 R 동적 문서 초안 공개 2024/11/10 14 장 R 차원 축소 초안 공개 2024/11/17 15 장 R 군집 분석 초안 공개 2024/11/21 16 장 R 통계적 가설검정 초안 공개 일러두기 절의 제목 뒤에 * 표시가 있는 절은 처음 R을 접하는 초심자는 건너뛰어도 되는 내용들이다. 이러한 절들은 R의 프로그래밍 언어로서의 특징과 세부사항을 더 잘 이해하고 싶은 독자들을 위한 내용이다. 이 책은 R의 프로그래밍 언어적 특성을 주로 다루고 있다. R을 이용한 통계분석 방법을 배우기를 원하는 독자는 졸저 R을 이용한 통계 분석이나 다른 책 등을 참고하기 바란다. "],["ch-intro.html", "Chapter 1 R 설치 및 시작 1.1 R 소개 1.2 R 설치하기 1.3 RStudio 1.4 RStudio로 R 시작하기", " Chapter 1 R 설치 및 시작 1.1 R 소개 R은 통계 계산과 그래픽을 위한 프로그래밍 언어이자 소프트웨어 환경이다. R은 1960년대와 1970년대 Bell 연구소에서 개발된 S라는 데이터 처리 언어에 기반을 두고 있다. 1990년대 중반 뉴질랜드 오클랜드 대학의 로스 이하카와 로버트 젠틀맨에 의해 시작되어 현재는 R의 핵심 기능은 R 코어 팀이, 다양한 추가 기능은 자발적 기여자들에 의해 개발되고 있다. R은 GPL 하에 배포되는 공개 소프트웨어로 누구나 자유롭게 이용할 수 있다. R은 빅데이터 분석에 널리 사용되고 있으며, 패키지 개발이 용이하여 통계 분석가들 사이에서 통계 소프트웨어 개발에 많이 쓰이고 있다. R은 데이터 조작, 계산, 그래픽 표현을 위한 소프트웨어이다. R의 주요 기능은 다음과 같다. 효율적이고 편련한 데이터 조작 및 처리 기능 데이터를 다양한 그래프로 표현해주는 데이터 시각화 기능 통계 분석 및 데이터 마이닝 알고리즘 수행 기능 분석 결과를 문서 및 발표 자료로 생성하는 기능 간단하며 효과적인 프로그래밍 언어로서의 기능 이 장에서는 R을 설치하고 실행하는 방법과 R의 개괄적인 기능을 소개한다. 1.2 R 설치하기 R 설치는 윈도우즈가 설치된 컴퓨터를 기준으로 설명한다. 1.2.1 R을 윈도우즈에 설치할 때 주의 사항 한글 윈도우에서 R과 RStudio를 설치하여 사용할 때 이유를 알 수 없는 여러 문제가 발생할 수 있다. 이러한 문제의 대부분은 파일과 디렉토리(폴더)의 경로명에 한글이 들어간 경우에 발생한다. 특히 윈도우 사용자 이름이 한글인 경우 이러한 문제가 빈번히 발생하는데, R이나 RStudio가 사용자 폴더의 하위 폴더에 필요한 파일과 디렉토리를 만들기 때문이다. 이러한 문제를 미연에 방지하려면 설치 전에 윈도우 사용자 이름이 한글인지 확인하고, 한글이면 영문 사용자 이름으로 관리자 계정을 하나 더 만들어 그 계정으로 R과 RStudio의 설치를 진행하는 것이 좋다. 물론 한글 사용자 이름을 사용하더라도 환경변수의 임시 디렉토리 설정을 변경하여 발생할 수 있는 대부분의 문제를 해결할 수 있지만, 새로운 패키지나 함수를 사용할 때마다 이러한 문제가 잠복되어 있다가 다른 방식으로 다시 발생할 수 있다. R에 대한 이해가 높지 않은 초심자의 경우 이러한 문제가 발생하면 문제의 원인을 파악하기 어렵다. 그렇기 때문에 영문 이름으로 된 관리자 권한의 사용자로서 R과 RStudio를 설치하기를 강력히 권장한다. 1.2.2 winget 명령어로 설치하기 winget 명령어를 사용하면 R의 설치, 제거 등을 하나의 명령어로 수행할 수 있어 편리하다. winget 명령줄 도구는 윈도우즈의 앱 설치 관리자로 윈도우즈 11이나 최신 버전의 윈도우즈 10에는 이미 설치되어 있다. 만약 winget 명령줄 도구가 설치되어 있지 않으면 Microsoft Store에서 앱 설치 관리자를 설치하거나 업데이트하면 winget 명령을 사용할 수 있다. winget에 대한 자세한 설명은 Microsoft의 공식 문서나 인터넷 상의 자료를 참조하기 바란다. winget이 설치되어 있으면 cmd 창이나 윈도우즈 Power Shell 창에서 다음 명령을 수행한다. 참고로 cmd 창은 윈도우즈 검색 창에 cmd라고 검색하면 cmd 창을 실행시킬 수 있다.) winget install --id RProject.R 이 명령을 실행하면 R 배포판을 내려받고 설치 관리자를 자동 실행할 것이다. 관련된 물음에 ’Yes’라고 대답하면 설치가 실행될 것이다. 처음 winget을 실행하는 경우에는 winget에 대한 안내 메시지가 나올 수 있다. R 이전 버전이 설치되어 있다면 다음 명령을 먼저 실행하여 이전 버전을 제거한다. winget uninstall --id RProject.R R 설치 관리자는 자동으로 이전 버전을 제거하지 않기 때문에 최신 버전을 설치하기 전에 이전 버전을 제거하는 것이 좋다. 경우에 따라서는 winget이 이전에 설치된 R을 제거하지 못할 때도 있다. 이 경우에는 윈도우즈 설정에서 직접 R 이전 버전을 제거한다. 만약 winget 명령어를 사용할 수 없으면, 아래 내용처럼 R 배포판을 직접 내려받아 설치한다. 1.2.3 R 배포판 내려받기 앞 절에서 winget을 사용하여 R을 설치하였으면 이 절의 내용은 수행하지 않고 1.3 절로 가서 RStudio를 설치하도록 한다. 이 절은 winget으로 R을 설치하지 못하였거나, 윈도우즈 이외의 운영체제를 사용하는 독자를 위해 R을 직접 내려받아 설치하는 방법을 설명한다. R을 설치하기 위해서는 R 배포판을 먼저 구해야 한다. R은 공개 소프트웨어이므로 무료로 R 공식 웹 사이트에서 내려받을 수 있다. R 공식 사이트의 첫 화면의 내용 중 download R 을 클릭하면 R 배포판을 내려받기할 CRAN 미러를 선택하는 화면으로 이동하게 된다. 지리적으로 가까운 CRAN 미러 서버를 선택하거나, 맨 위의 “0-Cloud”를 선택한다. 그러면 설치할 R 배포판을 선택하는 화면으로 이동한다. R 배포판을 선택하는 화면에서 Download R for Windows를 클릭하여 윈도우용 배포판을 선택한다.1 윈도우용 배포판 중 어떤 항목을 내려받을 것인지를 물어보는데 처음 설치하는 것이므로 Base를 선택한다. 그러면 32/64bits 겸용 윈도우용 R 바이너리 파일을 내려받을 수 있는 화면으로 이동한다. Download R x.x.x for windows를 클릭하여 배포판을 내려받는다. 여기서 x.x.x는 내려받기를 하는 R 배포판의 버전을 의미한다. 1.2.4 R 설치하기 내려받은 R 설치 파일을 실행시켜 R을 설치한다. 설치 과정 중 사용할 언어 선택 화면이 나타나면 한국어를 선택한 후 [확인]을 클릭한다. GNU 라이선스 정보 화면이 나타나면 [다음]을 클릭한다. 설치할 위치를 선택하는 화면이 나타나면 [찾아보기]를 클릭하여 적절한 설치 폴더를 직접 지정하거나 기본 값으로 설치한다. [다음]을 클릭한다. 구성 요소 설치를 묻는 화면이 나타나면 위쪽에 있는 선택 리스트를 이용하여 32-bit 사용자 편의를 위한 쉬운 설치 또는 64-bit 사용자 편의를 위한 쉬운 설치 중 자신의 윈도우즈 시스템이 32-bit 윈도우인지 64-bit 윈도우인지에 따라 선택한다. 그리고 [다음]을 클릭한다.(자신의 윈도우 종류를 모르겠으면 사용자 편의를 위한 쉬운 설치를 선택하여 전체를 다 설치하여도 된다. Windows 10을 기준으로 몇 bits 운영체제인지를 확인하려면, 시작 메뉴에서 [제어판]을 선택한 후 [시스템]-[정보]를 선택하면 시스템 종류에 해당 정보가 나온다.) R을 시작할 때의 사용하는 스타트업 옵션을 조정할 것인지를 묻는 화면이 나온다. 지금은 그냥 No (기본값 사용)을 선택하도록 한다. 그리고 [다음]을 클릭한다. 시작 메뉴 폴더를 선택하도록 하는데, 기본 값인 `R’을 이용하도록 한다. [다음]을 클릭한다. 추가 사항 적용은 특별한 요구가 없는 한 기본 설정을 이용하도록 한다. [다음]을 클릭하면 설치가 실행된다. 설치가 완료되면 [완료]를 클릭한다. 윈도우즈 시작 메뉴에 가면 R 폴더가 생성되어 있고 그 안의 메뉴를 클릭하면 R이 실행된다. 1.3 RStudio R 배포판이 제공하는 기능만으로도 기본적인 프로그래밍이나 데이터 분석이 가능하다. 그러나 프로그래밍이나 데이터 분석 작업이 복잡해지면 R을 좀 더 편리하게 사용할 수 있는 통합된 개발 환경(IDE: Integrated Development Environment)이 큰 도움이 된다. RStudio는 R을 위한 강력한 통합 개발 환경을 제공해 준다. R과 마찬가지로 공개 소프트웨어로 누구나 자유롭게 이용할 수 있다. 따라서 많은 R 사용자가 RStudio를 사용하고 있다. 1.3.1 winget을 이용한 RStudio 설치 winget에 대한 설명은 1.2.2 절을 참조한다. cmd 창이나 PowerShell 창에서 다음 명령을 실행하면 RStudo를 내려받고 설치 관리자를 실행한다. winget install --id Posit.RStudio 설치 관리자가 설치할 것인지 확인하면 ’Yes’를 선택한다. 만약 이전 버전의 RStudio가 이미 설치되어 있다면, 업그레이드 하도록 다음 명령을 실행한다. R과 달리 RStudio 설치 관리자는 이전 버전을 지우고 신규 버전을 재설치 한다. winget upgrade --id Posit.RStudio winget으로 RStudio를 설치할 수 없으면 다음 절의 설명을 참조하여 직접 RStudio를 내려받고 설치를 수행한다. 1.3.2 RStudio 설치 앞 절에서 winget을 사용하여 RStudio를 설치하였으면 이 절의 내용은 수행하지 않아도 된다. 이 절은 winget으로 RStudio를 설치하지 못하였거나, 윈도우즈 이외의 운영체제를 사용하는 독자를 위해 R을 직접 내려받아 설치하는 방법을 설명한다. RStudio 다운로드 웹페이지에 접속하면 RStudio를 내려 받을 수 있다. RStudio는 데스크탑용과 서버용이 있다. 데스크탑 버전은 개별 사용자를 위한 버전이고, 서버용 버전은 여러 사람이 동시에 데이터를 분석하거나 원격에서 데이터를 분석하기에 좋은 환경이다. 서버용 버전과 관련된 정보는 RStudio 홈페이지를 참조하기 바란다. [DOWNLOAD RSTUDIO]를 클릭하여 RStudio 설치 안내 페이지로 이동한다. 그러면 RStudio 설자 안내 페이지에는 1: Install R이라는 섹션에 R을 설치하를 먼저 하라고 나와있는데, 우리는 이미 R을 설치하였으므로 2: Install RStudio을 수행하면 된다. 페이지를 중간 쯤에 운영체제 별로 다운로드 할 수 있는 파일이 제공되고 있다. 윈도우즈 사용자들은 Windows 10/11 행에 있는 파일을 다운로드 하여 설치하면 된다. 만약 다른 운영체제의 RStudio가 필요하면 목록에서 적절한 배포판을 선택한다. 내려받은 파일을 실행하면 RStudio 설치를 완료할 수 있다. 1.4 RStudio로 R 시작하기 RStudio를 설치하면 윈도우 시작메뉴에 RStudio를 실행할 수 있는 메뉴가 나타난다. 이를 실행하면 다음 그림처럼 RStudio가 실행된다. 기본 설정은 왼편에 R 콘솔이나 코드 편집기 창들이 위치하고, 오른편에 작업 환경, 명령어 히스토리, 파일, 그림, 패키지, 도움말 관련 창들이 위치하도록 되어 있다. 1.4.1 R 콘솔과 프롬프트 R은 기본적으로 텍스트 기반의 명령문을 입력받아 명령문에 대한 응답하는 방식으로 작동한다. R 콘솔은 사용자의 명령문을 받고 텍스트 기반 결과물을 출력하는 곳이다. R 콘솔은 사용자의 명령을 받을 준비가 되어 있다는 것을 나타내기 위해 명령 프롬프트인 `&gt;’ 기호를 표시한다. 프롬프트가 보이면 R 명령문을 입력하고 Enter 키를 누르면 입력된 R 명령문이 R에 전달되어 실행된다. 명령문의 실행 결과가 텍스트이면 R 콘솔에 결과가 나타나고 그래프이면 오른편의 Plots 창에 그래프가 나타난다. 이 책에서는 아래에 나오는 형태로 R 콘솔의 입출력을 표시한다. &gt;가 있는 행은 사용자가 입력한 행이고 &gt;가 없는 행은 R의 출력 결과로 표시한다. R을 맛보기 위해 R이 제공하는 cars 데이터에 대해 기초적인 분석을 수행해보자. 이 절에서 이용되는 R 명령어에 대해서는 현재 시점에선 이해할 필요가 없다. 이 책이 진행되면서 차근차근 설명될 것이다. 먼저 다음과 같이 cars 데이터를 화면에 출력해 보자. 콘솔에 cars라고 입력 후 Enter를 입력한다. cars speed dist 1 4 2 2 4 10 3 7 4 4 7 22 5 8 16 6 9 10 ... cars 데이터는 자동차의 속력(speed)과 제동 거리(dist)에 대한 50 개의 관찰값으로 구성되어 있다. cars 데이터에 대하여 자세한 정보를 얻어보자. ?를 명령어에 붙이면 명령어에 대한 설명을 오른편의 Help 창에 도움말이 나타난다. ?cars summary() 함수를 이용하여 자동차의 속력과 제동 거리에 대한 최소값, 최대값, 평균, 사분위수 등 기본 통계치를 구해 보자. summary(cars) speed dist Min. : 4.0 Min. : 2.00 1st Qu.:12.0 1st Qu.: 26.00 Median :15.0 Median : 36.00 Mean :15.4 Mean : 42.98 3rd Qu.:19.0 3rd Qu.: 56.00 Max. :25.0 Max. :120.00 자동차의 속력과 제동 거리의 상관 관계를 보기 위해 plot() 함수를 이용하여 산점도(scatter plot)를 그려 본다. plot(dist ~ speed, data=cars) 자동차의 속력과 제동 거리의 관계를 선형 모형으로 나타내기 위해 다음 명령어를 이용하여 cars 데이터에 대한 선형회귀분석을 수행한다. lm.cars &lt;- lm(dist ~ speed, data=cars) lm.cars Call: lm(formula = dist ~ speed, data = cars) Coefficients: (Intercept) speed -17.579 3.932 제동 거리를 속도로 회귀분석해 보면 절편이 -17.579이고 기울기가 3.932가 됨을 알 수 있다. 앞에 그린 산점도에 abline() 함수를 이용하여 회귀 적합선을 그려 넣어 본다. plot(dist ~ speed, data=cars) abline(lm.cars, col=&quot;blue&quot;) 본 절에서 수행한 명령어가 궁금한 독자는 help(명령어)나 ?명령어를 R 콘솔에 입력해 보라. 관련 도움말을 얻을 수 있을 것이다. 1.4.2 R 콘솔 사용과 관련된 몇 가지 팁 입력 시 주의 사항 R 명령문은 대문자와 소문자를 다른 문자로 간주한다. 그러니 함수명이나 변수명을 입력할 때 대소문자가 틀리지 않도록 해야 한다. R 명령문 입력시 가장 많이 틀리는 부분이 ' ', \" \", ( ), { } 등이 서로 짝이 맞지 않는 경우다. R 명령문을 입력하고 Enter를 입력하였는데, 결과가 출력되지 않고 프롬프트가 +로 바뀌는 경우에는, 입력한 명령문이 완전하지 않기 때문에 나머지 입력을 받기 위해 기다리고 있다는 것을 나타낸다. 주로 앞서 설명한 ' ', \" \", ( ), { } 등이 서로 맞지 않아 발생하는 경우가 많다. 이를 해결하는 두 가지 방법이 있다. 명령문의 나머지를 + 프롬프트 뒤에 입력한 후 Enter를 입력하여 명령문을 마무리하거나, Esc를 눌러 지금까지 입력된 내용을 취소하는 것이다. RStudio의 콘솔은 몇 가지 편의 기능을 제공한다. 이 기능들을 이용하면 작업의 생산성을 향상시킬 수 있다. 코드 완성 RStudio 콘솔에서 Tab 키를 사용하여 코드를 자동 완성시킬 수 있다. 예를 들어 앞 절에 나온 lm.cars 변수를 사용하는 예제를 수행한 뒤라면, lm.c 까지만 입력한 후 Tab 키를 눌러보자. 그러면 자동으로 변수의 전체 이름을 완성해 줄 것이다. 코드 완성 기능을 이용하여 변수 이름을 입력하는 것을 습관화 하면 좋다. 변수의 이름을 잘못 입력하여 발생하는 오류를 줄일 수 있다. 코드 완성 기능은 함수에도 이용할 수 있다. sum까지만 입력한 후 Tab을 눌러보자. 그러면 다음 그림 처럼 sum으로 시작하는 함수의 목록이 나타난다. 목록 중 원하는 함수를 선택하면 해당 함수 이름을 콘솔에 자동 완성해 준다. 필요한 함수의 정확한 이름이 생각나지 않을 때 매우 유용하다. 코드 완성 기능은 함수의 인수 입력에도 이용할 수 있다. summary(라고 입력한 후에* Tab 키를 누르면 함수 인수의 목록과 설명이 나온다. R 함수들의 인수 이름을 정확히 기억하는 것은 쉽지 않다. 코드 완성 기능을 오류 없이 정확한 명령어를 빠르게 입력할 수 있도록 도와준다. 이전 명령문 불러오기 R 콘솔에서는 이전에 입력한 명령을 불러와 다시 실행하거나 수정하여 실행시킬 수 있다. 이전 명령은 위와 아래 화살표 키를 이용하여 불러온다. [위 화살표 키] 이전에 입력한 명령을 차례대로 불러온다. [아래 화살표 키] 위 화살표 키와 반대로 불러온다. [Ctrl + 위 화살표 키] 이전 명령의 목록을 보여준다. 1.4.3 R 스크립트 파일 만들기 R 콘솔에서 대화 형식으로 명령문을 입력하고 결과를 받는 것은 단순한 작업의 경우에는 편리하지만, 복잡한 분석을 위해 입력해야 할 명령문이 많거나 추후에 동일한 또는 유사한 작업을 할 예정이라면 R 스크립트 파일을 작성하여 명령문을 저장해 두는 것이 좋다. R 스크립트는 한번에 실행할 명령문을 단순한 텍스트 형식으로 기술한 파일이다. R 스크립트에는 실행할 명령문을 한 줄씩 입력한다. R은 스크립트를 읽어들여서 줄바꿈이 되는 곳을 기준으로 한 줄씩 처리한다. summary(cars) lm.cars &lt;- lm(dist~speed, data=cars) lm.cars plot(dist~speed, cars) abline(lm.cars) RStudio 코드 편집기 RStudio의 코드 편집기는 R 스크립트 등 다양한 파일을 작성하는 것을 도와준다. 문법 강조 표현, 코드 완성 등 다양한 기능들을 가지고 있다. 또한 코드 편집기에 입력한 R 명령을 콘솔에서 즉시 실행해 볼 수도 있다. 많은 R 사용자가 R 명령을 콘솔에서 직접 실행하는 것보다 코드 편집기에서 스크립트로 작성한 후 실행하는 것을 선호한다. 왜냐하면 코드 편집기를 이용하면 실행한 R 명령을 파일에 저장해 둘 수 있으므로, 나중에 동일한 코드를 재실행할 수 있을 뿐 아니라 함수 등으로 쉽게 변환할 수 있기 때문이다. RStudio에서 지원하는 주요 파일 형식 RStudio는 다음 형식의 파일에 대하여 문법 강조 표현 및 특화된 코드 편집 기능을 제공한다. R 스크립트: R 명령어 코드와 주석만을 포함하는 파일이다. R 노트북: R 명령어와 함께 실행 결과를 Mathematica 노트북 형태로 저장해주는 파일이다. R Markdown 문서: 마크다운이라는 매우 단순한 형식으로 문서 모양을 지정할 수 있다. R 명령어와 마크다운이 같이 한 문서에 사용되어 동적인 문서를 생성한다. R 마크다운 문서는 HTML, 워드 문서, PDF 문서로 변환이 가능하다. Shiny Web App: RStudio에서 개발한 R을 이용해 웹 응용을 쉽게 개발하도록 지원하는 웹 응용 개발 체계이다. R Sweave 문서: LaTex 문서 내에 R 명령어를 포함하여 동적인 LaTex 파일을 만들어 주는 형식이다. R HTML 문서: HTML 문서 내에 R 명령어를 포함하여 동적으로 HTML 파일을 만들어 주는 형식이다. R Presentation 문서: HTML5 기능을 이용하여 HTML 기반의 동적인 프리젠테이션 파일을 만들어 주는 파일 형식이다. R Documentation 문서: R 프로그램에 대한 문서화를 지원해 주는 파일 형식이다. 스크립트 파일 만들기 일반적인 사용자는 보통 R 스크립트 파일, R 마크다운 파일, R 프리젠테이션 파일을 많이 사용한다. RStudio에서 새로운 파일을 생성하려면 File-&gt;New File 메뉴를 이용하거나 그림처럼 새 파일을 만드는 명령 단추를 클릭한다. 기존 파일을 열기 위해서는 File-&gt;Open File… 또는 File-&gt;Recent Files 메뉴를 이용하거나, 파일 열기 명령 단추를 클릭한다. RStudio에서 여러 파일을 열게 되면 탭으로 각 파일을 표시해 준다. 매우 많은 파일이 열려서 탭을 모두 표시할 수 없으면 우측 상단에 &gt;&gt; 또는 좌측 상단에 &lt;&lt; 아이콘이 표시되어 보이지 않는 파일 탭 사이를 전환할 수 있도록 해 준다. 편집기의 코드 완성 기능 코드 편집기는 Tab 키를 이용하여 자동 코드 완성을 지원한다. 코드 완성 기능은 콘솔과 마찬가지니 콘솔의 설명을 참조하기 바란다. 문자 찾기와 바꾸기 코드 편집기는 문서의 문자를 찾거나 바꾸는 기능을 지원한다. Ctrl +F 단축키를 이용하거나 Edit-&gt;Find 또는 Edit-&gt;Replace and Find 메뉴를 이용한다. 코드 실행 RStudio는 코드 편집기의 코드를 직접 실행시킬 수 있다. 실행할 코드는 콘솔에 자동 입력되어 실행되고 그 결과도 콘솔에 표시된다. 코드의 한 줄 또는 일부 여러 줄을 실행하려면 그 줄을 선택한 후 코드 편집기의 도구 모음에서 Run를 실행하거나 Ctrl+Enter 키를 이용한다. 코드 전체를 실행하기 위해서는 코드 편집기의 도구 모음에서 Source -&gt; Source with Echo를 실행하거나 Ctrl+Shift+Enter 키를 이용한다. 코드 편집기의 도구 모음에서 그냥 Source를 실행하면 파일의 명령문이 실행은 되나 결과가 콘솔에 출력되지 않는다. 주석 처리 R 스트립트에 명령문이 아닌 내용을 입력하고 싶으면 #을 앞에 사용하여 주석 처리를 한다. # 뒤에 입력된 내용은 명령문으로 간주하지 않고 무시한다. 주석문은 명령문의 의미를 나중에 이해하기 쉽도록 기술하거나, R 스크립트 개발 과정에서 디버깅이나 다른 이유로 명령문을 실행에서 제외할 때 사용한다. 직접 #를 입력하는 방법뿐 아니라, Edit-&gt;Comment/Uncomment Lines 메뉴나 코드 편집기 상단의 코드 명령 단추에서 해당 메뉴를 이용하면 선택한 코드 부분 전체를 주석 처리하거나 주석 처리를 취소할 수 있다. 들여쓰기 코드를 작성할 때 동일한 논리적 단위들을 동일하게 들여쓰기하면 코드를 읽기가 쉬워진다. RStudio는 코드 작성시 현재의 들여쓰기 옵션에 따라 자동으로 들여쓰기를 해 준다. 코드를 작성한 후 들여쓰기를 직접 조정하고 싶으면, 코드를 선택한 후 Tab 키를 누른다. 그러면 Tab 키를 누른 횟수만큼 들여쓰기가 된다. 반대로 Shift+Tab 키를 누르면, 누른 횟수만큼 내어쓰기가 된다. 참고로 RStudio는 Tab 한 회에 공백 2문자만큼 들여쓰기를 한다. 이를 조절하고 싶으면 [Toos]-[Global Options]-[Code] 메뉴에 가서 Tab 한 회당 들여쓰기할 공백 문자 수를 조절하면 된다. 이 책에서는 윈도우에 R을 설치한다고 가정한다. R 배포판은 설치 방법이나 그래픽 인터페이스의 몇 가지 기능을 제외하고 운영 체제에 따른 차이는 없다. ↩︎ "],["ch-R-Data-Basic.html", "Chapter 2 R 데이터 기초 2.1 단순한 데이터 형식 (data types) 2.2 단순 연산 2.3 변수와 할당 2.4 함수를 이용한 연산", " Chapter 2 R 데이터 기초 R은 통계 데이터 분석 툴이기도 하지만 그 자체로 프로그래밍 언어이다. 한국어, 영어와 같은 모든 언어가 그러하듯이 R에도 자기만의 어휘와 표현법, 표현 형태들이 있다. 외국어에 익숙해지기 위해 기본적인 문법 요소와 다양한 문형들을 익혀야 하는 것처럼 R도 R의 기본 표현법과 표현 형태를 익혀야만 사용할 수 있다. 고급 문법과 문형에 익숙할수록 더 유창한 언어 실력을 보일 수 있듯이 R도 고급 표현을 익히면 더 다양한 분석을 수행할 수 있다. 이 장에서는 R의 가장 기초적인 데이터 요소를 배운다. 3에서 6 장까지는 이 장에서 배운 내용을 기초로 R의 기초 데이터를 확장해 나간다. 이 장의 내용은 프로그래밍 언어에 익숙한 독자들에게는 이미 익숙한 내용일 것이다. 그런 독자들은 다음 장부터 시작하여도 무방하다. 2.1 단순한 데이터 형식 (data types) R의 기본적 데이터 형식: 숫자, 문자, 논리값 R은 데이터를 다룬다. R에서 다루는 기본적인 데이터 형식은 숫자, 문자, 논리값이다. 어떤 학생의 키가 172.2이면 이 데이터의 형식은 숫자이다. 그 학생의 이름이 ’홍길동’이면 이 데이터는 문자 데이터이다. 그리고 이 학생이 남자인지 여부를 TRUE 또는 FALSE로 표현하였다면 이 데이터의 형식은 논리값이다. R의 모든 복잡한 데이터 형식은 이러한 숫자, 문자, 논리값을 기반으로 구성된다. 아래는 R의 콘솔에서 숫자, 문자, 논리값을 차례대로 입력해 본 결과이다. ‘&gt;’ 다음 부분을 R 콘솔에 입력한 후 Enter 키를 누른다. 그러면 입력한 내용이 R에 전달되어 출력 결과가 그 다음 줄에 나타난다(’&gt;’가 없는 줄). 10 [1] 10 TRUE [1] TRUE &quot;홍길동&quot; [1] &quot;홍길동&quot; 10 vs ‘10’ 여기서 주의할 점은 숫자와 논리값과는 달리 문자 데이터는 큰 따옴표나 작은 따옴표로 시작과 끝을 표현해 주어야 한다는 것이다. 따라서 사칙연산이 가능한 숫자 10과 문자 \"10\"은 서로 다르다. 마찬가지로 논리값 TRUE와 문자열 \"TRUE\"도 다른 의미를 가진다. 2.2 단순 연산 사칙 연산 R은 더하기, 빼기, 곱하기, 나누기 등의 사칙연산에 대한 기본적 기능을 제공한다. 아래의 ‘&gt;’ 이후의 부분을 입력 후 Enter 키를 누르면 그 아래에 출력 결과가 나온다. 2 + 2 [1] 4 2 - 2 [1] 0 2 * 2 [1] 4 2 / 2 [1] 1 몫과 나머지 R에서 나눗셈은 부동 소수점 형식의 실수(real numbers)로 계산된다. 만약 정수의 나눗셈에서 몫과 너머지를 구하려면 %/%과 %% 연산자를 사용한다. 11 / 3 [1] 3.666667 11 %/% 3 # 몫 [1] 3 11 %% 3 # 나머지 [1] 2 거듭 제곱 연산 또한 ‘^’ 연산자를 이용해 거듭제곱도 가능하다. 아래의 예는 2의 1제곱부터 4제곱까지의 결과이다. 여기서 4개의 거듭제곱 연산 명령문 (Enter 키를 쳐서 R로 보내는 내용)을 한 줄로 보내기 위해 ’;’로 각각의 명령문을 나누어 한번의 Enter 키로 명령을 실행하였다. 각 명령문의 결과는 다른 줄로 출력되었음을 볼 수 있다. 2^1; 2^2; 2^3; 2^4 [1] 2 [1] 4 [1] 8 [1] 16 파이썬처럼 ** 연산자를 거듭 제곱 연산자로 사용할 수도 있다. 2**4 [1] 16 비교 연산 ‘==’ vs. ‘=’ R은 사칙연산뿐 아니라 부등호와 등호를 이용한 비교연산도 가능하다. 아래는 비교 연산을 수행한 경우이다. ‘&gt;=’와’&lt;=’ 연산자는 같거나 크다 또는 같거나 작다를 의미한다. ‘==’ 연산자는 같다를 의미하고 ‘!=’ 연산자는 같지 않다를 의미한다. 여기서 주의할 점은 등호가 ‘=’가 아니라’==‘라는 점이다.’=’ 연산자는 뒤에서 살펴볼 변수에 값을 할당하는데 이용된다. 2 &gt; 2; 2 &gt;= 2; 2 &lt; 2 ; 2 &lt;= 2 [1] FALSE [1] TRUE [1] FALSE [1] TRUE 2 == 2; 2 != 2 [1] TRUE [1] FALSE 논리값 연산 &amp;, |, !, xor(x, y) 연산자를 이용하여 논리적 AND, OR, NOT, XOR 연산을 할 수 있다. TRUE &amp; FALSE [1] FALSE TRUE | FALSE [1] TRUE !TRUE [1] FALSE xor(TRUE, TRUE) [1] FALSE 문자열 결합 연산 paste() 문자열에 대한 연산으로는 paste() 함수를 이용하여 문자를 연결하는 연산이 있다. paste() 함수는 문자열을 공백 하나를 사이에 두고 하나의 문자열로 합쳐준다. 숫자처럼 문자가 아닌 것은 문자로 변환한 후 합쳐준다. sep인자를 이용하면 두 문자열의 사이에 다양한 문자를 넣을 수 있다. paste(2014, 3) [1] &quot;2014 3&quot; paste(&quot;March&quot;, 11, 2014) [1] &quot;March 11 2014&quot; paste(2014, 3, 11, sep=&quot;-&quot;) [1] &quot;2014-3-11&quot; paste(2014, 3, 11, sep=&quot;/&quot;) [1] &quot;2014/3/11&quot; paste(2014, 3, 11, sep=&quot;&quot;) [1] &quot;2014311&quot; 문자열 분리 연산 strsplit() paste와 반대로 하나의 문자열을 여러 문자열로 분리해 내는 strsplit 함수도 있다. split인자에 문자열을 분리하는 기준이 되는 문자 또는 문자열을 지정해 준다. strsplit(&quot;2016-3-11 11:16:22&quot;, split=&quot; &quot;) [[1]] [1] &quot;2016-3-11&quot; &quot;11:16:22&quot; strsplit(&quot;2016-3-11 11:16:22&quot;, split=&quot;-&quot;) [[1]] [1] &quot;2016&quot; &quot;3&quot; &quot;11 11:16:22&quot; strsplit(&quot;2016-3-11 11:16:22&quot;, split=&quot;:&quot;) [[1]] [1] &quot;2016-3-11 11&quot; &quot;16&quot; &quot;22&quot; strsplit(&quot;2016-3-11 11:16:22&quot;, split=c(&quot;16&quot;)) [[1]] [1] &quot;20&quot; &quot;-3-11 11:&quot; &quot;:22&quot; strsplit의 split 인자는 사실 정규식 표현도 가능하다. (정규식에 대해서는 regular expression에 대한 다른 자료를 참조하길 바란다.) 다음은 정규식을 이용하여 ‘-’나,’ ‘(공백)나,’:’ 문자가 있는 곳 모두를 분리한 예이다. strsplit(&quot;2016-3-11 11:16:22&quot;, split=&quot;[- :]&quot;) [[1]] [1] &quot;2016&quot; &quot;3&quot; &quot;11&quot; &quot;11&quot; &quot;16&quot; &quot;22&quot; 2.3 변수와 할당 변수는 메모리 공간에 붙이는 레이블 R에서 연산을 수행하다 보면 연산의 중간 결과를 저장해둘 필요가 있다. 이 때 이용할 수 있는 것이 변수이다. 변수는 데이터를 저장해 두는 공간이라고 생각하면 쉽다. 변수는 사실 데이터를 저장해 두는 공간에 라벨을 붙여두는 것이다. 다시 그 데이터가 필요할 때 라벨을 이용하여 데이터가 저장된 공간에 가서 그 데이터 값을 가져와 이용하면 된다. 변수에 값 할당하기 할당(assignments)이란 어떤 변수에 데이터를 저장하는 것을 말한다. 예를 들어 x에 5라는 숫자 데이터를 할당하였다면 5라는 숫자가 x라는 라벨이 붙은 저장 공간에 들어간 것과 마찬가지이다. 우리는 x라는 라벨을 이용하여 필요할 때 x라는 라벨이 붙은 저장공간에 저장된 데이터 값을 가져올 것이다. 할당 연산자 변수에 데이터를 할당하는 것은 ‘&lt;-’ 또는 ‘=’ 연산자를 이용하여 이루어진다. 이 책에는 할당 연산자로 ‘&lt;-’을 이용할 것이다. 할당 연산자의 모양에서도 알 수 있듯이’&lt;-’ 연산자 오른쪽의 데이터를 왼쪽의 변수에 집어넣는다. x라는 변수에 저장된 데이터 값을 알고 싶으면 x를 입력한 후 Enter 키를 누르면 x의 값이 출력된다. x &lt;- 5 x [1] 5 연산에 변수 사용하기 x를 이용하여 다양한 명령을 수행할 수 있다. 뿐만 아니라 괄호 등을 이용하여 복잡한 연산을 수행할 수 있다. x + 2 [1] 7 x * 2 [1] 10 x^2 [1] 25 (x+3)^2 + 5 [1] 69 x [1] 5 위의 마지막 결과에서 볼 수 있듯이 변수의 값은 ‘&lt;-’ 연산자에 의해 다시 다른 값으로 할당되지 않으면 연산에서 사용되어도 원래의 값이 변하지 않는다. 변수에 값 재할당하기 변수는 데이터의 저장공간일 뿐이므로 현재 들어간 데이터 값 대신 다른 값을 재할당할 수도 있다. 다음의 예는 x에 7을 재할당한 후 앞서 수행한 연산을 다시 수행해 본 것이다. x &lt;- 7 x + 2 [1] 9 x*2 [1] 14 x^2 [1] 49 2^x [1] 128 이제 x라는 라벨이 붙은 저장공간에 7이라는 숫자 데이터가 들어가 있으므로 x를 이용한 연산 결과가 앞의 예와는 다르게 나옴을 볼 수 있다. 할당문은 우변이 수행된 후 좌변으로 할당이 이루어진다. 한 명령문 안에서 x의 값을 가져와 연산에 이용한 후 그 결과를 다시 x에 재할당할 수 있다. 이 경우 ‘&lt;-’ 연산자 오른편의 연산이 먼저 수행된 후 ‘&lt;-’ 연산자에 의해 왼편의 변수로 할당이 이루어진다. x &lt;- x + 1; x [1] 8 x &lt;- 2 + x; x [1] 10 x &lt;- x*2; x [1] 20 x &lt;- x^2; x [1] 400 마찬가지로 한 변수의 값을 이용하여 연산을 수행한 후 다른 변수에 값을 할당할 수도 있다. 아래 예에서도 볼 수 있듯이 x가 연산에 이용되더라도 재할당이 이루어지지 않으면 x라고 라벨이 붙은 저장공간에 들어가 있는 데이터 값은 동일하다. x [1] 400 y &lt;- 2 * x y [1] 800 x [1] 400 여기서도 변수의 값은 할당문에 의해 할당 또는 재할당이 이루어지지 않으면 변화가 없음을 다시 확인할 수 있다. 변수 제거하기 rm() 여러 가지 이유로 변수를 제거할 필요가 있을 수 있다. 변수를 제거하려면 rm() 함수를 이용하면 된다. 제거할 변수를 rm() 함수 내에 기술하면 이 변수가 사라지게 된다. x; y [1] 400 [1] 800 rm(x, y) x Error in eval(expr, envir, enclos): 객체 &#39;x&#39;를 찾을 수 없습니다 y Error in eval(expr, envir, enclos): 객체 &#39;y&#39;를 찾을 수 없습니다 rm() 함수로 변수를 제거하면 변수가 사용하는 메모리는 자유롭게 되며, R이 다른 용도로 이용할 수 있다. 여기서 주의할 점은 rm()에 의해서 메모리가 자유롭게 되더라도 R이 사용하던 메모리가 운영체제로 바로 반환되지는 않는다는 것이다. 이를 처리하려면 gc() 함수를 이용하여 garbage collection을 하도록 해야 한다. 그러나 사실 R은 주기적으로 garbage collection을 하므로 특별한 이유가 없으면 이를 별도로 수행할 필요는 없다. 변수 목록 확인하기 ls() ls() 함수를 이용하면 현재 환경에서 정의되어진 모든 변수의 이름을 출력해 준다. 반면 rm() 함수는 list 인자에 변수의 이름을 주면 해당 변수를 메모리에서 제거한다. 따라서 아래와 같은 방식을 이용하면 현재 환경에 정의되어 있는 모든 변수를 제거할 수 있다. a &lt;- 5 b &lt;- 7 ls() [1] &quot;a&quot; &quot;b&quot; &quot;file_embedding&quot; &quot;os_type&quot; rm(list=ls()) ls() character(0) assign() 참고로 assign() 함수로도 변수의 할당은 할 수 있다. 대부분의 경우는 assign() 함수를 이용하는 것보다는 앞서 설명한 할당 연산자를 이용하여 변수에 값을 할당하는 것이 편리하고 이해하기도 쉽다. 그러나 가끔 많은 변수를 자동적으로 생성해야 하는 경우나 데이터베이스에서 변수의 이름을 읽어들여와 값을 할당하는 등의 경우에는 assign() 함수를 이용하는 것이 필요하다. assign() 함수는 첫번째 인수로 변수의 이름을 문자열로 갖고, 두번째 인수로 변수에 할당한 값을 갖는다. x1 Error in eval(expr, envir, enclos): 객체 &#39;x1&#39;를 찾을 수 없습니다 assign(&quot;x1&quot;, 5) x1 [1] 5 assign(&quot;x1&quot;, x1 + 3) x1 [1] 8 위의 예에서 x1이라는 변수가 없었는데, assign() 함수에 의해 x1 변수가 할당되었음을 볼 수 있다. 주의할 점은 보통의 할당문에서는 변수가 문자열과 구분되도록 따옴표 없이 사용되나, assign() 함수에서는 변수의 이름이 문자열로 따옴표와 함께 표시된다는 것이다. 2.4 함수를 이용한 연산 R의 기본 기능에는 다양한 함수가 포함되어 있다. 사용자도 자신만의 함수를 만들 수 있다. 함수는 입력으로 어떤 값을 받은 후 출력으로 어떤 값을 반환한다. 함수가 어떤 값을 입력받고 반환하는지는 함수마다 다르다. 함수 호출 하기 R에서 함수를 이용하려면 다음의 형태로 함수를 호출하여야 한다. &gt; 함수이름(함수 입력 인수) 함수 출력 값 아래는 제곱근을 구하는 sqrt() 함수의 예이다. 함수의 입력 인수(arguments)로는 4가 주어져 있고 제곱근을 구하는 함수는 입력된 4를 가지고 결과인 2를 반환하고 있다. 함수는 연산자와 함께 사용될 수 있고 함수의 결과가 다시 다른 함수의 입력 인수가 될 수 있다. sqrt(4) [1] 2 (sqrt(9) + 2) / 4 [1] 1.25 sin( (sqrt(9) + 2)/ 4 ) [1] 0.9489846 Table 2.1: 수학 관련 주요 함수 수학 함수 설명 ceiling(x) x의 값을 정수로 올림 floor(x) x의 값을 정수로 내림 trunc(x) x의 값의 소수점 자리를 버림 round(x) x의 값을 반올림 round(x, digits=n) x의 값을 소수점 n자리에서 반올림 sqrt(x) x의 제곱근 exp(x) x의 지수함수 값 log(x) 자연대수를 밑으로 하는 로그 값 log(x, base=a) a를 밑으로 하는 로그 값 sin(x), cos(x), tan(x) x의 삼각함수의 값 factorial(n) \\(n! = 1 \\times 2 \\times \\cdots \\times n\\) choose(n,k) n 개 중 k를 뽑는 조합의 수 실수를 정수로 변환하는 함수 표 2.1은 R에 내장되어 있는 수학 관련 주요 함수를 보여준다. 다음 예는 함수를 이용하여 숫자에 대한 올림, 내림, 버림, 반올림 등을 수행한 결과이다. a &lt;- 3.141593 ceiling(a) [1] 4 floor(a) [1] 3 trunc(a) [1] 3 round(a) [1] 3 round(a, digits=2) [1] 3.14 순열과 조합 함수 다음은 순열(factorial)과 조합(combination)의 값을 구한 결과이다. 30에 대한 순열 값은 매우 커서 공학 형식으로 숫자가 표시된다. 이를 일반적인 형식으로 표시하기 위해서 format 함수를 이용하였다. factorial(5) [1] 120 factorial(30) [1] 2.652529e+32 format(factorial(30), scientific = FALSE, ) [1] &quot;265252859812191032188804700045312&quot; choose(5, 2) [1] 10 choose(45, 6) [1] 8145060 함수에 대한 자세한 내용은 10 장의 함수(function)와 관련된 내용을 참조한다. "],["ch-R-Vectors.html", "Chapter 3 R 벡터 3.1 숫자 벡터 3.2 논리 벡터 3.3 문자 벡터 3.4 결측치 (Missing Values) 3.5 인덱스 벡터와 필터링", " Chapter 3 R 벡터 벡터는 R의 통계 분석에서 가장 중요한 데이터 형식이다. 다른 범용의 프로그래밍 언어와는 다르게 R은 벡터 단위의 연산 및 조작을 지원함으로써 통계 데이터 분석에 매우 편리한 이점을 제공한다. 벡터는 동일 형식 데이터의 나열 벡터는 50명 학생들의 키 데이터 (162.1, 175.8, 183.2, …), 50명 학생들의 성별 데이터 (\"여\", \"남\", \"남\", ...)처럼 한가지 타입의 데이터를 나열한 것이다. 여기서 타입이란 1, 2 등의 숫자 타입, \"yes\", \"no\" 등의 문자열 타입, TRUE/FALSE의 논리적 타입을 의미한다. 숫자 벡터에는 숫자 데이터만 나열되고, 문자 벡터나 논리 벡터에는 각각 문자열과 논리값만이 나열된다. 벡터의 길이/크기 벡터가 포함하고 있는 데이터의 개수를 벡터의 길이 또는 크기라고 한다. 따라서 50 명 학생의 키 데이터는 길이가 50인 벡터가 된다. 사실 R은 벡터가 아닌 숫자, 문자, 논리값은 없다. 10이라는 숫자 하나도 사실은 길이가 1인 숫자 벡터이고, 문자열도 논리값도 길이가 1인 문자 벡터와 논리 벡터일 뿐이다. 3.1 숫자 벡터 3.1.1 c() 함수를 이용한 숫자 벡터 만들기 숫자 연결하여 벡터 만들기 c() 함수는 여러 가지 기능을 하지만 가장 중요한 기능은 두개 이상의 벡터를 인수로 받아 이를 연결(concatenating)하여 새로운 벡터를 만드는 것이다. 다음은 c() 함수로 숫자 2, 4, 6, 8, 10으로 이루어진 숫자 벡터를 만들어 y라는 변수에 할당하는 예이다. y &lt;- c(2, 4, 6, 8, 10) y [1] 2 4 6 8 10 R 콘솔 상에 변수 y를 입력한 후 Enter를 치면 변수 y의 내용을 출력한다. 변수가 벡터인 경우에는 벡터의 요소들을 나열한다. 앞의 예에서는 정수만으로 이루어진 벡터를 만들었는데 이번에는 실수가 들어간 숫자 벡터를 만들어 보자. 실수 하나가 벡터의 요소로 들어가자 나머지 숫자도 소수점을 가지는 실수로 표현됨을 볼 수 있다. x &lt;- c(1,3,5,7,9.2) x [1] 1.0 3.0 5.0 7.0 9.2 길이가 2 이상인 벡터 연결하여 새 벡터 만들기 지금까지는 숫자(길이가 1인 숫자 벡터)만을 연결하여 숫자 벡터를 만들었다. 이제 길이가 2 이상인 숫자 벡터 x와 y를 연결하여 새로운 숫자 벡터 z를 만들어 보도록 하자. z &lt;- c(x, y) z [1] 1.0 3.0 5.0 7.0 9.2 2.0 4.0 6.0 8.0 10.0 위의 예에서 x와 y의 위치가 바뀌면 어떻게 될까? 아래 결과에서 볼 수 있듯이 새롭게 생긴 z 벡터의 요소의 순서가 바뀐다. y의 요소 다음에 x의 요소들이 차례대로 나열된다. z &lt;- c(y, x) z [1] 2.0 4.0 6.0 8.0 10.0 1.0 3.0 5.0 7.0 9.2 여러 줄에 걸친 벡터 출력 c() 함수는 세 개 이상의 벡터를 연결시킬 수도 있다. 아래 결과에서 벡터 w는 x, y, z의 요소들이 차례로 나열되어 새 벡터가 되었음을 볼 수 있다. 이 때 벡터가 길어 여러 줄로 출력이 되었다. 출력 결과 중 [1]과 [11]은 첫째 줄은 벡터의 1번째 요소부터, 둘째 줄은 11번째 요소부터 출력되고 있음을 나타낸다. 이렇듯 벡터가 길어 여러 줄로 콘솔에 출력되면 각 줄의 맨 앞에 표시되는 요소가 벡터의 몇 번째 요소인지를 알려준다. w &lt;- c(x, y, z) w [1] 1.0 3.0 5.0 7.0 9.2 2.0 4.0 6.0 8.0 10.0 [11] 2.0 4.0 6.0 8.0 10.0 1.0 3.0 5.0 7.0 9.2 3.1.2 패턴을 이용한 숫자 벡터 만들기 R의 데이터를 다루다 보면 어떤 패턴을 따르는 숫자 벡터가 필요한 경우가 있다. 예를 들어 50명의 학생에게 1부터 50까지 차례로 일련번호를 부여하려고 한다고 하자. c() 함수를 이용하여 1부터 50까지 숫자를 일일이 연결하여 이를 만드는 것은 매우 번거로운 일이다. 이러한 경우에는 n:m 명령을 사용하여, 숫자 n부터 시작하여 숫자 m까지 1씩 증가하거나 감소하는 수열로 된 벡터를 쉽게 만들 수 있다. n:m 1:10 [1] 1 2 3 4 5 6 7 8 9 10 10:1 [1] 10 9 8 7 6 5 4 3 2 1 위 결과에서 보듯이 m이 n보다 크면 1씩 증가하는 수열을, n이 m보다 크면 1씩 감소하는 수열이 생성된다. 위의 예는 자연수만을 사용하였는데, 사실 수열의 시작과 끝을 나타내는 숫자는 음의 정수나 실수 등 어떠한 숫자도 가능하다. n이 정수가 아닌 경우도 n부터 시작하여 1씩 증가 또는 감소하여 m을 넘지 않는 수열을 만든다는 사실은 변함이 없다. -4:8 [1] -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 0.7:8 [1] 0.7 1.7 2.7 3.7 4.7 5.7 6.7 7.7 2.3:-5 [1] 2.3 1.3 0.3 -0.7 -1.7 -2.7 -3.7 -4.7 seq() seq() 함수를 이용하면 1씩 증가하거나 감소하는 수열 벡터뿐 아니라 좀 더 복잡한 수열 벡터도 생성할 수 있다. seq(n, m) seq(n, m, by=k) seq(length=j, from=n, by=k) seq() 함수는 입력 인수의 형태에 따라 생성하는 수열이 다르다. seq(n, m)으로 함수를 호출하면 n:m과 마찬가지로 1씩 증가하거나 감소하는 수열을 생성한다. seq(n, m, by=k)로 호출하면 n부터 시작하여 k씩 증가하여 m을 넘지 않는 수열을 생성한다. seq(length=j, from=n, by=k)로 호출하면 n부터 시작하여 k씩 증가하는 길이가 j인 수열을 만든다. seq(5, 15) [1] 5 6 7 8 9 10 11 12 13 14 15 seq(5, 15, by = 2) [1] 5 7 9 11 13 15 seq(length=10, from = -3, by = 0.5) [1] -3.0 -2.5 -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 1부터 어떤 벡터의 길이까지 일련번호를 생성할 때 seq() 함수를 이용하면 편리하다. seq()의 along 인수에 벡터를 부여하면 1부터 그 벡터의 길이만큼의 일련번호가 생성된다. y [1] 2 4 6 8 10 seq(along=y) [1] 1 2 3 4 5 rep() 어떤 벡터를 반복시켜서 새로운 벡터를 만들고 싶을 때는 rep() 함수를 이용한다. 첫번째 인수에 반복할 벡터를, times 인수에 반복할 횟수를 부여한다. rep() 함수를 빈번하게 이용하는 경우가 숫자 하나를 여러번 반복하여 벡터를 만들 때이다. y &lt;- c(1:5, 0:-5) rep(y, times = 2) [1] 1 2 3 4 5 0 -1 -2 -3 -4 -5 1 2 3 4 5 0 -1 -2 -3 -4 -5 rep(1, times = 10) [1] 1 1 1 1 1 1 1 1 1 1 rep() 함수를 이용하면 벡터 전체를 차례로 반복시키는 것뿐 아니라, 요소별로 횟수만큼 반복시킨 후 이를 결합하여 새로운 벡터를 만들 수도 있다. 이 경우에는 times 인수 대신 each 인수에 반복할 회수를 부여한다. rep(y, each = 2) [1] 1 1 2 2 3 3 4 4 5 5 0 0 -1 -1 -2 -2 -3 -3 -4 -4 -5 -5 3.1.3 숫자 벡터의 연산 요소 단위 연산 (elementwise operation) R의 강점 중 하나가 벡터의 요소끼리 연산을 지원한다는 것이다. 이는 여타의 범용 프로그래밍 언어에서는 볼 수 없는 점이다. 길이가 동일한 두 벡터에 더하기나 곱하기 연산 등을 수행하면, 같은 위치에 있는 요소끼리 해당 연산이 이루어진다(그림 3.1 참조). x &lt;- seq(length=5, from=0, by=10) x [1] 0 10 20 30 40 y &lt;- 1:5 y [1] 1 2 3 4 5 x + y [1] 1 12 23 34 45 x - y [1] -1 8 17 26 35 x * y [1] 0 20 60 120 200 x / y [1] 0.000000 5.000000 6.666667 7.500000 8.000000 다른 범용 프로그래밍 언어에 대한 지식이 있는 독자라면, 이를 해당 언어로 구현하려면 어떻게 해야 할지 잠시 생각해 보자. 반복문을 이용하여 이를 수행해야 할 것이다. 이러한 점을 고려하면 R이 벡터 연산을 얼마나 편리하게 수행하게 해 주는지 이해할 수 있을 것이다. Figure 3.1: 길이가 같은 벡터의 연산 벡터 재사용 (recycling) 연산에 사용되는 두 벡터의 길이가 다르면 어떻게 될까? 이 경우 길이가 짧은 벡터의 요소들이 순환 반복되어 사용된다(그림 3.2 참조). 이러한 현상을 벡터의 재사용(recycling)이라고 부른다. 다음 예는 길이가 10인 z 벡터와 길이가 5인 y 벡터를 더한 결과를 보여준다. 결과에서 보듯이 z의 10개 요소와의 더하기 위해, y의 요소가 차례대로 한번 사용된 후 다시 한번 더 반복되어 사용되었다. (더한 결과의 일의 자리를 살펴보면 이를 확인할 수 있다). z &lt;- rep(x, times=2) z [1] 0 10 20 30 40 0 10 20 30 40 z + y [1] 1 12 23 34 45 1 12 23 34 45 다음은 길이가 11인 w 벡터와 길이가 5인 y 벡터를 더한 예이다. 이 경우에도 w의 11개 요소와 대응되기 위해서 y의 전 요소가 두 번 반복되어 이용되고 마지막으로 y의 첫째 요소가 다시 재사용되었음을 볼 수 있다(그림 3.2 참조). 이처럼 두 벡터의 길이가 서로 배수가 아닌 경우에는 혹시 사용자의 착각일 수도 있기 때문에 경고 메시지가 출력된다. 경고 메시지는 오류가 아니므로 계산 수행은 정상적으로 수행된다. w &lt;- c(z, 50) w [1] 0 10 20 30 40 0 10 20 30 40 50 w + y Warning in w + y: 두 객체의 길이가 서로 배수관계에 있지 않습니다 [1] 1 12 23 34 45 1 12 23 34 45 51 Figure 3.2: 길이가 다른 벡터의 연산 사실 길이가 다른 벡터 간의 연산이 가장 빈번히 사용되는 경우는 숫자 하나와 숫자 벡터간의 연산이다. 이 경우 숫자 하나가 벡터의 길이만큼 재사용되어 연산이 이루어진다. x &lt;- 1:5 10 * x [1] 10 20 30 40 50 x + 10 [1] 11 12 13 14 15 10/x [1] 10.000000 5.000000 3.333333 2.500000 2.000000 x^2 [1] 1 4 9 16 25 Table 3.1: 숫자 벡터를 인수로 하는 함수 예 함수명 함수 설명 length(x) 벡터 x의 길이를 반환한다. sum(x) 벡터 x에 있는 모든 요소들을 더한 결과를 반환한다. mean(x) 벡터 x에 있는 요소들의 평균을 반환한다. var(x) 벡터 x에 있는 요소들의 분산을 반환한다. sd(x) 벡터 x에 있는 요소들의 표준편차를 반환한다. range(x) 벡터 x에 있는 요소들의 최소값과 최대값을 반환한다. min(x)/max(x) 벡터 x에 있는 요소들의 최소값/최대값을 반환한다. median(x) 벡터 x에 있는 요소들의 중위수를 반환한다. rank(x) 벡터 x의 각 요소를 작은 것에서 큰 것까지 순위를 반환한다. sort(x) 벡터 x의 각 요소를 순서대로 배열한다. order(x) 벡터 x의 요소의 값이 가장 작은 것부터 가장 큰 것까지 순서대로 요소의 위치를 반환한다. which.max(x) 벡터 x의 최대값/최소값의 위치를 반환한다. which.min(x) which(x) 벡터 x에서 조건을 만족하는 요소의 위치를 반환한다. 숫자 벡터를 인수로 하는 함수 숫자 벡터에 사칙연산 등의 수학 연산뿐 아니라, R에서 제공하는 다양한 함수도 적용할 수 있다. 숫자 벡터를 인수로 하는 함수들은 많이 있는데, 그 중 대표적인 함수들을 표 3.1에 제시하였다. 다음은 숫자 벡터에 함수를 적용한 예이다. x &lt;- c(11, 3, 4, 20, 5) x [1] 11 3 4 20 5 length(x) [1] 5 sum(x) [1] 43 mean(x) [1] 8.6 var(x) [1] 50.3 sd(x) [1] 7.092249 sum( (x - mean(x))^2 ) / ( length(x) - 1 ) [1] 50.3 range(x) [1] 3 20 min(x) [1] 3 max(x) [1] 20 median(x) [1] 5 which.max(x) [1] 4 which.min(x) [1] 2 which(x &gt; 10 ) [1] 1 4 which(x &gt; 10 &amp; x &lt; 15) [1] 1 벡터의 순서 및 정렬 관련 함수 R은 벡터 요소들의 크기 순서, 정렬을 해주는 rank(), order(), sort() 함수가 있다. rank() 함수는 벡터 요소의 크기 등수를 작은 것에서 큰 것 순으로 1에서부터 등수를 매겨준다. 즉, rank() 함수 결과의 첫번째 요소는 원래 벡터의 첫번째 요소의 크기 등수이다. 반면 order() 함수는 작은 것부터 큰 것 순으로 요소의 원래 벡터에서의 위치를 알려준다. 즉, order() 함수 결과의 첫번재 요소는 원래 벡터에서 가장 작은 요소가 어느 위치에 있는지를 알려준다. 그림 3.3는 앞의 설명을 도식화하여 보여준다. rank(x) [1] 4 1 2 5 3 sort(x) [1] 3 4 5 11 20 order(x) [1] 2 3 5 1 4 Figure 3.3: rank() 함수와 order() 함수의 비교 3.2 논리 벡터 R은 숫자뿐 아니라 논리값으로 구성된 벡터를 만들 수 있다. 논리 벡터의 요소들은 TRUE, FALSE, NA (not available) 값을 가질 수 있다. c()로 논리 벡터 만들기 논리 벡터도 숫자 벡터와 마찬가지로 논리값을 c() 함수로 연결하여 만들 수 있다. 아래 예에서 보듯이 TRUE와 FALSE 대신 혼동의 여지가 없는 경우에는 T와 F 만 입력하여도 TRUE와 FALSE로 인식함을 볼 수 있다. a &lt;- c(T, F, T); a [1] TRUE FALSE TRUE 비교 연산으로 논리 벡터 만들기 논리 벡터는 위의 예처럼 c() 함수로도 만들 수 있지만 많은 경우 벡터의 비교 연산의 결과로서 만들어진다. 다음은 비교 연산을 통해 논리 벡터를 생성한 예이다. ‘&lt;’, ‘&lt;=’, ‘&gt;’, ‘&gt;=’, ‘==’, ‘!=’ 등의 비교 연산이 벡터 요소별로 수행되어 논리 벡터가 생성되었다. y &lt;- 1:5 y &gt; 3 [1] FALSE FALSE FALSE TRUE TRUE y &gt;= 3 [1] FALSE FALSE TRUE TRUE TRUE y &lt; 5 [1] TRUE TRUE TRUE TRUE FALSE y &lt;= 5 [1] TRUE TRUE TRUE TRUE TRUE y == 2 [1] FALSE TRUE FALSE FALSE FALSE y != 2 [1] TRUE FALSE TRUE TRUE TRUE 논리 연산으로 논리 벡터 만들기 기존 논리 벡터들에 대해 논리 연산을 수행하여 새로운 논리 벡터를 만들 수도 있다. 다음은 ‘&amp;’, ‘’, ‘!’ 등의 논리 연산자를 이용하여 논리 벡터에 대해 AND, OR, NOT 연산을 수행한 예이다. b &lt;- !a; b [1] FALSE TRUE FALSE a &amp; b [1] FALSE FALSE FALSE a | b [1] TRUE TRUE TRUE 논리 벡터 함수: any()와 all() 논리 연산은 아니지만 논리 벡터에 자주 사용되는 함수가 any()와 all() 함수이다. 이 함수를 이용하면 논리 벡터의 논리값 중 하나라도 TRUE가 있는지 또는 모든 논리값이 TRUE인지를 확인할 수 있다. any( c(F, F, F) ) [1] FALSE any( c(F, F, T) ) [1] TRUE all( c(T, F, T) ) [1] FALSE all( c(T, T, T) ) [1] TRUE any()와 all()을 비교 연산자와 함께 이용하면 어떤 조건을 만족하는 요소가 벡터에 하나라도 있는지 또는 모든 요소가 조건을 만족하는지를 쉽게 확인할 수 있다. cars$dist [1] 2 10 4 22 16 10 18 26 34 17 28 14 20 24 28 26 34 34 46 [20] 26 36 60 80 20 26 54 32 40 32 40 50 42 56 76 84 36 46 68 [39] 32 48 52 56 64 66 54 70 92 93 120 85 any(cars$dist &gt; 100) [1] TRUE any(cars$dist &gt; 200) [1] FALSE all(cars$dist &gt; 5) [1] FALSE all(cars$dist &gt; 0) # for checking data errors [1] TRUE Figure 3.4: ifelse() 함수 연산 논리 벡터 함수: ifelse() ifelse() 함수는 논리 벡터를 이용하는 또 다른 벡터 연산 함수이다. ifelse(x, a, b)로 호출되는데, x에는 논리 벡터, a와 b에는 (원칙적으로는) x의 길이와 동일한 벡터가 부여된다. ifelse() 함수는 x의 요소가 TRUE인 경우에는 벡터 a의 요소를, FALSE인 경우에는 벡터 b의 요소를 선택하여 x와 길이가 동일한 새로운 벡터를 만들어 낸다. 그림 3.4은 다음 예처럼 a 벡터가 1:5, b 벡터가 -1:-5일 때, x 벡터의 논리값에 따라 a와 b의 요소 중 어떤 요소가 선택되어 새로운 벡터가 만들어지는지를 보여준다. x &lt;- c(T, F, F, T, F) a &lt;- 1:5 b &lt;- -1:-5 y &lt;- ifelse(x, a, b); y [1] 1 -2 -3 4 -5 ifelse()의 첫번째 인수로 논리 벡터가 직접 부여되기보다는 비교 연산의 결과가 부여되는 경우가 많다. 다음은 벡터 y에서 양수인 요소는 그대로 두고, 0이하인 요소는 0이 되도록 하여 새로운 벡터를 만든 예이다. ifelse(y &gt; 0, y, 0) [1] 1 0 0 4 0 위의 결과가 나온 이유는 다음과 같다. 첫번째 x 인수에 y와 0을 비교하는 연산이 들어갔다. 이 비교 연산은 다음과 같이 y보다 큰 요소에만 TRUE를 주는 논리값 벡터를 반환한다. y &gt; 0 [1] TRUE FALSE FALSE TRUE FALSE 두번째 a 인수에는 y가 부여되었으므로로 위의 비교 연산에서 TRUE가 된 위치에는 y 요소가 선택된다. 그리고 세번째 b 인수에는 0이 들어갔다. x 위치에 들어간 벡터의 요소가 5개인데, b 위치에 들어간 벡터는 요소가 1개이므로 숫자 벡터의 연산에서와 마찬가지로 0이 5번 재사용된다. 그러므로 x의 값이 FALSE인 위치에 0이 들어가게 된다 (그림 3.5 참조). Figure 3.5: ifelse() 함수 연산에서의 벡터 재사용 3.3 문자 벡터 문자 벡터는 문자를 요소로 하는 벡터이다. 범주형 데이터를 다루거나 데이터에 이름을 부여할 때 자주 이용된다. 문자 벡터 만들기 문자 벡터의 생성은 숫자나 논리 벡터처럼 c() 함수를 이용하여 생성할 수 있다. students &lt;- c(&quot;길동&quot;, &quot;철수&quot;, &quot;Tom&quot;) students [1] &quot;길동&quot; &quot;철수&quot; &quot;Tom&quot; 숫자나 논리 벡터를 as.character() 함수를 이용하여 문자 벡터로 변환할 수도 있다. 다음 예에서 n은 숫자 벡터로 따옴표 없이 값이 표시되고, num은 문자 벡터로 모든 요소가 따옴표로 둘러싸여 표시됨을 확인한다. n &lt;- 1:3 n [1] 1 2 3 num &lt;- as.character(n) num [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; paste()로 문자 벡터 연결하기 문자 벡터에 많이 사용되는 연산 중 하나가 문자 벡터를 요소끼리 서로 연결시키는 연산이다. paste() 함수로 이러한 문자 벡터 연결을 수행할 수 있는데, 호출 시 sep 인수를 사용하지 않으면 연결되는 벡터의 요소는 공백으로 연결되고, sep 인수가 사용되면 sep 인수에 부여된 문자열이 연결되는 요소 사이에 구분자로 들어간다. paste(students, num) [1] &quot;길동 1&quot; &quot;철수 2&quot; &quot;Tom 3&quot; paste(students, num, sep=&quot;&quot;) [1] &quot;길동1&quot; &quot;철수2&quot; &quot;Tom3&quot; paste(students, num, sep=&quot;-&quot;) [1] &quot;길동-1&quot; &quot;철수-2&quot; &quot;Tom-3&quot; paste(students, 1:2) [1] &quot;길동 1&quot; &quot;철수 2&quot; &quot;Tom 1&quot; 마지막 예에서 문자 벡터의 길이가 다르면 숫자 벡터의 연산처럼 길이가 짧은 벡터의 요소가 재사용됨을 볼 수 있다. 또 paste() 적용시 숫자 벡터가 자동으로 문자 벡터로 변환되어 연결되었음을 볼 수 있다. paste() 함수는 세 개 이상의 문자 벡터를 연결하는 데에도 사용될 수 있다. paste(students, num, c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), &quot;!&quot;) [1] &quot;길동 1 A !&quot; &quot;철수 2 B !&quot; &quot;Tom 3 C !&quot; strsplit()로 문자 벡터 분리하기 paste()와 반대의 역할을 하는 함수가 strsplit()이다. strsplit()는 paste()와는 달리 문자열을 나눌 때 구분자로 사용할 문자열을 split 인수로 반드시 제공해야 한다. 마지막 예에서 x와 split의 요소가 같은 위치끼리 적용되어 문자열 분리가 수행되었음을 확인할 수 있다. x &lt;- c(&quot;2015-3-15 10:12:12&quot;, &quot;2016-10-11 11:12:13&quot;, &quot;2014-7-8 02:03:04&quot;) strsplit(x, split=&quot; &quot;) [[1]] [1] &quot;2015-3-15&quot; &quot;10:12:12&quot; [[2]] [1] &quot;2016-10-11&quot; &quot;11:12:13&quot; [[3]] [1] &quot;2014-7-8&quot; &quot;02:03:04&quot; strsplit(x, split=&quot;-&quot;) [[1]] [1] &quot;2015&quot; &quot;3&quot; &quot;15 10:12:12&quot; [[2]] [1] &quot;2016&quot; &quot;10&quot; &quot;11 11:12:13&quot; [[3]] [1] &quot;2014&quot; &quot;7&quot; &quot;8 02:03:04&quot; strsplit(x, split=&quot;:&quot;) [[1]] [1] &quot;2015-3-15 10&quot; &quot;12&quot; &quot;12&quot; [[2]] [1] &quot;2016-10-11 11&quot; &quot;12&quot; &quot;13&quot; [[3]] [1] &quot;2014-7-8 02&quot; &quot;03&quot; &quot;04&quot; strsplit(x, split=c(&quot;-&quot;, &quot;:&quot;, &quot; &quot;)) [[1]] [1] &quot;2015&quot; &quot;3&quot; &quot;15 10:12:12&quot; [[2]] [1] &quot;2016-10-11 11&quot; &quot;12&quot; &quot;13&quot; [[3]] [1] &quot;2014-7-8&quot; &quot;02:03:04&quot; nchar()로 문자수 세기 nchar() 함수는 문자 벡터의 각 요소의 문자 개수를 알려 준다. 공백도 문자이므로 문자 개수를 셀 때 포함이 된다는데 주의한다. nchar(&quot;날짜&quot;) [1] 2 a &lt;- c(&quot;날짜&quot;, &quot;day&quot;, &quot;date&quot;, &quot;날짜와 시간&quot;) nchar(a) [1] 2 3 4 6 Table 3.2: 문자 벡터를 인수로 하는 함수 예 함수명 함수 설명 nchar(x) 벡터 x의 문자열 요소의 문자 수를 반환한다. substr(x, start, stop) 벡터 x의 문자열 요소의 start번째 문자부터 stop번째 문자까지의 부분 문자열을 출력한다. grep(pattern, x, ignore.case=F, fixed=F) 벡터 x의 문자열 요소에 pattern 문자열 요소가 있는지 검색한다. pattern은 정규식일 수 있다. sub(pattern, replacement, x, ignore.case=F, fixed=F) 벡터 x의 문자열 요소에서 pattern을 찾아 replacement로 대체한다. strsplit(x, split, fixed=F) 벡터 x의 문자열 요소를 split에서 분리한 결과를 반환한다. paste(…, sep=’ ’) 문자 벡터를 sep를 이용하여 결합시킨 결과를 반환한다. toupper(x) 벡터 x의 문자열 요소를 대문자로 변환한다. tolower(x) 벡터 x의 문자열 요소를 소문자로 변환한다. 이외에도 다양한 문자 벡터 함수가 존재한다. 그 중 대표적인 함수를 표 3.2에 제시하였다. 3.4 결측치 (Missing Values) NA R에서는 데이터에 결측치가 있을 때 이를 NA 값으로 표시한다. 예를 들어 5명의 학생의 키 데이터가 있는데 마지막 학생의 데이터를 얻지 못하였다면, 그 학생의 데이터는 NA로 값을 입력한다. is.na()와 na.omit() is.na() 함수를 이용하면 결측치의 포함 여부나 위치를 확인할 수 있다. is.na()는 벡터에서 결측치가 있는 위치는 TRUE, 결측치가 아닌 위치는 FALSE로 하는 논리 벡터를 결과로 반환한다. na.omit() 함수를 이용하면 결측치를 제외한 벡터를 만들 수 있다. na.omit()에 대한 자세한 설명은 도움말을 참조하기 바란다. z &lt;- c(11:13, NA) z [1] 11 12 13 NA is.na(z) [1] FALSE FALSE FALSE TRUE na.omit(z) [1] 11 12 13 attr(,&quot;na.action&quot;) [1] 4 attr(,&quot;class&quot;) [1] &quot;omit&quot; na.rm 인수 숫자 벡터에 결측치가 있으면 sum()이나 mean() 함수 등의 결과는 NA로 출력된다. 숫자 벡터에 결측치가 있기 때문에 합이나 평균을 알 수 없다는 의미이다. 만약 결측치를 제외하고 합이나 평균을 구하고 싶으면, 이들 함수를 호출할 때 na.rm=TRUE 인수를 추가하여야 한다. 그러면 결측치를 제외하고 해당 결과를 계산하게 할 수 있다. sum(z) [1] NA sum(z, na.rm=TRUE) [1] 36 NaN 결측치는 아니지만 데이터의 값을 결정할 수 없는 경우가 있다. 대표적인 경우가 0에서 0을 나누는 경우이다. 이 경우 숫자 연산의 결과를 결정할 수 없으므로 NaN(Not a Number)로 결과를 표현된다. 주의할 점은 R은 무한대도 숫자로 간주하므로, 무한대의 결과가 나올 때는 Inf로 결과를 표현한다. 다음 예에서 앞의 두 계산은 무한대로, 뒤의 두 계산은 값을 결정할 수 없어 NaN로 결과를 반환함을 볼 수 있다. 1/0 [1] Inf Inf * 5 [1] Inf 0/0 [1] NaN Inf - Inf [1] NaN is.nan() 벡터에 NaN가 포함되어 있는지를 확인하려면 is.nan() 함수를 사용하면 된다. is.na()와 마찬가지로 NaN 요소가 있는 위치를 TRUE 값으로 하는 논리 벡터를 반환한다. 다음 예에서 보듯이 NaN가 포함되었는지를 정확히 알기 위해서는 is.na()가 아니라 is.nan() 함수를 실행하여야 한다. 왜냐하면 is.na() 함수는 NaN뿐 아니라 NA도 TRUE로 반환하기 때문이다. z &lt;- -1:1 / 0 z [1] -Inf NaN Inf is.na(z) [1] FALSE TRUE FALSE r &lt;- c(z, NA) is.na(r) [1] FALSE TRUE FALSE TRUE is.nan(r) [1] FALSE TRUE FALSE FALSE 통계 데이터에는 결측치가 자주 발생한다. 그리고 결측치 처리는 통계 분석에서 매우 중요한 문제 중 하나이다. R에서 결측치를 처리하는 다양한 기법에 대해서는 R in Action2의 18장을 참조하기 바란다. 3.5 인덱스 벡터와 필터링 데이터를 분석하다 보면, 데이터의 특정 요소만 추출하여 분석해 보고 싶을 때가 있다. 40세 이상의 고객만 추출하여 분석한다든지, 남자 학생에 대해서만 별도의 분석을 하는 경우가 그러한 예라고 할 수 있다. 이렇게 데이터에서 특정 부분만 추출하여 새로운 데이터를 만드는 작업을 필터링(filtering)이라고 한다. 벡터 필터링은 특정 벡터에서 특정 요소만을 추출하는 것을 의미한다. R에서 벡터 필터링은 인덱스 벡터를 이용하여 수행된다. 여기서 인덱스란 벡터에서 특정 요소의 위치를 의미한다. 예를 들어 5개의 요소로 구성된 벡터에서 두번째 요소를 추출하려면 두번째라는 위치가 그 요소의 인덱스가 된다. 그런데 어떤 벡터에서 추출하고자 하는 요소가 여러 개일 수도 있다. 이 경우 추출해야할 위치를 여러 개 나열해야 하고, 이렇게 나열한 요소의 위치 정보를 인덱스 벡터라고 한다. 물론 하나의 요소만 추출하고자 한다면 인덱스 벡터는 길이가 1이 될 것이다. 벡터 필터링을 하려면 다음처럼 벡터의 이름 다음에 인덱스 벡터를 대괄호 안에 기술하면 된다. vector[index_vector] 인덱스 벡터는 자연수 벡터, 음의 정수 벡터, 논리 벡터, 이름 벡터의 네 가지 형태를 가질 수 있다. 이를 각각 살펴보도록 하자. 3.5.1 자연수 인덱스 벡터 자연수 인덱스는 추출할 요소의 위치를 자연수로 표현한다. 벡터의 첫번째 요소의 위치는 1로, 두번째 요소의 위치는 2로 하여, 요소의 위치를 차례대로 1부터 벡터 길이까지의 자연수로 표현한다. 아래 예는 10개의 요소로 이루어진 벡터 x에서 자연수 인덱스 벡터로 새로운 벡터를 추출한 예이다(그림 3.6 참조). 마지막 예처럼 인덱스 벡터에서 자연수가 반복되면 해당 위치에 있는 요소가 반복되어 추출됨을 볼 수 있다. x &lt;- 11:20 x[6] [1] 16 x[c(6, 10)] [1] 16 20 x[seq(3, 9, by=2)] [1] 13 15 17 19 x[rep(c(2,4), times=3)] [1] 12 14 12 14 12 14 Figure 3.6: 자연수 인덱스 벡터를 이용한 벡터 필터링 인덱스 벡터를 사용하여 여러 요소를 뽑을 때 주의할 점이 있다. 벡터의 필터링에서 대괄호 안에는 오직 하나의 인덱스 벡터만 기술될 수 있다는 것이다. 만약 2개 이상의 요소를 뽑아야 한다면, c() 등으로 연결하여 하나의 인덱스 벡터로 만든 후 대괄호에 넣어야 한다. 만약 이를 실수하여 다음처럼 뽑을 요소를 각각 기술하게 되면 오류가 발생한다. x[6, 10] Error in x[6, 10]: incorrect number of dimensions 앞의 예에서는 6이라는 요소를 하나만 가지는 벡터 하나와, 10이라는 요소 하나만 가지는 또 다른 벡터를 대괄호 안에 기술한 것이다. 벡터는 일차원 구조로 오직 한 개의 인덱스 벡터를 입력 받으므로, 위의 경우는 c(6, 10)으로 하나의 벡터로 결합하여 인덱스 벡터를 전달해야 한다. 행렬에서는 두 개의 인덱스 벡터를 입력받게 되는데, 이 형식과 벡터의 인덱스 벡터를 혼동하지 않아야 한다. 추출해야 할 요소를 사용자가 직접 지정할 수도 있지만, 어떤 경우에는 함수를 이용하여 원하는 요소를 특정할 수도 있다. 예를 들어 which.min() 함수는 숫자 벡터의 최소값의 위치를 자연수 인덱스 형식으로 반환한다. 따라서 which.min() 결과를 인덱스 벡터로 이용하면 해당 벡터의 최소값을 추출할 수 있다. 자연수 인덱스 벡터로 많이 사용되는 함수 중 하나가 order() 함수이다. order() 함수는 크기 순으로 벡터 요소의 위치를 반환해 주는 함수이다. 이 함수의 결과를 인덱스 벡터로 사용하면 벡터의 요소를 크기로 정렬하는 효과가 발생한다. x &lt;- c(7, 9, 4, 6, 13, 4, 1, 11) x[which.min(x)] # You can use min() instead. [1] 1 x[which.max(x)] # You can use max() instead. [1] 13 x[which(x &gt; 10)] # You can use a logical index vector instead. [1] 13 11 x[order(x)] # You can use sort() instead. [1] 1 4 4 6 7 9 11 13 3.5.2 음의 정수 인덱스 벡터 자연수 인덱스가 추출한 요소의 위치를 표현한다면, 음의 정수 인덱스는 추출하지 않은 요소의 위치를 표현한다. 따라서 벡터 필터링에 음의 정수 인덱스 벡터가 사용되면, 데이터 벡터에서 해당 위치의 요소가 제외된 나머지 요소로 새로운 벡터를 만들어 반환한다. 예를 들어 인덱스 벡터가 -2라면 원래 벡터의 2번째 요소만 제외한 나머지 요소로 이루어진 벡터가 반환된다(그림 3.7 참조). x &lt;- 11:20; x [1] 11 12 13 14 15 16 17 18 19 20 x[-2] [1] 11 13 14 15 16 17 18 19 20 x[c(-2, -4)] [1] 11 13 15 16 17 18 19 20 x[-(3:6)] [1] 11 12 17 18 19 20 Figure 3.7: 음의 정수 인덱스 벡터를 이용한 벡터 필터링 3.5.3 논리 인덱스 벡터 논리 인덱스는 추출할 요소는 TRUE, 추출하지 않을 요소는 FALSE로 표시한다. 인덱스 벡터가 논리 벡터로 주어지면 데이터 벡터에서 TRUE 위치의 요소만 선택되어 새로운 벡터가 만들어진다. 다음 예와 그림 3.8은 논리 인덱스 벡터가 벡터 필터링에 어떻게 사용되는지를 보여준다. x &lt;- 1:5 y &lt;- c(T, F, T, T, F) x[y] [1] 1 3 4 Figure 3.8: 논리값 인덱스 벡터를 이용한 벡터 필터링 위의 예처럼 사용자가 직접 추출할 요소를 TRUE로 직접 기술하여 논리 인덱스 벡터를 제공할 수도 있지만, 더 많은 경우는 추출할 조건을 비교 연산 표현식으로 제공하는 경우가 더 많다(그림 3.8 참조). x &gt; 3 [1] FALSE FALSE FALSE TRUE TRUE x[x&gt;3] [1] 4 5 x &gt;3 &amp; x &lt;5 [1] FALSE FALSE FALSE TRUE FALSE x[x &gt;3 &amp; x &lt;5] [1] 4 다음처럼 논리 인덱스 벡터가 데이터 벡터의 길이보다 작으면 인덱스 벡터가 재사용되어 벡터 필터링이 이루어진다. y &lt;- c(TRUE, FALSE) x[y] [1] 1 3 5 3.5.4 이름 인덱스 벡터 R에선 벡터의 각 요소에 이름을 부여할 수 있다. 이름 인덱스 벡터는 추출할 요소의 위치를 벡터 요소의 이름으로 지정하는 방식이다. 벡터 요소의 이름은 names() 함수로 확인하거나 할당할 수 있다. 벡터의 요소에 이름을 부여하면, 벡터가 출력될 때 데이터의 값뿐 아니라 요소의 이름도 함께 출력이 된다. 다음은 names() 함수를 이용하여 animals라는 숫자 벡터의 각 요소에 이름을 부여한 후, 이름 인덱스 벡터로 요소들을 추출한 예이다. animals &lt;- c(5, 7, 3, 2) names(animals) &lt;- c(&quot;cats&quot;, &quot;dogs&quot;, &quot;camels&quot;, &quot;donkeys&quot;) animals cats dogs camels donkeys 5 7 3 2 animals[&quot;camels&quot;] camels 3 animals[c(&quot;dogs&quot;,&quot;donkeys&quot;)] dogs donkeys 7 2 3.5.5 인덱스 벡터를 이용해 벡터 요소에 값 할당하기 지금까지는 인덱스 벡터를 이용하여 필요한 요소를 추출하는 방법에 대하여 살펴보았다. 그런데 인덱스 벡터를 이용하여 데이터 벡터의 특정 요소에만 값을 할당할 수도 있다. 다음은 숫자 인덱스 벡터를 이용하여 벡터의 특정 요소에 값을 할당한 예이다. a &lt;- 1:5; a [1] 1 2 3 4 5 a[2] &lt;- 20; a [1] 1 20 3 4 5 a[c(3, 5)] &lt;- c(100, 300); a [1] 1 20 100 4 300 a[c(1, 3, 5)] &lt;- -5; a [1] -5 20 -5 4 -5 a[-1] &lt;- 0; a [1] -5 0 0 0 0 다음은 논리 인덱스 벡터를 이용하여 결측치가 있는 데이터에 결측치 대신 0을 넣는 예이다. is.na() 함수는 결측치가 있는 위치를 TRUE로 하는 논리값 벡터를 반환하므로, 이 결과를 인덱스 벡터로 하면 결측치가 있는 위치만 지정됨을 알 수 있다. x &lt;- c(NA, 2:4, NA) x [1] NA 2 3 4 NA x[is.na(x)] &lt;- 0 x [1] 0 2 3 4 0 다음은 논리 인덱스 벡터를 이용하여 숫자 벡터의 요소를 모두 양수로 바꾸는 예이다. y &lt;- c(-2, 0, 4, -7, 8) y[y&lt;0] &lt;- -y[y&lt;0] y [1] 2 0 4 7 8 Kabacoff, Robert. R in action. Manning Publications Co., 2015.↩︎ "],["ch-R-Matrix.html", "Chapter 4 R 행렬 4.1 행렬 만들기 4.2 벡터를 결합하여 행렬 만들기 4.3 행렬의 필터링 4.4 행렬의 연산 4.5 행렬과 함수 4.6 배열 * 4.7 행렬과 배열의 고급 연산 *", " Chapter 4 R 행렬 벡터보다 조금 더 복잡한 데이터 구조가 행렬과 배열이다. 행렬과 배열은 벡터처럼 모든 요소가 동일한 데이터의 타입을 가져야 한다. 행렬과 배열은 다차원적 데이터 구조이다. 지금까지 배운 벡터는 일차원적인 데이터 구조였다. 벡터의 길이가 50이라면 벡터의 각 요소의 위치는 \\(1, 2, \\ldots, 50\\)까지 하나의 숫자로 특정할 수 있다. 반면 행렬과 배열은 다차원적인 데이터 구조이다. 행렬은 2차원적 데이터 구조로 행과 열로 구성된다. 행렬의 각 요소의 위치는 어떤 행과 어떤 열에 포함되는지를 나타내는 두 개의 숫자로 특정할 수 있다. 배열은 행렬을 일반화한 것으로 다차원적인 데이터 구조이다. 예로 3차원 배열은 세 개의 숫자에 의해 데이터의 위치를 특정할 수 있다. 4.1 행렬 만들기 행렬의 필요성 행렬의 예로 다음을 고려해 보자. 어떤 강의의 수강생을 성별, 학년의 두 가지 기준으로 분류한다고 해 보자. 그러면 표 4.1 같은 형식으로 데이터를 정리할 수 있을 것이다. 이와 같이 두 범주형 변수에 대해 관측도수를 요약한 표를 교차표(cross table) 또는 분할표라고 한다. Table 4.1: 어떤 과목의 수강생 분할표 1 학년 2 학년 3 학년 4 학년 남 0 5 7 5 여 2 4 8 2 표 4.1 같은 데이터는 일차원적인 벡터 형태로 데이터를 저장하면 각 데이터 요소가 어떤 의미를 갖는지 파악하기가 쉽지 않다. 이러한 경우에는 2차원으로 구성된 행렬을 이용하는 것이 좋다. 행렬을 만드는 방법은 (1) 벡터를 행렬로 변환시키는 방법과 (2) 벡터를 결합하여 행렬을 만드는 방법이 있다. 이 절에서는 벡터를 행렬로 변환시키는 방법부터 살펴보자. matrix() matrix() 함수를 이용하면 데이터 벡터를 데이터 행렬로 변환시킬 수 있다. 다음의 예를 보면서 설명해 보자. n &lt;- 1:10 n [1] 1 2 3 4 5 6 7 8 9 10 m &lt;- matrix(n, nrow=2, ncol=5) m [,1] [,2] [,3] [,4] [,5] [1,] 1 3 5 7 9 [2,] 2 4 6 8 10 m &lt;- matrix(n, nrow=2) 위 예에서 n은 1부터 10까지 숫자를 가진 벡터이다. matrix() 함수의 첫 인수로 행렬로 바꿀 벡터를 주고, nrow 인수에 새로 만들 행렬의 행 수를 주면 행렬이 만들어짐을 볼 수 있다. 이렇게 만들어진 행렬 m은 크기가 \\(2 \\times 5\\) 인 행렬이 된다. 왜냐하면 전체 데이터의 수는 10개인데 2 개의 행이 지정되었으므로 모두 5개의 열이 있어야 모든 데이터를 수용할 수 있기 때문이다. matrix()는 열을 순서대로 채워나간다. 벡터의 요소는 차례대로 1열의 1행을 채우고 2행을 채운다. 그리고 난 후 2열의 모든 행을 순서대로 채운다. 이러한 방식으로 차례차례 모든 열의 데이터를 채워 나감을 볼 수 있다. 만약 열이 아니라 행을 차례대로 채워나가면서 행렬을 만드고 싶으면 byrow=TRUE 인수를 사용하면 된다. matrix(n, nrow=2, ncol=5, byrow=T) [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 행렬과 dim 속성 원래의 벡터 n과 벡터로 만들어진 행렬 m의 속성을 보기 위해 attributes() 함수를 이용하자. 벡터 n에는 아무 속성도 부여되지 않았지만 행렬 m은 차원을 의미하는 dim 속성이 부여되었음을 볼 수 있다. dim 속성에는 길이가 2인 숫자 벡터가 부여되어 있는데, 첫번째 요소는 행의 개수, 두번째 요소는 열의 개수를 나타낸다. attributes(n) NULL attributes(m) $dim [1] 2 5 matrix()로 벡터를 행렬로 변환시킬 때 행의 개수 대신 열의 개수를 지정할 수도 있다. 이 경우 nrow 대신 ncol 인수를 사용하면 된다. 아래 예에서는 열의 개수를 2로 지정하였으므로 행렬 m은 크기가 \\(5 \\times 2\\)인 행렬이 되었음을 볼 수 있다. 이는 dim 속성에서도 확인할 수 있다. m &lt;- matrix(n, nrow=5, ncol=2) m [,1] [,2] [1,] 1 6 [2,] 2 7 [3,] 3 8 [4,] 4 9 [5,] 5 10 attributes(m) $dim [1] 5 2 벡터 출력 vs. 행렬 출력 행렬 m을 출력한 내용을 보면 벡터와는 다름을 볼 수 있다. 먼저 벡터는 데이터를 R 콘솔의 모든 줄을 차례대로 채우면서 출력하고, 줄이 바뀔 때마다 각 줄의 첫 요소가 벡터의 몇 번째 데이터인지를 [i] 형태로 보여준다. 반면 행렬은 행과 열의 개수에 맞추어 출력시킬 뿐 아니라 [i,j] 형태로 데이터의 위치를 보여준다. matrix()에서 벡터 재사용 matrix() 함수를 이용하여 행렬을 만들 때 행과 열의 크기를 모두 지정할 수 있다. 만약 벡터의 크기가 행렬의 요소 개수보다 적으면 벡터가 재사용된다. 반대로 벡터의 크기가 행렬의 요소 개수보다 크거나 배수가 되지 않으면 경고 메시지가 출력되고 행렬을 만드는 데는 앞에 있는 벡터 요소들만 사용된다. m &lt;- matrix(1:9, nrow=3, ncol=3) m [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 m &lt;- matrix(1, nrow=3, ncol=3) m [,1] [,2] [,3] [1,] 1 1 1 [2,] 1 1 1 [3,] 1 1 1 m &lt;- matrix(1:3, nrow=3, ncol=3) m [,1] [,2] [,3] [1,] 1 1 1 [2,] 2 2 2 [3,] 3 3 3 m &lt;- matrix(11:30, nrow=3, ncol=3) Warning in matrix(11:30, nrow = 3, ncol = 3): data length [20] is not a sub-multiple or multiple of the number of rows [3] m [,1] [,2] [,3] [1,] 11 14 17 [2,] 12 15 18 [3,] 13 16 19 4.2 벡터를 결합하여 행렬 만들기 cbind()와 rbind() 기존의 벡터나 행렬을 열이나 행으로 묶어서 새로운 행렬을 만들 수 있다. 아래 예는 벡터를 cbind()와 rbind() 함수를 이용하여 열 또는 행으로 묶은 경우이다. cbind(1:5, 10:6) [,1] [,2] [1,] 1 10 [2,] 2 9 [3,] 3 8 [4,] 4 7 [5,] 5 6 rbind(1:5, 10:6, 11:15) [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 10 9 8 7 6 [3,] 11 12 13 14 15 벡터+벡터, 벡터+행렬, 행렬+행렬 결합 벡터들만 연결하여 행렬을 만드는 것이 아니라, 행렬과 벡터 또는 행렬과 행렬을 행 또는 열로 묶어 새로운 행렬을 만들 수 있다. A &lt;- matrix(1:9, nrow=3, ncol=3) cbind(A, 10:12) [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 rbind(10:12, A) [,1] [,2] [,3] [1,] 10 11 12 [2,] 1 4 7 [3,] 2 5 8 [4,] 3 6 9 cbind(A, A) [,1] [,2] [,3] [,4] [,5] [,6] [1,] 1 4 7 1 4 7 [2,] 2 5 8 2 5 8 [3,] 3 6 9 3 6 9 t &lt;- rbind(A, 10:12) t [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 [4,] 10 11 12 rbind(A, t) [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 [4,] 1 4 7 [5,] 2 5 8 [6,] 3 6 9 [7,] 10 11 12 cbind(A, t) Error in cbind(A, t): 각각의 행렬이 가진 행의 개수는 반드시 서로 일치해야 합니다 (인자 2를 참고하세요) 행렬+행렬 연결은 행 또는 열의 수가 같아야 한다. 마지막 예에서 볼 수 있듯이 행렬을 cbind 할 때는 행의 수가 같아야 하며, rbind를 할 때에는 열의 수가 일치하여야 한다. 하지만 벡터의 경우에는 가장 긴 길이에 맞추어 요소가 재사용된다. A &lt;- cbind(1:6, 7:9) A [,1] [,2] [1,] 1 7 [2,] 2 8 [3,] 3 9 [4,] 4 7 [5,] 5 8 [6,] 6 9 cbind(A, 10:11) [,1] [,2] [,3] [1,] 1 7 10 [2,] 2 8 11 [3,] 3 9 10 [4,] 4 7 11 [5,] 5 8 10 [6,] 6 9 11 rbind(1, 1:5) [,1] [,2] [,3] [,4] [,5] [1,] 1 1 1 1 1 [2,] 1 2 3 4 5 4.3 행렬의 필터링 행과 열 인덱스 벡터 벡터와 마찬가지로 행렬도 인덱스 벡터에 의해 필터링을 할 수 있다. 벡터는 오직 한 개의 인덱스 벡터를 가지는데, 행렬은 2차원인 만큼 각 차원을 지정할 수 있도록 2개의 인덱스 벡터를 가진다. 첫번째 인덱스 벡터는 추출할 행의 위치를, 두번째 인덱스 벡터는 추출할 열의 위치를 지정하게 된다. 벡터와 마찬가지로 행렬도 자연수, 음의 정수, 논리, 이름 인덱스 벡터를 가질 수 있다. 자연수 인덱스 벡터 아래는 1부터 25까지의 숫자를 크기 \\(5 \\times 5\\)인 행렬로 만든 후 인덱스 벡터로 각 데이터 요소를 특정하는 예를 보여주고 있다. z &lt;- matrix(1:25, nrow=5, ncol=5) z [,1] [,2] [,3] [,4] [,5] [1,] 1 6 11 16 21 [2,] 2 7 12 17 22 [3,] 3 8 13 18 23 [4,] 4 9 14 19 24 [5,] 5 10 15 20 25 z[1,1] [1] 1 z[5,5] [1] 25 z[1:3,1] [1] 1 2 3 z[2, 1:3] [1] 2 7 12 z[c(3, 5), c(2, 4)] [,1] [,2] [1,] 8 18 [2,] 10 20 다음 예처럼 인덱스 벡터 위치가 비어 있으면 그 인덱스는 전체 범위를 취한다. 인덱스 벡터가 모두 비어 있으면 행렬 그 자체가 된다. 즉 z[ , ]은 z와 같다. z[,2] [1] 6 7 8 9 10 z[3,] [1] 3 8 13 18 23 z[,c(3,5)] [,1] [,2] [1,] 11 21 [2,] 12 22 [3,] 13 23 [4,] 14 24 [5,] 15 25 z[ , ] [,1] [,2] [,3] [,4] [,5] [1,] 1 6 11 16 21 [2,] 2 7 12 17 22 [3,] 3 8 13 18 23 [4,] 4 9 14 19 24 [5,] 5 10 15 20 25 음의 정수 인덱스 벡터 벡터와 마찬가지로 음의 정수를 이용하면 해당 행과 열을 제외한 행렬을 구할 수 있다. z[,-2] [,1] [,2] [,3] [,4] [1,] 1 11 16 21 [2,] 2 12 17 22 [3,] 3 13 18 23 [4,] 4 14 19 24 [5,] 5 15 20 25 z[-3,] [,1] [,2] [,3] [,4] [,5] [1,] 1 6 11 16 21 [2,] 2 7 12 17 22 [3,] 4 9 14 19 24 [4,] 5 10 15 20 25 z[,-c(2,4)] [,1] [,2] [,3] [1,] 1 11 21 [2,] 2 12 22 [3,] 3 13 23 [4,] 4 14 24 [5,] 5 15 25 z[-3,-2] [,1] [,2] [,3] [,4] [1,] 1 11 16 21 [2,] 2 12 17 22 [3,] 4 14 19 24 [4,] 5 15 20 25 인덱스 벡터로 행과 열 재배치 하기 행렬의 인덱스 벡터를 이용하여 행 단위 재배치나 열 단위 재배치가 가능하다. z[5:1, ] [,1] [,2] [,3] [,4] [,5] [1,] 5 10 15 20 25 [2,] 4 9 14 19 24 [3,] 3 8 13 18 23 [4,] 2 7 12 17 22 [5,] 1 6 11 16 21 z[ , c(3:5, 1:2)] [,1] [,2] [,3] [,4] [,5] [1,] 11 16 21 1 6 [2,] 12 17 22 2 7 [3,] 13 18 23 3 8 [4,] 14 19 24 4 9 [5,] 15 20 25 5 10 아울러 인덱스 벡터를 사용하여 행과 열에 대한 정렬도 가능하다. 다음은 행렬의 첫번째 열을 기준으로 행을 큰 순에서 작은 순으로 정렬한 예이다. a &lt;- matrix(sample(1:16), nrow=4, ncol=4) a [,1] [,2] [,3] [,4] [1,] 5 8 2 12 [2,] 15 1 3 4 [3,] 6 11 10 13 [4,] 14 9 7 16 a[,1] [1] 5 15 6 14 order(a[,1]) [1] 1 3 4 2 a[order(a[,1]), ] [,1] [,2] [,3] [,4] [1,] 5 8 2 12 [2,] 6 11 10 13 [3,] 14 9 7 16 [4,] 15 1 3 4 논리 인덱스 벡터 벡터와 마찬가지로 논리 인덱스 벡터를 사용할 수 있다. 다음의 예에서 보듯이 행과 열의 인덱스 벡터에서 TRUE가 되는 행과 열만 선택된다. height &lt;- c(180, 172, 167, 175, 182) weight &lt;- c(72, 78, 58, 64, 68) year &lt;- c(1, 3, 2, 4, 2) A &lt;- cbind(height, weight, year) A[ , c(F, T, T)] weight year [1,] 72 1 [2,] 78 3 [3,] 58 2 [4,] 64 4 [5,] 68 2 A[ , c(T, F, T)] height year [1,] 180 1 [2,] 172 3 [3,] 167 2 [4,] 175 4 [5,] 182 2 A[ A[,1] &gt; 180, ] height weight year 182 68 2 A[ A[,2] &lt; 70, ] height weight year [1,] 167 58 2 [2,] 175 64 4 [3,] 182 68 2 행과 열 이름 부여하기: rownames()와 colnames() 벡터와 마찬가지로 행과 열의 이름을 인덱스로 하여 행렬의 부분을 참조할 수 있다. 행렬의 행과 열 이름의 확인과 할당은 rownames()와 colnames() 함수를 이용하여 이루어진다. rbind()나 cbind()에 의해 벡터 변수가 결합되면 변수의 이름이 자동적으로 행이나 열의 이름으로 부여된다. colnames(A) [1] &quot;height&quot; &quot;weight&quot; &quot;year&quot; rownames(A) NULL rownames(A) &lt;- paste(&quot;student&quot;, 1:5, sep=&quot;&quot;) A height weight year student1 180 72 1 student2 172 78 3 student3 167 58 2 student4 175 64 4 student5 182 68 2 A[, &quot;year&quot;] student1 student2 student3 student4 student5 1 3 2 4 2 A[&quot;student1&quot;,] height weight year 180 72 1 A[&quot;student2&quot;, &quot;weight&quot;] [1] 78 A[&quot;student2&quot;, 2] # 행과 열의 인덱스 벡터의 종류가 달라도 된다. [1] 78 벡터로서 필터링 하기 만약 행렬 이름 뒤에 인덱스 벡터가 하나밖에 주어지지 않으면, 행렬은 벡터로서 처리되어 필터링되고 행렬의 차원 정보는 무시된다 z [,1] [,2] [,3] [,4] [,5] [1,] 1 6 11 16 21 [2,] 2 7 12 17 22 [3,] 3 8 13 18 23 [4,] 4 9 14 19 24 [5,] 5 10 15 20 25 z[10] [1] 10 z[z&gt;15] [1] 16 17 18 19 20 21 22 23 24 25 4.4 행렬의 연산 행렬의 요소 단위 연산 행과 열의 수가 같은 행렬은 산술 연산을 할 수 있다. 이 경우 벡터와 마찬가지로 산술 연산은 같은 위치의 요소 단위(element-by-element)로 이루어진다. A &lt;- matrix(1:9, nrow=3, ncol=3) A [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 B &lt;- matrix(seq(from=10, length=9, by=10), nrow=3, ncol=3) B [,1] [,2] [,3] [1,] 10 40 70 [2,] 20 50 80 [3,] 30 60 90 A + B [,1] [,2] [,3] [1,] 11 44 77 [2,] 22 55 88 [3,] 33 66 99 B - A [,1] [,2] [,3] [1,] 9 36 63 [2,] 18 45 72 [3,] 27 54 81 A * B [,1] [,2] [,3] [1,] 10 160 490 [2,] 40 250 640 [3,] 90 360 810 B / A [,1] [,2] [,3] [1,] 10 10 10 [2,] 10 10 10 [3,] 10 10 10 행렬은 재사용되지 않는다 행과 열의 개수가 다른 행렬의 산술연산은 오류를 발생시킨다. 그 이유는 행렬은 벡터와 달리 요소의 재사용(recycling)이 일어나지 않기 때문이다. 그렇기 때문에 행렬과 행렬의 연산에서는 행과 열이 같은 크기이어야 한다. C &lt;- cbind(A, 10:12) C [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 B + C Error in B + C: 배열의 크기가 올바르지 않습니다 C &lt;- rbind(A, 1:3) C [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 [4,] 1 2 3 B * C Error in B * C: 배열의 크기가 올바르지 않습니다 벡터와 행렬의 연산: 벡터는 재사용된다 벡터와 행렬의 산술연산도 같은 위치의 요소 단위로 이루어진다. 벡터 a와 행렬 A의 연산시 벡터 a는 먼저 행렬 A와 같은 차원의 행렬로 변환되어 연산이 수행된다. 만약 벡터의 길이가 행렬의 길이보다 작으면 벡터의 데이터는 행렬의 길이만큼 순환 재사용된다. 연산을 위해 벡터가 행렬로 변환될 때도 matrix()로 행렬이 만들어질 때와 마찬가지로 열 별로 데이터를 채워나간다. a &lt;- 9:1 a + A [,1] [,2] [,3] [1,] 10 10 10 [2,] 10 10 10 [3,] 10 10 10 a &lt;- c(0, 10, 100) a + A [,1] [,2] [,3] [1,] 1 4 7 [2,] 12 15 18 [3,] 103 106 109 A * a [,1] [,2] [,3] [1,] 0 0 0 [2,] 20 50 80 [3,] 300 600 900 숫자와 행렬이 연산은 길이가 1인 벡터와 행렬이 연산되는 것이므로 모든 행렬의 요소와 숫자간에 연산이 이루어진다. 다음 예에서 숫자 10이 A의 모든 요소에 대응하여 계산되었음을 볼 수 있다. 10 * A [,1] [,2] [,3] [1,] 10 40 70 [2,] 20 50 80 [3,] 30 60 90 그러나 벡터의 길이가 배열의 길이보다 길면 오류가 발생한다. b &lt;- 1:10 b * A Warning in b * A: 두 객체의 길이가 서로 배수관계에 있지 않습니다 Error in eval(expr, envir, enclos): dims [product 9] do not match the length of object [10] 현재까지는 행렬의 연산 중 요소 단위의 연산만을 설명하였다. R은 이 외에도 행렬의 외적, 행렬의 곱, 역행렬 구하기 등 다양한 행렬 연산을 지원한다. 관심 있는 독자는 4.7 절을 참조한다. 4.5 행렬과 함수 4.5.1 행렬을 인수로 하는 함수들 이 절에서는 행렬을 인수로 하는 R 함수를 살펴본다. t() 어떤 행렬에서 행과 열이 바뀐 행렬을 전치행렬(transposed matrix)이라 한다. t() 함수를 이용하면 전치행렬을 구할 수 있다. A &lt;- matrix(1:4, nrow=2, ncol=2) A [,1] [,2] [1,] 1 3 [2,] 2 4 t(A) [,1] [,2] [1,] 1 2 [2,] 3 4 행렬의 차원 정보를 주는 함수: nrow(), ncol(), dim() 행렬의 행 수와 열 수를 구할 때는 nrow(), ncol() 함수를 이용한다. 행과 열의 차원 전체를 얻고자 하면 dim() 함수를 이용한다. nrow(A) [1] 2 ncol(A) [1] 2 dim(A) [1] 2 2 attributes(A) $dim [1] 2 2 행과 열에 이름 함수: rownames(), colnames() 행과 열 이름을 확인하거나, 새로 할당할 때는 rownames()와 colnames() 함수를 이용한다. rownames(A) NULL colnames(A) NULL rownames(A) &lt;- c(&quot;upper&quot;, &quot;lower&quot;) colnames(A) &lt;- c(&quot;left&quot;, &quot;right&quot;) A left right upper 1 3 lower 2 4 attributes(A) $dim [1] 2 2 $dimnames $dimnames[[1]] [1] &quot;upper&quot; &quot;lower&quot; $dimnames[[2]] [1] &quot;left&quot; &quot;right&quot; 벡터로 변환: as.vector(), c() as.vector()나 c() 함수를 이용하면 행렬을 벡터로 변경할 수 있다. 배열을 벡터로 바꾸는 공식적인 방법은 as.vector() 함수를 이용하는 것이다. 다음 예를 살펴보자. (R이 대소문자를 구분하는 것에 주의.) X &lt;- rbind(1:5, 5:1) X [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 5 4 3 2 1 x &lt;- as.vector(X) x [1] 1 5 2 4 3 3 4 2 5 1 attributes(x) NULL 하지만 c() 함수도 이와 유사한 효과를 나타낸다. cbind()와 rbind()는 행렬과 벡터의 차원 속성을 유지하며 데이터를 연결한다. 그러나 c() 함수는 dim과 dimnames 속성을 지운다. y &lt;- c(X) y [1] 1 5 2 4 3 3 4 2 5 1 attributes(y) NULL 행렬에 벡터 함수 적용하기 사실 행렬은 벡터에 dim 속성이 부여된 것뿐이므로, 벡터에 적용되는 함수를 행렬에 적용하면 행렬을 벡터로 간주하여 잘 동작한다. sum(X) [1] 30 mean(X) [1] 3 sd(X) [1] 1.490712 range(X) [1] 1 5 4.5.2 행렬의 행별 또는 열별로 함수를 적용하는 방법 apply() 함수를 이용하면 행렬의 행별 또는 열별로 함수를 적용할 수 있다. apply() apply(X, MARGIN, FUN, ...) apply() 함수의 X 인수에는 행별 또는 열별로 함수를 적용할 행렬을, MARGIN 인수에는 함수를 적용할 방향을 지정한다. MARGIN 인수가 1이면 행별로, 2이면 열별로 함수가 적용된다. apply() 함수의 FUN 인수에는 행이나 열별로 적용할 함수를 전달한다. 다음은 행렬 A에 대해 행별 합과 열별 합을 구한 예이다. 행렬 전체를 sum()한 결과와의 차이를 비교해 보라. set.seed(123) a &lt;- sample(1:25) a [1] 15 19 14 3 10 18 11 5 23 6 9 21 24 20 22 25 17 1 12 13 2 16 7 8 4 A &lt;- matrix(a, nrow=5, ncol=5) A [,1] [,2] [,3] [,4] [,5] [1,] 15 18 9 25 2 [2,] 19 11 21 17 16 [3,] 14 5 24 1 7 [4,] 3 23 20 12 8 [5,] 10 6 22 13 4 apply(A, 1, sum) [1] 69 84 51 66 55 apply(A, 2, sum) [1] 61 63 96 68 37 sum(A) [1] 325 apply() 함수가 적용되는 행렬의 행과 열에 이름이 있으면 apply()의 결과 벡터에도 해당 이름이 적용되어 출력된다. colnames(A) &lt;- LETTERS[1:5] rownames(A) &lt;- paste(&quot;X&quot;, 1:5, sep=&quot;&quot;) A A B C D E X1 15 18 9 25 2 X2 19 11 21 17 16 X3 14 5 24 1 7 X4 3 23 20 12 8 X5 10 6 22 13 4 apply(A, 1, min) X1 X2 X3 X4 X5 2 11 1 3 4 apply(A, 2, max) A B C D E 19 23 24 25 16 함수의 결과가 벡터이면 열로서 결합하여 출력한다. 지금까지 apply()의 FUN 인수에 부여된 함수는 sum()처럼 오직 하나의 값만을 반환하는 함수였다. 그렇기 때문에 apply() 함수로 행 또는 열별 합을 구하면 행 또는 열의 수만큼의 길이를 가지는 벡터로서 결과값이 반환되었다. 그러면 range()나 summary()처럼 길이가 2 이상인 벡터로서 결과를 주는 함수를 FUN 인수에 적용하면 어떻게 될까? 이 경우에는 함수가 적용되어 나온 결과 벡터를 cbind()처럼 열로서 결합하여 최종 결과를 출력한다. apply(A, 2, range) A B C D E [1,] 3 5 9 1 2 [2,] 19 23 24 25 16 apply(A, 1, range) X1 X2 X3 X4 X5 [1,] 2 11 1 3 4 [2,] 25 21 24 23 22 apply(A, 1, summary) X1 X2 X3 X4 X5 Min. 2.0 11.0 1.0 3.0 4 1st Qu. 9.0 16.0 5.0 8.0 6 Median 15.0 17.0 7.0 12.0 10 Mean 13.8 16.8 10.2 13.2 11 3rd Qu. 18.0 19.0 14.0 20.0 13 Max. 25.0 21.0 24.0 23.0 22 range() 함수는 최소값과 최대값이라는 두 요소로 이루어진 벡터를 결과로서 반환하는 함수이다. 따라서 첫번째 예는 A의 열별 최소값과 최대값을 열로 하는 행렬을, 두번째 예는 A의 행별 최대값과 최소값을 열로 하는 행렬을 반환하였다. 마지막 예에서는, summary() 함수가 최소값, 사분위수, 최대값, 평균 등의 통계치를 벡터로 반환하기 때문에, apply() 결과는 A의 행별 통계치를 열로 하는 행렬로서 반환되었다. 4.6 배열 * 4.6.1 배열의 생성 벡터는 일차원 데이터 구조로 하나의 인덱스 벡터로 요소의 위치를 지정한다. x &lt;- 11:20; x [1] 11 12 13 14 15 16 17 18 19 20 x[1] [1] 11 x[6:7] [1] 16 17 행렬은 2차원의 데이터 구조로 두 개의 인덱스 벡터로 요소의 위치를 지정한다. 첫번째 인덱스 벡터가 행의 위치를 지정하고, 두번째 인덱스 벡터가 열 위치를 지정한다. x &lt;- matrix(11:19, nrow=3, ncol=3); x [,1] [,2] [,3] [1,] 11 14 17 [2,] 12 15 18 [3,] 13 16 19 x[1, 2] [1] 14 x[2:3, 1] [1] 12 13 배열은 행렬을 일반화한 것으로 2차원 이상의 차원을 가지는 데이터 구조이다. 사실 행렬은 2차인 구조를 가지는 배열의 특수한 예이다. 배열은 벡터, 행렬과 마찬가지로 동일한 형식의 데이터만 그 요소로 가질 수 있으므로, 따라서 숫자 배열, 문자 배열, 논리값 배열 등이 만들어질 수 있다. array() 배열은 array() 함수를 이용하여 행렬과 비슷한 방법으로 만들수 있다. matrix(data, nrow, ncol) array(data, dim) dim 인수 matrix() 함수와 마찬가지로 데이터 요소를 가지고 있는 벡터가 array()의 첫번째 인수로 제공된다. matrix() 함수와 다른 점은 차원의 크기가 dim 인수에 벡터 형식으로 제공된다는 것이다. 행렬은 2차원으로 차원이 정해져 있으므로 첫번째 차원인 행의 크기는 nrow 인수에 두번째 차원인 열의 크기는 ncol 인수에 숫자 하나로 제공된다. 그러나 배열은 2차원 이상의 다양한 차원을 가질 수 있으므로, 원하는 차원의 수만큼 각 차원의 크기를 결정해야 한다. 따라서 차원의 개수만큼의 요소를 가지는 벡터가 dim 인수에 제공된다. 따라서 어떤 배열의 차원 벡터의 길이가 k이면 그 배열은 k차원 배열이라고 한다. 다음은 3차원 배열을 생성한 예이다. x &lt;- array(11:28, dim=c(3, 3, 2)) x , , 1 [,1] [,2] [,3] [1,] 11 14 17 [2,] 12 15 18 [3,] 13 16 19 , , 2 [,1] [,2] [,3] [1,] 20 23 26 [2,] 21 24 27 [3,] 22 25 28 3차원 배열의 출력 방식 행렬과 마찬가지로 3차원 배열의 첫번째 차원은 행(rows)을, 두번째 차원은 열(columns)을, 세번째 차원은 층(layers)을 나타낸다. 3차원 큐브를 생각하면 이해하기 쉽다. 앞의 예에서는 행은 3개, 열도 3개, 층은 2개로 데이터 요소가 배열되었다. 3차원 배열의 경우 컴퓨터 화면은 2차원이기 때문이 각 층을 차례로 보여주는 방식으로 배열의 요소를 출력한다. 따라서 각 층의 데이터는 2차원의 행렬의 형태로 출력된다. 출력된 행렬이 어떤 층의 데이터인지 보여주기 위해서 ’ , , (층 번호)’가 각 행렬의 위에 같이 출력되었다. 3차원 배열에서 데이터가 채워지는 순서 예에서 보듯이 행렬과 마찬가지로 앞 차원의 인덱스들이 먼저 변하며 데이터가 채워진다. 1층의 데이터가 다 채워진 후 2 층의 데이터가 채워지고, 동일 층에서는 앞의 열이 먼저 채워지고 뒤의 열이 다음에 채워진다. 동일 층의 동일 열에서는 앞의 행이 먼저 채워지고 뒤의 행이 다음에 채워진다. 즉, [행, 열, 층]의 인덱스가 [1, 1, 1]에서 시작하여 [2, 1, 1]로 진행하며 1층-1열의 모든 행을 다 채우고 나서, 다시 [1, 2, 1]부터 1층-2열의 데이터를 채운다. 그리고 1층의 데이터가 모두 채워지면 다시 2층의 1열의 1행, 즉 [1, 1, 2]부터 차례대로 1층과 같은 방식으로 데이터를 채워나간다. 비유적으로 설명하자면 숫자의 자리수가 일의 자리가 채워지면 십의 자리, 그리고 그 다음 백의 자리가 채워지듯이, 첫번째 차원의 인덱스가 모두 채워지면 두번째 차원의 인덱스가 하나 증가하고, 두번째 차원의 인덱스가 모두 채워지면 세번째 차원이 인덱스가 하나 증가하며 데이터가 채워진다고 할 수 있다. 다만 십진법에서는 숫자의 자리수는 모두 10으로 크기가 같고, 0부터 시작하며, 숫자 표기상 뒷쪽 자릿수가 먼저 채워지는데, R의 배열에서는 차원의 크기가 서로 다를 수 있고, 1부터 시작하고, 앞 쪽의 차원이 먼저 채워지는 것에 차이가 있다. k차원 배열은 k개의 인덱스 벡터로 요소의 위치를 지정한다. 3차원 배열에서 요소의 위치를 지정하기 위해서는 3개의 인덱스 벡터가 필요하다. 마찬가지로 k-차원의 배열에서 요소의 위치를 지정하기 위해서는 k개의 인덱스 벡터가 필요하다. x[2, 1, 1] [1] 12 x[2, 1, 2] [1] 21 x[1, 2:3, 2] [1] 23 26 행렬은 2차원 배열이므로 array() 함수를 이용해서도 행렬을 만들 수 있다. x &lt;- array(11:19, c(3,3)) x [,1] [,2] [,3] [1,] 11 14 17 [2,] 12 15 18 [3,] 13 16 19 벡터를 재사용하여 배열 만들기 행렬을 만들 때와 마찬가지로 데이터로 제공된 벡터가 배열의 모든 공간을 채울 수 없으면 벡터가 재사용된다. x &lt;- array(1, dim=c(2, 3, 2)) x , , 1 [,1] [,2] [,3] [1,] 1 1 1 [2,] 1 1 1 , , 2 [,1] [,2] [,3] [1,] 1 1 1 [2,] 1 1 1 x &lt;- array(1:6, dim=c(3, 3, 2)) x , , 1 [,1] [,2] [,3] [1,] 1 4 1 [2,] 2 5 2 [3,] 3 6 3 , , 2 [,1] [,2] [,3] [1,] 4 1 4 [2,] 5 2 5 [3,] 6 3 6 참고로 벡터를 재사용하여 배열을 채울 때, 벡터의 길이가 배열의 길이의 배수가 아니어도 경고 메시지가 나오지 않는다. 이는 행렬의 경우와 다른데 차원이 커지면 벡터의 길이와 배열의 길이를 배수로 맞추는 것이 쉽지 않기 때문에 생략한 것으로 보인다. x &lt;- array(1:5, dim=c(3, 3, 2)) x , , 1 [,1] [,2] [,3] [1,] 1 4 2 [2,] 2 5 3 [3,] 3 1 4 , , 2 [,1] [,2] [,3] [1,] 5 3 1 [2,] 1 4 2 [3,] 2 5 3 마찬가지로 벡터의 길이가 배열의 길이보다 길어도 아무 경고 메시지 없이 배열을 잘 생성한다. x &lt;- array(1:30, dim=c(3, 3, 2)) x , , 1 [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 , , 2 [,1] [,2] [,3] [1,] 10 13 16 [2,] 11 14 17 [3,] 12 15 18 4차원 배열 예 마지막으로 4차원 배열을 만들어 보자. 컴퓨터 화면은 2차원이므로 4차원 배열을 표현하기 위해, 세번째와 네번째 차원의 인덱스가 정해져 있을 때의 데이터를 2차원 행렬로 출력해 주는 것을 볼 수 있다. 3차원 배열 때와 마찬가지로 앞의 차원의 인덱스가 먼저 변하면서 데이터가 차례로 배정됨을 볼 수 있다. y &lt;- array(1:30, dim=c(2, 3, 2, 2)) y , , 1, 1 [,1] [,2] [,3] [1,] 1 3 5 [2,] 2 4 6 , , 2, 1 [,1] [,2] [,3] [1,] 7 9 11 [2,] 8 10 12 , , 1, 2 [,1] [,2] [,3] [1,] 13 15 17 [2,] 14 16 18 , , 2, 2 [,1] [,2] [,3] [1,] 19 21 23 [2,] 20 22 24 4.6.2 배열도 결국 벡터 배열은 dim 속성을 가진 벡터이다. 행렬과 마찬가지로 배열도 사실 벡터이다. 그러므로 typeof() 함수를 이용하여 생성된 배열의 타입을 확인해 보면 숫자 벡터임을 보여준다. 그러나 class() 함수로 배열의 클래스를 확인하면 array 클래스로 처리됨을 볼 수 있다. 앞의 예에서도 벡터가 array 클래스로 처리되기 때문에 행, 열, 층 등으로 잘 구분되어 출력될 수 있었던 것이다. Array 클래스의 데이터는 본질적으로 벡터가 dim 속성을 가지고 있는 것 뿐이다. Dim 속성은 해당 배열의 각 차원의 크기를 나타내 준다. R은 dim 속성에 저장된 차원 정보를 이용하여 데이터 요소를 각 차원에 맞게 출력해 준다. typeof(x) [1] &quot;integer&quot; class(x) [1] &quot;array&quot; attributes(x) $dim [1] 3 3 2 벡터에 dim 속성을 부여하여 배열 만들기 배열은 결국 벡터가 dim 속성을 가지고 있는 것이므로 벡터에 dim 속성을 부여하여 배열을 만들 수도 있다. 다음 예에서도 보듯이 데이터는 변함이 없고 dim 속성에 따라 데이터가 보여지는 형식이 달라짐을 볼 수 있다. x &lt;- 1:12 dim(x) NULL x [1] 1 2 3 4 5 6 7 8 9 10 11 12 dim(x) &lt;- c(3, 4) x [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 dim(x) &lt;- c(2, 3, 2) x , , 1 [,1] [,2] [,3] [1,] 1 3 5 [2,] 2 4 6 , , 2 [,1] [,2] [,3] [1,] 7 9 11 [2,] 8 10 12 dim(x) &lt;- NULL x [1] 1 2 3 4 5 6 7 8 9 10 11 12 dimnames 속성과 dimnames() 함수 배열도 행렬과 마찬가지로 각 차원에 이름을 부여할 수 있다. 배열의 dimnames 속성에 차원의 이름 벡터를 리스트 객체로 만들어 부여하면 된다. (리스트 객체에 대한 설명은 5장을 살펴보기 바란다.) 배열에 dimnames 속성을 부여하려면 array() 함수의 dimnames 인수를 이용하거나, 다음처럼 dimnames() 함수를 사용한다. dim(x) &lt;- c(2, 3, 2) dimnames(x) &lt;- list(c(&quot;A&quot;, &quot;B&quot;), paste(&quot;group&quot;,1:3,sep=&quot;-&quot;), c(&quot;Male&quot;, &quot;Female&quot;)) x , , Male group-1 group-2 group-3 A 1 3 5 B 2 4 6 , , Female group-1 group-2 group-3 A 7 9 11 B 8 10 12 attributes(x) $dim [1] 2 3 2 $dimnames $dimnames[[1]] [1] &quot;A&quot; &quot;B&quot; $dimnames[[2]] [1] &quot;group-1&quot; &quot;group-2&quot; &quot;group-3&quot; $dimnames[[3]] [1] &quot;Male&quot; &quot;Female&quot; 4.6.3 배열의 연산과 필터링 배열의 요소 단위 연산 배열 연산과 필터링은 행렬 연산과 필터링의 경우와 동일한 원리로 작동한다. 다른 점은 행렬보다 더 많은 차원의 데이터를 다룬다는 것이다. 행렬 연산과 마찬가지로 배열 연산도 동일한 차원 벡터를 갖는 배열들이 요소 단위로 연산이 이루어진다. a &lt;- array(1:8, c(2, 2, 2)); a , , 1 [,1] [,2] [1,] 1 3 [2,] 2 4 , , 2 [,1] [,2] [1,] 5 7 [2,] 6 8 b &lt;- array(10^(0:7), c(2, 2, 2)); b , , 1 [,1] [,2] [1,] 1 100 [2,] 10 1000 , , 2 [,1] [,2] [1,] 1e+04 1e+06 [2,] 1e+05 1e+07 a + b , , 1 [,1] [,2] [1,] 2 103 [2,] 12 1004 , , 2 [,1] [,2] [1,] 10005 1000007 [2,] 100006 10000008 a * b , , 1 [,1] [,2] [1,] 1 300 [2,] 20 4000 , , 2 [,1] [,2] [1,] 5e+04 7e+06 [2,] 6e+05 8e+07 행렬 연산과 마찬가지로 차원 벡터가 다른 배열과 연산을 시도하면 오류가 발생한다. d &lt;- array(11:30, c(2, 3, 2)); d , , 1 [,1] [,2] [,3] [1,] 11 13 15 [2,] 12 14 16 , , 2 [,1] [,2] [,3] [1,] 17 19 21 [2,] 18 20 22 a + d Error in a + d: 배열의 크기가 올바르지 않습니다 벡터와 배열이 연산되면 벡터는 배열의 길이만큼 재사용되어 연산이 수행된다. 2 * a , , 1 [,1] [,2] [1,] 2 6 [2,] 4 8 , , 2 [,1] [,2] [1,] 10 14 [2,] 12 16 1:2 * a , , 1 [,1] [,2] [1,] 1 3 [2,] 4 8 , , 2 [,1] [,2] [1,] 5 7 [2,] 12 16 차원 축소와 drop 인수 배열도 행렬과 마찬가지로 차원의 수만큼의 자연수, 음의 정수, 논리, 이름 인덱스 벡터로 필터링을 수행할 수 있다. 필터링의 결과로 어떤 차원의 크기가 1로 줄어들게 되면, 더 낮은 차원의 데이터 구조로 차원이 축소된다. 예를 들어 3차원 배열을 필터링한 결과가 1차원 벡터나 2차원 행렬이 될 수 있다. 이러한 차원 축소를 원하지 않으면 drop=FALSE 인수를 사용하여 필터링을 하면 된다.3 x , , Male group-1 group-2 group-3 A 1 3 5 B 2 4 6 , , Female group-1 group-2 group-3 A 7 9 11 B 8 10 12 x[ , , 2] group-1 group-2 group-3 A 7 9 11 B 8 10 12 x[ ,2, 2] A B 9 10 x[1, 2:3, 2] group-2 group-3 9 11 x[1, 2:3, 1:2] Male Female group-2 3 9 group-3 5 11 x[1, 2:3, 1:2, drop=F] , , Male group-2 group-3 A 3 5 , , Female group-2 group-3 A 9 11 x[,-2,c(T, F)] group-1 group-3 A 1 5 B 2 6 x[&quot;A&quot;, &quot;group-2&quot;, &quot;Female&quot;] [1] 9 4.7 행렬과 배열의 고급 연산 * 행렬은 배열의 매우 중요하고 특수한 경우이다. 따라서 R에서는 행렬에만 가능한 여러 연산과 기능들이 있다. 4.7.1 행렬의 곱 지금까지 행렬의 연산은 요소 단위로 이루어졌다. 따라서 행렬에 곱하기 연산자 *를 사용하면 같은 위치의 요소끼리 곱해졌다. 그러나 수학에서 일반적으로 정의하는 행렬의 곱은 다음과 같은 형식으로 수행된다. \\[\\begin{equation*} \\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix} \\times \\begin{pmatrix} e &amp; f \\\\ g &amp; h \\end{pmatrix} = \\begin{pmatrix}b\\,g+a\\,e &amp; b\\,h+a\\,f \\\\ d\\,g+c\\,e &amp; d\\,h+c\\,f \\end{pmatrix} \\end{equation*}\\] 연산자 %*%는 행렬의 곱 연산을 수행한다. 다음의 예는 요소별로 곱이 이루어지는 * 연산자와 행렬의 곱 연산자 %*%이 어떻게 다른지 보여준다. 결과에서 알 수 있듯이 행렬 곱은 교환법칙이 성립하지 않는다. 반면 요소 단위의 곱은 교환법칙이 성립한다. A &lt;- array(1:4, c(2,2)); A [,1] [,2] [1,] 1 3 [2,] 2 4 B &lt;- array(10^(0:3), c(2,2)); B [,1] [,2] [1,] 1 100 [2,] 10 1000 A * B [,1] [,2] [1,] 1 300 [2,] 20 4000 B * A [,1] [,2] [1,] 1 300 [2,] 20 4000 A %*% B [,1] [,2] [1,] 31 3100 [2,] 42 4200 B %*% A [,1] [,2] [1,] 201 403 [2,] 2010 4030 벡터가 행렬의 곱 수식에 나타나면 자동적으로 열 벡터나 행 벡터로 변환이 이루어진다. 그리고 행렬의 곱의 결과과 행이나 열 벡터로 표현되더라도 차원 축소는 일어나지 않는다. x &lt;- c(1,1) x %*% A [,1] [,2] [1,] 3 7 A %*% x [,1] [1,] 4 [2,] 6 x %*% A %*% x [,1] [1,] 10 4.7.2 행렬의 주대각선 요소와 대각행렬 행렬을 이용한 수학적 연산에서 행렬의 주대각선 요소나 대각행렬은 매우 중요한 역할을 수행한다. R은 diag() 함수를 이용하여 행렬에서 주대각선 요소를 추출하거나, 대각행렬을 만든다. diag() 함수는 첫번째 인수 x에 어떤 형식의 데이타가 오는지에 따라 다른 연산을 수행한다. 인수 x가 행렬이면, 그 행렬의 주대각선 요소를 벡터로 반환한다. 인수 x가 벡터이고 벡터의 길이가 1보다 크면, 그 벡터를 주대각선 요소로 하는 대각행렬(diagonal matrix)를 반환한다. 이 경우 nrow나 ncol이 주어지면 벡터가 재사용되어 대각행렬을 만들 수 있다. 인수 x가 숫자 하나이고 그 값이 k이면, \\(k \\times k\\) 단위 행렬(identity matrix)을 반환한다. 만약 nrow나 ncol 등이 주어지면 k가 주대각선 요소인 대각행렬이 생성된다. diag(A) [1] 1 4 diag(1:4) [,1] [,2] [,3] [,4] [1,] 1 0 0 0 [2,] 0 2 0 0 [3,] 0 0 3 0 [4,] 0 0 0 4 diag(3) [,1] [,2] [,3] [1,] 1 0 0 [2,] 0 1 0 [3,] 0 0 1 diag(3, nrow=2) [,1] [,2] [1,] 3 0 [2,] 0 3 4.7.3 연립 일차 방정식과 역행렬 다음과 같은 연립 일차 방정식이 있다고 하자. \\[\\begin{align*} 2 x - 3 y &amp;= 5 \\\\ -2 x + 4 y &amp;= -4 \\end{align*}\\] 위의 연립 일차 방정식은 행렬과 벡터를 이용하여 나타내면 다음처럼 표현된다. \\[\\begin{equation*} \\mathbf{A} \\mathbf{x} = \\mathbf{b} \\end{equation*}\\] 단, \\[\\begin{equation*} \\mathbf{A} = \\begin{pmatrix} 2 &amp; -3 \\\\ -2 &amp; 4 \\end{pmatrix}, \\, \\mathbf{x} = \\begin{pmatrix} x \\\\ y \\end{pmatrix}, \\, \\mathbf{b} = \\begin{pmatrix} 5 \\\\ -4 \\end{pmatrix}. \\end{equation*}\\] 위의 식의 해를 구하기 위해서는 앙변에 \\(\\mathbf{A}\\)의 역행렬 \\(\\mathbf{A}^{-1}\\)을 곱하면 된다. \\[\\begin{equation*} \\mathbf{x} = \\mathbf{A}^{-1} \\mathbf{b} \\end{equation*}\\] R에서는 solve() 함수를 이용하여 해를 구한다. solve(a, b) 함수의 첫번째 인수 a에는 연립 일차 방정식의 좌변의 계수를 나타내는 정방행렬이, 두번째 인수 b에는 우변의 상수항을 나타내는 벡터가 제공된다. A &lt;- matrix(c(2, -2, -3, 4), nrow=2, ncol=2); A [,1] [,2] [1,] 2 -3 [2,] -2 4 b &lt;- c(5, -4); b [1] 5 -4 x &lt;- solve(A, b); x [1] 4 1 A %*% x [,1] [1,] 5 [2,] -4 위의 문제의 답은 \\(x = 4\\)이고 \\(y = 1\\)임을 알 수 있다. 행렬 A와 해 x를 곱하면 우변항의 b와 같아짐을 확인할 수 있다. solve() 함수의 두번째 인수 b가 주어지지 않으면 b를 단위 행렬로 하여 해를 구한다. 그러면 해는 좌변 행렬의 역행렬이 된다. \\[\\begin{align*} &amp; \\mathbf{A} \\mathbf{x} = \\mathbf{I} \\\\ &amp; \\mathbf{x} = \\mathbf{A}^{-1} \\end{align*}\\] 단, \\(\\mathbf{I}\\)는 \\(\\mathbf{A}\\)와 차원이 같은 단위 행렬이다. 따라서 다음은 행렬 \\(\\mathbf{A}\\)의 역행렬 \\(\\mathbf{A}^{-1}\\)을 구해준다. 결과에서 solve()의 해를 원래의 행렬로 곱하면 단위 행렬이 됨을 확인할 수 있다. A.inverse &lt;- solve(A); A.inverse [,1] [,2] [1,] 2 1.5 [2,] 1 1.0 A %*% A.inverse [,1] [,2] [1,] 1 0 [2,] 0 1 \\(\\mathbf{A}^{-1}\\)을 구하였으므로 \\(\\mathbf{x} = \\mathbf{A}^{-1} \\mathbf{b}\\) 관계를 이용하여 앞의 방정식의 해를 구할 수도 있다. A.inverse %*% b [,1] [1,] 4 [2,] 1 하지만 이러한 방법은 수치 계산적인 측면에서 비효율적이고 불안정한 결과를 만들 수 있다. 따라서 \\(\\mathbf{A}\\)의 역행렬을 직접 구하기보다는 solve(A, b)를 이용하여 해를 구하는 것이 좋다. \\(\\mathbf{x}^{t} \\mathbf{A}^{-1} \\mathbf{x}\\) 처럼 이차형식(quadratic form)을 구할 때도 역행렬을 직접 구하기보다는 x %*% solve(A, x)로 계산하는 것이 더 좋다. 4.7.4 고유치(eigenvalues)와 고유벡터(eigenvectors) 행렬의 고유치와 고유벡터를 구하기 위해서는 eigen() 함수를 이용한다. eigen() 함수의 결과는 values와 vectors라는 이름을 가진 두 요소를 가지는 리스트이다. (리스트에 대해서는 5 장을 참조하라.) 고유치 또는 고유벡터를 확인하려면 values 또는 vectors로 리스트 요소를 지정하면 된다. A [,1] [,2] [1,] 2 -3 [2,] -2 4 ev &lt;- eigen(A) ev$values [1] 5.6457513 0.3542487 ev$vectors [,1] [,2] [1,] 0.6354064 -0.8767397 [2,] -0.7721779 -0.4809652 매우 큰 행렬의 경우 고유벡터가 필요하지 않다면 계산하지 않는 것이 효율적이다. eigen() 함수의 only.values 옵션을 TRUE로 설정하면 고유벡터는 계산하지 않고 고유치만 계산한다. eigen(A, only.values = TRUE) $values [1] 5.6457513 0.3542487 $vectors NULL C나 Java 등의 언어에 익숙한 독자들은 배열의 인덱스에 drop이라는 인수를 사용할 수 있다는 것이 의아할 수 있을 것이다. R은 함수적 프로그래밍 언어(functional programming language)로 배열의 필터링마저도 사실 함수의 형태로 구현된다. 필터링을 지원하는 함수는 [인데 이 함수는 drop 인수를 지원한다.↩︎ "],["ch-R-List.html", "Chapter 5 R 리스트 5.1 객체, 객체의 타입, 객체의 속성 * 5.2 리스트의 생성 및 필터링 5.3 리스트의 변경 및 연결 5.4 리스트에 함수 적용하기 5.5 리스트 활용 분야", " Chapter 5 R 리스트 지금까지는 객체에 포함되는 요소가 모두 같은 타입인 벡터나 행렬을 살펴보았다. 이 장에서는 숫자와 문자 등 다른 타입의 데이터를 결합시킬 수 있는 리스트라는 데이터 구조를 살펴본다. 실제 데이터 분석을 수행할 때 사용자가 리스트를 직접적으로 생성하는 경우는 그리 많지 않다. 그러나 리스트를 이해하는 것은 매우 중요한데 그 이유는 다음과 같다. 리스트 이해의 중요성 첫째, 6 장에서 보겠지만 데이터 분석에서 가장 중요한 데이터 구조는 데이터 프레임이다. 그리고 데이터 프레임은 리스트를 기반으로 하고 있다. 따라서 데이터 프레임의 근간이 되는 리스트에 대해 명확하게 이해하는 것이 데이터를 효율적으로 조작하는 데 도움이 된다. 둘째, 통계 및 데이터 마이닝을 위해 사용하는 다양한 R의 함수는 복잡한 분석의 결과를 리스트 타입으로 제공하는 경우가 많다. 따라서 데이터 분석의 결과를 효과적으로 이용하기 위해서는 리스트 구조를 이해할 필요가 있다. 앞서 리스트란 타입이 다른 데이터를 결합시킬 수 있는 데이터 구조라고 했으므로, 본격적으로 리스트를 논하기 전에 R에서 사용하는 다양한 데이터 타입을 먼저 살펴보자. 5.1 객체, 객체의 타입, 객체의 속성 * 객체 R에서는 메모리에 저장하거나 메모리에서 읽어 올 수 있는 모든 데이터 단위를 객체(objects)라고 부른다. 앞에서 살펴본 숫자 벡터, 논리 벡터, 문자 벡터들은 모두 객체이다. 또한 행렬, 배열, 그리고 앞으로 살펴볼 리스트, 데이터 프레임뿐 아니라, 함수, 그래프 등도 모두 객체여서 변수에 할당하여 메모리에 저장하거나 필요시 메모리에서 읽어들일 수 있다. 객체의 타입 객체는 하나의 데이터 타입(type)을 갖는다. (모드(mode)라고도 한다.) 데이터 타입이 다른 객체는 다른 방식으로 메모리에 저장되고 읽어들여진다. 예를 들어 논리 벡터의 경우 논리값 타입을 가지며, 논리값 타입을 갖는 데이터는 논리값이 효율적으로 저장되고 연산될 수 있는 형식으로 메모리에 저장되어진다. R에서는 함수를 나타내는 closure 타입, R의 표현식을 의미하는 expression 타입 등 다양한 타입이 존재한다. 그러나 데이터의 관점에서 보면 크게 두 가지 종류의 근본적인 데이터 타입이 존재한다. 하나는 원자적 벡터(atomic vectors)이고, 다른 하나는 일반적 벡터(generic vectors) 또는 리스트라고 불리는 데이터 타입이다. 원자적 벡터 atomic vector 원자적 벡터는 숫자 벡터, 논리 벡터, 문자 벡터처럼 하나의 데이터 형식으로 저장되는 데이터 타입을 의미한다. 반면 리스트는 숫자와 문자 등 서로 다른 데이터 형식으로 저장되는 요소를 가지는 데이터 타입이다. 원자적 벡터의 대표적인 타입은 논리값(logical), 정수(integer), 실수(double), 복소수(complex), 문자(chracter), 바이트(raw) 등이 있다. typeof() 객체가 어떤 데이터 타입으로 저장되어 있는지를 확인하기 위해서 typeof() 함수를 이용할 수 있다. a &lt;- c(T, F, F, T); typeof(a) [1] &quot;logical&quot; b &lt;- 1:4; typeof(b) [1] &quot;integer&quot; d &lt;- c(1.5, 2.7, 3.3, 4.7); typeof(d) [1] &quot;double&quot; e &lt;- c(&quot;car&quot;, &quot;bus&quot;, &quot;train&quot;, &quot;plane&quot;); typeof(e) [1] &quot;character&quot; 데이터 자동 형변환 논리값, 정수, 실수, 문자 데이터 형식은 제시된 순서대로 데이터가 자동 형변환 된다. 논리값과 정수가 하나의 벡터에 같이 사용되면, 벡터는 하나의 데이터 형식으로 저장되어야 하므로 논리값보다 더 표현 범위가 넓은 정수 형식으로 데이터가 변환된다. 논리값의 FALSE는 0으로, TRUE는 1로 변환된다. 정수와 실수가 같이 사용되면 모두 실수 형식으로 변환된다. 실수와 문자 데이터가 같이 사용되면 모두 문자 형식으로 자동 변환된다. f &lt;- c(a, b); f; typeof(f) [1] 1 0 0 1 1 2 3 4 [1] &quot;integer&quot; g &lt;- c(b, d); g; typeof(g) [1] 1.0 2.0 3.0 4.0 1.5 2.7 3.3 4.7 [1] &quot;double&quot; h &lt;- c(d, e); h; typeof(h) [1] &quot;1.5&quot; &quot;2.7&quot; &quot;3.3&quot; &quot;4.7&quot; &quot;car&quot; &quot;bus&quot; &quot;train&quot; &quot;plane&quot; [1] &quot;character&quot; 물론 숫자 형식의 데이터가 문자로 변환되면 더이상 숫자로서의 연산을 지원되지 않는다. g * 2 [1] 2.0 4.0 6.0 8.0 3.0 5.4 6.6 9.4 h * 2 Error in h * 2: 이항연산자에 수치가 아닌 인수입니다 내재적 속성 객체의 데이터 타입은 모든 객체의 내재적 속성 중 하나이다. 모든 객체가 가지는 또 다른 내재적 속성은 길이이다. 길이 속성은 해당 객체의 데이터 요소가 몇 개인지를 알려준다. typeof(objects)와 length(objects) 함수를 이용하면 객체의 데이터 타입과 길이를 알아낼 수 있다. length(a) [1] 4 length(b) [1] 4 행렬의 타입 행렬도 결국은 모두 같은 데이터 형식을 가지는 데이터 요소로 구성되어 있으므로, 원자적 벡터 형식의 데이터라고 할 수 있다. 따라서 행렬의 데이터 타입도 결국 벡터가 가지는 데이터 타입과 동일함을 확인할 수 있다. aa &lt;- matrix(a, nrow=2); typeof(aa); length(aa) [1] &quot;logical&quot; [1] 4 bb &lt;- matrix(b, nrow=2); typeof(bb); length(bb) [1] &quot;integer&quot; [1] 4 dd &lt;- matrix(d, nrow=2); typeof(dd); length(dd) [1] &quot;double&quot; [1] 4 ee &lt;- matrix(e, nrow=2); typeof(ee); length(ee) [1] &quot;character&quot; [1] 4 즉 벡터 b와 행렬 bb는 동일한 형식으로 정수가 4개 메모리에 저장되어 있는 데이터이다. 그러므로 데이터 타입도 integer로 동일하고 요소의 길이도 동일하다. 그러나 b와 bb를 출력해 보면 서로 다른 방식으로 처리되어 출력됨을 볼 수 있다. b는 일련의 숫자로 출력되고, bb는 행과 열이 2인 행렬의 형식으로 출력된다. R은 똑같이 저장되어 있는 데이터에서 이를 어떻게 구분하여 처리하는 것일까? b [1] 1 2 3 4 bb [,1] [,2] [1,] 1 3 [2,] 2 4 class(b) [1] &quot;integer&quot; class(bb) [1] &quot;matrix&quot; &quot;array&quot; 클래스 class() R은 객체에 데이터 타입 말고 클래스라는 속성을 부여할 수 있다. 데이터 타입은 내재적 속성으로 모든 객체에게 부여된다. 반면 클래스는 객체에 따라 부여되지 않을 수도 있고 여러 개가 부여될 수 있는 속성으로, 객체가 R 함수에 의해 처리될 때 어떤 방식으로 처리되어야 하는지를 알려준다. 위의 예에서 숫자 벡터 b는 아무 클래스도 부여되지 않았으므로 데이터 타입인 integer가 클래스로 지정되어 있고, 행렬 bb의 데이터 타입은 integer이지만 클래스로 matrix가 부여되어 있음을 확인할 수 있다. 따라서 R은 b와 bb의 클래스가 다르므로 print() 출력 함수로 데이터를 출력할 때 다른 방식으로 처리를 수행하였다. attributes() 그러면 R은 4개의 정수가 차례로 저장되어 있는 bb에 대해 2개의 행과 2개의 열을 가진 행렬로 표현해야 한다는 것을 어떻게 알았을까? R은 객체의 데이터를 데이터 타입에 맞추어 저장하고 있을 뿐만 아니라, 그 객체의 부가 정보(메타 정보)를 속성이라는 형태로 저장하고 있다. 각 객체가 가진 내재적 속성인 데이터 타입과 길이를 제외한 모든 속성은 attributes(objects) 함수에 의해 확인할 수 있다. attributes(b) NULL attributes(bb) $dim [1] 2 2 위의 예에서 벡터 b는 다른 속성 정보가 없지만, bb는 dim 속성에 행과 열의 길이 정보가 부여되어 있음을 알 수 있다. 사실 R은 벡터에 부여된 dim 속성을 보고 이 벡터가 행렬로 또는 배열로 처리되어야 하는지를 인식하고, 행과 열의 길에에 맞게 출력과 연산 등을 수행한다. attr() attributes(objects) 함수는 객체에 내재된 속성을 제외한 모든 속성을 보여주거나 모든 속성에 데이터를 할당할 때 이용되는 반면, attr(object, name) 함수는 객체에서 특정 이름을 가진 속성을 보여주거나 해당 속성에 데이터를 할당하기 위해 이용된다. 이러한 함수가 자주 사용되지는 않지만 속성에 대한 개념을 이해하는 것은 매우 중요하다. R의 객체 시스템과 각 속성들은 통합되어 있으므로 객체의 속성을 할당하거나 삭제할 때 주의할 필요가 있기 때문이다. 객체의 속성은 할당문의 좌변에 사용되어서 객체에 새로운 속성을 부여하거나 기존의 속성 값을 변경할 수 있다. 예를 들어 다음과 같이 z 객체에 dim 속성을 부여하여 R이 z를 3ⅹ3의 행렬인 것처럼 다루도록 할 수 있다. z &lt;- 1:9 z [1] 1 2 3 4 5 6 7 8 9 class(z) [1] &quot;integer&quot; attr(z, &quot;dim&quot;) NULL attr(z, &quot;dim&quot;) &lt;- c(3,3) attributes(z) $dim [1] 3 3 z [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 아래 예는 dimnames 속성에 행과 열의 이름을 할당하여 행렬이 출력될 때 행과 열의 이름이 같이 출력되도록 한 경우이다. 이 경우도 R은 저장되어 있는 9개의 정수뿐 아니라 객체의 부가적인 속성 정보를 이용하여 어떤 식으로 처리할 것인지를 결정하게 된다. attr(z, &quot;dimnames&quot;) &lt;- list(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 1:3) attributes(z) $dim [1] 3 3 $dimnames $dimnames[[1]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; $dimnames[[2]] [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; z 1 2 3 A 1 4 7 B 2 5 8 C 3 6 9 객체 속성 함수 attr() 함수를 이용하여 다양한 속성을 객체에 부가할 수 있다. 그러나 보통 속성 이름을 잘못 부여하여 오작동하는 것을 방지하고, 사용자의 편의를 도모하기 위해 자주 사용되는 속성을 확인하거나 할당하는 dim(), dimnames(), names(), row.names(), class() 등의 각 속성 전용의 함수들이 정의되어 있다. 각 함수의 사용법은 이 책의 관련 부분이나 R의 도움말을 참고하기 바란다. 객체 속성을 변경할 때는 이러한 attr()보다는 객체 속성 함수를 이용하는 것이 좋다. 왜냐하면 attr() 함수는 속성 이름이 잘 못되더라도 새로운 속성을 설정하는 것으로 생각하여 오류가 발생하지 않는다. 객체 속성 함수를 사용하면 해당 속성을 위한 함수를 잘 못 지정하면 오류가 발생하기 때문에 입력 오류를 바로 확인할 수 있다. 모드와 타입의 차이 마지막으로 모드와 타입의 차이를 설명하고자 한다. 많은 R 문서나 책을 보면 앞에서 이야기한 데이터 타입을 모드라는 이름으로 설명하는 경우가 많다. 사실 모드와 타입은 비슷한 개념으로 생각하면 된다. 타입이 R에서 이용되는 개념이라고 한다면, 모드는 R의 전신인 S 언어에서 데이터의 기본 형식을 지정하기 위해서 사용한 개념이다. R은 S 언어에 대한 호환성을 보장하기 위해 모드라는 개념을 같이 혼용하여 사용하고 있다. 객체의 모드를 확인하기 위해서는 mode() 함수를 이용한다. typeof(a); mode(a) [1] &quot;logical&quot; [1] &quot;logical&quot; typeof(b); mode(b) [1] &quot;integer&quot; [1] &quot;numeric&quot; typeof(d); mode(d) [1] &quot;double&quot; [1] &quot;numeric&quot; typeof(e); mode(e) [1] &quot;character&quot; [1] &quot;character&quot; 대부분의 경우 타입과 모드는 비슷한 결과를 주지만, 숫자 벡터의 경우 R의 타입은 integer와 double로 저장 형식이 정수인지 실수인지 구분하고, S 언어의 모드는 모두 numeric으로 표시한다. 그러나 S도 storage.mode()라는 함수를 이용하면 내부적으로 저장하는 형식을 확인할 수 있다. storage.mode(b) [1] &quot;integer&quot; storage.mode(d) [1] &quot;double&quot; 그러나 R에서는 mode()나 storage.mode() 함수 모두 typeof() 함수의 결과에 기반을 하고 있으므로, S 언어와의 하위 호환성 때문이 아니라면 타입이라는 개념과 typeof() 함수를 사용하는 것이 좋다. 5.2 리스트의 생성 및 필터링 R의 리스트는 요소(component)라고 불리는 객체들을 순서대로 모은 데이터 구조이다. 리스트의 요소들은 서로 다른 데이터 형식일 수 있다. 이론적으로 말하자면 리스트는 서로 다른 타입을 가지는 요소에 대한 주소 정보를 가지고 있는 데이터 형식이다. list() 리스트 객체는 list() 함수를 이용하여 만드는데, 아래처럼 리스트 요소에 이름 없이 만드는 방법과 리스트 요소에 이름을 붙여서 만드는 방법이 있다. list(요소1, 요소2, ...) list(이름1=요소1, 이름2=요소2, ...) 다음은 list() 함수를 이용하여 리스트를 만드는 예를 보여주고 있다. a &lt;- list(name=&quot;Fred&quot;, age=43, wife=&quot;Mary&quot;, no.children= 3, child.ages=c(4, 7, 9), is.house.owner=T) a $name [1] &quot;Fred&quot; $age [1] 43 $wife [1] &quot;Mary&quot; $no.children [1] 3 $child.ages [1] 4 7 9 $is.house.owner [1] TRUE a의 요소로 문자, 숫자, 논리값을 모두 포함할 수 있음을 볼 수 있다. 뒤에서 살펴보겠지만 리스트는 요소로 다른 리스트를 포함할 수도 있고, 함수 등의 다른 타입의 객체도 포함할 수 있다. 위의 예에서 list() 함수의 인수로 리스트에 포함될 요소를 ’이름=요소’의 형식으로 기술하였다. a 객체를 출력해 보면 각 요소의 이름이 $를 앞에 붙여 출력되고 그 다음에 요소의 내용이 출력된다. 리스트 객체의 타입, 길이, 속성 및 names() typeof()와 length() 함수를 이용하면 객체의 내재적 속성인 타입과 요소의 길이를 확인할 수 있다. attributes() 함수를 이용하면 그 밖의 속성을 확인할 수 있는데, names 속성이 부여되어 있음을 볼 수 있다. 사실 attributes()에 의해 반환되는 결과는 속성을 요소로 갖는 리스트 객체이다. typeof(a) [1] &quot;list&quot; length(a) [1] 6 attributes(a) $names [1] &quot;name&quot; &quot;age&quot; &quot;wife&quot; &quot;no.children&quot; [5] &quot;child.ages&quot; &quot;is.house.owner&quot; names(a) [1] &quot;name&quot; &quot;age&quot; &quot;wife&quot; &quot;no.children&quot; [5] &quot;child.ages&quot; &quot;is.house.owner&quot; list() 함수를 이용하여 객체를 정의할 때 요소에 이름을 부여하지 않으면, 특별한 이름 없이 각 요소가 순서대로 1부터 숫자가 매겨진다. 앞서와 달리 요소의 이름 대신 요소의 번호가 [[ ]] 안에 표시된 후 요소의 내용이 출력됨을 볼 수 있다. a2 &lt;- list(1:5, letters[1:8], LETTERS[1:3]) a2 [[1]] [1] 1 2 3 4 5 [[2]] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; [[3]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; 5.2.0.1 리스트 요소의 이름 자동으로 부여되지 않는다. 2차원 데이터 구조인 행렬을 만드는 cbind() 함수나, 또 다른 2차원 데이터 구조인 데이터프레임을 만드는 data.frame() 함수는 변수를 사용하여 행렬과 데이터프레임을 만들면 변수명을 열 이름으로 자동적으로 부여한다. (data.frame() 함수에 대해서는 6 장을 참조한다.) var1 &lt;- 1:3 var2 &lt;- 4:6 cbind(var1, var2) var1 var2 [1,] 1 4 [2,] 2 5 [3,] 3 6 data.frame(var1, var2) var1 var2 1 1 4 2 2 5 3 3 6 반면 list() 함수는 변수를 요소로 사용해도 변수명을 요소의 이름으로 자동으로 부여하지 않는다. list(var1, var2) [[1]] [1] 1 2 3 [[2]] [1] 4 5 6 그러므로 리스트 생성 시 요소에 이름을 부여하려면 앞서 본 것과 같이 요소이름=요소 형식으로 리스트를 생성하여야 한다. list(var1=var1, var2=var2) $var1 [1] 1 2 3 $var2 [1] 4 5 6 리스트 요소 지정 리스트에서 요소 하나를 지정할 때는 주로 다음의 세가지 방법을 사용한다. 첫번째 방법은, [[ ]] 연산자와 요소의 번호로 지정하는 것이다. 두번째 방법은 list_name$component_name의 형태로 $ 뒤에 리스트 요소의 이름을 이용하여 지정하는 것이다. 세번째 방법은, [[ ]] 연산자 안에 숫자 대신 요소의 이름을 나타내는 문자열을 제시하여 지정하는 것이다. 이 때 두번째와 세번째 방법은 요소의 이름을 사용하는 것은 모두 동일하나, 두번째 방법에서는 $ 뒤에 사용되는 요소의 이름이 변수처럼 따옴표 없이 그대로 이용되는 반면, 세번째 방법에서는 요소의 이름이 문자열로 따옴표로 표현되는 차이가 있다. 숫자 대신 이름을 이용하는 것은 숫자를 기억하지 않아도 되므로 편리하다. a[[3]] [1] &quot;Mary&quot; a$wife [1] &quot;Mary&quot; a[[&quot;wife&quot;]] [1] &quot;Mary&quot; 단계적으로 요소 지정 리스트 요소가 벡터나 행렬인 경우에는 지정된 요소에 다시 인덱스 벡터를 이용하여 부분을 선택할 수 있다. a[[5]] [1] 4 7 9 a[[5]][2:3] [1] 7 9 a$child.ages[2:3] [1] 7 9 요소 이름의 단축 요소의 이름이 다른 요소들의 이름과 충분히 구별 가능하면 축약된 형태로 적을 수도 있다. 그러나 되도록 이름의 단축 기능은 사용하지 말 것을 권장한다. 최근의 R 관련 프로그램은 대부분 코드 자동 완성 기능이 있으므로 긴 이름도 쉽게 작성할 수 있으므로, 이름의 단축으로 얻는 입력 타수 절약이라는 장점보다는 명령문의 가독성이 줄어드는 단점이 더 크기 때문이다. a$no [1] 3 a$child [1] 4 7 9 부분 리스트로 필터링 지금까지는 리스트의 한 요소를 지정하는 방법에 대하여 설명하였다. 어떤 경우에는 리스트의 여러 요소를 지정할 필요가 있다. 이러한 경우에는 [[ ]] 연산자가 아니라 벡터의 필터링에 사용한 [ ]를 동일하게 이용한다. a[1:3] $name [1] &quot;Fred&quot; $age [1] 43 $wife [1] &quot;Mary&quot; a[c(2, 5)] $age [1] 43 $child.ages [1] 4 7 9 a[-(4:5)] $name [1] &quot;Fred&quot; $age [1] 43 $wife [1] &quot;Mary&quot; $is.house.owner [1] TRUE a[c(&quot;wife&quot;, &quot;child.ages&quot;)] $wife [1] &quot;Mary&quot; $child.ages [1] 4 7 9 a[c(T, F, F)] $name [1] &quot;Fred&quot; $no.children [1] 3 벡터의 필터링과 마찬가지로 자연수를 이용하여 해당 위치의 요소를 뽑을 수도 있고, 음의 정수를 이용하여 해당 위치의 요소를 빼고 필터링을 수행할 수도 있다. 문자열 벡터를 이용하여 요소의 이름으로 필터링이 가능하다. 리스트 요소 지정 vs. 부분 리스트 필터링 여기서 주목해야 할 것은 벡터의 필터링의 결과는 원래 벡터의 부분으로 구성된 벡터인 것과 마찬가지로, 리스트의 [ ] 필터링의 결과는 리스트의 부분으로 구성된 또 다른 리스트가 된다. 반면 [[ ]]나 $ 연산자를 이용하여 요소를 지정하는 것은 리스트의 요소 그 자체가 된다. 즉, 또 다른 리스트가 되는 것이 아니라 리스트의 요소가 벡터이면 벡터 그 자체가 된다. 다음의 예는 [ ]와 [[ ]] 연산자를 이용하여 a의 5번째 요소를 뽑아낸 예이다. a[[5]] [1] 4 7 9 a[5] $child.ages [1] 4 7 9 전자는 벡터로 출력되고 후자는 다시 요소가 하나짜리 리스트로 표현됨을 볼 수 있다. 내용적으로 두 결과의 차이가 크지 않지만 형식적으로는 두 결과는 큰 차이를 가진다. 전자의 경우는 요소 그 자체인 벡터가 되므로 벡터 필터링이나 벡터와 관련된 연산이 가능하지만, 후자는 불가능하다. 대신 리스트와 관련된 연산이나 필터링을 수행해야 한다. a[[5]][2:3] [1] 7 9 a[[5]] * 7 [1] 28 49 63 a[5][2:3] $&lt;NA&gt; NULL $&lt;NA&gt; NULL a[5] * 7 Error in a[5] * 7: 이항연산자에 수치가 아닌 인수입니다 위의 예에서 [[ ]]로 지정된 결과는 요소 그 자체가 되므로, 결과가 숫자 벡터가 된다. 따라서 벡터와 관련된 모든 연산이 가능하다. 반면 [ ]로 필터링된 결과는 리스트라는 형식이 유지되어 요소가 하나인 리스트가 된다. 따라서 2번째와 3번째 요소를 필터링하자, 해당 요소가 없으므로 모두 NULL로 표시된다. 리스트이므로 수식 벡터의 연산도 수행되지 않음을 알 수 있다. 5.3 리스트의 변경 및 연결 리스트 요소의 추가 이미 생성된 리스트는 새로운 요소를 추가함으로써 확장될 수 있다. 새로운 요소를 추가하거나 변경하는 방법은 여러 가지가 있을 수 있는데, 첫번째로 생각할 수 있는 방법은 [[ ]] 연산자나 $ 연산자를 이용하여 요소를 추가하거나 변경하는 방법이다. 다음은 새로운 요소를 리스트에 추가한 예이다. length(a) [1] 6 a[[7]] &lt;- 1:5 a[[&quot;address&quot;]] &lt;- &quot;Cheonan&quot; a$years.since.marrage &lt;- 15 a $name [1] &quot;Fred&quot; $age [1] 43 $wife [1] &quot;Mary&quot; $no.children [1] 3 $child.ages [1] 4 7 9 $is.house.owner [1] TRUE [[7]] [1] 1 2 3 4 5 $address [1] &quot;Cheonan&quot; $years.since.marrage [1] 15 리스트 요소의 변경 벡터와 마찬가지로 기존 요소를 지정한 후 할당을 하면 기존 요소가 변경된다. a[[7]] &lt;- 10:18 a$address &lt;- &quot;Daejeon&quot; a[[9]] &lt;- 16 a $name [1] &quot;Fred&quot; $age [1] 43 $wife [1] &quot;Mary&quot; $no.children [1] 3 $child.ages [1] 4 7 9 $is.house.owner [1] TRUE [[7]] [1] 10 11 12 13 14 15 16 17 18 $address [1] &quot;Daejeon&quot; $years.since.marrage [1] 16 자연수 인덱스를 이용한 리스트 요소의 추가와 빈 요소의 생성 위의 예에서 새로운 요소를 추가할 때 요소의 이름을 이용하면 현재까지 있는 요소의 다음 위치에 차례로 해당 이름을 갖는 요소가 추가된다. 그러나 숫자를 이용하여 위치를 지정하여 새로운 요소를 추가하면 해당 위치에 요소가 생성된다. 위의 예처럼 이미 해당 위치에 다른 요소가 있다면 새로운 값으로 변경이 될 것이며, 아무 것도 없었다면 해당 위치에 새로운 데이터가 추가된다. 그러면 기존 리스트의 마지막 요소의 다음 위치가 아니라 더 먼 위치에 새로운 요소를 추가하면 어떻게 될까? a2 [[1]] [1] 1 2 3 4 5 [[2]] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; [[3]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; a2[[5]] &lt;- &quot;New items&quot; a2 [[1]] [1] 1 2 3 4 5 [[2]] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; [[3]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; [[4]] NULL [[5]] [1] &quot;New items&quot; 위의 예에서 보듯이 비어 있는 요소는 아무 것도 없다는 뜻의 NULL로 표현되어 출력되고 마지막 위치에 있는 요소까지 모두 출력된다. 리스트 요소의 삭제 리스트의 요소를 삭제하기 위해서는 해당 요소를 [[ ]]나 $ 연산자를 이용하여 지정한 후 해당 요소에 NULL을 할당하면 된다. a2[[5]] &lt;- NULL a2 [[1]] [1] 1 2 3 4 5 [[2]] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; [[3]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; [[4]] NULL a2[[4]] &lt;- NULL a2 [[1]] [1] 1 2 3 4 5 [[2]] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; [[3]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; names(a2) &lt;- c(&quot;num&quot;, &quot;lower.case&quot;, &quot;upper.case&quot;) a2 $num [1] 1 2 3 4 5 $lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; $upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; a2$num &lt;- NULL a2 $lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; $upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; 부분 리스트를 이용한 리스트 변경 * 지금까지는 [[ ]]나 $ 연산자를 이용하여 요소 하나를 추가, 변경, 삭제하는 것을 보여주었다. [ ] 연산자를 이용하면 리스트의 여러 요소를 추가 또는 변경할 수 있다. 이 때 할당문의 오른쪽에 있는 객체는 리스트 객체여야 한다. 왜냐하면 [ ] 연산자를 이용한 필터링의 결과는 원래 리스트의 부분 리스트이기 때문이다. a2[3:4] &lt;- list(1:5, month.name) a2 $lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; $upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; [[3]] [1] 1 2 3 4 5 [[4]] [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; 리스트의 recycling * 만약 오른쪽 항의 리스트가 할당될 부분 리스트보다 요소 수가 적으면 오른쪽 항의 리스트가 재사용된다. a2[3:6] &lt;- list(11:15, month.abb) a2 $lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; $upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; [[3]] [1] 11 12 13 14 15 [[4]] [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; &quot;Dec&quot; [[5]] [1] 11 12 13 14 15 [[6]] [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; &quot;Dec&quot; 벡터의 리스트로의 형변환 * 또한 부분 리스트를 지정한 후 할당하는 예에서, 오른쪽에 리스트가 아니라 벡터가 주어지면 벡터의 각 요소가 리스트의 요소로 변환된 후 할당이 이루어진다. 이는 R 등의 고급 언어들의 특징인데 할당해야 할 내용이 할당받을 객체의 타입과 다른 경우, 가능하면 할당문의 왼쪽에 있는 객체의 타입으로 변환하려고 노력한다. as.list() 함수를 이용하여 벡터를 리스트로 사용자가 명시적으로 변환할 수도 있다. a2[3:6] &lt;- c(&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;W&quot;) a2 $lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; $upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; [[3]] [1] &quot;X&quot; [[4]] [1] &quot;Y&quot; [[5]] [1] &quot;Z&quot; [[6]] [1] &quot;W&quot; c(&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;W&quot;) [1] &quot;X&quot; &quot;Y&quot; &quot;Z&quot; &quot;W&quot; as.list(c(&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;W&quot;)) [[1]] [1] &quot;X&quot; [[2]] [1] &quot;Y&quot; [[3]] [1] &quot;Z&quot; [[4]] [1] &quot;W&quot; a2[3:6] &lt;- NULL a2 $lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; $upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; 위의 예에서 부분리스트에 NULL을 할당하면 부분 리스트에 해당되는 모든 요소가 삭제됨을 볼 수 있다. 이 때도 역시 NULL이 재사용되어 4개의 요소에 모두 NULL이 할당되었다. c()를 이용한 리스트 연결하기 리스트는 벡터와 같이 c() 함수를 이용하여 리스트들을 연결하여 하나의 리스트로 만들 수 있다. a3 &lt;- list(first=1:3, second=4:6) a3 $first [1] 1 2 3 $second [1] 4 5 6 a4 &lt;- c(a2, a3) a4 $lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; $upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; $first [1] 1 2 3 $second [1] 4 5 6 length(a4) [1] 4 계층적인 리스트 만들기 위의 예에서 c()로 연결된 리스트들은 모든 요소가 평평하게 하나의 계층으로 연결되었음을 볼 수 있다. 그런데 리스트는 모든 타입의 요소를 포함할 수 있기 때문에 리스트의 요소에 리스트가 할당될 수 있다. 이 경우 리스트는 계층적인 구조를 갖게 된다. a5 &lt;- list(a2, a3) a5 [[1]] [[1]]$lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; [[1]]$upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; [[2]] [[2]]$first [1] 1 2 3 [[2]]$second [1] 4 5 6 length(a5) [1] 2 c()로 같은 계층으로 연결한 앞의 a4의 결과와 a5의 출력 결과를 비교해 보라. a4에서 upper.case 요소를 뽑기 위해서는 2번째 요소를 뽑으면 된다. 그러나 a5에서는 2번째 요소를 뽑으면 2번째 리스트 전체가 뽑혀져서 나오는 것을 볼 수 있다. a5에서 upper.case를 뽑으려면 첫번째 요소를 뽑은 후, 거기서 다시 2번째 요소를 뽑아야 한다. a4[[2]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; a5[[2]] $first [1] 1 2 3 $second [1] 4 5 6 a5[[1]][[2]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; a5[[2]]$second [1] 4 5 6 a4$second [1] 4 5 6 계층적인 구조의 리스트를 c()로 연결하면 첫 층위에서만 하나의 리스트로 합쳐진다. 모든 층위의 요소를 재귀적으로 하나로 합치려면 recursive=TRUE 인수를 설정한다. 그러면 모든 요소들이 하나로 합쳐져 벡터로 변환된다. 다음 예에서는 문자 요소가 있으므로 모두 문자로 자동 형변환되어 합쳐졌다. c(a4, a5) $lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; $upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; $first [1] 1 2 3 $second [1] 4 5 6 [[5]] [[5]]$lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; [[5]]$upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; [[6]] [[6]]$first [1] 1 2 3 [[6]]$second [1] 4 5 6 c(a4, a5, recursive = TRUE) lower.case1 lower.case2 lower.case3 lower.case4 lower.case5 lower.case6 &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; lower.case7 lower.case8 upper.case1 upper.case2 upper.case3 first1 &quot;g&quot; &quot;h&quot; &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;1&quot; first2 first3 second1 second2 second3 lower.case1 &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;a&quot; lower.case2 lower.case3 lower.case4 lower.case5 lower.case6 lower.case7 &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; lower.case8 upper.case1 upper.case2 upper.case3 first1 first2 &quot;h&quot; &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;1&quot; &quot;2&quot; first3 second1 second2 second3 &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; unlist()로 리스트를 벡터로 형 변환하기 앞서 as.list()를 이용하여 벡터를 리스트로 변환한 예를 보았다. 어떤 경우에는 리스트의 모든 요소를 벡터로 변환할 필요가 있다. 앞의 예처럼 c( , recursive = TRUE)를 사용할 수도 있지만, 이 때 사용하는 전용 함수인 unlist()를 사용하는 것이 더 일반적이다. unlist(a3) first1 first2 first3 second1 second2 second3 1 2 3 4 5 6 unlist(a4) lower.case1 lower.case2 lower.case3 lower.case4 lower.case5 lower.case6 &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; lower.case7 lower.case8 upper.case1 upper.case2 upper.case3 first1 &quot;g&quot; &quot;h&quot; &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;1&quot; first2 first3 second1 second2 second3 &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; 예에서 보듯이 리스트의 요소가 모두 숫자로 표시가 가능하면 숫자 벡터로 변환하지만, 하나라도 문자 등이 있으면 모두 문자 벡터로 변환한다. 그리고 벡터의 각 요소에 리스트 요소의 이름과 벡터의 위치에 따라 자동으로 이름이 부여되었음을 확인할 수 있다. unlist() 함수는 strsplit() 결과를 하나의 문자 벡터로 만들 때 자주 사용된다. a &lt;- c(&quot;R은 통계분석을 위해 특화된 프로그램 언어입니다.&quot;, &quot;다양한 데이터 분석 함수가 내장되어 있습니다.&quot;) b &lt;- strsplit(a, split = &quot; &quot;) b [[1]] [1] &quot;R은&quot; &quot;통계분석을&quot; &quot;위해&quot; &quot;특화된&quot; &quot;프로그램&quot; [6] &quot;언어입니다.&quot; [[2]] [1] &quot;다양한&quot; &quot;데이터&quot; &quot;분석&quot; &quot;함수가&quot; &quot;내장되어&quot; &quot;있습니다.&quot; unlist(b) [1] &quot;R은&quot; &quot;통계분석을&quot; &quot;위해&quot; &quot;특화된&quot; &quot;프로그램&quot; [6] &quot;언어입니다.&quot; &quot;다양한&quot; &quot;데이터&quot; &quot;분석&quot; &quot;함수가&quot; [11] &quot;내장되어&quot; &quot;있습니다.&quot; 5.4 리스트에 함수 적용하기 행렬을 공부할 때 apply() 함수를 이용하여 행렬의 각 행 또는 각 열에 함수를 적용하는 방법을 공부하였다. 리스트에도 리스트의 각 요소에 함수를 적용하는 lapply()와 sapply() 함수가 있다. 5.4.1 lapply() 함수 lapply() lapply() 함수는 다음의 문법 구조를 가진다. lapply(리스트, 함수) 다음 예는 lapply()를 이용하여 숫자 벡터로 이루어진 리스트의 각 요소에 mean() 함수를 적용한 예이다. 어떤 객체에 함수를 적용할 때는 function(object) 형식으로 함수의 인수로 객체를 제공한다. 그러나 lapply()에서는 첫번째 인수로 리스트를 제공하고, 두번째 인수로 함수 객체를 제공한다. b &lt;- list(1:5, 21:29, seq(2, 20, by=2)) b [[1]] [1] 1 2 3 4 5 [[2]] [1] 21 22 23 24 25 26 27 28 29 [[3]] [1] 2 4 6 8 10 12 14 16 18 20 mean(b[[1]]) [1] 3 mean(b[[2]]) [1] 25 mean(b[[3]]) [1] 11 lapply(b, mean) [[1]] [1] 3 [[2]] [1] 25 [[3]] [1] 11 위의 예에서 보듯이 lapply()는 리스트의 각 요소에 함수를 적용한 후 그 결과를 동일한 형식의 리스트 객체로 제공한다. lapply() 결과 리스트의 요소 이름 아래 예는 리스트에 여러 함수들을 적용한 예이다. 리스트에 이름을 제공하면 결과에도 동일한 이름이 요소에 붙여짐을 확인할 수 있다. lapply(b, max) [[1]] [1] 5 [[2]] [1] 29 [[3]] [1] 20 names(b) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) lapply(b, range) $A [1] 1 5 $B [1] 21 29 $C [1] 2 20 5.4.2 sapply() 함수 sapply() 많은 경우에 최종 결과가 리스트보다는 벡터나 행렬 등의 간단한 형태로 제공되는 것이 편리하다. 이런 경우에는 sapply()를 사용한다. (simplified lapply로 기억하면 편리하다.) sapply()도 lapply()와 문법적 구조가 동일하다. 다른 점은 최종 결과를 리스트가 아니라 가능하면 벡터나 행렬처럼 간단한 형식으로 반환한다는 점이다. sapply()도 apply() 함수처럼 벡터로 결과를 반환하거나, 요소 하나에 함수를 적용한 결과가 길이가 2 이상인 벡터이면 열로 결과를 붙여서 행렬 형식으로 결과를 반환한다. sapply(b, length) A B C 5 9 10 sapply(b, range) A B C [1,] 1 21 2 [2,] 5 29 20 lb &lt;- lapply(b, length) typeof(lb) [1] &quot;list&quot; sb &lt;- sapply(b, length) typeof(sb) [1] &quot;integer&quot; 사용자 정의 함수의 적용 lapply()와 sapply(), 또는 apply() 등을 이용하여 객체의 각 요소나 부분에 함수를 적용할 때 기존의 함수뿐 아니라 사용자가 정의한 함수를 적용할 수도 있다. (함수를 정의하는 법은 10 장의 함수와 관련된 내용을 참조하기 바란다.) 다음은 리스트의 각 요소에서 10보다 큰 수의 개수를 세는 예이다. sapply(b, function(x){ sum(x &gt; 10) }) A B C 0 9 5 5.4.3 mapply() 함수 lapply()와 sapply()가 하나의 리스트에 대해 각 요소에 함수를 적용한다면, mapply()는 다수의 리스트에 대해 같은 위치의 요소들에 함수를 적용하기 위한 함수이다. mapply()는 sapply()처럼 결과를 벡터나 행렬 등의 단순한 형태로 제공할 수 있으면 리스트가 아니라 단순한 형태로 결과를 제공한다. mapply()는 다음과 같은 문법 구조를 가진다. 먼저 리스트의 요소에 적용할 함수를 첫번째 FUN 인수로 제공한다. 그리고는 함수를 동시에 같이 적용할 리스트의 목록을 기술한다. 그러면 이 리스트의 같은 위치의 요소들이 함수의 인수로 제공된다. 리스트 외에도 별도의 인수를 함수에 제공할 필요가 있으면 MoreArgs 인수에 리스트 형태로 제공한다. mapply(FUN, list_1(vector_1), ..., list_n(vector_n), MoreArgs=NULL) 다음과 같은 2 개의 리스트가 존재한다고 하자. a &lt;- list(1:5, 10:5, letters[1:4]) b &lt;- list(6:4, 4:7, LETTERS[5:1]) 다음은 리스트의 같은 위치에 있는 요소를 c() 함수를 이용하여 각각 연결한 예이다. mapply(c, a, b) [[1]] [1] 1 2 3 4 5 6 5 4 [[2]] [1] 10 9 8 7 6 5 4 5 6 7 [[3]] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;E&quot; &quot;D&quot; &quot;C&quot; &quot;B&quot; &quot;A&quot; 또한 mapply()에 리스트를 인수로 제공할 때 이름=리스트 형태로 인수를 제공하면 FUN 인수에 부여된 함수에 해당 이름으로 인수가 제공된다. 다음은 rep() 함수에 반복할 벡터 x와 반복 횟수를 times을 리스트로 제공한 예이다. mapply(rep, times=2:4, x=list(1:2, 11:12, 21:22)) [[1]] [1] 1 2 1 2 [[2]] [1] 11 12 11 12 11 12 [[3]] [1] 21 22 21 22 21 22 21 22 위의 결과에서 x 리스트의 각 요소와 times 벡터의 각 요소가 차례로 결합되어 rep() 함수가 적용되었음을 볼 수 있다. 5.5 리스트 활용 분야 리스트로 결과를 반환하는 함수의 예 이 장의 시작부분에서 리스트가 중요한 이유를 설명할 때, 많은 데이터 분석 함수들이 결과를 리스트 형태로 제공한다고 하였다. 실제 그러한지 예를 통해 살펴보도록 하자. 다음은 선형회귀분석을 수행하는 lm() 함수의 결과가 리스트 객체라는 것을 보여준다. 리스트 객체의 각 요소는 수행된 선형회귀분석에 대한 자세한 결과를 저장하고 있다. x &lt;- lm(dist~speed, data=cars) x Call: lm(formula = dist ~ speed, data = cars) Coefficients: (Intercept) speed -17.579 3.932 typeof(x) [1] &quot;list&quot; class(x) [1] &quot;lm&quot; names(x) [1] &quot;coefficients&quot; &quot;residuals&quot; &quot;effects&quot; &quot;rank&quot; [5] &quot;fitted.values&quot; &quot;assign&quot; &quot;qr&quot; &quot;df.residual&quot; [9] &quot;xlevels&quot; &quot;call&quot; &quot;terms&quot; &quot;model&quot; x$residuals 1 2 3 4 5 6 7 3.849460 11.849460 -5.947766 12.052234 2.119825 -7.812584 -3.744993 8 9 10 11 12 13 14 4.255007 12.255007 -8.677401 2.322599 -15.609810 -9.609810 -5.609810 15 16 17 18 19 20 21 -1.609810 -7.542219 0.457781 0.457781 12.457781 -11.474628 -1.474628 22 23 24 25 26 27 28 22.525372 42.525372 -21.407036 -15.407036 12.592964 -13.339445 -5.339445 29 30 31 32 33 34 35 -17.271854 -9.271854 0.728146 -11.204263 2.795737 22.795737 30.795737 36 37 38 39 40 41 42 -21.136672 -11.136672 10.863328 -29.069080 -13.069080 -9.069080 -5.069080 43 44 45 46 47 48 49 2.930920 -2.933898 -18.866307 -6.798715 15.201285 16.201285 43.201285 50 4.268876 x$terms dist ~ speed attr(,&quot;variables&quot;) list(dist, speed) attr(,&quot;factors&quot;) speed dist 0 speed 1 attr(,&quot;term.labels&quot;) [1] &quot;speed&quot; attr(,&quot;order&quot;) [1] 1 attr(,&quot;intercept&quot;) [1] 1 attr(,&quot;response&quot;) [1] 1 attr(,&quot;.Environment&quot;) &lt;environment: R_GlobalEnv&gt; attr(,&quot;predvars&quot;) list(dist, speed) attr(,&quot;dataClasses&quot;) dist speed &quot;numeric&quot; &quot;numeric&quot; lm() 함수의 결과의 타입은 list이고, 클래스는 함수의 이름과 동일한 lm임을 볼 수 있다. (R에서는 사용자의 기억을 돕기 위해서 일반적으로 함수의 결과가 복잡한 경우 함수의 이름과 동일한 클래스 이름으로 결과를 반환한다. 클래스에 대해서는 11 장을 참조한다.) lm 클래스의 객체이긴 하지만 타입이 리스트이므로 names() 함수를 이용하여 요소의 이름을 확인하고, $ 연산자를 이용하여 요소에 접근하여 요소의 내용을 확인할 수 있다. unclass() 주의할 점은 리스트이긴 하지만 lm 클래스이므로 출력을 해 보면 리스트의 모든 요소가 출력되는 것이 아니라 lm 클래스에 맞추어 회귀분석의 주요 결과만 간략하게 출력됨을 볼 수 있다. 만약 리스트로서 모든 요소를 확인하고 싶으면 unclass() 함수를 이용하여 객체에 부여된 클래스 속성을 제거한다. 그러면 단순한 리스트 객체가 되어서 모든 요소가 출력된다. 출력이 매우 길므로 출력 결과는 생략하였다. unclass(x) 데이터 프레임 리스트가 중요한 또 다른 이유는 R에서 데이터를 저장할 때 빈번하게 이용하는 데이터 프레임이라는 형식이 리스트를 기반으로 하고 있기 때문이다. 정확히 이야기하면, 데이터 프레임은 data.frame이라는 클래스 속성을 갖는 리스트이다. head(cars) speed dist 1 4 2 2 4 10 3 7 4 4 7 22 5 8 16 6 9 10 typeof(cars) [1] &quot;list&quot; class(cars) [1] &quot;data.frame&quot; 이번에도 cars 객체는 리스트로 데이터를 저장하지만, 클래스가 data.frame이므로 출력해 보면 일반적인 리스트의 형식으로 출력되지 않고 행렬 형태로 출력된다. unclass()를 이용하면 클래스가 없어져서 이 데이터가 리스트 형식으로 저장되어 있음을 확인할 수 있다. unclass(cars) $speed [1] 4 4 7 7 8 9 10 10 10 11 11 12 12 12 12 13 13 13 13 14 14 14 14 15 15 [26] 15 16 16 17 17 17 18 18 18 18 19 19 19 20 20 20 20 20 22 23 24 24 24 24 25 $dist [1] 2 10 4 22 16 10 18 26 34 17 28 14 20 24 28 26 34 34 46 [20] 26 36 60 80 20 26 54 32 40 32 40 50 42 56 76 84 36 46 68 [39] 32 48 52 56 64 66 54 70 92 93 120 85 attr(,&quot;row.names&quot;) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 결과에서 speed와 dist로 이름이 붙여진 숫자 벡터로 구성된 리스트임을 확인할 수 있다. 그리고 row.names라는 속성이 부여되어 있음을 확인할 수 있다. 데이터 프레임은 보통 다른 통계 소프트웨어에서 데이터 집합 또는 데이터 행렬이라고 불리는 것이다. R에서는 본질적으로 데이터 프레임은 data.frame 클래스인 리스트인데, 요소의 길이가 모두 같은 리스트이다. 그러므로 데이터를 행렬 형태로 표현할 수 있다. 리스트의 각 요소가 각 열로 표현된다. 리스트를 데이터 프레임으로 변환시키기 위해서는 as.data.frame()을 이용하면 된다. y &lt;- list(a=11:15, b=letters[11:15]) y $a [1] 11 12 13 14 15 $b [1] &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; typeof(y); class(y) [1] &quot;list&quot; [1] &quot;list&quot; z &lt;- as.data.frame(y) z a b 1 11 k 2 12 l 3 13 m 4 14 n 5 15 o typeof(z); class(z) [1] &quot;list&quot; [1] &quot;data.frame&quot; "],["ch-R-Data-Frame.html", "Chapter 6 R 데이터 프레임 6.1 범주형 데이터와 요인 (Factors) 6.2 데이터 프레임 만들기 6.3 데이터 프레임 각 열의 지정 6.4 데이터 프레임의 필터링 6.5 데이터 프레임에 함수 적용하기 6.6 파일에서 데이터 읽어오기 6.7 데이터 프레임을 파일로 쓰기 6.8 데이터 프레임의 열을 변수처럼 이용하는 방법 *", " Chapter 6 R 데이터 프레임 이 장에서는 여러 타입의 데이터가 혼재된 데이터 프레임이란 데이터 구조를 다룬다. 보통 다른 통계 소프트웨어에서 데이터 분석의 기본 단위인 데이터 집합 또는 데이터 행렬이라고 불리는 것이다. 데이터 프레임의 두 측면: 리스트적 측면 행렬적 측면 데이터 프레임은 행렬을 일반화한 것으로 생각하면 이해하기 쉽다. 행렬에 속한 데이터는 모두 같은 타입인데 반해, 데이터 프레임은 각 열마다 각기 다른 타입의 데이터를 가질 수 있다. 데이터 프레임에는 한 열은 숫자 타입의 데이터가, 다른 한 열은 문자 타입의 데이터가 각각 들어갈 수 있다. 한 강의를 듣는 학생에 대한 표 6.1 같은 데이터가 있다고 하자. 이 데이터에는 중간고사, 기말고사 같이 숫자 데이터도 있지만, 학생 이름과 성별처럼 문자 데이터도 있다. 그리고 재수강 여부처럼 논리 값 데이터도 있다. 데이터의 형태는 다르지만 한 학생에 대한 정보를 얻기 위해서는 숫자, 문자, 논리 값을 포함한 데이터를 다룰 수 있어야 한다. 이 경우에 사용할 수 있는 데이터 구조가 데이터 프레임이다. 본질적으로 데이터 프레임은 ‘data.frame’ 클래스인 리스트이다. 리스트가 특정 조건을 만족하면 데이터 프레임이 될 수 있다. 리스트와 데이터 프레임의 관계에 대한 자세한 내용은 5 장을 참조하라. Table 6.1: 한 과목의 수강생 데이터 번호 이름 학년 성별 중간고사 기말고사 재수강 1 김철수 1 남 74 91 T 2 김영희 4 여 82 77 F 3 이철수 3 남 67 88 F 4 이영희 2 여 89 78 T 5 홍길동 1 남 92 86 F 6.1 범주형 데이터와 요인 (Factors) R 데이터 프레임의 각 열은 숫자, 문자, 논리 값 벡터 또는 요인으로 구성된다. 숫자, 문자, 논리 값 벡터에 대해서는 3 장에서 다루었다. 본 절에서는 R 데이터 프레임에 대하여 설명하기에 앞서 요인에 대하여 살펴보도록 한다. 6.1.1 명목형 변수와 요인 전국 유권자 대상으로 지지하는 정당에 대해 다음 설문조사를 하였다고 하자. 다음 중 지지하는 정당은? ( ) A 정당 B 정당 C 정당 지지하는 정당 없음 범주 데이터의 숫자 코딩 10 명의 유권자에게 응답을 얻었다면 아마도 1부터 4까지의 숫자를 이용하여 다음과 같이 설문 결과를 입력하게 될 것이다. results &lt;- c(1, 3, 2, 4, 3, 2, 1, 3, 2, 2) results [1] 1 3 2 4 3 2 1 3 2 2 여기서 숫자로 코딩된 설문 결과는 1부터 4까지의 수량적 의미를 가지기보다는 4가지 범주(A 정당, B 정당, C 정당, 없음)의 차이를 숫자로 표현한 것 뿐이다. 그런데 이렇게 범주형 데이터를 숫자 벡터로 표현하는 것은 범주형 데이터를 편리하게 코딩할 수 있는 장점이 있는 반면 다음과 같은 단점을 가진다. 숫자 코딩의 문제점 결과가 숫자 벡터로 입력되었으므로 다음처럼 어떤 범주에도 대응되지 않는 잘못된 숫자가 입력될 수도 있다. results[1] &lt;- 5 results [1] 5 3 2 4 3 2 1 3 2 2 결과를 숫자형 데이터로 오인하여 잘못된 처리를 수행할 수 있다. 입력하는 시점에는 오인을 할 가능성이 적지만 데이터를 분석하는 과정에서 주의를 기울이지 않으면 범주형 데이터를 숫자 데이터로 오인하여 잘못된 분석을 수행할 수 있다. 다음은 범주형 데이터를 나타내는 벡터를 수량 데이터로 오인하여 평균을 분석한 예이다. mean(results) [1] 2.7 데이터 입력 후 제대로 기록해 두지 않으면 각 숫자의 의미가 무엇인지 파악하기 어렵게 된다. factor() 이러한 문제를 해결하기 위해 R은 범주형 데이터를 처리할 때 이용할 수 있는 요인(factor)이라는 데이터 형태를 제공한다. 요인을 생성하기 위해서 factor() 함수를 이용한다. 수준 levels 다음은 숫자로 코딩된 결과(results)를 이용하여 1, 2, 3, 4 수준(level)을 가진 요인을 생성한 예이다. 요인에서 수준은 요인 데이터가 가질 수 있는 차별적 값을 나타낸다. results [1] 5 3 2 4 3 2 1 3 2 2 attributes(results) NULL fResults &lt;- factor(results, levels=1:4) fResults [1] &lt;NA&gt; 3 2 4 3 2 1 3 2 2 Levels: 1 2 3 4 attributes(fResults) $levels [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; $class [1] &quot;factor&quot; 결과에서 보듯이 수준에 포함되지 않은 5의 값은 NA로 변환된다. 요인으로 변경된 데이터의 클래스는 factor가 되고, levels 속성이 지정되어 있음을 볼 수 있다. results의 첫 번째 데이터를 제대로 된 값인 1로 변경한 후 다시 한번 요인으로 변경해 보자. results[1] &lt;- 1 fResults &lt;- factor(results, levels=1:4) fResults [1] 1 3 2 4 3 2 1 3 2 2 Levels: 1 2 3 4 만약 요인 데이터에 이미 정의된 수준을 제외한 다른 값을 입력하면 다음과 같이 경고가 출력되고 입력된 데이터는 NA로 입력됨을 볼 수 있다. fResults[11] &lt;- 4 fResults [1] 1 3 2 4 3 2 1 3 2 2 4 Levels: 1 2 3 4 fResults[12] &lt;- 5 Warning in `[&lt;-.factor`(`*tmp*`, 12, value = 5): 요인의 수준(factor level)이 올바르지 않아 NA가 생성되었습니다. fResults [1] 1 3 2 4 3 2 1 3 2 2 4 &lt;NA&gt; Levels: 1 2 3 4 만약 요인 데이터를 숫자 벡터로 착각하여 평균을 구하려고 해 보자. 먼저 fResults의 데이터를 원래대로 돌려놓은 후 mean() 함수로 평균을 구해보자. 그러면 숫자 데이터가 아니므로 평균을 구할 수 없음을 알 수 있다. fResults[12] &lt;- 2 fResults [1] 1 3 2 4 3 2 1 3 2 2 4 2 Levels: 1 2 3 4 mean(fResults) Warning in mean.default(fResults): 인자가 수치형 또는 논리형이 아니므로 NA를 반환합니다 [1] NA levels() 요인의 수준을 좀 더 의미있는 형태로 바꾸어 보자. 그러면 요인에 입력된 숫자가 각각 어떤 범주에 대응하는지를 쉽게 파악할 수 있다. levels(fResults) [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; levels(fResults) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;None&quot;) fResults [1] A C B None C B A C B B None B Levels: A B C None 이제 fResults 요인을 출력해 보면 각 데이터가 수준에 정의된 문자로 표현됨을 볼 수 있다. 그러면 fResults는 문자 데이터로 변환된 것일까? 그렇지 않다. 요인은 내부적으로 데이터를 각각의 범주를 1부터 시작하는 자연수로 관리한다. 이 예에서는 4가지 서로 다른 범주(수준)이 있으므로 1부터 4까지의 자연수로 데이터를 표현한다. 단지 입출력될 때 요인에 부여된 수준으로 처리를 할 뿐이다. 이를 확인하기 위해서 typeof() 함수로 요인의 근원적 타입을 확인하고, unclass() 함수를 이용하여 요인이 내부적으로 어떤 정보를 가지고 있는지 확인해 보자. typeof(fResults) [1] &quot;integer&quot; class(fResults) [1] &quot;factor&quot; unclass(fResults) [1] 1 3 2 4 3 2 1 3 2 2 4 2 attr(,&quot;levels&quot;) [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;None&quot; 요인이 내부적으로 숫자로 데이터를 표현하고 있다고 하더라도, 수준에 정의되지 않은 숫자로 데이터를 입력할 수는 없다. 요인은 항상 수준에 정의되어 있는 데이터 값만으로 입력되거나 출력될 수 있다. levels(fResults) [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;None&quot; fResults[11] &lt;- 4 Warning in `[&lt;-.factor`(`*tmp*`, 11, value = 4): 요인의 수준(factor level)이 올바르지 않아 NA가 생성되었습니다. fResults[12] &lt;- &quot;None&quot; fResults [1] A C B None C B A C B B &lt;NA&gt; None Levels: A B C None 6.1.2 순서형 변수와 요인 범주형 데이터는 앞의 예처럼 범주 간에 순서가 없는 명목형 데이터도 있지만, 범주 간에 순서가 있는 순서형 데이터도 있다. 전국 유권자 대상으로 현 정권에 대한 만족도에 대해 다음 설문조사를 하였다고 하자. 현 정권의 국정 수행에 대해 만족하고 계십니까? ( ) 매우 불만 불만 보통 만족 매우 만족 설문 결과를 다음과 같이 요인을 가지고 결과를 코딩할 수 있을 것이다. 그러나 요인은 디폴트로 수준 간에 순서가 없는 명목형 변수로 데이터를 처리한다. 그러므로 순서를 비교하는 비교 연산을 적용할 수 없다. satisfaction &lt;- c(&quot;매우 불만&quot;, &quot;매우 만족&quot;, &quot;불만&quot;, &quot;만족&quot;, &quot;보통&quot;, &quot;불만&quot;, &quot;매우 불만&quot;, &quot;보통&quot;, &quot;매우 만족&quot;, &quot;불만&quot;) fSatisfaction &lt;- factor(satisfaction, levels=c(&quot;매우 불만&quot;, &quot;불만&quot;, &quot;보통&quot;, &quot;만족&quot;, &quot;매우 만족&quot;)) fSatisfaction [1] 매우 불만 매우 만족 불만 만족 보통 불만 매우 불만 [8] 보통 매우 만족 불만 Levels: 매우 불만 불만 보통 만족 매우 만족 fSatisfaction &gt;= &quot;만족&quot; Warning in Ops.factor(fSatisfaction, &quot;만족&quot;): 요인(factors)에 대하여 의미있는 &#39;&gt;=&#39;가 아닙니다. [1] NA NA NA NA NA NA NA NA NA NA ordered 인수로 순서형 변수 만들기 명목형 데이터를 나타내는 요인의 숫자는 각 범주를 표현하는 의미를 가지므로 앞의 맨 마지막 예처럼 순서를 비교하는 연산을 수행할 수 없다. 그런데 이 경우에는 범주 간에 순서적 의미가 있으므로 factor() 함수의 ordered 인수를 설정하여 범주 간의 순서 관계를 명확히 할 수 있다. 다음 예에서 볼 수 있듯이 범주 간의 순서가 수준이 출력될 때 명시됨을 볼 수 있고, 순서 비교가 가능함을 볼 수 있다. 심지어는 order() 함수로 순서를 파악할 수 있다. oSatisfaction &lt;- factor(satisfaction, ordered = TRUE, levels=c(&quot;매우 불만&quot;, &quot;불만&quot;, &quot;보통&quot;, &quot;만족&quot;, &quot;매우 만족&quot;)) oSatisfaction [1] 매우 불만 매우 만족 불만 만족 보통 불만 매우 불만 [8] 보통 매우 만족 불만 Levels: 매우 불만 &lt; 불만 &lt; 보통 &lt; 만족 &lt; 매우 만족 oSatisfaction &gt;= &quot;만족&quot; [1] FALSE TRUE FALSE TRUE FALSE FALSE FALSE FALSE TRUE FALSE sum(oSatisfaction &gt;= &quot;만족&quot;) [1] 3 mean(oSatisfaction &gt;= &quot;만족&quot;) [1] 0.3 order(oSatisfaction) [1] 1 7 3 6 10 5 8 4 2 9 R은 범주형 변수인 ’불만’과 ’만족’의 순서를 알 수 없다. ordered() 함수로 순서형 범주를 만들 때 levels에 나열된 순서로 크기가 주어진다고 가정한다. 만약 위의 예에서 levels의 순서가 다르면 다른 결과가 나올 것이다. oSatisfaction &lt;- factor(satisfaction, ordered = TRUE, levels=c(&quot;매우 만족&quot;, &quot;만족&quot;, &quot;보통&quot;, &quot;불만&quot;, &quot;매우 불만&quot;)) oSatisfaction [1] 매우 불만 매우 만족 불만 만족 보통 불만 매우 불만 [8] 보통 매우 만족 불만 Levels: 매우 만족 &lt; 만족 &lt; 보통 &lt; 불만 &lt; 매우 불만 oSatisfaction &gt;= &quot;만족&quot; [1] TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE FALSE TRUE sum(oSatisfaction &gt;= &quot;만족&quot;) [1] 8 mean(oSatisfaction &gt;= &quot;만족&quot;) [1] 0.8 order(oSatisfaction) [1] 2 9 4 5 8 3 6 10 1 7 수준의 순서 순서형이 아닌 명목형 범주 데이터는 factor()로 만들어지고 이 때도 levels에 주어진 순서로, 범주(수준)가 내부적으로 저장되는 숫자가 결정된다. levels에 언급된 수준의 순서대로 1번부터 차례로 숫자가 부여된다. 순서형 범주 데이터처럼 순서가 데이터 분석에 핵심적인 역할을 하지는 않지만, 그래프나 표가 표현될 때 이 범주(수준)의 순서대로 출력되므로, 범주를 원하는 순서대로 출력하고자 하면 levels 인수에 수준의 순서를 명시하는 것이 좋다. 그렇지 않으면 단어의 사전적 순서 등에 의해 순서가 부여된다. a &lt;- c(&quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;) fa1 &lt;- factor(a) fa1 [1] F M F M F Levels: F M unclass(fa1) [1] 1 2 1 2 1 attr(,&quot;levels&quot;) [1] &quot;F&quot; &quot;M&quot; table(fa1) fa1 F M 3 2 fa2 &lt;- factor(a, levels=c(&quot;M&quot;, &quot;F&quot;)) fa2 [1] F M F M F Levels: M F unclass(fa2) [1] 2 1 2 1 2 attr(,&quot;levels&quot;) [1] &quot;M&quot; &quot;F&quot; table(fa2) fa2 M F 2 3 relevel()과 reorder()를 이용한 수준의 순서 변경 앞의 예에서는 factor() 함수의 levels 인수를 사용하여 수준의 순서를 바꾸는 방법을 보았다. 이러한 방법은 수준의 수가 적을 때는 편리한 방법이지만, 수준의 수가 많으면 모든 수준을 levels 인수에 나열하여야 하기 때문에 불편하다. 예를 들어, 분석의 주안점이 되는 수준이 있고, 나머지 수준의 순서는 중요하지 않은 경우, 관심의 대상이 되는 수준이 맨 앞에 오도록 순서를 변경하려면 factor() 함수의 levels 인수에 모든 수준을 다시 나열해 주어야 하므로 불편하다. 이러한 경우에는 relevel() 함수를 사용하면 원하는 결과를 쉽게 얻을 수 있다. 다음의 fResult 요인에서 \"None\"이라는 수준이 맨 앞에 나타나도록 변경하고자 한다. fResults [1] A C B None C B A C B B &lt;NA&gt; None Levels: A B C None relevel() 함수의 ref 인수에 맨 앞에 나타날 수준을 지정하면 나머지 수준의 순서는 변하지 않고 지정된 수준만 앞으로 이동하게 된다. fResults2 &lt;- relevel(fResults, ref = &quot;None&quot;) fResults2 [1] A C B None C B A C B B &lt;NA&gt; None Levels: None A B C table(fResults2) fResults2 None A B C 2 2 4 3 InsectSprays는 살충제의 종류(spray)와 농작물에 있는 해충의 수(count)를 보여주는 데이터이다. 살충제의 종류는 6 개의 수준을 가지는 요인이다. head(InsectSprays) count spray 1 10 A 2 7 A 3 20 A 4 14 A 5 14 A 6 12 A InsectSprays$spray [1] A A A A A A A A A A A A B B B B B B B B B B B B C C C C C C C C C C C C D D [39] D D D D D D D D D D E E E E E E E E E E E E F F F F F F F F F F F F Levels: A B C D E F 다음은 살충제 종류에 따른 해충의 수의 분포를 상자 그래프로 나타낸 것이다. boxplot(count ~ spray, data=InsectSprays) 그런데 이런 데이터는 살충력이 높은 것에서 낮은 것 순으로 배열되는 것이 더 이해하기가 쉽다. 그러한 형태로 그래프를 그리려면 요인이 spray 열의 수준이 count의 중위수가 낮은 것부터 높은 것 순으로 정렬되어야 한다. reorder() 함수를 사용하면 이러한 수준의 변경을 손 쉽게 할 수 있다. reorder()는 첫 번째 인수로 요인을, 두 번째 인수로 요인의 수준을 결정할 다른 수치 벡터를, 세 번째 인수로 수치 벡터에 적용할 통계 함수를 지정한다. 그러면 수치 벡터를 요인의 수준 별로 나누어 통계 함수를 적용한 후, 가장 낮은 값에서 큰 값으로 수준의 순서를 재정렬한다. boxplot(count ~ reorder(spray, count, median), data=InsectSprays) labels 인수 요인을 만든 후 기존의 수준을 변경하고 싶으면 levels() 함수를 이용하여 새로운 수준을 할당한다고 설명하였다. 그러나 요인을 만들 때 기존에 코딩된 수준을 바로 변경하고 싶을 수가 있다. 이 경우에는 factor() 함수에 labels 인수를 이용하면 기존의 수준이 labels 인수에 주어진 형태로 변경된다. 이 때 주의할 점은 levels 인수는 원래 데이터가 코딩된 형태로 정의되어야 하고, labels 인수는 바꿀 코딩 형태로 정의되어야 한다. fa3 &lt;- factor(a, levels=c(&quot;M&quot;, &quot;F&quot;), labels=c(&quot;Male&quot;, &quot;Female&quot;)) fa3 [1] Female Male Female Male Female Levels: Male Female unclass(fa3) [1] 2 1 2 1 2 attr(,&quot;levels&quot;) [1] &quot;Male&quot; &quot;Female&quot; table(fa3) fa3 Male Female 2 3 fa3[6] &lt;- &quot;M&quot; Warning in `[&lt;-.factor`(`*tmp*`, 6, value = &quot;M&quot;): 요인의 수준(factor level)이 올바르지 않아 NA가 생성되었습니다. fa3[6] &lt;- &quot;Male&quot; 6.2 데이터 프레임 만들기 data.frame() data.frame() 함수를 이용하면 벡터, 행렬, 요인, 심지어 다른 데이터 프레임을 묶어서 새로운 데이터 프레임을 만들 수 있다. 이 때 다음과 같은 제한 조건이 있다. 첫째, 벡터는 모두 같은 길이를 가져야 하며 행렬과 데이터 프레임은 모두 같은 행 수를 가져야 한다. 벡터의 같은 위치의 데이터와 행렬 및 데이터 프레임의 같은 행에 있는 데이터가 연결되어 하나의 데이터 단위가 된다. 둘째, 벡터는 하나의 벡터가 데이터 프레임의 하나의 열이 되지만, 행렬, 데이터 프레임은 각 열이 데이터 프레임의 하나의 열이 된다. 이러한 사실을 염두하면서 표 6.1의 데이터를 데이터 프레임으로 만들어 본다. 먼저 학생이름, 학년, 성별로만 이루어진 데이터 프레임을 만들어 보자. name &lt;- c(&quot;김철수&quot;, &quot;김영희&quot;, &quot;이철수&quot;, &quot;이영희&quot;, &quot;홍길동&quot;) grade &lt;- c(1, 4, 3, 2, 1) gender &lt;- c(&quot; M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;) student &lt;- data.frame(name, grade, gender) student name grade gender 1 김철수 1 M 2 김영희 4 F 3 이철수 3 M 4 이영희 2 F 5 홍길동 1 M 위의 예에서는 길이가 같은 벡터와 요인을 인수로 해서 데이터 프레임을 만들었다. 데이터 프레임을 출력해 보면 자동으로 행 번호가 부여되어 있음을 볼 수 있다. 열의 이름으로 각각 벡터와 요인을 저장한 변수명이 부여되었음을 볼 수 있다. 이번에는 만들어진 데이터 프레임에 중간, 기말 고사 점수와 재수강 여부를 포함시켜 새로운 데이터 프레임을 만들어 보자. 아래 예에서는 중간, 기말 고사 점수를 행렬로 먼저 만든 후 데이터 프레임에 포함시켜 보았다. midterm = c(74, 82, 67, 89, 92) final = c(91, 77, 88, 78, 86) scores = cbind(midterm, final) scores midterm final [1,] 74 91 [2,] 82 77 [3,] 67 88 [4,] 89 78 [5,] 92 86 rt &lt;- c(TRUE, FALSE, FALSE, TRUE, FALSE) students &lt;- data.frame(student, scores, retake = rt) students name grade gender midterm final retake 1 김철수 1 M 74 91 TRUE 2 김영희 4 F 82 77 FALSE 3 이철수 3 M 67 88 FALSE 4 이영희 2 F 89 78 TRUE 5 홍길동 1 M 92 86 FALSE 위에서 새로운 데이터 프레임의 각 열의 이름은 기존 데이터 프레임의 각 열의 이름, 행렬의 열 이름이 자동으로 부여되고 있음을 볼 수 있다. 재수강 여부 데이터벡터 rt는 data.frame()이 호출될 때, retake = rt 형태로 인수를 전달하여 새로운 데이터 프레임에서는 이름이 retake로 변경되었다. 데이터 프레임을 생성할 때 각 열에 이름을 부여하고 싶으면 이와 같은 방식으로 이름을 부여하면 된다. cbind() 앞서 설명하였듯이 데이터 프레임은 행렬적인 외양을 가지고 있으므로 행렬처럼 cbind()나 rbind()를 이용하여 행과 열을 추가할 수 있다. 다음 예는 cbind를 이용하여 중간과 기말의 총점 열을 추가한 예이다. total.scores &lt;- midterm + final cbind(students, total.scores) name grade gender midterm final retake total.scores 1 김철수 1 M 74 91 TRUE 165 2 김영희 4 F 82 77 FALSE 159 3 이철수 3 M 67 88 FALSE 155 4 이영희 2 F 89 78 TRUE 167 5 홍길동 1 M 92 86 FALSE 178 rbind() 다음 예는 rbind()로 새로운 데이터 행을 추가한 예이다. 이 때 주의할 점은 추가할 데이터의 각 항목의 이름과 형식이 일치해야 한다는 것이다. a &lt;- data.frame(name=&quot;Jane Eyre&quot;, grade=4, gender=&quot;F&quot;, midterm=90, final=85, retake=F) a name grade gender midterm final retake 1 Jane Eyre 4 F 90 85 FALSE rbind(students, a) name grade gender midterm final retake 1 김철수 1 M 74 91 TRUE 2 김영희 4 F 82 77 FALSE 3 이철수 3 M 67 88 FALSE 4 이영희 2 F 89 78 TRUE 5 홍길동 1 M 92 86 FALSE 6 Jane Eyre 4 F 90 85 FALSE 6.3 데이터 프레임 각 열의 지정 데이터 프레임은 리스트 타입 생성된 데이터 프레임에 대해 typeof() 함수와 attributes() 함수를 이용하여 타입과 속성을 알아보자. 다음 결과에서 데이터 프레임은 리스트 타입이며, names 속성에 데이터 프레임의 각 열의 이름이 나열되어 있음을 볼 수 있다. typeof(students) [1] &quot;list&quot; attributes(students) $names [1] &quot;name&quot; &quot;grade&quot; &quot;gender&quot; &quot;midterm&quot; &quot;final&quot; &quot;retake&quot; $class [1] &quot;data.frame&quot; $row.names [1] 1 2 3 4 5 리스트 형식으로 데이터 프레임의 열 지정 데이터 프레임은 본질적으로 리스트 타입이므로 데이터 프레임의 각 열은 리스트의 요소가 된다. 따라서 데이터 프레임의 각 열을 지정할 때는 리스트의 각 요소를 지정할 때와 마찬가지로, $ 기호 또는 [[ ]]를 이용하여 다음과 같은 형태로 지정하면 된다. 이는 데이터 프레임이 리스트 타입이기 때문에 리스트와 같은 방식으로 요소들에 접근할 수 있기 때문이다. 리스트에 대한 자세한 설명은 5 장을 확인하기 바란다. data_frame_name$column_name data_frame_name[[column_number]] data_frame_name[[column_name]] 다음은 위에서 생성한 students의 각 열을 이름으로 지정하여, 학생의 성별 데이터, 중간, 기말고사를 출력한 예이다. students$gender [1] &quot; M&quot; &quot;F&quot; &quot;M&quot; &quot;F&quot; &quot;M&quot; students[[&quot;midterm&quot;]] [1] 74 82 67 89 92 students[[5]] [1] 91 77 88 78 86 students$name [1] &quot;김철수&quot; &quot;김영희&quot; &quot;이철수&quot; &quot;이영희&quot; &quot;홍길동&quot; typeof(students$name) [1] &quot;character&quot; 데이터 프레임의 각 열은 벡터 데이터 프레임의 각 열은 벡터이므로 데이터 프레임의 특정 열을 리스트 필터링과 같은 방식으로 지정한 후, 벡터 연산이나 벡터 인덱스를 이용하여 각 요소의 값을 출력하거나 변경할 수 있다. students$midterm * 2 [1] 148 164 134 178 184 sum(students$midterm) [1] 404 students$midterm[5] [1] 92 students$midterm[5] &lt;- 50 students[[4]][3:5] [1] 67 89 50 또한 리스트에 새로운 요소를 추가할 때와 마찬가지 방법으로 열을 추가할 수도 있다. 다음 예는 hw이라는 이름으로 숙제 점수 열을 추가하는 예이다. students$hw &lt;- c(8, 9, 7, 8, 10) students name grade gender midterm final retake hw 1 김철수 1 M 74 91 TRUE 8 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M 67 88 FALSE 7 4 이영희 2 F 89 78 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 6.4 데이터 프레임의 필터링 데이터를 분석하다 보면 작업 중인 데이터 프레임의 일부만을 선택하여 작업을 할필요가 있다. 어떤 경우에는 데이터의 일부분만 변경할 필요가 있다. 필요 없는 열을 제거하거나 새로운 열을 추가하기 위해서는 여러 열을 한번에 지정할 수도 있어야 한다. 이러한 작업을 수행하기 위해서는 데이터 프레임의 일부분을 지정하는 필터링을 수행하여야 한다. 데이터 프레임은 리스트를 기본적인 속성으로 하기 때문에 리스트로서 부분을 필터링하는 방법이 있고, 행렬적 외양을 가지고 있기 때문에 행렬처럼 필터링을 하는 방법이 있다. 6.4.1 리스트 형식으로 필터링 데이터 프레임은 리스트 구조를 가지고 있으며, 데이터 프레임의 열은 리스트의 각 요소가 된다. 따라서 5 장에서 이용한 리스트의 부분 필터링을 수행하는 방법으로 데이터 프레임의 일부 열만 필터링을 수행할 수 있다. 리스트로서 필터링은 1차원 인덱스 구조를 갖는다. 리스트로서 데이터 프레임을 필터링하는 방법은 아래와 같이 인덱스 벡터를 이용하는 것이다. 여기서 인덱스 벡터는 벡터나 리스트의 인덱스 벡터와 마찬가지로 숫자, 이름, 논리값 벡터가 될 수 있다. data_frame_name[index_vector] 다음 예는 students 데이터 프레임에서 열의 인덱스를 숫자, 이름, 논리값으로 각각 지정하여 새로운 데이터 프레임을 만든 경우이다. students.new &lt;- students[1:2] students.new name grade 1 김철수 1 2 김영희 4 3 이철수 3 4 이영희 2 5 홍길동 1 students.new &lt;- students[-(1:2)] students.new gender midterm final retake hw 1 M 74 91 TRUE 8 2 F 82 77 FALSE 9 3 M 67 88 FALSE 7 4 F 89 78 TRUE 8 5 M 50 86 FALSE 10 student.new &lt;- students[c(&quot;gender&quot;, &quot;grade&quot;)] student.new gender grade 1 M 1 2 F 4 3 M 3 4 F 2 5 M 1 student.new &lt;- students[c(T, F, F, T, T, F)] student.new name midterm final hw 1 김철수 74 91 8 2 김영희 82 77 9 3 이철수 67 88 7 4 이영희 89 78 8 5 홍길동 50 86 10 data.frame() 함수를 이용하면 기존의 데이터 프레임에 새로운 열을 추가하여 새로운 데이터 프레임도 만들 수 있다. 다음 예는 기존의 students 데이터 프레임에 키 데이터를 추가한 경우이다. height &lt;- c(172, 167, 181, 162, 178) students.new &lt;- data.frame(students[2:3], height=height) students.new grade gender height 1 1 M 172 2 4 F 167 3 3 M 181 4 2 F 162 5 1 M 178 열 지정하기 vs. 한 열만 데이터 프레임으로 필터링 앞서 설명하였듯이 데이터 프레임은 리스트이므로 데이터 프레임의 한 열만을 지정할 때 []뿐 아니라 [[]]나 와 $를 이용해 한 열을 지정할 수 있다. 두 방식의 차이는 전자가 데이터 프레임에서 지정된 열만으로 이루어진 새로운 데이터 프레임을 반환하는 반면, 후자는 데이터 프레임에 있는 열 자체, 즉 벡터를 반환한다. 아래는 students 데이터 프레임에서 []와 [[]]를 이용하여 두번째 열을 지정한 결과이다. a &lt;- students[2] a grade 1 1 2 4 3 3 4 2 5 1 typeof(a) [1] &quot;list&quot; attributes(a) $names [1] &quot;grade&quot; $row.names [1] 1 2 3 4 5 $class [1] &quot;data.frame&quot; a &lt;- students[[2]] a [1] 1 4 3 2 1 typeof(a) [1] &quot;double&quot; attributes(a) NULL 지금까지 설명한 내용은 데이터 프레임이 리스트 타입이기 때문에 성립하는 내용이다. 따라서 지금까지 설명한 내용은 리스트에도 모두 적용된다. 6.4.2 행렬 형식으로 필터링 행렬로서 필터링은 2차원 인덱스 구조를 갖는다. 데이터 프레임은 열의 길이가 모두 같기 때문에, 보통의 리스트에는 없는 행렬과 같은 필터링 방법이 존재한다. 특히 기존의 데이터 프레임에 행을 삭제 또는 추가할 필요가 있는 경우 이러한 행렬 방식의 필터링 방법은 매우 유용한다. 데이터 프레임의 인덱스 벡터의 사용은 다음과 같이 행렬의 방식과 동일하게 행과 열을 독립적으로 지정하는 2차원 인덱스 구조를 가진다. data_frame_name[row_index_vector, column_index_vector] 다음은 students 데이터 프레임에서 행렬 인덱스 벡터를 이용하여 데이터의 일부를 지정한 예이다. students[1,] name grade gender midterm final retake hw 1 김철수 1 M 74 91 TRUE 8 students[2:3,] name grade gender midterm final retake hw 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M 67 88 FALSE 7 students[-(2:3),] name grade gender midterm final retake hw 1 김철수 1 M 74 91 TRUE 8 4 이영희 2 F 89 78 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 students[,4] [1] 74 82 67 89 50 students[,-4] name grade gender final retake hw 1 김철수 1 M 91 TRUE 8 2 김영희 4 F 77 FALSE 9 3 이철수 3 M 88 FALSE 7 4 이영희 2 F 78 TRUE 8 5 홍길동 1 M 86 FALSE 10 students[, c(2, 4)] grade midterm 1 1 74 2 4 82 3 3 67 4 2 89 5 1 50 students[2:4, 3:5] gender midterm final 2 F 82 77 3 M 67 88 4 F 89 78 students$midterm &gt;= 80 [1] FALSE TRUE FALSE TRUE FALSE students[students$midterm &gt;= 80, ] name grade gender midterm final retake hw 2 김영희 4 F 82 77 FALSE 9 4 이영희 2 F 89 78 TRUE 8 students[students$midterm &gt;= 80, c(&quot;name&quot;, &quot;grade&quot;, &quot;gender&quot;)] name grade gender 2 김영희 4 F 4 이영희 2 F students[students$grade != 1, c(&quot;name&quot;, &quot;grade&quot;, &quot;gender&quot;)] name grade gender 2 김영희 4 F 3 이철수 3 M 4 이영희 2 F 행렬 필터링 방법을 이용한 데이터 프레임 정렬 행렬과 마찬가지로 데이터 프레임을 특정 열을 기준으로 정렬할 수 있다. 다음은 학년을 기준으로 데이터 프레임을 정렬한 예와, 기말고사 점수가 높은 학생부터 낮은 학생 순으로 정렬한 예이다. order(students$grade) [1] 1 5 4 3 2 students[order(students$grade), ] name grade gender midterm final retake hw 1 김철수 1 M 74 91 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 4 이영희 2 F 89 78 TRUE 8 3 이철수 3 M 67 88 FALSE 7 2 김영희 4 F 82 77 FALSE 9 order(students$final, decreasing = TRUE) [1] 1 3 5 4 2 students[order(students$final, decreasing = TRUE), ] name grade gender midterm final retake hw 1 김철수 1 M 74 91 TRUE 8 3 이철수 3 M 67 88 FALSE 7 5 홍길동 1 M 50 86 FALSE 10 4 이영희 2 F 89 78 TRUE 8 2 김영희 4 F 82 77 FALSE 9 만약 학생을 학년으로 정렬을 한 후, 동일 학년이면 기말고사가 높은 사람이 먼저 나오게 정렬하고자 하면 어떻게 할까? 사실 order() 함수는 길이가 같은 여러 개의 벡터를 차례대로 비교하여 순위를 결정할 수 있다. order()의 인수 중 맨처음 나열된 벡터를 기준으로 순서를 결정하지만, 동률이 있으면 두번째로 나열된 벡터를 기준으로 동률 간의 순서를 결정한다. 두번째 벡터에서도 동률이면 다음에 나열된 벡터를 기준으로 이용한다. 예를 들어 학생을 학년 순서로 정렬하는데, 학년이 동률인 경우 기말고사 점수로 순서를 정한다고 하자. 그러면 다음과 같이 order() 함수를 기술하면 된다. order(students$grade, students$final) [1] 5 1 4 3 2 students[order(students$grade, students$final), ] name grade gender midterm final retake hw 5 홍길동 1 M 50 86 FALSE 10 1 김철수 1 M 74 91 TRUE 8 4 이영희 2 F 89 78 TRUE 8 3 이철수 3 M 67 88 FALSE 7 2 김영희 4 F 82 77 FALSE 9 그런데 우리는 학년은 낮은 학년부터 높은 학년으로 정렬하지만 기말고사는 높은 점수에서 낮은 점수로 정렬하고자 한다. order() 함수의 decreasing 인수를 TRUE로 하면 학년마저 높은 순에서 낮은 순으로 되니 원하는 결과를 얻을 수 없다. 이런 경우에는 첫번째 벡터는 그대로 두고, 두번째 벡터에 -1을 곱한 후 순서를 정렬하면 원하는 결과를 얻을 수 있다. students[order(students$grade, students$final, decreasing=T), ] name grade gender midterm final retake hw 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M 67 88 FALSE 7 4 이영희 2 F 89 78 TRUE 8 1 김철수 1 M 74 91 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 students[order(students$grade, -students$final), ] name grade gender midterm final retake hw 1 김철수 1 M 74 91 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 4 이영희 2 F 89 78 TRUE 8 3 이철수 3 M 67 88 FALSE 7 2 김영희 4 F 82 77 FALSE 9 6.4.3 subset()을 이용한 필터링 subset()4 함수는 벡터, 행렬, 데이터 프레임에서 조건에 맞는 부분을 반환하는 함수이다. 지금까지 우리는 벡터, 행렬, 데이터 프레임을 필터링할 때, 인덱스 벡터를 이용하여 이를 수행하였다. 사실 데이터 처리에 필요한 거의 모든 작업은 subset()을 이용할 필요가 없이, 지금까지 설명한 인덱스 벡터를 이용하여 필터링을 수행하면 된다. 그러나 subset() 함수를 이용하면 지금까지의 필터링 방법을 좀 더 쉽게 할 수 있는 경우가 있다. subset() 함수는 다음과 같은 형식을 가진다. subset() subset(x, subset, select, drop=FALSE, ...) subset() 함수로 필터링하는 방법과 인덱스 벡터를 이용하는 필터링과의 차이점은 다음 3가지이다. 조건에 부합하는 행을 필터링 할 때, subset() 함수는 subset 인수에 조건을 기술한다. 인덱스 벡터는 자연수, 음의 정수, 논리값, 문자열이 모두 가능하지만, subset에서는 논리값만 가능하다. subset에서는 열을 변수처럼 기술할 수 있기 때문에 행 필터링 조건을 인덱스 벡터를 이용하는 방법보다 좀 더 간편하게 기술할 수 있다. subset() 함수를 이용한 필터링에서는 subset의 조건식의 결과가 NA인 경우는 FALSE로 평가하여 NA 행을 자동으로 제거한다. 인덱스 벡터를 이용하는 경우는 조건식의 결과가 NA이어도 그 행은 제거되지 않는다. 열을 필터링할 때, 인덱스 벡터를 이용한 필터링에서는 열의 번호나 이름으로 필터링할 열을 지정한다. 열의 이름으로 필터링 할 때는 반드시 문자열로 열의 이름이 표시된다. subset()의 경우 선택할 열은 select 인수로 표현하는데, 열의 이름을 따옴표 없이 변수처럼 그대로 기술한다. 그러면 열의 이름이 열의 번호로 대체되어 최종적으로 필터링이 수행된다. 위에서 설명한 내용이 어떤 의미인지를 벡터, 행렬, 데이터 프레임의 경우에서 각각 살펴보도록 한다. subset()을 이용한 벡터 필터링 x &lt;- c(7, 9, NA, 5, 2) x[x&gt;6] [1] 7 9 NA subset(x, x&gt; 6) [1] 7 9 위의 예에서 보듯이 벡터를 필터링할 때, 인덱스 벡터를 이용하는 방법은 NA가 있는 경우 그 결과를 알 수 없으므로 필터링한 결과에도 NA로 표시한다. 그러나 subset() 함수는 NA를 자동으로 제거함을 알 수 있다. subset()을 이용한 데이터 프레임 필터링 y &lt;- 1:5 z &lt;- -1:-5 long.name &lt;- data.frame(x, y, z) long.name x y z 1 7 1 -1 2 9 2 -2 3 NA 3 -3 4 5 4 -4 5 2 5 -5 rm(x, y, z) long.name[long.name$x &gt;6, ] x y z 1 7 1 -1 2 9 2 -2 NA NA NA NA subset(long.name, x&gt;6) x y z 1 7 1 -1 2 9 2 -2 위의 예에서 보듯이 인덱스 벡터를 이용하는 경우에는 데이터 프레임의 열을 지정하기 위해서 $ 앞에 데이터 프레임 이름을 일일이 지정해야 했다. 그러나 subset()의 경우 두번째 인수에 열을 그냥 변수처럼 기술한다. 인덱스 벡터를 이용하는 방법은 NA가 있는 경우 그 결과를 알 수 없으므로 필터링한 결과에도 NA로 표시한다. 그러나 subset() 함수는 NA를 자동으로 제거한다. long.name[long.name$x &gt;6, 2:3] y z 1 1 -1 2 2 -2 NA NA NA subset(long.name, x&gt;6, y:z) y z 1 1 -1 2 2 -2 long.name[long.name$x &gt;6, c(&quot;x&quot;, &quot;z&quot;)] x z 1 7 -1 2 9 -2 NA NA NA subset(long.name, x&gt;6, c(x, z)) x z 1 7 -1 2 9 -2 subset(long.name, x&gt;6, -z) x y 1 7 1 2 9 2 인덱스 벡터의 경우 열을 지정할 때 번호나 문자열 이름을 이용하였는데, subset()은 열의 이름을 변수처럼 사용하여 지정하고 있음을 알 수 있다. 앞서 설명하였듯이 변수처럼 사용된 열의 이름은 열의 위치를 나타내는 숫자로 변환되어 처리된다. 그렇기 때문에 y:z나 -z 등의 기술이 가능하다. 6.5 데이터 프레임에 함수 적용하기 리스트로서 각 열에 함수 적용하기 데이터 프레임은 리스트로서의 속성이 있기 때문에 lapply()나 sapply() 함수를 이용하여 열별로 함수를 적용할 수 있다. lapply(students[4:5], mean) $midterm [1] 72.4 $final [1] 84 sapply(students[4:5], mean) midterm final 72.4 84.0 sapply(students[4:5], summary) midterm final Min. 50.0 77 1st Qu. 67.0 78 Median 74.0 86 Mean 72.4 84 3rd Qu. 82.0 88 Max. 89.0 91 행렬 함수 적용하기 데이터 프레임은 행렬과 동일한 형식을 가지고 있기 때문에 행렬에서 사용했던 다양한 함수가 데이터 프레임에도 작동하는 경우가 많다. 다음은 행과 열의 길이를 알아내는 nrow()과 ncol() 함수, 그리고 행과 열을 전치시키는 t() 함수를 데이터 프레임에 적용한 예이다. nrow(students) [1] 5 ncol(students) [1] 7 t(students) [,1] [,2] [,3] [,4] [,5] name &quot;김철수&quot; &quot;김영희&quot; &quot;이철수&quot; &quot;이영희&quot; &quot;홍길동&quot; grade &quot;1&quot; &quot;4&quot; &quot;3&quot; &quot;2&quot; &quot;1&quot; gender &quot; M&quot; &quot;F&quot; &quot;M&quot; &quot;F&quot; &quot;M&quot; midterm &quot;74&quot; &quot;82&quot; &quot;67&quot; &quot;89&quot; &quot;50&quot; final &quot;91&quot; &quot;77&quot; &quot;88&quot; &quot;78&quot; &quot;86&quot; retake &quot;TRUE&quot; &quot;FALSE&quot; &quot;FALSE&quot; &quot;TRUE&quot; &quot;FALSE&quot; hw &quot; 8&quot; &quot; 9&quot; &quot; 7&quot; &quot; 8&quot; &quot;10&quot; 행과 열이 전치된 데이터 프레임을 살펴보면 모든 열이 문자열 벡터로 변경되었음을 볼 수 있다. 데이터 프레임의 각 열은 모두 동일한 타입이어야 한다. 전치된 열은 논리값, 숫자, 문자가 모두 포함되어 있다. 따라서 이를 모두 수용할 수 있는 문자 행렬로 변환되었음을 볼 수 있다. apply()로 행이나 열에 함수 적용하기 데이터 프레임에도 apply() 함수를 적용할 수 있다. 그러나 여기서 주의할 점은 R은 apply() 함수를 적용하기 앞서 데이터 프레임을 행렬로 변환시킨다. 따라서 앞의 t() 함수의 적용 결과처럼 요소 중에 하나라도 문자가 있으면 모든 요소를 수용할 수 있는 문자 행렬로 변환하게 된다. apply(students, 2, mean) name grade gender midterm final retake hw NA NA NA NA NA NA NA apply(students[4:5], 2, mean) midterm final 72.4 84.0 apply(students[4:5], 1, sum) [1] 165 159 155 167 136 첫번째 예에서는 students에 문자 열이 있어 모두 문자 행렬로 변환된다. 그러므로 mean이 적용될 수 없어서 경고와 함께 모두 NA의 값이 출력되었다. 그러나 중간과 기말고사 점수가 있는 부분만으로 부분 데이터 프레임을 만들어 apply()을 적용하면 모두 숫자이므로 숫자 행렬로 변환되어 결과가 잘 수행되었음을 알 수 있다. 따라서 열별로 함수를 적용할 때에는 행렬로 변환이 필요한 apply()보다는 lapply()나 sapply()를 바로 적용하는 것이 더 좋다. 긴 데이터 프레임의 앞 또는 뒷 부분 출력하기 데이터 프레임에만 적용되는 것은 아니지만 head()와 tail() 함수를 이용하면 긴 데이터 프레임의 앞 부분과 뒤 부분만을 쉽게 참조할 수 있다. nrow(iris) [1] 150 head(iris) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5.0 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa tail(iris) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 145 6.7 3.3 5.7 2.5 virginica 146 6.7 3.0 5.2 2.3 virginica 147 6.3 2.5 5.0 1.9 virginica 148 6.5 3.0 5.2 2.0 virginica 149 6.2 3.4 5.4 2.3 virginica 150 5.9 3.0 5.1 1.8 virginica iris 데이터는 R에서 제공하는 데이터인데 150 개의 관측치로 되어 있으므로 이를 화면에 다 출력하면 화면이 많이 스크롤되어서 데이터를 파악하기 힘들다. 이런 경우 head()나 tail()을 사용하여 데이터의 앞 또는 뒷 부분을 파악한다. 이 두 함수는 데이터 프레임의 앞과 뒤의 6줄을 반환한다. 다음처럼 n 인수를 사용하여 출력할 행의 수를 직접 지정할 수도 있다. head(iris, n = 3) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa tail(iris, n = 2) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 149 6.2 3.4 5.4 2.3 virginica 150 5.9 3.0 5.1 1.8 virginica 6.6 파일에서 데이터 읽어오기 규모가 큰 데이터는 R 콘솔에서 직접 입력하기보다는 파일에서 불러오는 경우가 많다. R에서는 주로 텍스트 파일이나 Excel의 데이터를 읽어오는 경우가 많다. 6.6.1 텍스트 파일에서 데이터 읽어오기 텍스트에 있는 모든 데이터를 데이터 프레임에 저장하려는 경우 read.table() 함수를 이용하면 편리하다. 파일을 불러오기 전에 주의할 점은 파일의 이름만으로 파일을 읽어오고 싶으면 현재의 작업 디렉토리(폴더)에 파일이 있어야 한다는 것이다. 그렇지 않은 경우에는 파일의 절대 경로를 모두 써 주어야만 읽어올 수 있다. 작업 디렉토리 설정 R 윈도우 버전에서 작업 디렉터리의 변경은 [파일]-[작업디렉토리변경] 메뉴를 이용하면 된다. RStudio에서는 [Session]-[Set Working Directory]-[Choose Directory] 메뉴를 이용하면 된다. 현재의 작업 디렉터리가 어디인지를 알기 위해서는 getwd() 명령을 이용하면 된다. 현재 작업 디렉터리의 파일을 보고 싶으면 list.files() 명령을 이용한다. R 명령으로 작업 디렉터리를 변경하려면 setwd()를 이용한다. 다음은 getwd()로 현재 작업 디렉토리를 얻은 후 setwd()로 data라는 하위 디렉토리(폴더)로 작업 디렉토리를 변경하고, 그 안에 있는 파일 목록을 확인한 예이다. WD &lt;- getwd() setwd(file.path(WD, &quot;data&quot;)) list.files(pattern = &quot;txt&quot;) [1] &quot;courses2.txt&quot; &quot;scores_no_header.txt&quot; &quot;scores_rn.txt&quot; [4] &quot;scores.txt&quot; &quot;students.txt&quot; 텍스트 파일을 읽어들이는 예제는 다음 파일을 사용하니 예제를 따라하고자 하는 분들은 내려받기를 하자. 텍스트 파일 내려받기 머리 행이 있는 텍스트 데이터 파일 읽기 다음처럼 파일에 있는 데이터가 첫 행은 각 항목의 이름이고 둘째 행부터 데이터가 있는 경우를 먼저 살펴보자. prov scores 서울 25 대전 35 천안 42 데이터 파일이 작업 디렉토리(폴더) 밑에 scores.txt로 저장되어 있다면 read.table() 함수를 이용하여 다음과 같이 header=TRUE 인수로 데이터 프레임으로 읽어올 수 있다. prov.scores &lt;- read.table(&quot;scores.txt&quot;, header=TRUE, fileEncoding=&quot;UTF-8&quot;) prov.scores prov scores 1 서울 25 2 대전 35 3 천안 42 attributes(prov.scores) $names [1] &quot;prov&quot; &quot;scores&quot; $class [1] &quot;data.frame&quot; $row.names [1] 1 2 3 위 결과에서 보면 파일에서 데이터를 읽어와 데이터 프레임을 생성했고, 첫 행에 나와 있는 항목 이름을 데이터 프레임 각 열의 이름으로 하고 있다. 행의 이름으로는 1, 2, 3의 순서로 행 번호를 자동 부여했다. 각 행의 데이터는 공백 문자를 기준으로 구분을 하였다. 앞의 명령어에서 fileEncoding 인수는 텍스트 파일이 어떤 문자 인코딩으로 저장되어 있는지를 지정한 것이다. 윈도우즈를 제외한 대부분의 시스템에서는 UTF-8 형식으로 텍스트 파일을 저장하지만, 한글 윈도우는 CP949 (EUC-KR)로 텍스트를 인코딩 한다. 여러 시스템 간의 호환성을 위하여 이 책에서는 텍스트 데이터를 UTF-8으로 저장하고 읽어들이기로 한다. read.table() 함수 등은 시스템의 디폴트 인코딩을 사용하여 데이터를 읽어 온다. 한글 윈도우즈의 디폴트 인코딩은 CP949이므로 UTF-8으로 텍스트 데이터를 처리하기 위하여 fileEncoding 인수를 지정하였다. 행 이름이 있는 텍스트 데이터 파일 읽기 다음 예는 파일에 데이터의 행 번호 또는 이름이 부여되어 있는 경우이다. 이 같은 경우에는 첫 행에 행 번호를 나타내는 이름은 표시하지 않는다. 따라서 첫 행과 다른 행은 항목의 수가 하나 차이가 난다. prov scores 10 서울 25 20 대전 35 30 천안 42 이와 같은 형식의 파일이 작업 디렉토리 밑의 scores_rn.txt에 저장되어 있는 경우에도 같은 방식으로 데이터를 데이터 프레임으로 읽어온다. 다음에서 볼 수 있듯이 행 번호로 파일의 첫 번째 열의 값이 사용되었다. 그리고 read.table() 함수에서 header 인수를 사용하지 않았다. 항목이 하나 적은 것으로 첫 번째 행이 머리행인 것을 자동 인식하기 때문이다. prov.scores &lt;- read.table(&quot;scores_rn.txt&quot;, fileEncoding=&quot;UTF-8&quot;) prov.scores prov scores 10 서울 25 20 대전 35 30 천안 42 머리 행이 없는 텍스트 데이터 파일 읽기 위의 결과에서 파일에 있는 행 번호가 데이터 프레임에 이용되었음을 볼 수 있다. read.table() 함수는 머리 행이 없는 텍스트 파일에서도 데이터를 읽어들일 수 있다. 다음과 같은 scores_no_header.txt 파일이 작업 디렉토리에 저장되어 있다고 하자. 서울 25 대전 35 천안 42 다음 명령문은 scores_no_header.txt 데이터 파일을 데이터 프레임으로 읽어들인 예이다. 열의 이름이 임의로 붙여졌음을 볼 수 있다. prov.scores &lt;- read.table(&quot;scores_no_header.txt&quot;, header=FALSE, fileEncoding=&quot;UTF-8&quot;) prov.scores V1 V2 1 서울 25 2 대전 35 3 천안 42 edit() 데이터 프레임에서 데이터를 편집하고 싶으면 edit() 함수를 이용한다. 다음 명령을 수행하면 데이터 프레임이 스프레드시트 형태로 나타나 수정이 가능하다. 편집창에서 수정 후 편집창을 닫으면 변경한 내용이 반영되어 새로운 데이터 프레임 prov.scores.new가 생성된다. prov.scores.new &lt;- edit(prov.scores) 6.6.2 CSV 파일에서 데이터 읽어오기 CSV 파일 많은 경우 데이터가 Excel로 저장되어 있다. Excel에서 데이터를 읽어오기 위해서는 먼저 Excel 파일을 CSV 형태의 파일로 작업 디렉토리에 저장하여야 한다.5 CSV 파일은 데이터의 각 필드가 쉼표로 분리되어 있는 파일이다. 대부분의 통계 패키지뿐 아니라 다수의 SW에서 지원하는 파일 형식이다. Excel의 버전에 따라 저장방식이 조금 차이가 있을 수 있으나, 대부분 ’다른 이름으로 저장’에서 파일 형식을 CSV 형식으로 지정해 주면 된다. CSV 파일을 읽어들이는 예제는 다음 파일을 사용하니 예제를 따라하고자 하는 독자는 내려받도록 하자. Download suicide_rates.csv read.csv() R에서 CSV 파일을 읽어오는 함수는 read.csv()이다. 다음은 각 국의 자살률에 대한 성별, 조사년도 데이터를 읽어온 예이다. 총 105개의 데이터인데 처음 몇 개의 데이터만 출력하여 보이고 있다. sr &lt;- read.csv(file=&quot;suicide_rates.csv&quot;, fileEncoding=&quot;UTF-8&quot;) nrow(sr) [1] 105 head(sr) Country Year Males Females 1 ALBANIA 3 4.7 3.3 2 ANTIGUA AND BARBUDA 95 0.0 0.0 3 ARGENTINA 8 12.6 3.0 4 ARMENIA 8 2.8 1.1 5 AUSTRALIA 6 12.8 3.6 6 AUSTRIA 9 23.8 7.1 참고로 이 예에서는 영어로 된 파일이므로 파일 인코딩을 지정하지 않아도 된다. 사실 read.csv() 함수는 read.table()의 wrapper 함수로서 header=TRUE, sep=‘,’ 인수로 read.table() 함수를 호출하기만 한다. 따라서 다음처럼 read.table() 함수를 이용해서도 CSV 파일을 읽어들일 수 있다. 이 때 주의할 점은 함수 호출 시 header=TRUE, sep=‘,’ 인수를 지정해야 한다는 것이다. sr2 &lt;- read.table(file=&quot;suicide_rates.csv&quot;, header=TRUE, sep=&quot;,&quot;, fileEncoding=&quot;UTF-8&quot;) nrow(sr2) [1] 105 head(sr2) Country Year Males Females 1 ALBANIA 3 4.7 3.3 2 ANTIGUA AND BARBUDA 95 0.0 0.0 3 ARGENTINA 8 12.6 3.0 4 ARMENIA 8 2.8 1.1 5 AUSTRALIA 6 12.8 3.6 6 AUSTRIA 9 23.8 7.1 read.csv()와 관련된 흔한 실수 read.csv() 함수를 이용할 때 초보자가 가장 자주 하는 실수가 일반 텍스트 파일인데 read.csv() 함수로 데이터를 읽어들이는 것이다. 다음은 공백으로 필드가 구분된 scores.txt 파일을 read.table()과 read.csv() 함수로 각각 읽어들인 결과이다. prov.scores &lt;- read.table(&quot;scores.txt&quot;, header=TRUE, fileEncoding=&quot;UTF-8&quot;) prov.scores prov scores 1 서울 25 2 대전 35 3 천안 42 prov.scores.csv &lt;- read.csv(&quot;scores.txt&quot;, fileEncoding=&quot;UTF-8&quot;) prov.scores.csv prov..scores 1 서울 25 2 대전 35 3 천안 42 출력해 보면 두 결과가 유사해 보인다. 그러나 읽어들여진 데이터로 작업을 해보면 read.csv() 파일로 읽어들인 데이터로는 제대로 된 작업이 수행되지 않음을 알 수 있다. 먼저 두 데이터에서 scores 열에 대한 평균을 내 보자. mean(prov.scores$scores) [1] 34 mean(prov.scores.csv$scores) Warning in mean.default(prov.scores.csv$scores): 인자가 수치형 또는 논리형이 아니므로 NA를 반환합니다 [1] NA 결과에서 보듯이 read.table()로 읽어들인 데이터 프레임에서는 원하는 결과를 얻을 수 있지만 read.csv()로 읽어들인 데이터 프레임에서는 그렇지 않았다. 그 이유는 read.csv()는 데이터 열이 쉼표로 분리된 것으로 가정하므로 한 줄의 데이터를 읽어들인 후 쉼표를 발견할 수 없어서 모두 하나의 열로 처리를 했기 때문이다. 하나가 된 데이터에는 문자와 숫자가 모두 포함되어 있으므로 이를 모두 처리할 수 있는 문자 벡터로 데이터를 저장하게 된다. 따라서 숫자 데이터 처리 함수인 mean()을 적용할 때 오류가 난 것이다. 이는 두 데이터 프레임의 열의 개수와 이름 등을 확인해 보면 쉽게 확인할 수 있다. ncol(prov.scores) [1] 2 names(prov.scores) [1] &quot;prov&quot; &quot;scores&quot; ncol(prov.scores.csv) [1] 1 names(prov.scores.csv) [1] &quot;prov..scores&quot; 6.7 데이터 프레임을 파일로 쓰기 write.table()과 write.csv() 데이터 프레임의 작업 결과를 추후에 다시 이용하기 위해서, 또는 다른 통계 패키지에서 작업 결과를 이용하기 위해서는 데이터 프레임을 파일로 저장할 수 있어야 한다. 이 경우 write.table()과 write.csv() 함수를 이용하면 데이터 프레임을 파일에 저장할 수 있다. 다음 sr 데이터프레임에 남자(Males)와 여자(Females)의 자살률의 산술 평균을 Avg 열로 추가한 후, 그 결과를 sr.csv라는 파일로 저장하는 예이다. sr$Avg &lt;- (sr$Males + sr$Females) / 2 head(sr) Country Year Males Females Avg 1 ALBANIA 3 4.7 3.3 4.00 2 ANTIGUA AND BARBUDA 95 0.0 0.0 0.00 3 ARGENTINA 8 12.6 3.0 7.80 4 ARMENIA 8 2.8 1.1 1.95 5 AUSTRALIA 6 12.8 3.6 8.20 6 AUSTRIA 9 23.8 7.1 15.45 write.csv(sr, file = &quot;sr.csv&quot;) 작업 디렉토리에 저장된 sr.csv 파일을 열어보면 다음처럼 행번호도 함께 저장된 것을 확인할 수 있다. &quot;&quot;,&quot;Country&quot;,&quot;Year&quot;,&quot;Males&quot;,&quot;Females&quot;,&quot;Avg&quot; &quot;1&quot;,&quot;ALBANIA&quot;,3,4.7,3.3,4 &quot;2&quot;,&quot;ANTIGUA AND BARBUDA&quot;,95,0,0,0 &quot;3&quot;,&quot;ARGENTINA&quot;,8,12.6,3,7.8 &quot;4&quot;,&quot;ARMENIA&quot;,8,2.8,1.1,1.95 행번호를 제외하고 파일에 데이터를 저장하려면 row.names=F로 설정한다. write.csv(sr, file = &quot;sr2.csv&quot;, row.names = F) 작업 디렉토리에 저장된 sr2.csv 파일을 열어보면 이번에는 행번호가 저장되지 않은 것을 확인할 수 있다. &quot;Country&quot;,&quot;Year&quot;,&quot;Males&quot;,&quot;Females&quot;,&quot;Avg&quot; &quot;ALBANIA&quot;,3,4.7,3.3,4 &quot;ANTIGUA AND BARBUDA&quot;,95,0,0,0 &quot;ARGENTINA&quot;,8,12.6,3,7.8 &quot;ARMENIA&quot;,8,2.8,1.1,1.95 만약 데이터에 영어와 숫자 이외에 한글 등이 포함되어 있으면 파일의 인코딩을 지정하여 저장하여 저장하는 것이 좋다. 다음 예제에서 사용하는 students는 앞선 예제에서 만든 데이터 프레임이다. 만약 이 데이터 프레임이 현재 R 세션에 없다면, 다음 students.RData 파일을 RStudio로 적재하면 students 객체가 생성될 것이다. Download students.RData 다음 예에서는 이 장에서 만든 students 데이터 프레임을 세 가지 형식으로 작업 디렉토리 밑에 저장하고 있다. 한글 때문에 파일의 인코딩 방식을 지정하여 저장하였다. students name grade gender midterm final retake hw 1 김철수 1 M 74 91 TRUE 8 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M 67 88 FALSE 7 4 이영희 2 F 89 78 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 write.table(students, &quot;students.txt&quot;, row.names=FALSE, fileEncoding=&quot;UTF-8&quot;) write.csv(students, &quot;students.csv&quot;, row.names=FALSE, fileEncoding=&quot;UTF-8&quot;) write.csv(students, &quot;students_rn.csv&quot;, row.names=TRUE, fileEncoding=&quot;UTF-8&quot;) 첫 번째 write.table()은 공백문자로 데이터 표레임의 열을 분리하여 일반 텍스트 파일로 저장한 예이다. 다음은 저장된 students.txt 파일의 모습이다. 결과에서 볼 수 있듯이 데이터 프레임의 열 이름이 머리 행으로 저장되고 데이터들이 공백문자로 구분되어 저장되었다. 숫자 데이터는 그대로, 문자 데이터는 따옴표로 둘러싸여서 저장되어 있다. &quot;name&quot; &quot;grade&quot; &quot;gender&quot; &quot;midterm&quot; &quot;final&quot; &quot;retake&quot; &quot;hw&quot; &quot;김철수&quot; 1 &quot; M&quot; 74 91 TRUE 8 &quot;김영희&quot; 4 &quot;F&quot; 82 77 FALSE 9 &quot;이철수&quot; 3 &quot;M&quot; 67 88 FALSE 7 &quot;이영희&quot; 2 &quot;F&quot; 89 78 TRUE 8 &quot;홍길동&quot; 1 &quot;M&quot; 50 86 FALSE 10 두 번째 명령문은 write.csv() 함수를 사용하여 데이터 프레임을 CSV 파일 형식으로 저장한 예이다. 다음은 저장된 students.csv 파일의 모습이다. 결과에서 볼 수 있듯이 쉼표로 각 데이터가 분리되어 있다.다음 결과에서 볼 수 있듯이 쉼표로 각 데이터가 분리되어 있다. Excel에서 파일을 읽으면 데이터를 Excel의 각 셀로 잘 읽어 들일 수 있다. &quot;name&quot;,&quot;grade&quot;,&quot;gender&quot;,&quot;midterm&quot;,&quot;final&quot;,&quot;retake&quot;,&quot;hw&quot; &quot;김철수&quot;,1,&quot; M&quot;,74,91,TRUE,8 &quot;김영희&quot;,4,&quot;F&quot;,82,77,FALSE,9 &quot;이철수&quot;,3,&quot;M&quot;,67,88,FALSE,7 &quot;이영희&quot;,2,&quot;F&quot;,89,78,TRUE,8 &quot;홍길동&quot;,1,&quot;M&quot;,50,86,FALSE,10 세 번째 명령문은 write.csv()을 사용하여 CSV 파일로 데이터를 저장한 것은 두 번째 명령문과 같은데 다만 행 번호를 같이 저장한 예이다. 다음은 저장된 students_rn.csv 파일의 모습니다. 결과에서 첫 번째 열에 행 번호가 저장되어 있음을 볼 수 있다. &quot;&quot;,&quot;name&quot;,&quot;grade&quot;,&quot;gender&quot;,&quot;midterm&quot;,&quot;final&quot;,&quot;retake&quot;,&quot;hw&quot; &quot;1&quot;,&quot;김철수&quot;,1,&quot; M&quot;,74,91,TRUE,8 &quot;2&quot;,&quot;김영희&quot;,4,&quot;F&quot;,82,77,FALSE,9 &quot;3&quot;,&quot;이철수&quot;,3,&quot;M&quot;,67,88,FALSE,7 &quot;4&quot;,&quot;이영희&quot;,2,&quot;F&quot;,89,78,TRUE,8 &quot;5&quot;,&quot;홍길동&quot;,1,&quot;M&quot;,50,86,FALSE,10 다음 예에서 write.table() 또는 write.csv() 파일로 저장한 데이터를 다시 데이터 프레임으로 잘 복원할 수 있음을 확인할 수 있다. 이 때로 파일의 형식이 공백으로 분리된 파일인지 CSV 파일인지에 따라 read.table()과 read.csv()를 적절히 선택하여야 한다. read.table(&quot;students.txt&quot;, header=TRUE, fileEncoding=&quot;UTF-8&quot;) name grade gender midterm final retake hw 1 김철수 1 M 74 91 TRUE 8 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M 67 88 FALSE 7 4 이영희 2 F 89 78 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 read.csv(&quot;students.csv&quot;, header=TRUE, fileEncoding=&quot;UTF-8&quot;) name grade gender midterm final retake hw 1 김철수 1 M 74 91 TRUE 8 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M 67 88 FALSE 7 4 이영희 2 F 89 78 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 사실 write.csv() 함수는 write.table()에서 sep 인수에 ','를 부여한 결과와 같다. 따라서 두 번째와 세 번째 명령문은 다음처럼 하여도 같은 결과를 얻을 수 있다. write.table(students, &quot;students.csv&quot;, sep=&quot;,&quot;, row.names=FALSE, fileEncoding=&quot;UTF-8&quot;) write.table(students, &quot;students_rn.csv&quot;, sep=&quot;,&quot;, row.names=TRUE, fileEncoding=&quot;UTF-8&quot;) 6.7.1 바이너리 형식으로 데이터 객체 저장 및 복원 데이터 프레임뿐 아니라 R의 모든 객체들을 saveRDS()와 readRDS(), 또는 save()와 load() 함수를 이용하여 바이너리 형식으로 저장하고 복원할 수 있다. 이 경우 메모리에 적재되는 형태대로 파일에 저장되었다가 복원되므로 별도의 처리 과정이 불필요해진다. 그러므로 대용량의 데이터를 R 플랫폼 내에서 저장하거나 복원할 때 매우 유용하다. 다음은 x라는 벡터, y라는 행렬, z라는 데이터 프레임을 만든 후, save() 함수를 이용하여 바이너리 형식으로 xyz.RData라는 파일에 저장하는 예이다. x &lt;- 1:3; x [1] 1 2 3 y &lt;- matrix(4:12, nrow=3, ncol=3); y [,1] [,2] [,3] [1,] 4 7 10 [2,] 5 8 11 [3,] 6 9 12 z &lt;- data.frame(x, y); z x X1 X2 X3 1 1 4 7 10 2 2 5 8 11 3 3 6 9 12 save(x, y, z, file = &quot;xyz.RData&quot;) 작업 디렉토리에 가보면 xyz.RData라는 파일이 생성된 것을 확인할 수 있다. save()와 load() 함수를 이용하여 저장하는 데이터 파일은 일밙거으로 .RData라는 확장자를 이용한다. 그러면 대부분의 컴퓨터 설정에서 .RData 데이터 파일이 R이나 RStudio로 자동으로 연결되어 더블 클릭만으로 파일에 저장된 객체를 R 세션에 적재할 수 있다. 파일에 데이터가 잘 저장되었고 이를 다시 load() 함수로 R 세션에 잘 복원할 수 있는지를 확인하기 위하여, 현재 R 세션에 있는, x, y, z 객체를 환경에서 제거해 보자. 다음 명령을 사용하거나 RStudio의 Environment 패널에 이 객체를 제거할 수 있다. rm(x, y, z) x; y; z Error in eval(expr, envir, enclos): 객체 &#39;x&#39;를 찾을 수 없습니다 Error in eval(expr, envir, enclos): 객체 &#39;y&#39;를 찾을 수 없습니다 Error in eval(expr, envir, enclos): 객체 &#39;z&#39;를 찾을 수 없습니다 세 객체가 모두 제거되었기 때문에 객체를 출력하려고 하면 오류가 발생한다. 다음으로 작업 디렉토리의 xyz.RData를 이용하여 R 세션에 복원해 보자. 이를 위해 다음처럼 데이터 파일이 있는 폴더를 작업 디렉토리로 설정하고 load() 함수를 사용할 수도 있고, 파일 탐색기에서 해당 파일의 컨텍스트 메뉴에서 연결 프로그램을 RStudio로 하여 파일을 열어도 된다. load(&quot;xyz.RData&quot;) x; y; z [1] 1 2 3 [,1] [,2] [,3] [1,] 4 7 10 [2,] 5 8 11 [3,] 6 9 12 x X1 X2 X3 1 1 4 7 10 2 2 5 8 11 3 3 6 9 12 이번에는 세 객체가 모두 잘 출력되는 것을 확인할 수 있다. RStudio의 Environment 패널에서도 이 객체가 다시 생성되었음을 확인할 수 있다. 6.8 데이터 프레임의 열을 변수처럼 이용하는 방법 * 변수 검색 경로 $ 기호를 이용하는 방법보다 좀 더 간편하게 데이터 프레임의 열에 접근할 수 있는 방법이 있다. attach() 함수를 이용하면 데이터 프레임의 각 열을 변수로 등록할 수 있다. attach() 함수가 실행되면 해당 데이터 프레임의 각 열을 변수로 검색 경로(search path)에 등록한다. 검색 경로란 R이 어떤 변수를 참조할 때 변수에 대한 정보를 검색하는 경로를 의미한다. 현재의 검색 경로를 파악하기 위해서는 search() 함수를 이용하면 된다. search() [1] &quot;.GlobalEnv&quot; &quot;package:stats&quot; &quot;package:graphics&quot; [4] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; [7] &quot;package:methods&quot; &quot;Autoloads&quot; &quot;package:base&quot; 위의 결과에서 알 수 있듯이 R이 기동되면 현재의 작업공간을 .GlobalEnv라는 이름으로 첫 번째 검색 경로로 등록한다. 현재의 작업 공간에서 만든 변수들은 여기서 찾을 수 있다. 그리고 package:를 접두사로 하여 패키지별 변수의 데이터베이스가 검색 경로에 등록된다. R은 검색 경로에 나와 있는 순서대로 변수들의 정보를 찾는다. attach()로 데이터 프레임을 검색 경로에 등록하기 본격적으로 attach() 함수의 작동을 보기 전에 students 데이터 프레임을 제외하고 다른 데이터 객체를 .GlobalEnv에서 삭제하도록 하겠다. .GlobalEnv 작업공간에 있는 변수를 보기 위해서는 ls() 또는 objects() 함수를 사용한다. rm() 함수를 이용하면 작업공간의 변수를 삭제할 수 있다. 이들 함수의 자세한 사용방법은 도움말을 참조한다. obj &lt;- ls() rm(list=obj[which(obj != &quot;students&quot;)]) ls() [1] &quot;obj&quot; &quot;students&quot; rm(obj) objects() [1] &quot;students&quot; 아래는 attach() 함수를 이용하여 students 데이터 프레임을 검색 경로에 등록한 예이다. 아래 예에서 보듯이 students를 검색 경로에 등록하기 전에는 retake 변수가 검색 경로에 없으므로 찾을 수 없다고 나온다. 그러나 students 데이터 프레임을 검색 경로에 등록하면 데이터 프레임의 열인 retake를 변수처럼 이용할 수 있음을 알 수 있다. retake Error in eval(expr, envir, enclos): 객체 &#39;retake&#39;를 찾을 수 없습니다 attach(students) retake [1] TRUE FALSE FALSE TRUE FALSE search() [1] &quot;.GlobalEnv&quot; &quot;students&quot; &quot;package:stats&quot; [4] &quot;package:graphics&quot; &quot;package:grDevices&quot; &quot;package:utils&quot; [7] &quot;package:datasets&quot; &quot;package:methods&quot; &quot;Autoloads&quot; [10] &quot;package:base&quot; attach()로 등록된 변수는 데이터 프레임과 독립적인 복사본이다. 여기서 주의할 점은 attach 된 변수가 변경되더라도 원래 데이터 프레임의 데이터가 변경되지는 않는다는 것이다. attach를 통해 등록된 변수는 데이터 프레임의 데이터가 복사되어 생성되지만 데이터 프레임과는 무관한 별도의 변수처럼 작동한다. retake[1] &lt;- NA retake [1] NA FALSE FALSE TRUE FALSE students$retake [1] TRUE FALSE FALSE TRUE FALSE 데이터 프레임의 데이터를 변경하려면 $ 기호를 써서 직접 변경하여야 한다. 마찬가지로 원래 데이터 프레임의 데이터가 변경되어도 검색 경로에 추가된 retake 변수의 데이터는 변경되지 않음을 알 수 있다. students$retake[5] &lt;- NA students$retake [1] TRUE FALSE FALSE TRUE NA retake [1] NA FALSE FALSE TRUE FALSE detach() 데이터 프레임을 검색 경로에서 제거하려면 detach() 함수를 이용한다. detach(students) search() [1] &quot;.GlobalEnv&quot; &quot;package:stats&quot; &quot;package:graphics&quot; [4] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; [7] &quot;package:methods&quot; &quot;Autoloads&quot; &quot;package:base&quot; attach()로 등록된 변수의 검색 경로 상의 위치 R에서 검색 경로의 첫 번째 위치는 항상 현재의 작업공간이 차지한다. attach()에 의해 추가되는 변수들은 항상 검색 경로 상에서 두번째나 그 뒤의 위치에 놓인다. 디폴트로 attach()에 의해 추가되는 변수는 검색 경로 상에서 두번째 위치에 놓이게 되므로 현재의 작업공간을 제외하고는 검색 우선순위가 가장 높게 설정된다. 이를 바꾸고 싶으면 attach() 함수의 position 인수를 이용하면 된다. (자세한 내용은 attach()의 도움말을 참조한다.) 일반적으로 데이터 프레임을 이용할 때 다음이 좋은 절차라 알려져 있다. 첫째, 어떤 문제와 관련된 모든 변수를 데이터 프레임에 포함시키고 적절한 이름을 부여한다. 둘째, 분석하는 문제와 관련된 데이터 프레임을 attach()하여 검색 경로 위치 두 번째에 추가한다. 검색경로의 첫 번째 위치에 작업공간이 있어서 분석 운영을 위한 수치와 임시적인 변수들이 놓인다. 셋째, 분석하는 문제를 떠나기 전에 다음에 사용하고자 하는 변수는 $를 이용하여 데이터 프레임에 저장한다. 그리고 detach() 한다. 넷째, 작업공간의 모든 필요 없는 변수를 삭제한다. 그러나 저자의 경우 attach()와 detach()를 잘 이용하지 않는다. 왜냐하면 이러한 방식은 프로그램이 복잡하거나 동시에 다루어야 할 데이터 프레임이 여러 개인 경우 변수 이름의 충돌이 일어나기 쉽다. 그래서 자신이 원하는 곳의 변수가 아니라 다른 위치의 동일한 이름의 변수를 참조하거나 변경하는 오류가 발생하기 쉽다. 또한 RStudio 같은 IDE를 사용하면 편집기 상에서 데이터 프레임의 이름 등을 자동 완성시킬 수 있으므로 긴 이름을 입력하는 것이 그리 수고스럽지 않기 때문이다. 이 두 가지 방법 중 어떠한 스타일을 택할 것인지는 개인의 선호에 달려 있다. 이 책에서는 특별한 경우가 아니면 attach() 등을 사용하지 않을 것이다. 참고로 이름이 비슷한 함수로 car 패키지의 subsets()라는 함수가 있다. 이 함수는 변수의 부분집합으로 회귀분석한 후, 그 결과를 그래프로 그리는 함수이다.↩︎ Excel 파일 형식으로 바로 데이터를 읽어들이기 위해서는 readxl 패키지의 read_excel() 함수를 이용하면 된다. 관심있는 독자는 웹 검색을 해 보면 관련 자료를 쉽게 찾을 수 있을 것이다.↩︎ "],["ch-dataTransformation.html", "Chapter 7 dplyr을 이용한 데이터 변환 7.1 정돈 데이터 (tidy data) 7.2 tidyverse 패키지 7.3 dplyr 패키지와 정돈 데이터의 변환 7.4 filter()로 행 선택하기 7.5 slice()로 행 선택하기 7.6 arrange()로 행 정렬하기 7.7 select()를 이용하여 변수 이름으로 열 선택하기 7.8 mutate()로 새로운 변수 만들기 7.9 summarize()로 변수 요약하기 7.10 group_by()로 그룹별로 요약하기 7.11 %&gt;% 파이프 연산자", " Chapter 7 dplyr을 이용한 데이터 변환 데이터를 분석하려면 데이터를 분석에 적절한 형식으로 변환하는 전처리가 필요하다. 또한 기본적인 분석을 위해서도 데이터를 요약하는 작업이 필요하다. 이 장에서는 정돈 형식의 데이터 프레임을 변환하는 방법을 배운다. 7.1 정돈 데이터 (tidy data) 7.1.1 정돈 데이터 형식의 조건 정돈 데이터란 그림 7.1처럼 다음의 조건을 만족하는 데이터 행렬(R에서는 데이터 프레임)의 형식을 의미한다. 데이터 행렬의 각 행과 관측(대상)(observations)은 일대일의 관계이다. 데이터 행렬의 각 열과 변수(variables)는 일대일의 관계이다. 측정값(values)은 각 셀과 일대일의 관계이다. Figure 7.1: 정돈 데이터 7.1.2 비정돈 데이터 형식 현실에서 만나는 많은 데이터가 정돈 데이터 형식이지만, 그렇지 않은 데이터도 자주 볼 수 있다. 그림 7.2의 왼쪽 데이터는 어떤 가상의 감염병에 대해 세 나라의 발생 사례를 월별로 정리한 데이터이다. 이 데이터는 감염 사례라는 변수와 관련된 데이터가 3개의 열에 흩어져 있으므로 비정돈 형식이다. 월별, 년도별 매출처럼 시계열 데이터는 종종 이런 형식으로 데이터가 표현된다. 이러한 방식의 표현은 데이터를 매우 압축적인 방식으로 표현할 수 있고 같은 시간대의 데이터를 비교하기 쉬운 장점이 있다. 그림 7.2의 오른쪽 데이터는 왼쪽 데이터를 정돈 형식으로 변환한 결과이다. 이러한 변환을 하는 방법에 대해서는 9 장에서 다룰 것이다. Figure 7.2: 비정돈 데이터 7.1.3 정돈 데이터를 사용하는 이유 그림 7.2를 보면 정돈 형식 데이터가 오히려 비효율적인 방식으로 보이며, 데이터를 한 눈에 비교하기도 어려워 보인다. 그럼에도 정돈 형식의 데이터를 사용하는 이유는 표준화된 데이터 변환 작업을 하기 위해서이다. 한 행이 하나의 관측 대상을, 한 열이 하나의 변수를, 한 셀이 한 값을 나타낸다는 가정이 성립하면, 데이터 변환이나 데이터를 이용한 그래픽 작업을 데이터의 내용에 무관하게 항상 일정한 형식으로 수행할 수 있다. 7.2 tidyverse 패키지 tidyverse 패키지는 정돈 데이터 패러다임을 따른 R 패키지들을 한번에 설치하고 적재할 수 있도록 돕는 패키지이다. 7.2.1 tidyverse 패키지 설치 tidyverse 패키지를 설치하려면 다음 명령을 실행하면 된다. 패키지의 이름은 문자열이므로 따옴표 안에 기술해야 한다. install.packages(&quot;tidyverse&quot;) 또는 RStudio의 Packages 탭에서 [Install]을 클릭한 후 tidyverse라고 입력을 하면 된다. 패키지 설치는 한 번만 수행하면 된다. 7.2.2 tidyverse 패키지 적재 tidyverse 패키지가 설치되었으면 패키지를 사용할 때마다 네임스페이스를 적재하고 검색 리스트에 패키지를 포함하는 작업이 필요하다.6 다음은 tidyverse 패키지를 적재하는 명령어이다. 이번에는 패키지 이름에 따옴표가 없음에 주의한다. library(tidyverse) ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ✔ dplyr 1.1.4 ✔ readr 2.1.5 ✔ forcats 1.0.0 ✔ stringr 1.5.1 ✔ ggplot2 3.5.1 ✔ tibble 3.2.1 ✔ lubridate 1.9.3 ✔ tidyr 1.3.1 ✔ purrr 1.0.2 ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ✖ dplyr::filter() masks stats::filter() ✖ dplyr::lag() masks stats::lag() ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors 앞의 명령을 실행하면 정돈 데이터 패러다임을 따르는 여러 개의 패키지가 동시에 적재된다. 그리고 R 기본 패키지와 정돈 데이터 패키지 중에서 이름이 충돌이 나는 것에 대해 보고를 한다. 만약 R 기본 패키지에서 이 함수를 사용하는 경우에는 패키지이름::함수() 형식으로만 사용할 수 있다. 자세한 내용은 R 관련 책을 참조하기 바란다. 7.3 dplyr 패키지와 정돈 데이터의 변환 7.3.1 dplyr 패키지 정돈 데이터의 변환에는 tidyverse 패키지가 포함하고 있는 dplyr 패키지가 이용된다. 앞에서 tidyverse를 적재하였으면 이미 dplyr이 적재되어 있으므로 다시 적재할 필요가 없다. 7.3.2 정돈 데이터 변환의 종류 정돈 데이터의 변환은 크게 5가지 변환 작업이 있다. 행 선택: filter(): 데이터에서 특정 열의 값이 조건에 맞는 행만 선택한다. slice(): 데이터에서 특정 위치의 행만 선택한다. 행 정렬 arrange(): 특정 열의 값을 기준으로 데이터의 행을 정렬한다. 열 선택: select(): 열의 이름, 위치, 데이터 형식 등으로 일부 열만 데이터에서 선택한다. 열 추가: mutate(): 기존 열을 사용하여 새로운 열을 데이터에 추가한다. 데이터 요약: summarize(): 데이터 전체 또는 특정 열을 하나의 통계량으로 요약한다. group_by(): 데이터 요약에만 사용되는 것은 아니나, 그룹별로 데이터를 통계 요약할 때 자주 사용된다. 그리고 위의 작업은 group_by() 함수와 같이 사용되어 전체 데이터에서 작업이 수행되는 것이 아니라, 데이터 행을 특정 열의 값을 기준으로 그룹으로 나누어서 그룹별로 데이터 변환 작업이 수행되도록 조정할 수 있다. 다음 그림은 정돈 데이터 변환 함수에 의한 변환 결과를 예시하고 있다. 이 함수들은 모두 다음과 같은 인터페이스를 가지고 있다. 첫 번재 인수로 변환할 데이터프레임을 받는다. 나머지 인수는 데이터프레임에 어떤 변환을 할지를 지정한다. 데이터프레임의 열을 지정할 때 열 이름을 따옴표 없이 변수처럼 사용한다. 함수의 결과는 변환이 수행된 새로운 데이터프레임이다. 일반적으로 데이터의 변환 작업은 위의 6가지 작업이 여러 차례 순서대로 결합하여 진행된다. 7.3.3 dplyr 패키지 vs. R의 기본 기능 앞으로 볼 dplyr 패키지의 함수들이 수행하는 작업은 R에서 제공하는 기본 함수로도 수행될 수 있다. 특히 filter(), arrange(), select(), mutate() 함수의 작업은 R 데이터프레임의 필터링 기능을 사용하면 대체할 수 있으며, summarize()와 group_by() 함수의 작업은 tapply(), aggregate() 등을 사용하면 대체할 수 있다. 그럼에도 불구하고 복잡한 데이터 변환을 수행할 때 R의 기본 기능보다는 dplyr 패키지의 함수들이 선호되는 이유는 다음과 같다. dplyr 함수에서는 데이터프레임의 열을 변수처럼 사용할 수 있어서 R의 기본 기능보다 더 짧은 명령문으로 데이터의 조작과 변환이 가능하다. R의 기본 함수들은 한 함수가 여러 가지 변환을 수행하고 서로의 기능이 중복되는데 반해, dplyr 패키지의 함수는 오직 하나의 기능만을 수행하고 서로 기능이 중복되지 않아서 명령문을 이해하기 쉽다. R의 기본 함수들이 입력과 출력 형식이 제각각인데 반해, dplyr 패키지의 함수는 공통된 입력과 출력 형식을 사용하므로 여러 단계를 거치는 복잡한 데이터 변환 작업도 dplyr 함수를 파이프 연산자로 연결하여 쉽게 구현할 수 있다. 7.3.4 mpg 데이터 이 장에서는 ggplot2() 패키지에서 제공하는 mpg 데이터를 이용하여 정돈 데이터를 변환하는 함수를 설명한다. 다음 명령을 이용하여 mpg 데이터를 출력해 보자. 화면의 크기에 따라 출력되는 내용이 책과는 조금 다를 수 있다. mpg # A tibble: 234 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… 3 audi a4 2 2008 4 manu… f 20 31 p comp… 4 audi a4 2 2008 4 auto… f 21 30 p comp… 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… 8 audi a4 quattro 1.8 1999 4 manu… 4 18 26 p comp… 9 audi a4 quattro 1.8 1999 4 auto… 4 16 25 p comp… 10 audi a4 quattro 2 2008 4 manu… 4 20 28 p comp… # ℹ 224 more rows mpg는 1999년과 2008년에 미국 EPA에서 조사하여 발표한 자동차 주요 모델별 연비 데이터이다. 데이터는 234 개의 행이 있으며, 각 행은 다음과 같은 변수로 구성되어 있다. manufacturer: 자동차 제조사 model: 자동차 모델명 displ: 자동차 배기량 year: 제조년도 cyl: 엔진 실린더 수 trans: 자동차 트랜스미션 종류 drv: 자동차 구동 방식. f=전륜구동, r=후륜구동, 4=사륜구동 cty: 도심 연비 (마일/갤론) hwy: 고속도로 연비 (마일/갤론) fl: 연료 종류 class: 자동차 분류 7.4 filter()로 행 선택하기 7.4.1 선택 조건이 하나인 경우 선택 조건이 하나인 경우 다음 형식으로 filter()를 사용한다. filter(데이터프레임, 조건) ’데이터프레임’에는 filter()를 적용할 데이터 프레임을 ’조건’에는 행 선택 조건을 기술한다. ’조건’은 논리값 벡터이어야 한다. 많은 경우 ’조건’은 다음처럼 변수와 어떤 값을 비교연산자로 비교한다. 다음 예에서 보는 것처럼 dplyr 패키지의 함수들은 첫번째 인수로 데이터프레임을 지정한 후, 나머지 부분에서 그 데이터프레임의 열을 변수처럼 사용할 수 있다. filter(mpg, manufacturer==&quot;hyundai&quot;) # A tibble: 14 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 1999 4 auto(l4) f 18 26 r mids… 2 hyundai sonata 2.4 1999 4 manual(… f 18 27 r mids… 3 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 4 hyundai sonata 2.4 2008 4 manual(… f 21 31 r mids… 5 hyundai sonata 2.5 1999 6 auto(l4) f 18 26 r mids… 6 hyundai sonata 2.5 1999 6 manual(… f 18 26 r mids… 7 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… 8 hyundai tiburon 2 1999 4 auto(l4) f 19 26 r subc… 9 hyundai tiburon 2 1999 4 manual(… f 19 29 r subc… 10 hyundai tiburon 2 2008 4 manual(… f 20 28 r subc… 11 hyundai tiburon 2 2008 4 auto(l4) f 20 27 r subc… 12 hyundai tiburon 2.7 2008 6 auto(l4) f 17 24 r subc… 13 hyundai tiburon 2.7 2008 6 manual(… f 16 24 r subc… 14 hyundai tiburon 2.7 2008 6 manual(… f 17 24 r subc… filter(mpg, cty &gt; 28) # A tibble: 3 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 volkswagen jetta 1.9 1999 4 manua… f 33 44 d comp… 2 volkswagen new beetle 1.9 1999 4 manua… f 35 44 d subc… 3 volkswagen new beetle 1.9 1999 4 auto(… f 29 41 d subc… filter(mpg, cty &gt;= 28) # A tibble: 5 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 honda civic 1.6 1999 4 manua… f 28 33 r subc… 2 toyota corolla 1.8 2008 4 manua… f 28 37 r comp… 3 volkswagen jetta 1.9 1999 4 manua… f 33 44 d comp… 4 volkswagen new beetle 1.9 1999 4 manua… f 35 44 d subc… 5 volkswagen new beetle 1.9 1999 4 auto(… f 29 41 d subc… 조건을 서술할 때 자주 틀리는 부분이 등호 기호로 =를 사용하는 것이다. R에서 두 값이 같은지를 비교할 때는 ==를 사용한다. 다음처럼 조건에 사용되는 변수에 대해 연산을 수행한 후에 그 결과를 비교할 수도 있다. filter(mpg, cty * 2 &gt; 60) # A tibble: 2 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 volkswagen jetta 1.9 1999 4 manua… f 33 44 d comp… 2 volkswagen new beetle 1.9 1999 4 manua… f 35 44 d subc… filter(mpg, sqrt(cty) &lt; 3.2) # A tibble: 5 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 dodge dakota pic… 4.7 2008 8 auto… 4 9 12 e pick… 2 dodge durango 4wd 4.7 2008 8 auto… 4 9 12 e suv 3 dodge ram 1500 p… 4.7 2008 8 auto… 4 9 12 e pick… 4 dodge ram 1500 p… 4.7 2008 8 manu… 4 9 12 e pick… 5 jeep grand cher… 4.7 2008 8 auto… 4 9 12 e suv 7.4.2 여러 조건을 만족하는 행 추출하기 두 개 이상의 조건을 모두 만족하는 행만 뽑아내려면 다음의 문법을 사용한다. filter(데이터프레임, 조건1, 조건2, ..., 조건n) 다음은 현대에서 생산한 차 중 도심 연비가 20 마일 이상인 차만 추출한 결과이다. filter(mpg, manufacturer==&quot;hyundai&quot;, cty &gt;= 20) # A tibble: 4 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 2 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… 3 hyundai tiburon 2 2008 4 manual(m… f 20 28 r subc… 4 hyundai tiburon 2 2008 4 auto(l4) f 20 27 r subc… 앞의 조건에서 배기량이 2.4 이상인 차만 추출해 보자. filter(mpg, manufacturer==&quot;hyundai&quot;, cty &gt;= 20, displ &gt;= 2.4) # A tibble: 2 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 2 hyundai sonata 2.4 2008 4 manual(m5) f 21 31 r mids… 7.4.3 논리 연산자로 복합 조건 만들기 지금까지는 하나의 조건이나 여러 조건을 동시에 만족하는 행을 추출하는 방법을 보았다. 어떤 경우에는 여러 조건 중 하나라도 만족하면 그 행을 추출해야 할 경우가 있다. 이러한 경우에는 2 장에서 배운 논리 연산자를 이용하여 복합 조건을 만들어야 한다. 다음은 OR 연자자인 |를 이용하여 두 조건 중 하나만 만족하여도 행이 추출되도록 하였다. filter(mpg, model==&quot;sonata&quot; | cty &gt;= 28) # A tibble: 12 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 honda civic 1.6 1999 4 manu… f 28 33 r subc… 2 hyundai sonata 2.4 1999 4 auto… f 18 26 r mids… 3 hyundai sonata 2.4 1999 4 manu… f 18 27 r mids… 4 hyundai sonata 2.4 2008 4 auto… f 21 30 r mids… 5 hyundai sonata 2.4 2008 4 manu… f 21 31 r mids… 6 hyundai sonata 2.5 1999 6 auto… f 18 26 r mids… 7 hyundai sonata 2.5 1999 6 manu… f 18 26 r mids… 8 hyundai sonata 3.3 2008 6 auto… f 19 28 r mids… 9 toyota corolla 1.8 2008 4 manu… f 28 37 r comp… 10 volkswagen jetta 1.9 1999 4 manu… f 33 44 d comp… 11 volkswagen new beetle 1.9 1999 4 manu… f 35 44 d subc… 12 volkswagen new beetle 1.9 1999 4 auto… f 29 41 d subc… 만약 위의 결과에서 2008년도 데이터만 추출하고 싶다면 어떻게 해야 할까? 다음처럼 두 조건식을 사용하여 첫 번째 조건과 두 번째 조건을 모두 만족하는 결과만 추출할 수도 있고, 하나의 조건식에 AND 연산자인 &amp;를 사용하여 복합 조건식을 사용하여 추출할 수도 있다. filter(mpg, model==&quot;sonata&quot; | cty &gt;= 28, year==2008) # A tibble: 4 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 2 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… 3 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… 4 toyota corolla 1.8 2008 4 manual(m… f 28 37 r comp… filter(mpg, (model==&quot;sonata&quot; | cty &gt;= 28) &amp; year==2008) # A tibble: 4 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 2 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… 3 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… 4 toyota corolla 1.8 2008 4 manual(m… f 28 37 r comp… 단, 복합 조건식에서 AND 연산이 OR 연산보다 우선순위가 있으므로 괄호를 사용하여 연산의 순서가 제대로 되도록 하여야 한다. 괄호가 없으면 AND가 수행된 후 OR가 수행되어 모든 소타나 자동차의 결과가 추출되었음을 볼 수 있다. filter(mpg, model==&quot;sonata&quot; | cty &gt;= 28 &amp; year==2008) # A tibble: 8 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 1999 4 auto(l4) f 18 26 r mids… 2 hyundai sonata 2.4 1999 4 manual(m… f 18 27 r mids… 3 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 4 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… 5 hyundai sonata 2.5 1999 6 auto(l4) f 18 26 r mids… 6 hyundai sonata 2.5 1999 6 manual(m… f 18 26 r mids… 7 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… 8 toyota corolla 1.8 2008 4 manual(m… f 28 37 r comp… 7.4.4 %in% 연산자 만약 조사 년도가 2008년이고, 고속도로 연비가 30 이상이면서, 자동차 모델이 sonata 또는 corolla 또는 jetta인 행을 찾고자 한다면 어떻게 해야 할까? 앞에서 배운 복잡 조건문을 사용하여 다음처럼 수행할 수 있을 것이다. filter(mpg, year==2008, hwy &gt;= 28, model==&quot;sonata&quot; | model==&quot;corolla&quot; | model==&quot;jetta&quot;) # A tibble: 9 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 2 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… 3 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… 4 toyota corolla 1.8 2008 4 manual(m… f 28 37 r comp… 5 toyota corolla 1.8 2008 4 auto(l4) f 26 35 r comp… 6 volkswagen jetta 2 2008 4 auto(s6) f 22 29 p comp… 7 volkswagen jetta 2 2008 4 manual(m… f 21 29 p comp… 8 volkswagen jetta 2.5 2008 5 auto(s6) f 21 29 r comp… 9 volkswagen jetta 2.5 2008 5 manual(m… f 21 29 r comp… 위의 명령은 %in% 연산자를 사용하면 좀 더 간단해 질 수 있다. %in% 연산자는 어떤 값이 벡터의 요소 중에 하나인지를 판별해 준다. a &lt;- 1:3 0 %in% a [1] FALSE 1 %in% a [1] TRUE 3 %in% a [1] TRUE 4 %in% a [1] FALSE 그러므로 앞에서 수행한 명령은 다음처럼 수행할 수도 있다. filter(mpg, year==2008, hwy &gt;= 28, model %in% c(&quot;sonata&quot;,&quot;corolla&quot;,&quot;jetta&quot;)) # A tibble: 9 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 2 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… 3 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… 4 toyota corolla 1.8 2008 4 manual(m… f 28 37 r comp… 5 toyota corolla 1.8 2008 4 auto(l4) f 26 35 r comp… 6 volkswagen jetta 2 2008 4 auto(s6) f 22 29 p comp… 7 volkswagen jetta 2 2008 4 manual(m… f 21 29 p comp… 8 volkswagen jetta 2.5 2008 5 auto(s6) f 21 29 r comp… 9 volkswagen jetta 2.5 2008 5 manual(m… f 21 29 r comp… 7.5 slice()로 행 선택하기 slice() 함수는 다음 문법을 사용하여 행을 선택한다. slice(데이터프레임, 선택위치1, 선택위치2, ...) 선택위치에는 양의 정수 또는 음의 정수 벡터가 지정된다. 양의 정수 벡터가 지정되면 해당 위치의 행이 선택되고, 음의 정수 벡터가 지정되면 해당 위치의 행을 제외한 나머지 행이 선택된다. 그런데 주의할 점은 선택위치에 지정되는 벡터는 모두 양의 정수 벡터이거나 모두 음의 정수 벡터이어야 한다는 것이다. 다음은 2008년도 현대의 자동차 모델만 filter()론 선택하여 a라는 변수에 저장한 후, 이 데이터를 가지고 slice()를 사용하여 여러 위치의 행을 선택해본 예이다. a &lt;- filter(mpg, manufacturer == &quot;hyundai&quot;, year == 2008) a # A tibble: 8 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 2 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… 3 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… 4 hyundai tiburon 2 2008 4 manual(m… f 20 28 r subc… 5 hyundai tiburon 2 2008 4 auto(l4) f 20 27 r subc… 6 hyundai tiburon 2.7 2008 6 auto(l4) f 17 24 r subc… 7 hyundai tiburon 2.7 2008 6 manual(m… f 16 24 r subc… 8 hyundai tiburon 2.7 2008 6 manual(m… f 17 24 r subc… slice(a, 1) # 1 행 선택 # A tibble: 1 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsize slice(a, 1:3) # 1-3 행 선택 # A tibble: 3 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 2 hyundai sonata 2.4 2008 4 manual(m5) f 21 31 r mids… 3 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… slice(a, 1:3, 6:7) # 1-3과 6-7 행 선택 # A tibble: 5 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 2 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… 3 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… 4 hyundai tiburon 2.7 2008 6 auto(l4) f 17 24 r subc… 5 hyundai tiburon 2.7 2008 6 manual(m… f 16 24 r subc… slice(a, -1) # 1 행 제외 # A tibble: 7 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… 2 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… 3 hyundai tiburon 2 2008 4 manual(m… f 20 28 r subc… 4 hyundai tiburon 2 2008 4 auto(l4) f 20 27 r subc… 5 hyundai tiburon 2.7 2008 6 auto(l4) f 17 24 r subc… 6 hyundai tiburon 2.7 2008 6 manual(m… f 16 24 r subc… 7 hyundai tiburon 2.7 2008 6 manual(m… f 17 24 r subc… slice(a, -1, -(4:6)) # 1 행과 4-6 행 제외 # A tibble: 4 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… 2 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… 3 hyundai tiburon 2.7 2008 6 manual(m… f 16 24 r subc… 4 hyundai tiburon 2.7 2008 6 manual(m… f 17 24 r subc… 7.5.1 slice_sample()로 표본 추출하기 데이터를 분석할 때 데이터의 일부 행만 임의로 추출해야하는 경우가 있다. slice_sample()을 사용하면 데이터에서 원하는 수 또는 비율만큼 행을 임의 추출할 수 있다. 원하는 수만큼 임의 추출하려면 n 인수를 원하는 비율만큼 행을 추출하려면 prop 인수를 사용한다. slice_sample(a, n=3) # 데이터에서 3 개의 행을 추출 # A tibble: 3 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai tiburon 2 2008 4 manual(m… f 20 28 r subc… 2 hyundai tiburon 2.7 2008 6 manual(m… f 16 24 r subc… 3 hyundai tiburon 2.7 2008 6 auto(l4) f 17 24 r subc… slice_sample(a, prop=0.8) # 데이터에서 80% 행을 추출 # A tibble: 6 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai tiburon 2 2008 4 manual(m… f 20 28 r subc… 2 hyundai tiburon 2.7 2008 6 manual(m… f 16 24 r subc… 3 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… 4 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 5 hyundai tiburon 2 2008 4 auto(l4) f 20 27 r subc… 6 hyundai tiburon 2.7 2008 6 auto(l4) f 17 24 r subc… 7.5.2 slice_head()와 slice_tail() 데이터의 맨 앞의 행들이나, 맨 뒤의 행을 추출할 때 사용한다. n 인수를 지정하여 원하는 수만큼의 행을 추출할 수도 있고, prop 인수를 지정하여 원하는 비율만큼의 행을 추출할 수도 있다. slice_head(mpg, n=4) # 데이터의 처음 4 행 추출 # A tibble: 4 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… slice_tail(mpg, prop=0.05) # 데이터의 마지막 5% 추출 # A tibble: 11 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 volkswagen new beetle 2 1999 4 manu… f 21 29 r subc… 2 volkswagen new beetle 2 1999 4 auto… f 19 26 r subc… 3 volkswagen new beetle 2.5 2008 5 manu… f 20 28 r subc… 4 volkswagen new beetle 2.5 2008 5 auto… f 20 29 r subc… 5 volkswagen passat 1.8 1999 4 manu… f 21 29 p mids… 6 volkswagen passat 1.8 1999 4 auto… f 18 29 p mids… 7 volkswagen passat 2 2008 4 auto… f 19 28 p mids… 8 volkswagen passat 2 2008 4 manu… f 21 29 p mids… 9 volkswagen passat 2.8 1999 6 auto… f 16 26 p mids… 10 volkswagen passat 2.8 1999 6 manu… f 18 26 p mids… 11 volkswagen passat 3.6 2008 6 auto… f 17 26 p mids… 7.5.3 slice_min()과 slice_max() 특정 열을 기준으로 가장 값이 작은 행 또는 가장 값이 큰 행을 추출하는 함수이다. 사실 뒤에서 설명할 arrange() 함수를 적용한 후 slice() 함수를 적용하면 같은 효과를 구현할 수 있다. slice_min(a, cty, n=2) # cty 열의 값이 가장 작은 2 행 추출 # A tibble: 3 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai tiburon 2.7 2008 6 manual(m… f 16 24 r subc… 2 hyundai tiburon 2.7 2008 6 auto(l4) f 17 24 r subc… 3 hyundai tiburon 2.7 2008 6 manual(m… f 17 24 r subc… slice_min(a, hwy, n=2) # hwy 열의 값이 가장 큰 2 행 추출 # A tibble: 3 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai tiburon 2.7 2008 6 auto(l4) f 17 24 r subc… 2 hyundai tiburon 2.7 2008 6 manual(m… f 16 24 r subc… 3 hyundai tiburon 2.7 2008 6 manual(m… f 17 24 r subc… 결과에서 보듯이 동률이 있는 경우 동률인 행도 모두 추출되므로 n으로 정한 행의 수보다 많은 행이 추출될 수 있다. 동률인 행인 추출되지 않도록 하려면 with_ties=FALSE 인수를 설정하면 된다. slice_min(a, cty, n=2, with_ties = F) # 동률 행을 추출하지 않는다. # A tibble: 2 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai tiburon 2.7 2008 6 manual(m… f 16 24 r subc… 2 hyundai tiburon 2.7 2008 6 auto(l4) f 17 24 r subc… 7.6 arrange()로 행 정렬하기 arrange()는 다음 문법을 사용하여 행을 정렬한다. arrange(데이터프레임, 첫번째 정렬 기준 변수, 두번째 정렬 기준 변수, ....) filter()와 마찬가지로 첫 번재 인수로 정렬할 데이터 프레임을 전달 받는다. 그리고 두번재 인수부터 정렬의 기준이 되는 변수를 차례로 기술한다. 첫 번째 기준 변수의 값이 같으면, 두 번째 기준 변수를, 두 번째 기준 변수의 값까지 같으면 그 다음 변수를 기준으로 차례로 순서를 결정하여 정렬을 수행한다. 다음은 2008년도 현대의 자동차 모델만 filter()론 선택하여 a라는 변수에 저장한 후, 이 데이터에 대하여 여러 조건으로 정렬을 수행해본 예이다. a &lt;- filter(mpg, manufacturer == &quot;hyundai&quot;, year == 2008) a # A tibble: 8 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 2 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… 3 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… 4 hyundai tiburon 2 2008 4 manual(m… f 20 28 r subc… 5 hyundai tiburon 2 2008 4 auto(l4) f 20 27 r subc… 6 hyundai tiburon 2.7 2008 6 auto(l4) f 17 24 r subc… 7 hyundai tiburon 2.7 2008 6 manual(m… f 16 24 r subc… 8 hyundai tiburon 2.7 2008 6 manual(m… f 17 24 r subc… arrange(a, cyl) # A tibble: 8 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 2 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… 3 hyundai tiburon 2 2008 4 manual(m… f 20 28 r subc… 4 hyundai tiburon 2 2008 4 auto(l4) f 20 27 r subc… 5 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… 6 hyundai tiburon 2.7 2008 6 auto(l4) f 17 24 r subc… 7 hyundai tiburon 2.7 2008 6 manual(m… f 16 24 r subc… 8 hyundai tiburon 2.7 2008 6 manual(m… f 17 24 r subc… arrange(a, cyl, cty) # A tibble: 8 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai tiburon 2 2008 4 manual(m… f 20 28 r subc… 2 hyundai tiburon 2 2008 4 auto(l4) f 20 27 r subc… 3 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 4 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… 5 hyundai tiburon 2.7 2008 6 manual(m… f 16 24 r subc… 6 hyundai tiburon 2.7 2008 6 auto(l4) f 17 24 r subc… 7 hyundai tiburon 2.7 2008 6 manual(m… f 17 24 r subc… 8 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… arrange(a, model, trans) # A tibble: 8 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 2 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… 3 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… 4 hyundai tiburon 2 2008 4 auto(l4) f 20 27 r subc… 5 hyundai tiburon 2.7 2008 6 auto(l4) f 17 24 r subc… 6 hyundai tiburon 2 2008 4 manual(m… f 20 28 r subc… 7 hyundai tiburon 2.7 2008 6 manual(m… f 17 24 r subc… 8 hyundai tiburon 2.7 2008 6 manual(m… f 16 24 r subc… 7.6.1 desc()를 이용하여 내림차순으로 정렬하기 앞의 예에서 arrange()는 수치 변수는 올림차순으로 문자 변수는 알파벳 순으로 정렬하는 것을 볼 수 있다. 만약 위의 예에서 내림차순으로, 또는 알파벳 역순으로 정렬을 하고 싶으면 어떻게 하여야 할까? dplyr 패키지는 desc()를 이용하면 된다. arrange(a, desc(cyl)) # A tibble: 8 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… 2 hyundai tiburon 2.7 2008 6 auto(l4) f 17 24 r subc… 3 hyundai tiburon 2.7 2008 6 manual(m… f 16 24 r subc… 4 hyundai tiburon 2.7 2008 6 manual(m… f 17 24 r subc… 5 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 6 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… 7 hyundai tiburon 2 2008 4 manual(m… f 20 28 r subc… 8 hyundai tiburon 2 2008 4 auto(l4) f 20 27 r subc… arrange(a, desc(cyl), cty) # A tibble: 8 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai tiburon 2.7 2008 6 manual(m… f 16 24 r subc… 2 hyundai tiburon 2.7 2008 6 auto(l4) f 17 24 r subc… 3 hyundai tiburon 2.7 2008 6 manual(m… f 17 24 r subc… 4 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… 5 hyundai tiburon 2 2008 4 manual(m… f 20 28 r subc… 6 hyundai tiburon 2 2008 4 auto(l4) f 20 27 r subc… 7 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 8 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… arrange(a, model, desc(trans)) # A tibble: 8 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r mids… 2 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r mids… 3 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r mids… 4 hyundai tiburon 2.7 2008 6 manual(m… f 16 24 r subc… 5 hyundai tiburon 2 2008 4 manual(m… f 20 28 r subc… 6 hyundai tiburon 2.7 2008 6 manual(m… f 17 24 r subc… 7 hyundai tiburon 2 2008 4 auto(l4) f 20 27 r subc… 8 hyundai tiburon 2.7 2008 6 auto(l4) f 17 24 r subc… desc()가 적용된 변수만 내림차순을 기준으로 정렬을 하는 것을 볼 수 있다. 7.7 select()를 이용하여 변수 이름으로 열 선택하기 7.7.1 변수 이름을 나열하여 선택하기 select() 함수는 다음처럼 변수 이름을 일일이 나열하여 원하는 열을 선택할 수 있다. R의 기본 문법을 알고 있는 사람들은 데이터 프레임의 인덱싱에서처럼 문자열로 이름을 나열하는 것이 아니라 변수를 사용하듯 따옴표 없이 이름을 나열하는 것에 주의한다. select(데이터프레임, 변수이름1, 변수이름 2, ....) select(a, model, year, cty, hwy) # A tibble: 8 × 4 model year cty hwy &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 sonata 2008 21 30 2 sonata 2008 21 31 3 sonata 2008 19 28 4 tiburon 2008 20 28 5 tiburon 2008 20 27 6 tiburon 2008 17 24 7 tiburon 2008 16 24 8 tiburon 2008 17 24 7.7.2 변수 이름으로 변수 범위를 선택하기 select() 함수는 다음처럼 변수 이름으로 선택할 변수의 범위를 지정할 수 있다. select(데이터프레임, 범위시작_변수이름:범위종료_변수이름, ...) select(a, model:trans) # A tibble: 8 × 5 model displ year cyl trans &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; 1 sonata 2.4 2008 4 auto(l4) 2 sonata 2.4 2008 4 manual(m5) 3 sonata 3.3 2008 6 auto(l5) 4 tiburon 2 2008 4 manual(m5) 5 tiburon 2 2008 4 auto(l4) 6 tiburon 2.7 2008 6 auto(l4) 7 tiburon 2.7 2008 6 manual(m6) 8 tiburon 2.7 2008 6 manual(m5) select(a, model:trans, cty:hwy) # A tibble: 8 × 7 model displ year cyl trans cty hwy &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; 1 sonata 2.4 2008 4 auto(l4) 21 30 2 sonata 2.4 2008 4 manual(m5) 21 31 3 sonata 3.3 2008 6 auto(l5) 19 28 4 tiburon 2 2008 4 manual(m5) 20 28 5 tiburon 2 2008 4 auto(l4) 20 27 6 tiburon 2.7 2008 6 auto(l4) 17 24 7 tiburon 2.7 2008 6 manual(m6) 16 24 8 tiburon 2.7 2008 6 manual(m5) 17 24 반대로 다음처럼 변수 이름으로 선택하지 않을 변수의 범위를 지정할 수 있다. select(데이터프레임, -(범위시작_변수이름:범위종료_변수이름), ...) select(a, -(model:trans)) # A tibble: 8 × 6 manufacturer drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai f 21 30 r midsize 2 hyundai f 21 31 r midsize 3 hyundai f 19 28 r midsize 4 hyundai f 20 28 r subcompact 5 hyundai f 20 27 r subcompact 6 hyundai f 17 24 r subcompact 7 hyundai f 16 24 r subcompact 8 hyundai f 17 24 r subcompact select(a, -(model:trans), -manufacturer) # A tibble: 8 × 5 drv cty hwy fl class &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 f 21 30 r midsize 2 f 21 31 r midsize 3 f 19 28 r midsize 4 f 20 28 r subcompact 5 f 20 27 r subcompact 6 f 17 24 r subcompact 7 f 16 24 r subcompact 8 f 17 24 r subcompact 7.7.3 변수 위치로 매칭하여 선택하기 select() 함수는 R의 기본 인덱싱(필터링)처럼 선택할 열의 위치를 자연수 인덱스 벡터로, 선택하지 않을 열은 음의 정수 인덱스 벡터로 지정할 수도 있다. select(a, 1:3) # 1 번부터 3번 열 선택 # A tibble: 8 × 3 manufacturer model displ &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 hyundai sonata 2.4 2 hyundai sonata 2.4 3 hyundai sonata 3.3 4 hyundai tiburon 2 5 hyundai tiburon 2 6 hyundai tiburon 2.7 7 hyundai tiburon 2.7 8 hyundai tiburon 2.7 select(a, 1:3, 5) # 1 번부터 3번 열과 5 번 열 선택 # A tibble: 8 × 4 manufacturer model displ cyl &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; 1 hyundai sonata 2.4 4 2 hyundai sonata 2.4 4 3 hyundai sonata 3.3 6 4 hyundai tiburon 2 4 5 hyundai tiburon 2 4 6 hyundai tiburon 2.7 6 7 hyundai tiburon 2.7 6 8 hyundai tiburon 2.7 6 select(a, -(4:10)) # 4 번부터 10 번 열 제외하고 선택 # A tibble: 8 × 4 manufacturer model displ class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; 1 hyundai sonata 2.4 midsize 2 hyundai sonata 2.4 midsize 3 hyundai sonata 3.3 midsize 4 hyundai tiburon 2 subcompact 5 hyundai tiburon 2 subcompact 6 hyundai tiburon 2.7 subcompact 7 hyundai tiburon 2.7 subcompact 8 hyundai tiburon 2.7 subcompact 7.7.4 변수 이름을 매칭하여 선택하기 dplyr 패키지는 다양한 형태로 변수를 선택할 수 있도록 다음의 변수 이름 매칭 함수를 제공한다. 이러한 함수는 변수의 수가 많을 때 매우 유용하다. starts_with(\"abs\"): abc로 이름이 시작하는 모든 변수 ends_with(\"abs\"): abc로 이름이 끝나는 모든 변수 contains(\"abs\"): abc를 이름에 포함하고 있는 모든 변수 matches(\"(.)\\\\1\"): 정규 표현식을 만족하는 이름을 가진 모든 변수 num_range(\"x\", 1:3): “x1”, “x2”, “x3”이라는 이름의 변수 select(a, starts_with(&quot;c&quot;)) # A tibble: 8 × 3 cyl cty class &lt;int&gt; &lt;int&gt; &lt;chr&gt; 1 4 21 midsize 2 4 21 midsize 3 6 19 midsize 4 4 20 subcompact 5 4 20 subcompact 6 6 17 subcompact 7 6 16 subcompact 8 6 17 subcompact 7.7.5 변수의 형식이나 조건으로 매칭하여 선택하기* select() 함수에 where() 함수를 사용하면 해당 조건에 맞는 열만 매칭하여 선택할 수 있다. where() 함수는 유일한 인수로 함수를 입력받는데, 이 함수는 논리값을 반환하는 함수여야 하며, where() 함수는 각 열에 이 함수를 적용한다. select() 함수는 where()의 결과가 TRUE인 열만 선택한다. where() 함수가 주로 사용되는 곳은 데이터 형식에 따라 열을 선택할 때이다. is.로 시작하는 함수들은 어떤 객체가 특정 형식인지를 테스트 한다. 다음 예는 where()와 is.character() 함수를 사용하여 문자열인 열만 선택한 것이다. select(a, where(is.character)) # A tibble: 8 × 6 manufacturer model trans drv fl class &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata auto(l4) f r midsize 2 hyundai sonata manual(m5) f r midsize 3 hyundai sonata auto(l5) f r midsize 4 hyundai tiburon manual(m5) f r subcompact 5 hyundai tiburon auto(l4) f r subcompact 6 hyundai tiburon auto(l4) f r subcompact 7 hyundai tiburon manual(m6) f r subcompact 8 hyundai tiburon manual(m5) f r subcompact 다음 예는 무기명 함수를 이용하여 열이 수치 벡터이고, 열의 평균이 10 이상인 열만 출력한 것이다. select(a, where(function(x) is.numeric(x) &amp;&amp; mean(x) &gt;= 10)) # A tibble: 8 × 3 year cty hwy &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 2008 21 30 2 2008 21 31 3 2008 19 28 4 2008 20 28 5 2008 20 27 6 2008 17 24 7 2008 16 24 8 2008 17 24 또는 다음처럼 purr 형식의 수식으로 무기명 함수를 좀 더 간략하게 정의할 수도 있다. select(a, where(~ is.numeric(.x) &amp;&amp; mean(.x) &lt; 10)) # A tibble: 8 × 2 displ cyl &lt;dbl&gt; &lt;int&gt; 1 2.4 4 2 2.4 4 3 3.3 6 4 2 4 5 2 4 6 2.7 6 7 2.7 6 8 2.7 6 7.7.6 변수 이름 바꾸기 select() 함수에서 변수 이름을 지정할 때, (새로운 변수 이름)=(기존 변수 이름) 형식으로 지정하면 변수의 이름을 바꿀 수 있다. select(a, model, city=cty, highway=hwy) # A tibble: 8 × 3 model city highway &lt;chr&gt; &lt;int&gt; &lt;int&gt; 1 sonata 21 30 2 sonata 21 31 3 sonata 19 28 4 tiburon 20 28 5 tiburon 20 27 6 tiburon 17 24 7 tiburon 16 24 8 tiburon 17 24 만약 전체 데이터를 유지한 상태에서 변수 이름만 변경하려면, rename() 함수를 이용한다. 문법은 select()와 같다. rename(a, city=cty, highway=hwy) # A tibble: 8 × 11 manufacturer model displ year cyl trans drv city highway fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l… f 21 30 r mids… 2 hyundai sonata 2.4 2008 4 manual… f 21 31 r mids… 3 hyundai sonata 3.3 2008 6 auto(l… f 19 28 r mids… 4 hyundai tiburon 2 2008 4 manual… f 20 28 r subc… 5 hyundai tiburon 2 2008 4 auto(l… f 20 27 r subc… 6 hyundai tiburon 2.7 2008 6 auto(l… f 17 24 r subc… 7 hyundai tiburon 2.7 2008 6 manual… f 16 24 r subc… 8 hyundai tiburon 2.7 2008 6 manual… f 17 24 r subc… 7.7.7 변수 순서 바꾸기 select() 함수는 나열된 변수의 순서에 따라 새롭게 만들어진 데이터 프레임의 변수의 순서를 조정한다. select(a, cty, hwy) # A tibble: 8 × 2 cty hwy &lt;int&gt; &lt;int&gt; 1 21 30 2 21 31 3 19 28 4 20 28 5 20 27 6 17 24 7 16 24 8 17 24 select(a, hwy, cty) # A tibble: 8 × 2 hwy cty &lt;int&gt; &lt;int&gt; 1 30 21 2 31 21 3 28 19 4 28 20 5 27 20 6 24 17 7 24 16 8 24 17 이러한 성질과 everything() 함수를 이용하면 변수의 순서를 쉽게 바꿀 수 있다. everything()은 이미 선택된 변수를 제외한 나머지 변수를 의미한다. select(a, cty, hwy, everything()) # A tibble: 8 × 11 cty hwy manufacturer model displ year cyl trans drv fl class &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 21 30 hyundai sonata 2.4 2008 4 auto(l4) f r mids… 2 21 31 hyundai sonata 2.4 2008 4 manual(m… f r mids… 3 19 28 hyundai sonata 3.3 2008 6 auto(l5) f r mids… 4 20 28 hyundai tiburon 2 2008 4 manual(m… f r subc… 5 20 27 hyundai tiburon 2 2008 4 auto(l4) f r subc… 6 17 24 hyundai tiburon 2.7 2008 6 auto(l4) f r subc… 7 16 24 hyundai tiburon 2.7 2008 6 manual(m… f r subc… 8 17 24 hyundai tiburon 2.7 2008 6 manual(m… f r subc… 7.8 mutate()로 새로운 변수 만들기 mutate()는 기존 변수를 이용하여 새로운 변수를 만들어 데이터 프레임의 가장 마지막 열로 추가한다. mutate(데이터프레임, 새로운_변수=기존_변수_연산식, ....) 다음은 도심 연비와 고속도로 연비의 합과, 평균, 그리고 고속도로 대비 도심 연비의 비율(%)을 계산하여 새로운 열을 만든 예이다. b &lt;- select(a, -(cyl:drv), -(fl:class)) b # A tibble: 8 × 6 manufacturer model displ year cty hwy &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 hyundai sonata 2.4 2008 21 30 2 hyundai sonata 2.4 2008 21 31 3 hyundai sonata 3.3 2008 19 28 4 hyundai tiburon 2 2008 20 28 5 hyundai tiburon 2 2008 20 27 6 hyundai tiburon 2.7 2008 17 24 7 hyundai tiburon 2.7 2008 16 24 8 hyundai tiburon 2.7 2008 17 24 mutate(b, sum=cty + hwy) # A tibble: 8 × 7 manufacturer model displ year cty hwy sum &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 hyundai sonata 2.4 2008 21 30 51 2 hyundai sonata 2.4 2008 21 31 52 3 hyundai sonata 3.3 2008 19 28 47 4 hyundai tiburon 2 2008 20 28 48 5 hyundai tiburon 2 2008 20 27 47 6 hyundai tiburon 2.7 2008 17 24 41 7 hyundai tiburon 2.7 2008 16 24 40 8 hyundai tiburon 2.7 2008 17 24 41 mutate(b, sum=cty + hwy, mean=(cty + hwy) / 2, ratio= cty / hwy * 100) # A tibble: 8 × 9 manufacturer model displ year cty hwy sum mean ratio &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 hyundai sonata 2.4 2008 21 30 51 25.5 70 2 hyundai sonata 2.4 2008 21 31 52 26 67.7 3 hyundai sonata 3.3 2008 19 28 47 23.5 67.9 4 hyundai tiburon 2 2008 20 28 48 24 71.4 5 hyundai tiburon 2 2008 20 27 47 23.5 74.1 6 hyundai tiburon 2.7 2008 17 24 41 20.5 70.8 7 hyundai tiburon 2.7 2008 16 24 40 20 66.7 8 hyundai tiburon 2.7 2008 17 24 41 20.5 70.8 7.8.1 transmute()로 새로운 변수만 남기기 만약 새롭게 만들어진 변수만 데이터에 남기려면 mutate() 대신 transmute()를 사용한다. 문법은 두 함수가 동일하다. transmute(b, sum=cty + hwy, mean=(cty + hwy) / 2, ratio= cty / hwy * 100) # A tibble: 8 × 3 sum mean ratio &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 51 25.5 70 2 52 26 67.7 3 47 23.5 67.9 4 48 24 71.4 5 47 23.5 74.1 6 41 20.5 70.8 7 40 20 66.7 8 41 20.5 70.8 7.8.2 새로운 변수를 만들 때 사용할 수 있는 함수들 새로운 변수를 생성할 때, 기존 변수와 관련된 수치, 논리, 문자열 연산을 수행할 수 있다. 다음처럼 제조사와 모델을 하나로 합쳐서 새로운 변수를 만들수도 있고, 배기량이 3 이상인지 여부를 나타내는 변수도 만들 수 있다. mutate(b, newName=paste(manufacturer, model, sep=&quot;-&quot;), dis3=displ &gt;= 3) # A tibble: 8 × 8 manufacturer model displ year cty hwy newName dis3 &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; 1 hyundai sonata 2.4 2008 21 30 hyundai-sonata FALSE 2 hyundai sonata 2.4 2008 21 31 hyundai-sonata FALSE 3 hyundai sonata 3.3 2008 19 28 hyundai-sonata TRUE 4 hyundai tiburon 2 2008 20 28 hyundai-tiburon FALSE 5 hyundai tiburon 2 2008 20 27 hyundai-tiburon FALSE 6 hyundai tiburon 2.7 2008 17 24 hyundai-tiburon FALSE 7 hyundai tiburon 2.7 2008 16 24 hyundai-tiburon FALSE 8 hyundai tiburon 2.7 2008 17 24 hyundai-tiburon FALSE 아울러 다음 함수가 새로운 변수를 만들 때 자주 사용된다. row_number(): 각 행의 행번호. 각 행에 일련번호를 붙일 때 유용. lead(): 기존 변수를 한 행, 또는 여러 행 빠르게 시작하는 변수 lag(): 기존 변수를 한 행, 또는 여러 행 늦게 시작하는 변수 cumsum(), cummean(): 누적 합과 평균 min_rank(): 가장 작은 것부터 차례대로 크기 순서로 등수를 매기는 함수. desc() 함수를 변수에 적용한 후 등수를 매기면 가장 큰 것부터 순서를 매길 수 있다. dense_rank(), percent_rank(), cume_dist(), ntile() 등도 사용될 수 있다. 자세한 내용은 도움말을 참조하기 바란다. 다음의 가상의 상점의 월별 매출 데이터를 사용하여 위에서 설명한 함수의 기능을 살펴보자. store &lt;- data.frame(month=1:6, sales=c(23, 45, 34, 67, 30, 41)) store month sales 1 1 23 2 2 45 3 3 34 4 4 67 5 5 30 6 6 41 mutate(store, before = lag(sales, n = 1), # 1 달 전 판매량 after = lead(sales, n = 1), # 1 달 후 판매량 total = cumsum(sales), # 누적 판매량 mean = cummean(sales), # 누적 평균 판매량 rank1 = min_rank(sales), # 판매량 순위 (올림차순) rank2 = min_rank(desc(sales)) # 판매량 순위 (내림차순) ) month sales before after total mean rank1 rank2 1 1 23 NA 45 23 23.00 1 6 2 2 45 23 34 68 34.00 5 2 3 3 34 45 67 102 34.00 3 4 4 4 67 34 30 169 42.25 6 1 5 5 30 67 41 199 39.80 2 5 6 6 41 30 NA 240 40.00 4 3 다음은 앞의 예에서 만든 b라는 데이터프레임에 일련번호를 사용하여 id라는 열을 추가한 사례이다. mutate(b, id = row_number()) # A tibble: 8 × 7 manufacturer model displ year cty hwy id &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 hyundai sonata 2.4 2008 21 30 1 2 hyundai sonata 2.4 2008 21 31 2 3 hyundai sonata 3.3 2008 19 28 3 4 hyundai tiburon 2 2008 20 28 4 5 hyundai tiburon 2 2008 20 27 5 6 hyundai tiburon 2.7 2008 17 24 6 7 hyundai tiburon 2.7 2008 16 24 7 8 hyundai tiburon 2.7 2008 17 24 8 7.9 summarize()로 변수 요약하기 summarize(데이터프레임, 요약변수이름=요약함수(변수), ....) summarize() 함수는 데이터프레임을 하나의 행으로 요약한다. 하나의 행으로 요약하기 위하여 변수의 모든 값을 하나의 값으로 통계요약하는 함수를 주로 이용한다. 대표적인 통계요약 함수는 다음과 같다. n(): 행의 수를 구한다. sum(): 수치 변수의 합을 구한다. mean(): 수치 변수의 균을 구한다. median(): 수치 변수의 중위수를 구한다. sd(): 수치 변수의 표준편차를 구한다. var(): 수치 변수의 분산을 구한다. min(): 수치 변수의 최소값을 구한다. max(): 수치 변수의 최대값을 구한다. quantile(변수, probs): 수치 변수의probs` 분위수를 구한다. 다음은 도심 연비의 데이터 수, 평균, 중위수, 최소값, 최대값을 구한 결과이다. summarize(b, count=n(), mean=mean(cty), med=median(cty), min=min(cty), max=max(cty)) # A tibble: 1 × 5 count mean med min max &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; 1 8 18.9 19.5 16 21 다음처럼 여러 변수에 대하여 통계 요약할 수도 있다. summarize(b, meanCty=mean(cty), meanHwy=mean(hwy), medianCty=median(cty), medianHqy=median(hwy)) # A tibble: 1 × 4 meanCty meanHwy medianCty medianHqy &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 18.9 27 19.5 27.5 7.9.1 across()로 여려 변수를 요약하기* 앞의 예에서 우리는 도심 연비와 고속도로 연비 열에 대해 동일한 통계요약 함수를 적용하였다. 동일한 통계요약 함수를 적용할 열이 한두 개이면 앞의 예처럼 일일이 기술해주면 되지만, 적용해야 할 열이 많아지면 이를 일일이 기술하는 것은 번잡할 뿐만 아니라 오류의 발생 가능성을 높이고 나중에 코드를 변경하기 어렵게 만든다. across() 함수는 select()처럼 열을 선택하여 동일한 함수를 적용할 수 있게 해준다. across() 함수는 두 개의 주요 인수를 가지고 있다. 첫 번째 인수는 .cols로 함수를 적용할 열을 지정한다. 열의 지정은 select() 함수처럼 변수 이름, 위치, 형식으로 지정할 수 있다. 두 번재 인수는 .fns로 열에 적용할 함수를 지정한다. across() 함수는 summarize() 함수와 함께 자주 사용되는데 다음처럼 사용된다. summarize(b, across(c(cty, hwy), mean)) # A tibble: 1 × 2 cty hwy &lt;dbl&gt; &lt;dbl&gt; 1 18.9 27 여러 함수를 함께 적용하려면 함수를 리스트로 묶어서 .fns 인수로 전달한다. 이 때 리스트의 요소의 이름을 부여하면 열이름과 해당 요소의 이름으로 결과 열의 이름이 생성된다. summarize(b, across(c(cty, hwy), list(mean=mean, med=median))) # A tibble: 1 × 4 cty_mean cty_med hwy_mean hwy_med &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 18.9 19.5 27 27.5 결과 열의 이름을 다른 형태로 지정하고 싶으면 .name 인수에 원하는 형식을 함수 이름을 나타내는 {.fn}과 열의 이름을 나타내는 {.col}을 사용하여 설정할 수 있다. 다음은 함수 이름 후에 -가 나온 후 열 이름이 나오도록 한 것이다. summarize(b, across(c(cty, hwy), list(mean=mean, med=median), .names=&quot;{.fn}-{.col}&quot;)) # A tibble: 1 × 4 `mean-cty` `med-cty` `mean-hwy` `med-hwy` &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 18.9 19.5 27 27.5 만약 지금처럼 적용되는 열을 기준으로 정렬되는 것이 아니라 함수 별로 정렬되어 결과가 나오게 하고 싶으면, across() 함수를 각 함수 별로 적용을 한다. 이 때 서로 열 이름이 충돌이 나지 않도록 .names 인수를 설정해 준다. summarize(b, across(c(cty, hwy), mean, .names=&quot;mean-{.col}&quot;), across(c(cty, hwy), median, .names=&quot;med-{.col}&quot;)) # A tibble: 1 × 4 `mean-cty` `mean-hwy` `med-cty` `med-hwy` &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 18.9 27 19.5 27.5 다음 예는 모든 수치 열에 대하여 표준편차를 구한 것이다. summarize(b, across(where(is.numeric), sd)) # A tibble: 1 × 4 displ year cty hwy &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 0.427 0 1.96 2.78 7.10 group_by()로 그룹별로 요약하기 group_by(데이터프레임, 그룹기준변수1, 그룹기준변수2, ...) group_by() 함수는 기준이 되는 변수의 구분되는 값에 따라 데이터를 그룹화한다. 그룹화된 결과를 summarize() 함수에 전달하면 그룹별로 요약된 결과를 출력한다. byModel &lt;- group_by(b, model) summarize(byModel, count=n(), mean=mean(cty), sd=sd(cty)) # A tibble: 2 × 4 model count mean sd &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 sonata 3 20.3 1.15 2 tiburon 5 18 1.87 그룹화된 결과를 출력해 보면, 원 데이터인 b와 같아보이는데, 출력시 model 변수로 그룹화 되어 있다는 것이 같이 출력된다. byModel # A tibble: 8 × 6 # Groups: model [2] manufacturer model displ year cty hwy &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 hyundai sonata 2.4 2008 21 30 2 hyundai sonata 2.4 2008 21 31 3 hyundai sonata 3.3 2008 19 28 4 hyundai tiburon 2 2008 20 28 5 hyundai tiburon 2 2008 20 27 6 hyundai tiburon 2.7 2008 17 24 7 hyundai tiburon 2.7 2008 16 24 8 hyundai tiburon 2.7 2008 17 24 변수를 여러 개를 조합하여 그룹화를 할 수도 있다. byModel &lt;- group_by(a, model, cyl) summarize(byModel, count=n(), mean=mean(cty)) `summarise()` has grouped output by &#39;model&#39;. You can override using the `.groups` argument. # A tibble: 4 × 4 # Groups: model [2] model cyl count mean &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 sonata 4 2 21 2 sonata 6 1 19 3 tiburon 4 2 20 4 tiburon 6 3 16.7 여러 변수로 그룹화를 하면 summarize() 함수는 그룹별로 하나의 행만 생성이 되었으면 결과에서 마지막 그룹을 제거한다. 위의 결과에서는 model과 cyl의 값의 조합에 대하여 하나의 행만 생성되었으므로, 마지막 그룹 변수인 cyl와 관련된 그룹은 사라지고, model과 관련된 그룹만 남는다. 출력된 결과와 메시지에서 이를 확인할 수 있다. summarize() 함수의 .groups 인수를 사용하면 summarize() 후에 그룹을 유지할지, 모두 없앨지 등을 조정할 수 있다. 관심있는 독자는 summarize() 함수의 도움말을 참조하기 바란다. 7.10.1 group_by()로 그룹별로 새 변수 추가하기 group_by()는 summarize()와 함께 자주 사용되지만, mutate()나 filter() 등의 다른 dplyr 함수와 함께 사용될 수 있다. 다음은 mutate()로 전체 대이터에 대하여 고속도로 연비 순으로 순위를 매기는 것과, group_bu()와 함께 사용하여 모델별로 고속도로 연비의 순위를 매긴 것을 비교하여 보여 주고 있다. mutate(b, rank=min_rank(desc(hwy))) # 전체 데이터에서 고속도로 연비 순위 매기기 # A tibble: 8 × 7 manufacturer model displ year cty hwy rank &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 hyundai sonata 2.4 2008 21 30 2 2 hyundai sonata 2.4 2008 21 31 1 3 hyundai sonata 3.3 2008 19 28 3 4 hyundai tiburon 2 2008 20 28 3 5 hyundai tiburon 2 2008 20 27 5 6 hyundai tiburon 2.7 2008 17 24 6 7 hyundai tiburon 2.7 2008 16 24 6 8 hyundai tiburon 2.7 2008 17 24 6 mutate(byModel, rank=min_rank(desc(hwy))) # 모델 별로 고속도로 연비 순위 매기기 # A tibble: 8 × 12 # Groups: model, cyl [4] manufacturer model displ year cyl trans drv cty hwy fl class rank &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 hyundai sona… 2.4 2008 4 auto… f 21 30 r mids… 2 2 hyundai sona… 2.4 2008 4 manu… f 21 31 r mids… 1 3 hyundai sona… 3.3 2008 6 auto… f 19 28 r mids… 1 4 hyundai tibu… 2 2008 4 manu… f 20 28 r subc… 1 5 hyundai tibu… 2 2008 4 auto… f 20 27 r subc… 2 6 hyundai tibu… 2.7 2008 6 auto… f 17 24 r subc… 1 7 hyundai tibu… 2.7 2008 6 manu… f 16 24 r subc… 1 8 hyundai tibu… 2.7 2008 6 manu… f 17 24 r subc… 1 7.10.2 count()로 개수 세기 앞의 예에서 모델 별로 데이터 개수만을 세려면 다음과 같은 명령어를 사용하면 된다. byModel &lt;- group_by(b, model) summarise(byModel, n=n()) # A tibble: 2 × 2 model n &lt;chr&gt; &lt;int&gt; 1 sonata 3 2 tiburon 5 그런데 이렇게 특정 열을 기준으로 값의 빈도를 세는 작업은 매우 빈번히 수행되므로, count() 함수는 위에서 두 단계로 수행해야 하는 명령을 하나의 명령만으로 수행할 수 있게 해 준다. count(b, model) # A tibble: 2 × 2 model n &lt;chr&gt; &lt;int&gt; 1 sonata 3 2 tiburon 5 다음은 mpg 데이터에서class` 열의 각 값의 빈도를 센 결과이다. count(mpg, class) # A tibble: 7 × 2 class n &lt;chr&gt; &lt;int&gt; 1 2seater 5 2 compact 47 3 midsize 41 4 minivan 11 5 pickup 33 6 subcompact 35 7 suv 62 만약 빈도가 큰 값일수록 위에 표시되게 하려면 다음처럼 sort=TRUE 인수를 설정한다. count(mpg, class, sort=TRUE) # A tibble: 7 × 2 class n &lt;chr&gt; &lt;int&gt; 1 suv 62 2 compact 47 3 midsize 41 4 subcompact 35 5 pickup 33 6 minivan 11 7 2seater 5 count()는 하나의 열뿐만 아니라 여러 열을 사용하여 빈도를 계산할 수 있다. 다음은 class와 cyl의 값의 가능한 조합별로 빈도를 계산한 결과이다. count(mpg, class, cyl, sort=T) # A tibble: 19 × 3 class cyl n &lt;chr&gt; &lt;int&gt; &lt;int&gt; 1 suv 8 38 2 compact 4 32 3 midsize 6 23 4 subcompact 4 21 5 pickup 8 20 6 midsize 4 16 7 suv 6 16 8 compact 6 13 9 minivan 6 10 10 pickup 6 10 11 suv 4 8 12 subcompact 6 7 13 2seater 8 5 14 subcompact 8 5 15 pickup 4 3 16 compact 5 2 17 midsize 8 2 18 subcompact 5 2 19 minivan 4 1 이외에도 count() 함수는 빈도를 계산할 때, wt 인수를 사용하여 행의 개수로 빈도를 계산하는 것이 아니라 해당 행의 특정 열의 값의 합으로 빈도를 계산할 수도 있다. 관심있는 독자는 count() 함수의 도움말을 찾아보기 바란다. 7.11 %&gt;% 파이프 연산자 7.11.1 여러 단계를 거쳐 데이터를 변환할 때 mpg 데이터에서 조사 연도와 모델 별로 데이터 수와 도심 연비의 평균을 구한 후, 평균이 22 이상인 모델로 이루어진 행을 추출하려고 한다. 이를 수행하려면 다음처럼 변수를 이용하여 결과를 차례로 전달하거나, 함수를 결합하여 한 문장에 사용하여야 한다. byModel &lt;- group_by(mpg, model, year) meanCty &lt;- summarize(byModel, count=n(), mean=mean(cty)) `summarise()` has grouped output by &#39;model&#39;. You can override using the `.groups` argument. filter(meanCty, mean &gt;= 22) # A tibble: 5 × 4 # Groups: model [3] model year count mean &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 civic 1999 5 24.8 2 civic 2008 4 24 3 corolla 1999 3 24.7 4 corolla 2008 2 27 5 new beetle 1999 4 26 filter(summarize(group_by(mpg, model, year), count=n(), mean=mean(cty)), mean &gt;= 22) `summarise()` has grouped output by &#39;model&#39;. You can override using the `.groups` argument. # A tibble: 5 × 4 # Groups: model [3] model year count mean &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 civic 1999 5 24.8 2 civic 2008 4 24 3 corolla 1999 3 24.7 4 corolla 2008 2 27 5 new beetle 1999 4 26 전자는 불피요하게 중간 결과를 저장할 변수를 만들어야 하고, 후자는 복잡하여 이 명령이 무엇을 하는 명령어인지 쉽게 파악하기 힘들다. 또한 중첩된 괄호 때문에 오류가 발생하기 쉽다. 7.11.2 파이프 연산자 파이프 연산자는 데이터 변환이 여러 단계를 거칠 때 불필요한 변수의 생성 없이도 함수 간에 중간 데이터를 전달할 수 있게 해 준다. 파이프 연산자는 앞의 함수의 결과를 뒤 함수의 첫 번째 인수로 전달해 준다. 파이프 연산자를 사용할 때는 그러므로 첫 번째 인수는 생략하여 기술한다. 파이프 연산자로는 magrittr 패키지가 제공하는 %&gt;% 연산자를 사용할 수도 있고, R 4.1.0 버전부터 도입된 기본 기능에 포함된 |&gt; 연산자를 사용할 수도 있다. 여기서는 R 버전이 낮은 사용자에게도 동일하게 적용될 수 있도록 %&gt;% 연산자를 사용하도록 한다. 이 연산자는 tidyverse 패키지를 적재하였으면 사용할 수 있다. 다음은 앞의 예와 동일한 예를 파이프 연산자를 사용하여 수행한 결과이다. mpg %&gt;% group_by(model, year) %&gt;% summarize(count=n(), mean=mean(cty)) %&gt;% filter(mean &gt;= 22) `summarise()` has grouped output by &#39;model&#39;. You can override using the `.groups` argument. # A tibble: 5 × 4 # Groups: model [3] model year count mean &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 civic 1999 5 24.8 2 civic 2008 4 24 3 corolla 1999 3 24.7 4 corolla 2008 2 27 5 new beetle 1999 4 26 불필요하게 데이터를 기술하는 부분이 사라져서 각 단계에서 수행하는 작업이 무엇인지 명확하게 들어나고 불필요한 중간 변수를 만들지 않아도 되므로 파이프 연산자는 매우 편리하다. 그런데 파이프 연산자를 사용하려면 앞의 함수의 결과가 뒤의 함수의 첫 인수로 사용하기 적절한 형태이어야 한다. dplyr 패키지의 주요 함수들은 정돈 데이터 형식으로 데이터의 결과를 반환하고, 첫 인수가 정돈 데이터 형식의 데이터로 간주한다. 파이프 연산자를 사용할 때 주의할 점은 여러 줄로 명령을 기술할 때, 파이프 연산자로 중간 문장이 종료되어야 한다는 것이다. 그래야 아직 문장이 완료되지 않았다는 것을 이해하여 다음 단계의 명령이 입력되기를 기다린다. 다음처럼 기술하면 R은 명령 입력이 중간에 완료된 것으로 보고 잘못된 결과를 출력한다. b %&gt;% group_by(model) %&gt;% summarize(count=n(), mean=mean(cty)) %&gt;% filter(mean &gt;= 20) Error: &lt;text&gt;:3:3: 예기치 않은 SPECIAL입니다 2: summarize(count=n(), mean=mean(cty)) 3: %&gt;% ^ %&gt;% 연산자 이외에도 연산 결과를 출력도 하고 결과를 반환하고 싶을 때 사용하는 %T&gt;% 연산자, 입력된 객체에 결과를 재할당하고 싶을 때 사용하는 %&lt;&gt;% 연산자 등도 있으니 관심있는 독자는 도움말을 살펴보기 바란다. 7.11.3 ungroup() 파이프 연산자를 사용하여 데이터를 전달하다 보면 데이터가 그룹화 된 것을 중간 단계에서 해제하고 싶을 때가 있다. 이 경우에는 ungroup() 명령을 사용한다. byModel &lt;- b %&gt;% group_by(model) byModel %&gt;% summarize(count=n()) # A tibble: 2 × 2 model count &lt;chr&gt; &lt;int&gt; 1 sonata 3 2 tiburon 5 byModel %&gt;% ungroup() %&gt;% summarize(count=n()) # A tibble: 1 × 1 count &lt;int&gt; 1 8 반드시 필요한 작업은 아니다. 그렇지만 실행하는 것이 작업할 때 매우 편리하므로 필수적인 작업으로 생각하는 것이 좋다.↩︎ "],["ch-visualization.html", "Chapter 8 ggplot2를 이용한 데이터 시각화 8.1 ggplot2 시작하기 8.2 도형의 속성에 데이터 열을 대응시키기 (aesthetic mapping) 8.3 측면(facets)으로 나누어 그리기 8.4 그래프 계층(layers)과 도형(geoms) 8.5 ggplot 명령문을 입력할 때 자주 발생하는 문제들 8.6 통계 변환 8.7 위치 조정 8.8 ggplot2 그래프의 종류 8.9 그래프의 외양 바꾸기 8.10 기타 유용한 팁들", " Chapter 8 ggplot2를 이용한 데이터 시각화 이 장에서는 ggplot2를 이용하여 데이터를 시각화하는 방법을 배운다. ggplot2 패키지는 tidyverse 패키지를 설치하였으면 자동으로 설치된다. 그리고 tidyverse 패키지를 적재하면 ggplot2 패키지도 자동 적재된다. library(tidyverse) ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ✔ dplyr 1.1.4 ✔ readr 2.1.5 ✔ forcats 1.0.0 ✔ stringr 1.5.1 ✔ ggplot2 3.5.1 ✔ tibble 3.2.1 ✔ lubridate 1.9.3 ✔ tidyr 1.3.1 ✔ purrr 1.0.2 ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ✖ dplyr::filter() masks stats::filter() ✖ dplyr::lag() masks stats::lag() ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors 8.1 ggplot2 시작하기 이 절에서는 ggplot2에서 제공하는 mpg 데이터를 이용하여 ‘배기량이 커지면 연비가 낮아지는가?’ 라는 물음을 그래프를 이용하여 탐색해 보자. mpg는 1999년과 2008년에 미국 EPA에서 조사하여 발표한 자동차 주요 모델별 연비 데이터이다. mpg 데이터에 대한 자세한 설명은 7.3 절의 mpg 데이터에 대한 설명이나 R 도움말을 참조하기 바란다. 8.1.1 ggplot2 그래프 그려보기 mpg 데이터로부터 배기량(displ)을 x 축으로, 고속도로 연비(hwy)를 y 축으로 하는 산점도를 그려보자. ggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) 산점도에서 배기량이 커짐지면 연비가 줄어드는 경향을 관찰할 수 있다. 이 산점도를 그린 R 명령어는 두 개의 함수가 결합하여 실행되었다. ggplot(): ggplot2 그래프의 좌표축과 좌표평면을 만드는 함수이다. 뒤에서 살펴보겠지만 그래프에 공통된 데이터와 매핑을 설정할 수 있다. geom_point(): ggplot() 함수가 만들어 놓은 좌표평면 위에, 점이라는 도형을 이용하여 그래프를 그린다. 각 geom 함수의 그래프는 좌표평면 상에서 별도의 층으로 구성된다. ggplot2의 명령문을 입력할 때 여러 함수를 합쳐서 실행하기 위하여 + 연산자를 이용한다. dplyr 패키지의 파이프 연산자와 유사한 역할을 한다. 그러나 문법이 다르기 때문에 ggplot2 명령어 들 사이에는 + 연산자를 사용하여야 한다. 앞의 예에서는 geom_point() 함수의 data와 mapping이라는 인수를 설정하였다. data: 도형으로 표현할 데이터 프레임을 지정한다. mapping: 도형의 시각적 속성과 data에 지정된 데이터 프레임의 열을 쌍으로 대응시킨다. aes() 함수 내에 &lt;도형의 속성&gt;=&lt;데이터 열 이름&gt;의 형식으로 기술된다. 앞의 예에서 점의 x-축 위치에 displ 열이, y-축 위치에 hwy 열이 쌍으로 대응되었다. ggplot2에는 점을 그리는 geom_point() 함수뿐 아니라 다양한 도형을 그리는 geom 함수들이 있다. 이 함수들은 모두 data와 mapping이라는 인수를 가지고 있다. ggplot2는 그래픽 문법(grammar of graphics)를 가지고 있어서 모든 그래프를 동일한 형식으로 생성할 수 있다. 다음은 ggplot2의 그래픽 문법의 개요를 보여준다. 우리는 이 장에서 ggplot2의 여러 문법적 요소를 하나씩 살펴볼 것이다. Figure 8.1: ggplot2의 그래픽 문법 (출처: Data visualization with ggplot2::cheat sheet (RStudio)) 8.2 도형의 속성에 데이터 열을 대응시키기 (aesthetic mapping) 앞의 산점도에서 배기량에 따라 연비가 줄어드는 관계를 조금 벗어나는 관측치들이 있다. 이 예외적인 관측치들이 자동차 종류의 차이 때문에 발생했다, 라고 가설을 세웠다 하자. 이 가설을 확인해 보려면 자동차 종류별로 관측치를 시각화할 필요가 있다. 앞서 본 geom_point() 함수는 ’점’이라는 도형을 좌표평면 상에서 그린다. 점이라는 도형은 x-축의 위치(x)와 y-축의 위치(y)뿐 아니라 색상(color), 모양(shape), 크기(size), 투명도(alpha) 등의 다른 시각적 속성을 가지고 있다. 우리는 이러한 속성 중 하나에 mpg 데이터의 class 열을 대응시켜 자동차 종류 별로 좌표평면에서 시각적으로 구분되는 점으로 표현할 수 있다. 8.2.1 범주형 변수를 색상(color) 속성에 매핑하기 다음은 관측치의 종류(class)에 따라 점을 서로 다른 색상(color)으로 표현한 예이다. 자동차의 종류에 따라 점이 다른 색상으로 표현되고, 어떤 색상이 어떤 자동차 종류에 대응되었는지에 대한 범례가 자동 생성된다. ggplot() + geom_point(mapping=aes(x=displ, y=hwy, color=class), data=mpg) 앞선 그래프에서 이상치로 표현되었던 점들 중 한 점만 제외하고 모두 2seater 자동차의 관측치였음을 알 수 있다. 이 종류의 차는 스포츠카로 배기량에 비해 가벼운 몸체를 가지고 있어 예외적인 연비가 관측된 것으로 보인다. 다음으로 class 열을 shape, size, alpha 등의 속성에 대응시켜 어떤 결과가 나오는지 살펴보자. 8.2.2 범주형 변수를 모양(shape) 속성에 매핑하기 shape 속성은 점의 모양을 결정한다. 다음은 앞의 산점도를 구동 방식(drv)에 따라 점의 모양이 다르게 표시한 예이다. ggplot() + geom_point(mapping=aes(x=displ, y=hwy, shape=drv), data=mpg) shape 속성에 매핑할 때 주의할 점은 shape은 최대 6개의 모양으로만 점을 구분하기 때문에 class 열처럼 6개보다 많은 종류의 데이터가 있는 열을 매핑하면 데이터가 제대로 표시가 되지 않는다. 다음 예처럼 shape 속성에 class 열을 매핑하니 경고가 나타나고 suv 데이터를 표시하지 못한 것을 확인할 수 있다. ggplot() + geom_point(mapping=aes(x=displ, y=hwy, shape=class), data=mpg) Warning: The shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate ℹ you have requested 7 values. Consider specifying shapes manually if you need that many have them. Warning: Removed 62 rows containing missing values or values outside the scale range (`geom_point()`). 8.2.3 연속형 변수를 크기(size), 투명도(alpha), 색상(color) 속성에 매핑하기 모양(shape) 속성은 몇 가지 값으로 표현되는 범주형 변수를 표현하기 좋다. 데이터의 열이 연속형 변수이면 연속적인 값을 표현하기 좋은 가로축(x), 세로축(y), 크기(size), 투명도(alpha) 등을 이용하는 것이 좋다. 색상(color)은 범주형 변수와 연속형 변수에 모두 매핑될 수 있다. 범주형 변수로 매핑되면 구분되는 색상으로, 연속형 변수로 매핑되면 색상의 그라데이션으로 값을 표시한다. 다음은 도심 연비와 고속도로 연비를 가로축과 세로축으로 하는 그래프에서 점의 크기 속성을 배기량 열에 매핑한 결과이다. 도심 연비와 고속도로 연비가 좋은 차들은 배기량이 작은 차임을 알 수 있다. ggplot() + geom_point(mapping=aes(x=cty, y=hwy, size=displ), data=mpg) 다음은 동일한 도심 연비와 고속도로 연비 산점도에서 그래프에서 점의 색상을 배기량 열에 매핑한 결과이다. 범주형 변수가 매핑될 때와는 달리 색상의 연속적인 변화인 그라데이션을 사용하여 배기량을 표현하고 있음을 볼 수 있다. ggplot() + geom_point(mapping=aes(x=cty, y=hwy, color=displ), data=mpg) 다음은 동일한 도심 연비와 고속도로 연비 산점도에서 그래프에서 점의 투명도를 실린더 수 열에 매핑한 결과이다. ggplot() + geom_point(mapping=aes(x=cty, y=hwy, alpha=cyl), data=mpg) 그럼 size와 alpha 등의 속성에 연속형 변수가 아니라 범주형 변수를 매핑하면 어떻게 될까? 범주의 순서를 기준으로 각 범주를 1부터 1씩 증가하는 수치로 간주하여 그래프를 그려준다. 다음 예는 size와 alpha 속성에 자동차 종류(class)를 매핑한 결과이다. size와 alpha 속성은 범산형 데이터를 표시하기에는 적절하지 않아서 관련된 경고 메시지를 표시한다. 왜냐하면 점의 크기와 투명도는 연속적인 값을 가지는 속성이기 때문에 연속형 변수를 매핑하는 것이 자연스럽기 때문이다. ggplot() + geom_point(mapping=aes(x=displ, y=hwy, size=class), data=mpg) Warning: Using size for a discrete variable is not advised. ggplot() + geom_point(mapping=aes(x=displ, y=hwy, alpha=class), data=mpg) Warning: Using alpha for a discrete variable is not advised. 8.2.4 도형의 여러 속성에 데이터 열을 매핑시키기 도형의 여러 속성에 데이터의 한 열을 매핑시킬 수도 있다. 다음 예에서는 구동방식(drv)에 따라 점의 모양과 색상을 다르게 표시하였다. 아울러 어떤 구동방식이 어떤 색상과 모양의 점으로 표현되었는지에 대한 범례도 자동 생성되었다. ggplot() + geom_point(mapping=aes(x=displ, y=hwy, color=drv, shape=drv), data=mpg) 그래프에서 보듯이 예외적인 관측치를 구동방식의 차이로 설명하기는 어려워 보인다. 예외적인 관측치의 대부분이 후륜구동(r)이긴 하지만 주류적인 연비 경향 안에 포함되어 있는 후륜구동 관측치들도 많기 때문이다. 위의 예에서 color와 shape 속성에 각각 다른 데이터 열을 매핑할 수도 있다. ggplot() + geom_point(mapping=aes(x=displ, y=hwy, color=class, shape=drv), data=mpg) 8.2.5 도형 속성에 데이터 열을 매핑하기 - 예제 지금까지 x-축과 y-축을 배기량(displ)과 고속도로 연비(hwy) 열로만 매핑하였다. 다음처럼 도심 연비(cty)와 고속도로 연비(hwy)의 관계를 보기 위하여 x-축과 y-축에 이 두 데이터 열을 매핑하여 그래프를 그릴 수도 있다. ggplot() + geom_point(mapping=aes(x=cty, y=hwy, color=drv, shape=drv), data=mpg) iris 데이터는 R의 기본 기능에서 제공하는 붓꽃에 대한 데이터이다. head(iris) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5.0 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa 다음은 iris 데이터의 Sepal.Length와 Sepal.Width를 점의 x-축과 y-축 속성에 매핑하고, 색상과 모양 속성에 Species 열을 매핑한 예이다. ggplot() + geom_point(mapping=aes(x=Sepal.Length, y=Sepal.Width, color=Species, shape=Species), data=iris) 8.2.6 도형의 속성에 대응시키기 vs. 도형의 속성 인수를 설정하기 마지막으로 데이터를 도형의 속성으로 대응시키기와 도형의 속성 인수를 설정하기의 차이를 살펴보자. 8.2.6.1 도형의 속성 인수 설정하기 지금까지는 점의 속성에 데이터의 열을 대응시켜 관측치의 값에 따라 점이 시각적으로 다르게 표현되도록 하였다. 그런데 데이터와 무관하게 점의 속성을 특정한 값으로 설정할 수도 있다. 다음은 산점도 점을 모두 파란색으로 지정한 예이다. ggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg, color=&quot;blue&quot;) 이처럼 도형의 어떤 속성을 특정한 값으로 지정하는 것을 도형의 속성 인수를 설정한다고 한다. 이 경우 도형의 시각적 속성의 변화는 데이터와는 무관하며, 그렇기 때문에 mapping 인수의 aes() 함수 내에 정의되지 않는다. 대신 aes() 바깥에 별도의 geom 함수의 인수로서 설정된다. 도형의 속성 인수를 설정할 때, 설정되는 값은 인수에 따라 다르다. color 인수: 색상의 이름이 문자열로 부여된다. 부여할 수 있는 생상의 이름을 확인하려면 colors() 함수를 실행해 본다. size 인수: 점의 크기가 mm 단위로 설정된다. shape 인수: 표시할 문자를 직접 설정할 수도 있고, 0에서 24까지의 숫자로도 지정할 수 있다. 다음은 color=\"red\"와 fill=\"blue\"로 인수가 설정되었을 때 shape 인수의 값에 따라 점의 모양을 보여준다. 8.2.6.2 도형의 속성 인수를 속성 대응시키기에 잘못 설정하는 경우 ggplot2의 초보자가 가끔 도형의 속성을 데이터의 열에 대응시키기와 도형의 속성 인수를 설정하는 것을 혼동할 때가 있다. 다음처럼 color=\"blue\"의 인수 설정을 aes() 안에 기술하면 어떻게 될까? 실제 이를 실행해 보면 점들이 파란색이 아니라 빨간색으로 표시되는 것을 볼 수 있다. ggplot() + geom_point(mapping=aes(x=displ, y=hwy, color=&quot;blue&quot;), data=mpg) aes() 함수 안에 설정되었기 때문에 ggplot은 color=\"blue\"를 color 속성에 “blue”라는 하나의 값을 가진 열이 대응된 것으로 간주한다. 그러므로 이 값에 적절한 색-이 예에서는 빨간색-을 대응시켜 점을 표시한 후, 범례에 blue라는 값이 빨간색으로 대응되었음을 표시하였다. 따라서 도형 속성을 데이터 열에 대응시키기와 도형의 속성 인수를 설정하는 것을 구분하여 사용하지 않으면 이렇듯 엉뚱한 결과를 얻을 수 있으므로 주의가 필요하다. 8.2.7 group 속성 geom 도형의 대부분의 속성은 도형의 시각적 표현을 직접적으로 변화시키는 속성들이다. 대표적인 예가 x, y, color, shape, size, fill 등의 속성이다. 이러한 속성은 시각적으로 효과가 직접적으로 들어나므로 이해하기 쉽다. 반면 group 속성은 도형의 시각적 속성을 직접 변형하는 것이 아니라, 도형을 그릴 때 데이터를 어떤 식으로 그룹으로 묶어 사용할지만 지정한다. 이를 통해 그래프의 전체 모양에 영향을 준다. geom_point() 함수는 관측치 하나에 점 하나를 대응시켜 그래프를 그린다. 그러나 어떤 geom 함수는 여러 관측치를 그룹으로 묶어서 하나의 도형을 그린다. 대표적인 예가 geom_line()과 geom_smooth() 함수이다. 이 함수들은 여러 관측치를 사용하여 하나의 선을 완성한다. 만약 group 속성이 매핑되어 있지 않으면 모든 데이터를 하나의 그룹으로 하여 선 하나를 그린다. 반면 group 속성이 매핑되면, group속성에 매핑된 값을 기준으로 데이터를 그룹화하여 각각 도형 하나(geom_line()과 geom_smooth() 함수에서는 선 하나)를 그린다. 지금 설명한 내용을 예를 들어 살펴보자. 8.2.8 그룹으로 나누어 선 그래프 그리기 Orange 데이터는 5 그루의 나무에서 age(나이: 일)와 circumference(둘레: mm)을 측정한 결과이다. Tree 변수는 5그루 나무에 붙인 일련번호이다. Orange Tree age circumference 1 1 118 30 2 1 484 58 3 1 664 87 4 1 1004 115 5 1 1231 120 6 1 1372 142 7 1 1582 145 8 2 118 33 9 2 484 69 10 2 664 111 11 2 1004 156 ...... 다음은 age와 circumference를 x와 y aesthetics에 매핑한 그래프이다. ggplot() + geom_point(mapping=aes(x=age, y=circumference), data=Orange) 이번에는 위와 동일한 매핑으로 geom_line()을 그려보자. geom_line()은 x좌표가 작은 것에서 큰 것 순으로 점을 연결하여 하나의 선을 완성한다. ggplot() + geom_line(mapping=aes(x=age, y=circumference), data=Orange) 동일한 나이 대의 데이터가 많아서 하나의 선으로 연결한 그래프가 의미를 갖기 어려워 보인다. 이번에는 group 속성에 Tree 변수를 매핑해 보자. 데이터가 Tree의 값에 따라 그룹으로 묶여 선이 각각 그려졌음을 확인할 수 있다. ggplot() + geom_line(mapping=aes(x=age, y=circumference, group=Tree), data=Orange) 8.2.9 이산형 변수는 group 속성으로 자동 매핑된다. 각 나무의 데이터를 구분해 보기 위하여 다음처럼 color 속성을 추가해 보자. Tree 변수는 순서형 범주 데이터로 이산형 데이터이므로, color가 뚜렷이 구분되는 색으로 매핑되었다. 그리고 수준의 순서에 따라 범례도 정렬되었다. Orange$Tree [1] 1 1 1 1 1 1 1 2 2 2 2 2 2 2 3 3 3 3 3 3 3 4 4 4 4 4 4 4 5 5 5 5 5 5 5 Levels: 3 &lt; 1 &lt; 5 &lt; 2 &lt; 4 ggplot() + geom_line(mapping=aes(x=age, y=circumference, group=Tree, color=Tree), data=Orange ) 그런데 이를 좀 더 간편히 할 수 있는 방법이 있다. ggplot2는 속성에 매핑된 변수 중에 이산형 변수가 있으면 이를 group 속성에 자동으로 매핑시킨다. 다음처럼 color 속성에 Tree를 매핑만 하면, 자동으로 이를 group 속성에 반영하여 선을 구분하여 그려준다. ggplot() + geom_line(mapping=aes(x=age, y=circumference, color=Tree), data=Orange) 다음 예는 linetype 속성으로 각 나무를 구분한 예이다. ggplot() + geom_line(mapping=aes(x=age, y=circumference, linetype=Tree), data=Orange) 8.2.10 geom_smooth() 함수에서 group 속성 group 속성이 이용되는 또 다른 예가 geom_smmooth() 함수이다. 이 함수는 group에 매핑된 정보에 따라 데이터를 그룹화하여 추세선을 그린다. ggplot() + geom_smooth(mapping=aes(x=age, y=circumference), data=Orange ) `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; ggplot() + geom_smooth(mapping=aes(x=age, y=circumference, color=Tree), data=Orange ) `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; ggplot() + geom_smooth(mapping=aes(x=age, y=circumference, color=Tree), data=Orange, se=F) `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; 마지막 예에서는 geom_smooth() 함수의 se 인수를 FALSE로 설정하여 신뢰구간이 표시되지 않도록 하였다. 8.3 측면(facets)으로 나누어 그리기 8.2 장에서 배기량과 고속도로 연비의 산점도를 자동차 종류에 따라 분리하여 살펴보기 위해 점의 시각적 속성 중 하나에 자동차 종류를 대응시켰다. 원래의 그래프를 또 다른 변수의 측면에서 세분화하여 살펴보는 방법으로는 도형의 다른 속성에 해당 변수를 대응시키는 것 말고도 해당 변수값에 따라 데이터를 나누어 각각에 대한 그래프를 그려볼 수도 있다. ggplot2에서는 이러한 방식으로 그래프를 그리는 것을 측면(facets)으로 나누어 그래프를 그린다고 한다. 8.3.1 facet_wrap()로 일차원 측면 그래프 그리기 다음은 facet_wrap() 함수의 사용법을 보여준다. ~ 은 R에서 수식을 표현할 때 사용되는데, facet_wrap() 함수는 수식을 인수로 입력받는다. facet_wrap() 함수는 ~ 우변에 기술된 변수를 측면(facets)으로 하여 데이터를 나누어 그래프를 그린다. 이 때 측면(facets)으로 사용되는 변수는 범주형 데이터이어야 한다. facet_wrap()은 부분 그래프가 많아지면 줄바꿈하여 그래프를 표시한다. ncol이나 ncol을 설정하면 그래프의 행과 열의 수를 지정하여 줄바꿈 처리를 제어할 수 있다. ggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) + facet_wrap(~class, nrow = 2) 두 개 이상의 변수를 조합하여 측면을 만드려면 다음처럼 수식의 우변에 두 개의 변수를 +로 연결하여 기술하면 된다. ggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) + facet_wrap(~drv + year, nrow = 2) 8.3.2 facet_grid()로 이차원 측면 그래프 그리기 원래 그래프를 두 변수의 측면에서 나누어 그리기를 하려면 facet_grid()를 사용하는 것이 좋다. facet_grid()도 수식은 인수로 입력 받는데, 수식의 좌변과 우변에 데이터의 변수를 지정할 수 있다. 그러면 수식의 좌변에 기술된 변수를 그래프의 행으로, 우변에 기술된 변수를 그래프의 열로 하여 측면 그래프를 그린다. ggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) + facet_grid(drv~cyl) facet_wrap() 함수와 마찬가지로 수식의 좌변과 우변에 +로 하나 이상의 변수를 지정할 수 있다. ggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) + facet_grid(drv+year~cyl) 8.4 그래프 계층(layers)과 도형(geoms) ggplot2의 장점은 필요에 따라 다양한 형식의 그래프를 쉽게 만들 수 있고, 만들 수 있는 형식도 무궁무진하다는데 있다. ggplot2 그래프의 계층적 구조와 데이터 열과 속성을 자유롭게 매핑할 수 있다는 점이 이러한 무궁무진한 그래프 형식을 만들어 내는 핵심 요소라 할 수 있다. 8.4.1 geom 함수의 순서와 그래프 계층 ggplot2는 좌표평면 위에 여러 계층으로 그래프를 그려서 하나의 좌표평명에 나타냄으로써 복잡한 형식의 그래프를 만들어 낼 수 있다. 다음 두 그래프에서는 배기량과 고속도로 연비의 산점도와 추세선을 각각 그렸다. ggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) ggplot() + geom_smooth(mapping=aes(x=displ, y=hwy), data=mpg) `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; 위의 두 그래프는 다음처럼 한 좌표평면 위에 겹쳐서 그릴 수 있다. ggplot2에서 서로 다른 geom 함수는 서로 다른 도형-앞의 예는 점과 추세선-을 그래프에 표시한다. ggplot() 함수가 여러 개의 geom 함수와 연결되면, 하나의 좌표평면에 각각의 geom() 함수의 결과를 층층이 그린다. 이 때, 명령문에 나타나는 순서에 따라 첫번째 나온 geom 함수의 도형이 가장 아래 계층에, 다음에 나오는 geom 함수의 도형이 차례로 그 윗 계층에 그려진다. ggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) + geom_smooth(mapping=aes(x=displ, y=hwy), data=mpg) `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; 8.4.2 ggplot() 함수는 좌표축을 자동 조정한다. 만약 위의 그래프에 배기량과 도심연비의 산점도와 추세선을 겹쳐서 표시하려면 다음처럼 네 계층으로 이루어진 그래프를 그린다. ggplot() 함수가 데이터에 따라 좌표평면의 범위를 자동적으로 조정하는 것을 볼 수 있다. ggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) + geom_smooth(mapping=aes(x=displ, y=hwy), data=mpg) + geom_point(mapping=aes(x=displ, y=cty), data=mpg, col=&quot;red&quot;, shape=1) + geom_smooth(mapping=aes(x=displ, y=cty), data=mpg, linetype=2, col=&quot;red&quot;) `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; 8.4.3 여러 데이터를 사용하여 그래프 계층 만들기 지금까지는 동일한 데이터(data)에 대해서 geom 함수들이 그래프를 그렸다. 그러나 사실 각 계층의 geom 함수가 이용할 data와 mapping을 독립적으로 설정할 수 있다. 다음 예는 mpg 데이터와 함께 R의 기본 패키지에서 제공하는 iris 데이터를 사용하여 그래프를 그려보자. head(iris) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5.0 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa iris 데이터는 꽃받침의 길이(‘Sepal.Length’)와 폭(‘Sepal.Width’) 열을 가지고 있는데, 이 두 열의 산점도를 앞의 그래프에 겹쳐서 그려보았다. ggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) + geom_smooth(mapping=aes(x=displ, y=hwy), data=mpg) + geom_point(mapping=aes(x=displ, y=cty), data=mpg, col=&quot;red&quot;, shape=1) + geom_smooth(mapping=aes(x=displ, y=cty), data=mpg, linetype=2, col=&quot;red&quot;) + geom_point(mapping=aes(x=Sepal.Length, y=Sepal.Width), data=iris, col=&quot;orange&quot;) `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; 물론 이 그래프는 배기량과 꽃받침의 길이를 같은 x-축으로, 고속도로 연비와 꽃받침의 폭을 같은 y-축으로 그래프를 그렸으므로 억지스러운 측면이 있다. 단지 아주 별개의 데이터를 동시에 사용해서 하나의 그래프를 그릴 수 있다는 것을 보여주기 위해 그린 그래프일 뿐이다. 그러나 이 예에서 다음 사실을 확인할 수 있다. 첫째, 서로 다른 데이터를 사용해도 좌표평면이 자동으로 조정되어 모든 계층의 도형이 모두 적절히 표시된다. 둘째, 아울러 축의 이름은 첫 계층의 geom 함수의 x와 y로 대응된 변수가 자동으로 선택된다. 뒤에서 보겠지만 labs() 함수 등을 사용하면 축의 이름을 자유롭게 변경할 수 있다. 8.4.4 다른 데이터 범위로 그래프 계층 만들기 8.2 절을 시작할 때, 주경향에서 벗어난 점들을 더 큰 빨간색 점으로 표현한 그래프를 보았을 것이다. 이 그래프는 어떻게 그렸을까? 답은 7.4 절에서 설명한 filter() 함수를 이용하여 예외적인 경향의 데이터만 뽑아낸 후, 이 데이터를 가지고 별도의 산점도를 그리는 것이다. 이 데이터를 이용해서 그린 산점도가 마지막 그래프 계층에 그려졌으므로 빨간 점이 원래의 검은 점 위에 그려진다. ggplot() + geom_point(mapping=aes(displ, hwy), data=mpg) + geom_point(mapping=aes(displ, hwy), data=filter(mpg, displ &gt; 5, hwy &gt; 20), color=&quot;red&quot;, size=2) 8.4.5 공통 data와 mapping의 설정 지금까지 geom 함수에 data와 mapping 인수를 각각 설정하였다. 그런데 공통된 data와 mapping을 사용하여 여러 층으로 그래프를 겹쳐 그리는 경우, 이러한 방식으로 data와 mapping을 일일이 설정하는 것은 귀찮을 뿐 아니라 명령문의 오류 가능성을 증가시키고 변경을 어렵게 만든다. 8.4.5.1 ggplot() 함수에 공통 데이터와 매핑 설정하기 ggplot() 함수는 좌표평면을 생성하는 기능뿐 아니라, 그래프 계층에 공통된 data와 mapping을 설정하는 기능도 가지고 있다. 다음 예에서는 배기량과 고속도로 연비의 산점도와 추세선을 공통된 data와 mapping 설정을 이용하여 그렸다. 주의할 점은 data와 mapping 인수의 위치가 geom 함수와 ggplot() 함수에서 반대라는 것이다. ggplot(data=mpg, mapping=aes(x=displ, y=hwy)) + geom_point() + geom_smooth() `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; 위와 같은 형식으로 명령문을 구성하면, 다음처럼 한 군데만 변경하면 고속도로 연비가 아니라 도심 연비로 산점도와 추세선을 그릴 수 있어 편리하다. ggplot(data=mpg, mapping=aes(x=displ, y=cty)) + geom_point() + geom_smooth() `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; 8.4.5.2 geom 함수에서 데이터와 매핑의 재정의 ggplot() 함수에 data와 mapping 인수가 정의되어 있어도, geom 함수에 이를 재지정할 수 있다. 이 경우 각 geom 함수에서 사용하는 data와 mapping은 다음 규칙에 의해 결정된다. geom 함수는 ggplot() 함수에 설정된 data와 mapping을 상속받아 그래프를 그린다. 만약 geom 함수에 data 인수가 설정되면 ggplot() 함수에 설정된 data는 무시된다. 만약 geom 함수에 mapping 인수가 설정되면 ggplot() 함수에 설정된 mapping에 geom 함수에 설정된 mapping이 추가된다. 만약 동일한 도형 속성에 대한 정의가 두 군데 나타나면 geom 함수의 설정이 사용된다. 도형 속성과 데이터 열의 매핑이 어디에 나타나는지에 따라 그래프가 어떻게 변화하는지 살펴보자. 다음은 ggplot() 함수에서 color 속성을 drv 열에 매핑하여 점과 추세선 모두 drv 값에 따라 구분되는 다른 색으로 표현하였다. ggplot(data=mpg, mapping=aes(x=displ, y=hwy, color=drv)) + geom_point() + geom_smooth() `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; 만약 color 속성의 drv 열 매핑을 geom_point()로 옮기면 어떻게 될까? 다음 결과에서 보듯이 color 속성이 점에만 매핑되었으므로, 점만 drv에 따라 구분되어 색상이 표시되고, 추세선은 모든 데이터에 대하여 하나만 그려지는 것을 볼 수 있다. 왜냐하면 geom_smooth()는 ggplot()에 매핑된 x와 y 속성에 대한 매핑만 상속 받고, 다른 계층에 있는 매핑은 상속받지 않기 때문이다. ggplot(data=mpg, mapping=aes(x=displ, y=hwy)) + geom_point(mapping=aes(color=drv)) + geom_smooth() `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; 마찬가지로 color 속성의 drv 열 매핑을 geom_smooth()로 옮기면 추세선만 drv에 따라 구분된 색상으로 각각 표시되고, 점은 모든 데이터에 대하여 하나의 색상으로 구별없이 표현되는 것을 볼 수 있다. ggplot(data=mpg, mapping=aes(x=displ, y=hwy)) + geom_point() + geom_smooth(mapping=aes(color=drv)) `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; geom 함수들은 ggplot() 함수에서 상속한 매핑에다 새로운 매핑을 추가할 수도 있다. 앞의 배기량과 고속도로 연비의 산점도와 추세선을 그린 그래프에서 추세선을 선 종류(linttype)가 구동 방식(drv)에 따라 다르게 표현하고 싶다. 그런데 산점도는 점이라는 도형으로 그래프를 그리므로 선 종류라는 속성을 가지고 있지 않다. 그리고 산점도도 점의 모양(shape)이 구동 방식에 따라 다르게 표현하고 싶다고 하자. 마찬가지로 추세선은 선이라는 도형으로 그래프를 그리므로 점의 모양이라는 속성을 가지고 있지 않다. 이렇듯 여러 geom 함수를 연결하여 그래프를 그릴 때, 특정 geom 함수에만 해당하는 속성은 해당 geom 함수에서 속성과 데이터 열을 매핑하는 것이 좋다. geom 함수도 ggplot() 함수처럼 aes() 함수를 이용하여 그래프 속성과 데이터 열을 매핑하는데, 이 매핑이 geom 함수의 첫 번째 인수로 기술된다는 점만 다르다. ggplot(data=mpg, mapping=aes(x=displ, y=hwy, color=drv)) + geom_point(mapping=aes(shape=drv)) + geom_smooth(mapping=aes(linetype=drv)) `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; 또한 ggplot() 함수에 이미 설정된 매핑 중 일부 매핑판을 geom 함수에서 다시 설정할 수도 있다. 다음은 배기량과 고속도로 연비의 산점도와 추세선에 배기량과 도심 연비의 추세선을 더한 그래프는 다음 명령으로도 그릴 수 있다. 두 번째로 나타나는 geom_point()와 geom_smooth()에서 y의 매핑을 hwy가 아니라 cty로 변경한 것을 볼 수 있다. ggplot(data=mpg, mapping=aes(x=displ, y=hwy)) + geom_point() + geom_smooth() + geom_point(mapping=aes(y=cty), col=&quot;red&quot;, shape=1) + geom_smooth(mapping=aes(y=cty), linetype=2, col=&quot;red&quot;) `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; 아울러 geom 함수에서 ggplot() 함수에 정의된 데이터도 재설정할 수 있다. 다음 그래프에서는 추세선을 자동차 종류가 suv인 데이터에 대해서만 그려지도록 하였다. 이를 위해 filter 함수를 이용하여 mpg 데이터에서 class 변수가 suv인 관측치만 선택하여 새로운 데이터를 만들어 geom_smooth() 함수의 data 인수에 설정하였다. 그리고 geom_smooth()에 설정된 데이터는 해당 계층에서만 유효한 것이고, geom_point()는 ggplot() 함수에 정의된 전체 mpg 데이터를 사용하여 점을 그리고 있음을 확인하라. ggplot(data=mpg, mapping=aes(x=displ, y=hwy)) + geom_point(aes(color=class)) + geom_smooth(data=filter(mpg, class==&quot;suv&quot;)) `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; 8.4.5.3 ggplot()과 geom 함수에서 대표 인수의 이름을 생략하기 지금까지 공통 데이터와 매핑을 ggplot() 함수에 기술하여 명령문을 단순화하였다. 그런데 이 명령문들은 더 단순화할 수 있다. R 함수에서 인수를 인수의 순서대로 입력하는 경우에는 인수의 이름을 굳이 표시하지 않아도 된다. ggplot() 함수의 처음 두 인수는 차례로 data와 mapping이고 모든 geom 함수의 처음 두 인수는 차레로 mapping과 data이다. 또한 aes() 함수의 처음 두 인수는 x와 y이다. 따라서 이 정보를 사용하면 위 명령어는 다음처럼 단순해 진다. 주의할 점은 마지막 점과 추세선 geom 함수의 aes() 함수에서는 y만 나오므로 인수 이름을 사용하였다. ggplot(mpg, aes(displ, hwy)) + geom_point() + geom_smooth() + geom_point(aes(y=cty), col=&quot;red&quot;, shape=1) + geom_smooth(aes(y=cty), linetype=2, col=&quot;red&quot;) 8.5 ggplot 명령문을 입력할 때 자주 발생하는 문제들 ggplot은 매우 강력한 기능을 가지고 있지만 Excel 등의 GUI 프로그램에만 익숙한 사람은 문자 기반 명령어를 입력하는 것에 어려움을 느낄 수 있다. 컴퓨터는 사람만큼의 유연성을 발휘하지 못하므로 컴퓨터는 자신이 실행해야 할 명령문의 문법에 매우 까다롭게 반응한다. ggplot 명령어 입력시 흔히 발생하는 문제들은 다음과 같다. R 명령문은 대소문자를 구분한다. 따라서 Color와 color는 ggplot에서 서로 다른 인수로 인식되어 오류가 발생한다. ggplot 명령문의 키워드의 철자가 틀리면 다른 키워드로 간주하기 때문에 오류가 발생할 수 있다. 이를 방지하려면 키워드의 일부만 입력한 후 Tab 키를 눌러 자동완성 기능을 사용하여 입력하는 것을 권장한다. R 명령문이 조금 길어지면 가장 흔하게 발생하는 실수가 ( )와 \" \"을 짝을 맞추어 제대로 입력하지 못하는 것이다. ggplot2의 명령문도 많은 함수를 사용하다 보니 이를 주의하여야 한다. R 콘솔은 명령이 계속 입력 중이라고 생각하여 &gt;가 아니라 +를 콘솔의 프롬프트로 표시한다. 이 경우 가장 간단한 해결책은 Esc 키를 눌러 명령 입력에서 빠져나와 다시 명령문을 입력하는 것이다. ggplot2의 명령문을 입력할 때 여러 함수를 합쳐서 실행하기 위하여 + 연산자를 이용한다.7 ggplot2의 명령문이 길어지면 명령문을 여러 줄로 쓰는 것이 필요한데, 보통 +로 연결되는 곳에서 줄바꿈하는 것이 읽기에 좋다. 이 때 주의할 점이, 줄바꿈을 + 앞이 아니라 뒤에서 해야 한다는 것이다. + 앞에서 하면 R은 명령문의 입력이 완성된 것으로 간주하기 때문이다. 다음은 산점도와 추세선을 한 그래프에 그린 예이다. ggplot(mpg, aes(x=displ, y=hwy, color=drv)) + geom_point() + geom_smooth() `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; 그런데 위의 명령어는 길기 때문에 스크립트 파일을 작성할 때 보기에 불편하다. 이러한 경우에 위의 명령은 다음처럼 세 줄로 나누어 기술될 수 있다. 세 함수를 연결하는 + 위치가 어디에 있는지 살펴보라. (다음 예에서 왼쪽의 &gt; 프롬프트 아래 있는 +는 R 콘솔에서 명령문이 계속되고 있음을 나타내는 표시이다. 이 표시와 사용자가 입력한 +를 혼동하면 안 된다.) ggplot(mpg, aes(x=displ, y=hwy, color=drv)) + geom_point() + geom_smooth() 만약 다음처럼 + 위치가 잘못되면 오류가 발생한다. 왜 이런 결과가 나왔고 오류 메시지의 의미는 무엇일까? R은 Enter로 명령문을 구분한다. 그러므로 첫번째 줄은 +가 없으므로 완벽한 명령문이기 입력된 것으로 간주하고 실행이되어 좌표평면만 그린 것이다. 그러고 나서 두번째 줄을 새로운 명령문으로 실행을 한다. 그런데 갑자기 명령문이 +로 시작하니 R은 명령문에 오류가 있다고 판단한다. 왜냐하면 + 연산은 왼편과 오른편에 더할 요소가 있어야 하는데, 왼편의 요소가 기술되지 않았기 때문이다. ggplot(mpg, aes(x=displ, y=hwy, color=drv)) + geom_point() Error: ! Cannot use `+` with a single argument. ℹ Did you accidentally put `+` on a new line? 8.6 통계 변환 8.6.1 범주형 변수의 통계 요약 ggplot2 패키지의 diamonds는 약 54,000개의 다이아몬드에 대한 다음 정보를 측정한 데이터이다. caret: 다이아 몬드 무게 cut: 가공의 품질. Fair, Good, Very Good, Premium, Ideal color: 색상. D(최상)에서 F(최하)까지 clarity: 투명도. I1(최하), SI2, SI1, VS2, VS1, VVS2, VVS1, IF(최상) x, y, z: 길이, 폭, 깊이 depth: 깊이 비율 = z / mean(x, y) table: 최대폭 대비 윗면의 폭의 길이 비율 diamonds # A tibble: 53,940 × 10 carat cut color clarity depth table price x y z &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 4 0.29 Premium I VS2 62.4 58 334 4.2 4.23 2.63 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39 # ℹ 53,930 more rows 다이아몬드의 가공의 품질(cut) 수준에 따른 빈도를 시각화해 보자. 현재 cut의 수준별 빈도수에 대한 데이터가 없기 때문에 먼저 이 데이터를 구하기 위한 통계적 변환을 수행해야 한다. 이를 위해 뒤에 설명할 dplyr 패키지의 summarize() 함수를 이용하였다. cut_table &lt;- diamonds %&gt;% group_by(cut) %&gt;% summarize(n=n()) cut_table # A tibble: 5 × 2 cut n &lt;ord&gt; &lt;int&gt; 1 Fair 1610 2 Good 4906 3 Very Good 12082 4 Premium 13791 5 Ideal 21551 그리고 geom_col() 함수를 이용하여 막대 그래프를 그린다. geom_col() 함수는 막대라는 도형을 그리는 geom 함수로 x 값의 위치에 y에 매핑된 값을 높이로 가지는 막대를 그린다. ggplot(cut_table) + geom_col(aes(x=cut, y=n)) 그런데 geom 함수의 stat 인수를 이용하면 원래 데이터를 통계 요약하여 그래프를 그리는 과정을 사용자의 개입없이 쉽게 수행할 수 있다. ggplot(diamonds) + geom_bar(aes(x=cut), stat=&quot;count&quot;) 그림 8.2는 geom_bar() 함수에서 stat 인수가 어떻게 작동하는지를 보여준다. geom_bar() 함수는 stat 인수에 \"count\"가 설정되면 stat_count() 함수를 사용하여 원래 데이터를 통계 요약한다. stat_count()는 x에 맵핑된 열을 수준(level; 구분되는 값) 별로 절대적 빈도와 상대적 빈도를 계산하여 count와 prop라는 열을 가지는 요약 데이터를 만든다. 그리고 이 요약 데이터를 이용하여 x-축에 원래 변수의 수준을, y-축에 count 변수를 맵핑하여 막대 그래프를 그린다. Figure 8.2: stat의 작동 방식 (출처: R for Data Science) 사실 geom_bar() 함수의 디폴트 stat는 \"count\"이기 때문에, stat를 생략하여도 같은 결과를 얻을 수 있다. ggplot(diamonds) + geom_bar(aes(x=color)) stat_count()가 요약한 데이터에서 절대 빈도수 count가 아니라 상대 빈도수 prop을 사용하여 그래프를 그리려면 y=after_stat(prop)을 mapping에 추가하여야 한다. stat가 생성한 요약 데이터의 열을 지정할 때는 after_stat(요약변수) 형식으로 지정을 한다. 그래야 원래 데이터가 아니라 요약 데이터에서 해당 열을 찾아 매핑을 한다. 상대 빈도는 group 속성에 따라 계산을 하는데, 전체 데이터를 대상으로 상대 빈도를 구하기 위해 모든 데이터가 동일한 그룹이 되도록 group=1로 설정을 하였다.8 ggplot(diamonds) + geom_bar(aes(clarity, after_stat(prop), group=1)) 8.6.2 수치형 변수의 통계 요약 carat 같은 연속형 변수에 geom_bar()를 적용하면 구별되는 모든 수치에 대해 빈도를 계산하여 막대를 그린다. 그러나 연속형 변수는 구별되는 값이 매우 많으므로 이렇게 만들어진 그래프로 데이터의 경향을 파악하긴 어렵다. ggplot(diamonds) + geom_bar(aes(carat)) 8.6.2.1 stat_bin()을 이용한 히스토그램 연속형 변수는 구분되는 값이 아니라 일정한 구간 별로 빈도를 계산하여 막대 그래프를 그리는 것이 더 적절하다. (이러한 그래프를 히스토그램이라고 한다.) stat 인수에 stat_bin()을 사용하면 x에 맵핑된 연속형 변수의 값을 구간으로 나누어 이러한 작업을 한다. ggplot(diamonds) + geom_bar(aes(carat), stat=&quot;bin&quot;) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 8.6.2.2 geom_histogram() 사실 stat_bin()을 디폴트 stat로 사용하는 geom 함수가 있다. geom_histogram()이 그 함수이다. geom_histogram()를 이용하면 다음처럼 연속형 변수에 대한 히스토그램을 그릴 수 있다. ggplot(diamonds) + geom_histogram(aes(carat)) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 그리고 bins 또는 binwidth 인수를 사용하면 구간의 수 또는 구간의 길이를 직접 지정하여 히스토그램을 그릴 수 있다. ggplot(diamonds) + geom_histogram(aes(table), bins=50) ggplot(diamonds) + geom_histogram(aes(price), binwidth=500) stat_bin()은 구간 별 절대 빈도수(count)뿐 아니라 구간의 밀도(density)와 빈도수와 밀도의 최대 값이 1이 되도록 규모를 변환한 ncount와 ndensity 변수도 생성한다. 그러므로 필요에 따라 이 값을 이용하여 히스토그램을 그림 수 있다. ggplot(diamonds) + geom_histogram(aes(x=x, y=after_stat(density))) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(diamonds) + geom_histogram(aes(x=y, y=after_stat(ncount))) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(diamonds) + geom_histogram(aes(x=z, y=after_stat(ndensity))) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 8.6.2.3 geom_boxplot() geom_boxplot() 함수는 수치 변수를 4분위수와 이상치로 요약하여 그래프를 그려준다. 다음은 다이아몬드의 중량(carat) 변수에 대한 4분위수와 이상치를 상자 그래프로 표시한 예이다. ggplot(diamonds) + geom_boxplot(aes(y = carat)) 상자 그래프에 대한 해석은 다음처럼 한다. 상자의 상단의 3분위수를 표현한다. 상자의 하단은 1분위수를 표현한다. 상자의 가운데 선분은 중위수(2분위수)를 표현한다. 상자의 상단과 하단의 길이를 inter-quartile range라고 하고 IQR이라고 표현한다. 일반적으로 3분위 수에서 1.5 IQR보다 큰 수치나, 1분위수에서 1.5 IQR보다 작은 수치는 이상치(outliers)라고 판단한다. 상자의 하단과 상단에 나타나는 선분은 1.5 IQR 내의 최소치와 최대치를 나타낸다. 상자의 상하단에서 1.5 IQR 바깥에 있는 데이터는 이상치로 보고 점으로 표시한다. 상자 그래프는 위와 같이 세로축을 기준으로 그리기도 하지만 다음처럼 가로축을 기준으로 표시하기도 한다. 가로축으로 그래프를 표시하려면 수치 변수를 y가 아니라 x에 매핑을 하여야 한다. ggplot(diamonds) + geom_boxplot(aes(x = carat)) 상자 그래프는 앞의 예처럼 한 수치형 변수를 요약할 때는 잘 사용되지 않는다. 왜냐하면 히스토그램이 수치형 변수를 더 자세히 요약할 수 있기 때문이다. 상자 그래프는 주로 다음 절에서 보듯이 범주형 변수와 수치형 변수의 관계를 탐색할 때 주로 이용한다. 8.6.3 수치형 변수의 범주별 통계요약 다이아몬드의 가격이 가공 품질에 따라 어떤 범위로 움지이는지 살펴보자. 이 때 유용한 geom 함수가 geom_boxplot()이다. geom_boxplot() 함수는 상자그림으로 수치 데이터를 표현한다. 이 함수는 stat로 stat_boxplot()을 디폴트로 사용한다. stat_boxplot()은 x에 매핑된 열의 수준 별로 y에 매핑된 데이터를 모아서 상자그림에 필요한 통계량을 계산한다. ggplot(diamonds) + geom_boxplot(aes(cut, price)) ggplot(diamonds) + geom_boxplot(aes(cut, carat), notch=T) 이 외에도 stat_summary()를 이용하면 연속형 변수 데이터를 범주별로 나누어 함수를 적용한 결과를 출력할 수 있다. fun, fun.max, fun.min에 각각 수치 변수를 요약할 함수를 지정하면 해당 함수로 수치의 값을 y, ymax, ymin이라는 변수로 요약한다. 다음은 가공품질(cut) 별로 다이아몬드의 깊이(depth)의 중위수, 최대값, 최소값을 점과 구간으로 나타낸 결과이다. ggplot(diamonds, aes(cut, depth)) + stat_summary(fun=median, fun.max=max, fun.min=min) 위의 예에서 geom 함수를 사용하지 않고 stat 함수를 ggplot() 함수에 연결한 것을 볼 수 있다. geom 함수마다 디폴트 stat 함수가 정의되어 있는 것처럼, stat 함수에는 디폴트 geom 함수가 정의되어 있다. 그래서 위와 같이 stat 함수가 그래프의 계층(layer)로 사용되면 stat 함수의 디폴트 geom 함수에 의해 요약 결과가 그려진다. stat_summary() 함수의 디폴트 geom 함수는 geom_pointrange()로 점과 구간으로 그래프를 표현해 준다. 8.7 위치 조정 geom_bar()는 막대의 색상과 관련된 fill, color, alpha라는 속성이 있는데, 각각 막대의 색, 막대 테두리 색, 막대 색의 투명도를 조정한다. 다음은 mpg 데이터에서 class별 빈도를 막대 그래프로 그린 예이다. fill 속성 인수에 남색을 부여하였다. ggplot(mpg) + geom_bar(aes(class), fill=&quot;dark blue&quot;) ggplot(mpg) + geom_bar(aes(class), color=&quot;dark blue&quot;) 앞의 막대 그래프는 class별로 데이터의 빈도를 구해 한 색상으로 막대를 그렸다. 이번에는 class 별 빈도에 대한 막대 그래프를 그리는데 fill 속성에 drv 열을 매핑하여 어떤 차이가 있는지 살펴보자. ggplot(mpg) + geom_bar(aes(class, fill=drv)) fill 속성에 drv라는 이산 변수가 매핑되자, 동일한 class 값이지만 서로 다른 drv의 값을 가지는 경우를 구분하여 다른 색상으로 막대를 그렸다. 그리고 동일한 class인데 drv 값이 다른 막대를 동일한 가록축에 층(stack)으로 쌓아 올렸다. 예를 들어 subcompact 클래스의 경우 drv가 4, f, r이 모두 있으므로 총 3개의 막대가 그려져야 한다. 그러나 이 3 막대는 모두 동일한 x 값을 가지므로 서로 겹치는 것을 피하기 위하여 쌓아 표현하였다. geom 함수에서 position 인수는 동일한 위치의 도형 객체를 어떻게 조화롭게 표현할지를 결정한다. 앞의 예에서는 geom_bar()의 position 인수의 디폴트 값은 \"stack\"이므로 같은 x 위치의 막대를 쌓아 표현하였다. 만약 같은 위치의 막대를 쌓아 표현하지 않고 옆으로 나란히 세워 표현하고 싶으면 postion 인수를 \"dodge\"로 설정한다. ggplot(mpg) + geom_bar(aes(class, fill=drv), position=&quot;dodge&quot;) geom 함수에 따라 취할 수 있는 position 인수의 값은 다를 수 있다. geom_bar()의 경우 \"stack\", \"dodge\", \"fill\" 그리고 \"identity\" 값을 가질 수 있다. (여기서 \"fill\"과 \"identity\"는 막대의 fill 속성이나 통계 요약 함수인 stat_identity()와는 상관없는 동일 위치의 도형의 위치 조정에 관한 값이다.) position인수가 \"fill\"이면, 막대의 전체 길이가 1이 되도록 조정하여 동일한 x의 값에서의 상대적 비율을 파악할 수 있게 해준다. ggplot(mpg) + geom_bar(aes(class, fill=drv), position=&quot;fill&quot;) position이 \"identity\"로 설정되면 동일한 위치에 겹쳐지는 geom 객체에 아무 조정도 하지 않는다. 앞과 동일한 예에서 position=\"identity\"로 설정해 보자. 모두 동일한 자리에 그려지므로 아래 그려진 막대가 가려지므로 막대의 윤곽선만 그리고 투명도를 조정하여 겹쳐진 막대를 확인할 수 있도록 하자. ggplot(mpg) + geom_bar(aes(class, col=drv), position=&quot;identity&quot;, alpha=0.1) 사실 \"identity\" position은 막대 그래프에서 별로 유용한 조정 방법이 아니다. 그러나 geom_frepoly() 등 빈도를 선으로 표현하는 geom 객체에는 매우 유용하다. ggplot(mpg) + geom_freqpoly(aes(hwy, color=drv), position=&quot;identity&quot;) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 사실 geom_freqpoly()는 \"identity\"를 position의 디폴트 값으로 가지므로 다음 명령어도 동일한 결과를 준다. ggplot(mpg) + geom_freqpoly(aes(hwy, color=drv)) 8.8 ggplot2 그래프의 종류 이 절에서는 ggplot2에서 그릴 수 있는 대표적인 그래프 종류를 하나씩 살펴본다. 그래프는 결국 데이터를 시각적 객체로 변환한 것이므로 그래프의 종류는 그래프가 어떤 geom 객체를 이용하는가에 따라 나눠 볼 수 있다. Table 8.1에는 그래프에서 자주 사용되는 geom 함수들이 제시되어 있다. Table 8.1: geom 함수 함수 도형 도형의.속성 geom_bar() Bar chart color, fill, alpha geom_boxplot() Box plot color, fill, alpha, notch, width geom_density() Density plot color, fill, alpha, linetype geom_histogram() Histogram color, fill, alpha, linetype, binwidth geom_hline() Horizontal lines color, alpha, linetype, size geom_jitter() Jittered points color, size, alpha, shape geom_line() Line graph color, alpha, linetype, size geom_point() Scatterplot color, alpha, shape, size geom_rug() Rug plot color, side geom_smooth() Fitted line method, formula, color, fill, linetype, size geom_text() Text annotations 많은 옵션이 있으므로 도움말 참조 geom_violin() Violin plot color, fill, alpha, linetype geom_vline() Vertical lines color, alpha, linetype, size 한편 그래프는 데이터에 대한 시각적 표현이므로 표현하려는 데이터의 형식에 따라 그래프를 구분해 볼 수도 있다. 데이터의 각 변수는 크게 수치형 변수와 범주형 변수로 나누어 볼 수 있다. 앞으로 우리는 그래프에서 표현하려는 데이터가 무엇인지에 따라 다음처럼 그래프를 분류하여 살펴보고자 한다. 하나의 범주형 변수를 나타내는 그래프 하나의 수치형 변수를 나타내는 그래프 두 개의 범주형 변수의 관계를 나타내는 그래프 하나의 범주형 변수와 하나의 수치형 변수의 관계를 나타내는 그래프 두 개의 수치형 변수의 관계를 나타내는 그래프 세 개 이상의 변수의 관계를 나타내는 그래프 이를 각각 살펴보기에 앞서 그래프에 단순한 선과 도형을 표현하는 기본 함수를 먼저 살펴보자. 8.8.1 직선을 그리는 그래픽 함수 직선을 그리는 그래픽 함수를 살펴보기 위해 mpg 데이터에 대한 도심 연비와 고속도로 연비를 나타내는 산점도 그래프를 고려해 보자. p &lt;- ggplot(mpg, aes(cty, hwy)) + geom_point() p 앞의 산점도에 도심 연비와 고속도로 연비의 평균을 나타내보자. ggplot2에서는 수평선은 geom_hline(), 수직선은 geom_vline() 함수로 그릴 수 있다. 다음은 geom_vline()으로 도심연비의 평균선을 나타낸 예이다. xintercept는 수직선이 지나가는 x축의 절편의 값이다. linetype 인수는 선의 종류를 결정하는 인수인데, 1은 실선, 2는 파선을 나타낸다. 이 외에도 다양한 linetype을 설정할 수 있으니 자세한 내용은 ??linetype을 이용하여 관련된 설명을 확인해 보길 바란다. p + geom_vline(xintercept = mean(mpg$cty), linetype=2, color=&quot;red&quot;) 다음으로 geom_hline()으로 고속도로 연비의 평균선을 그려보자. yintercept는 수평선이 지나가는 y 절편의 값이다. p1 &lt;- p + geom_vline(xintercept = mean(mpg$cty), linetype=2, color=&quot;red&quot;) + geom_hline(yintercept = mean(mpg$hwy), linetype=2, color=&quot;red&quot;) p1 이렇게 그려 놓고 보면, 도심 및 고속도로 연비가 모두 평균 이상인 그룹과 어느 하나만 평균 이상인 그룹, 둘 다 평균 이하인 그룹을 구분해 볼 수 있다. 도심 연비와 고속도로 연비의 비율을 알기 위하여 기울기가 1이고 절편이 0인 직선을 그려보자. geom_abline()은 절편이 a, 기울기가 b인 직선을 그래프에 그려준다. 결과에서 확인하듯이 모든 차들이 도심 연비에 비해 고속도로 연비가 좋음을 확인할 수 있다. 아울러 두 연비의 비를 알아볼 수 있도록 scale 함수를 이용하여 좌표축의 범위를 동일하게 설정하였다(8.9 장 참조). p1 + geom_abline(a=0, b=1, linetype=3, color=&quot;blue&quot;) + scale_x_continuous(limits = c(0, 45)) + scale_y_continuous(limits = c(0, 45)) Warning in geom_abline(a = 0, b = 1, linetype = 3, color = &quot;blue&quot;): Ignoring unknown parameters: `a` and `b` 8.8.2 한 범주형 변수의 그래프 우리는 이미 geom_bar()를 이용하여 하나의 범주형 변수의 빈도에 대한 막대 그래프를 그리는 법을 보았다. 여기서는 범주형 변수의 막대 그래프 표현에 대하여 좀 더 자세히 살펴본다. 먼저 범주형 변수가 무엇인지 살펴보자. 범주형 변수란 변수의 값이 몇 개의 정해진 범주로 한정되는 변수라고 할 수 있다. 예를 들어 gender라는 변수가 어떤 수업의 수강생의 성별 정보를 표현하고 있다면, 남자 또는 여자라는 두 가지 범주에 의해서 데이터가 표현될 것이다. mpg의 class 열은 연비가 조사된 자동차의 종류를 compact, midsize, suv, 2seater, minivan, pickup, subcompact라는 7 가지 값으로 표현하는 변수이다. 다음 명령을 실행해 데이터를 확인해 보자. unique(mpg$class) [1] &quot;compact&quot; &quot;midsize&quot; &quot;suv&quot; &quot;2seater&quot; &quot;minivan&quot; [6] &quot;pickup&quot; &quot;subcompact&quot; ggplot2에서는 geom_bar() 함수를 이용하여 다음 형식 중 하나를 선택하여 막대 그래프를 그린다. ggplot(data=데이터, mapping=aes(x=범주형.변수.이름)) + geom_bar() ggplot(데이터, aes(범주형.변수.이름)) + geom_bar() ggplot(데이터) + geom_bar(aes(범주형.변수.이름)) ggplot() + geom_bar(aes(범주형.변수.이름), 데이터) geom_bar() 함수는 x에 매핑된 변수를 범주형 변수로 간주하고, 해당 변수에서 구분되는 값을 범주로 뽑아낸 후, 범주 별로 빈도수 계산한 후 이를 막대 그래프로 그려준다. (빈도수를 계산하는 과정은 사실 stat_count() 함수가 수행한다.) class 변수는 7가지의 구분되는 값으로 구성되어 있다. 문자열로 표현되는 범주는 알파벳 순으로 정렬되어 그래프의 가록축에 표현된다. 다음은 mpg 데이터의 class 열에 대한 막대 그래프를 그린 예이다. ggplot(mpg, aes(class)) + geom_bar() mpg 데이터이 cyl 열은 수치로 표현되어 있지만 사실은 실린더 개수이므로 4, 6, 8, 5라는 4 개의 범주를 가진 범주형 변수이다. geom_bar()를 이용하면 이 범주로 이용하여 빈도수를 계산한 후 막대 그래프로 그릴 수 있다. 범주가 수치인 경우에는 수의 크기로 정렬하여 가로축을 생성한다. ggplot(mpg, aes(cyl)) + geom_bar() 수치형 변수도 구별되는 값의 개수가 많지 않으면 geom_bar()를 이용할 수 있다. 예를 들어 도심 연비를 나타내는 cty는 다음처럼 총 21 개의 값을 가지고 있다. 그러므로 geom_bar()를 이용하여 각 값 별로 데이터의 빈도를 세어 막대 그래프를 그릴 수 있다. unique(mpg$cty) [1] 18 21 20 16 19 15 17 14 11 13 12 22 9 28 24 25 23 26 33 35 29 ggplot(mpg, aes(cty)) + geom_bar() 이 경우는 cty 변수에 구별되는 값이 많지 않아 막대 그래프로 표현해도 크게 어색하지 않다. 그러나 대부분의 수치형 변수는 연속적인 값을 가지므로 이런 식으로 막대 그래프를 그리기가 어렵다. 따라서 수치형 변수의 경우 geom_histogram()을 이용하여 구간으로 나누어 구간별 빈도에 대한 막대 그래프를 그리는 것이 좋다. 막대 그래프를 그릴 때 그래프의 x-축에 표현되는 범주의 순서를 바꾸고 싶을 때가 있다. 예를 들어 다음같은 drv에 대한 막대 그래프를 f, r, 4 순으로 막대를 표현하고 싶다고 하자. ggplot(mpg, aes(drv)) + geom_bar() geom_bar()는 기본적으로 문자는 알파벳 순으로 숫자는 숫자의 크기 순으로 정렬하여 막대를 그리므로 이를 바꾸고 싶으면 요인(factor)로 바꾸어야 한다. 요인의 경우는 수준(levels)에 정의된 순서에 따라 막대 그래프를 그리기 때문이다. 마지막의 labs() 함수는 x-축의 레이블을 \"drv\"로 표시하기 위해 사용되었다. 이 함구가 없으면 x-축 레이블이 어떻게 변하는지 확인해 보라. ggplot(mpg, aes(factor(drv, levels=c(&quot;f&quot;, &quot;r&quot;, &quot;4&quot;)))) + geom_bar() + labs(x=&quot;drv&quot;) 다음 예는 mpg의 class 데이터에서 빈도가 작은 범주부터 차례로 막대가 나오도록 하는 예이다. reorder() 함수는 첫 번째 인수인 factor를 두 번째 인수로 주어진 벡터를 factor의 범주 별로 나누어 세 번째 인수로 주어진 함수를 적용한 결과의 순서로 factor의 levels를 정렬한다. 아래 예에서 세 번째 인수로 length() 함수가 설정되었으므로, class 열의 범주 별 개수에 의해 class 열의 범주가 정렬된다. ggplot(mpg) + geom_bar(aes(reorder(class, class, length))) + labs(x=&quot;class&quot;) 위의 예에서 reorder() 함수는 결과가 작은 범주부터 큰 범주로 levels를 정렬하는 것을 알 수 있다. 만약 결과가 큰 범주부터 작은 범주로 levels를 정렬하려면 어떻게 해야 할까? 다음처럼 length() 함수의 결과를 음수로 바꾸면 가장 빈도가 큰 범주가 가장 작은 수가 되므로 원하는 결과를 얻을 수 있다. ggplot(mpg) + geom_bar(aes(reorder(class, class, function(x) -length(x))))+ labs(x=&quot;class&quot;) reorder() 함수로 범주의 순서를 결정할 때, 다른 변수의 값으로도 정렬이 가능하다. 다음은 class의 범주를 hwy의 평균이 작은 것에서 큰 것 순으로 정렬한 예이다. ggplot(mpg) + geom_bar(aes(reorder(class, hwy, mean))) + labs(x=&quot;class&quot;) 정말로 hwy 평균에 따라 class의 범주가 정렬되었는지 확인해 보자. 다음 결과에서 정말 그렇게 되었음을 확인할 수 있다. mpg %&gt;% group_by(class) %&gt;% summarise(hwy_mean = mean(hwy)) %&gt;% arrange(hwy_mean) # A tibble: 7 × 2 class hwy_mean &lt;chr&gt; &lt;dbl&gt; 1 pickup 16.9 2 suv 18.1 3 minivan 22.4 4 2seater 24.8 5 midsize 27.3 6 subcompact 28.1 7 compact 28.3 범주형 데이터를 막대로 그릴 때, 각 범주별 데이터를 다른 변수로 좀 더 세분화하여 살펴보고 싶을 때가 있다. 이 경우 흔히 한 범주를 표현하는 막대를 다른 변수의 범주에 따라 색상으로 구분하여 세분화하여 표현한다. geom_bar()의 fill aesthetics에 범주형 변수를 매핑하면 각 범주별로 색상을 달리 표시한다. 다음은 class별 막대 그래프를 년도(year)로 더 세분화하여 표현한 경우이다. mpg 데이터의 year 변수는 수치형 데이터로 표현되어 있으므로 factor() 함수를 이용하여 이산형으로 변형하여 fill aesthetics에 매핑하였다. ggplot(mpg, aes(class, fill=factor(year))) + geom_bar() + labs(fill=&quot;year&quot;) 만약 각 class 값에 따라 1999년도와 2008년도의 상대적 빈도를 비교해 보고 싶다면, 다음처럼 position 인수를 \"fill\"로 설정하면 된다. postion 인수에 대한 자세한 설명은 8.7 절을 참조하기 바란다. 이렇게 하면 막대 그래프를 이용하여 두 범주형 변수의 관계를 살펴볼 수 있다. ggplot(mpg, aes(class, fill=factor(year))) + geom_bar(position=&quot;fill&quot;) + labs(fill=&quot;year&quot;) 8.8.3 한 수치형 변수의 그래프 한 수치형 변수에서 일차적으로 확인해야 할 내용은 그 변수의 분포이다. 분포를 확인하는 가장 단순한 방법은 수치를 구간으로 나누어 빈도를 나타내는 히스토그램을 그려보는 것이다. geom_histogram() 함수는 x로 매핑된 변수를 구간으로 나누어 빈도수를 구한 후 - 이 작업은 stat_bin() 함수가 수행한다 - 막대 형태의 히스토그램 그래프를 그려준다. 다음은 고속도로 연비 데이터를 구간 크기를 2로하여 나눈 후 히스토그램을 그린 예이다. 구간의 길이는 bandwidth 인수를 이용하여 설정한다. ggplot(mpg, aes(hwy)) + geom_histogram(binwidth=2) 히그토그램은 구간의 크기에 따라 다른 모양의 그래프가 나오므로, 구간의 크기를 변화시키면서 분포를 가장 적절하게 나타내는 구간크기를 찾아 보아야 한다. ggplot(mpg, aes(hwy)) + geom_histogram(binwidth=1) 그런데 앞의 고속도로 연비 히스토그램을 보면 두 개의 봉우리를 가지는 분포를 보인다. 이처럼 분포에 여러 봉우리가 나타날 때는 서로 다른 특성을 가지는 데이터 그룹이 하나로 섞여 있기 때문인 경우가 많다. 예를 들어 성인의 키의 분포를 그리면 남자와 여자라는 서로 다른 특성의 그룹 때문에 쌍봉 형태의 그래프가 나온다. 고속도로 연비가 쌍봉 형태를 보이는 것이 자동차의 구동 방식 때문인지를 한번 살펴보자. 다음처럼 fill aesthetics에 drv 변수를 매핑하면 빈도를 drv 요소로 분해하여 살펴볼 수 있다. 결과에서 보듯이 왼쪽 봉우리는 주로 4륜 구동(4) 차가, 오른쪽 봉우리는 전륜 구동(f) 차가 분포의 대부분을 차지하고 있음을 볼 수 있다. ggplot(mpg, aes(hwy, fill=drv)) + geom_histogram(binwidth=1) 그런데 앞의 예에서 geom_histogram()은 디폴트 position이 \"stack\"으로 설정되어 있어서 쌓인 형태로 막대 그래프가 나타났다. 쌓인 그래프 형태로 표현되다 보니 각 구동방식에 따른 고속도로 연비의 분포를 파악하기는 어렵다. 이런 경우 geom_freqpoly()를 이용하여 각 범주별 분포를 분리하여 그려보면 좋다. geom_freqpoly()는 geom_histogram()과 마찬가지로 연속형 수치 변수를 구간으로 나누어 빈도를 보여주는데, 막대가 아니라 선을 이용하여 빈도를 보여준다. ggplot(mpg, aes(hwy)) + geom_freqpoly(binwidth=2) 따라서 여러 그룹으로 나누어 구간으로 나누어 빈도를 보일 때도 서로 구분이 용이하다. geom_freqpoly()의 디폴트 position은 \"identity\"이다. 아래 그래프를 보면 4륜 구동과 전륜 구동의 분포에 의해 전체 분포에서 쌍봉이 나타났음을 뚜렷하게 확인할 수 있다. ggplot(mpg, aes(hwy, color=drv)) + geom_freqpoly(binwidth=2) 그런데 위의 그래프는 구동방식에 따라 구간별 고속도로 연비의 절대빈도를 보여준다. 따라서 데이터 수가 적은 후륜 구동(r)의 경우 매우 작게 표시되어 상대적인 분포를 확인하기 어렵다. 이런 경우 전체 면적을 1로하는 상대빈도를 이용하여 그래프를 나타내는 것이 더 좋다. geom_histogram()과 geom_freqpoly() 모두 디필트 stat로 stat_bin()을 이용하는데, 이 함수는 x로 매핑된 변수를 구간으로 나누어 구간별 빈도(count), 밀도(density), 최대값이 1로 조정된 빈도(ncount), 최대값이 1로 조정된 밀도(ndensity) 등을 산출한다. 특별한 지시가 없으면 stat_bin()은 count 변수를 y로 매핑하여 준다. 그리고 이 y 값을 geom_histogram()에서는 막대의 높이로, geom_freqpoly()에서는 선의 y 값으로 이용한다. count 대신 density를 이용하여 그래프를 그리고 싶으면, aes() 매핑에서 y가 density가 되도록 매핑하면 된다. 단, 이 때 stat 함수에 의해 계산된 변수는 after_stat(요약변수) 형태로 표시한다. ggplot(mpg, aes(hwy, after_stat(density), color=drv)) + geom_freqpoly(binwidth=2) 4륜 구동 차는 15에서 20사이의 구간에서 가장 많은 빈도를 보였고, 후륜구동 차는 15에서 30 사이로 펴져서 분포를 하고 있고, 전륜구동 차는 25에서 30에서 가장 많은 빈도를 보이는 것을 확인할 수 있다. 그런데 geom_histogram()과 geom_freqpoly()는 구간을 어떻게 나누는가에 따라 그래프의 형태가 크게 달라지는 단점이 있다. geom_density() 함수는 수치형 변수의 값을 사용하여 확률밀도를 추정한 후 추정된 확률밀도에 대한 그래프를 보여주므로 구간 나누기의 임의성을 피할 수 있다. ggplot(mpg, aes(hwy)) + geom_density() ggplot(mpg, aes(hwy, color=drv)) + geom_density() 8.8.4 두 범주형 변수의 그래프 두 범주형 변수의 관계는 8.8.2 절에서 본 것과 같이 한 범주형 변수의 막대 그래프에 fill aesthetics에 다른 범주형 변수를 매핑하여 두 변수의 관계를 살펴보거나, 아니면 다음처럼 facet을 이용하여 한 범주형 변수의 값을 고정시켜 놓고 다른 범주형 변수에 대해 막대 그래프를 그려 두 변수의 관계를 살펴본다. ggplot(mpg, aes(class)) + geom_bar() + facet_wrap(~drv) 이 경우 절대빈도로 막대 그래프가 표시되어 facet에 지정된 변수의 값에 따라 분포가 다른지 비교하기가 어렵다. geom_bar()의 디폴트 stat인 stat_count()는 x로 매핑된 변수에 대해 범주별로 빈도수를 세어 count 변수에 저장하고, 상대빈도를 prop 변수에 저장한다. stat_count()는 디폴트로 count 변수의 값을 y에 매핑한다. 만약 prop 변수를 막대 그래프의 y의 값으로 매핑하려면, y를 after_stat(prop)으로 지정한다. (8.8.3 절에서 설명한 바와 같이 stat 함수가 생성한 변수의 지정은 after_stat(요약변수)의 형식을 사용한다.) 그러면 각 범주별 상대 빈도가 나타나 facet으로 지정된 변수의 값에 따라 상대적 비율이 달라지는지 비교해 볼 수 있다. ggplot(mpg, aes(class, after_stat(prop), group=drv)) + geom_bar() + facet_wrap(~drv) 두 범주형 변수의 관계를 살펴보는 또 다른 방법은 두 범주형 변수의 데이터를 산점도로 표시해 보는 것이다. ggplot(mpg, aes(class, drv)) + geom_point() 그런데, 문제는 같은 값을 갖는 데이터가 너무 많으므로 여러 데이터가 한 점으로 표시되어 빈도를 알 수 없다. 이 경우 geom_jitter()를 사용하면 각 점의 x, y 좌표에 임의의 변동을 주어 겹치는 점이 다른 곳에 표시되도록 할 수 있다. width와 height 인수는 임의의 변동의 최대값이다. 범주형 변수의 범주 사이의 길이는 1이므로 다음의 예는 붙어 있는 두 범주 사이의 거리의 약 \\(\\pm\\) 20% 정도의 변동이 일어나도록 조정한 예라 할 수 있다. ggplot(mpg, aes(class, drv)) + geom_jitter(width=0.2, height=0.2) 그러나 산저도의 점의 수가 많으면 두 변수의 관계를 명확하게 알기는 힘들다. 이 경우 geom_count()를 이용하면 빈도에 따라 더 큰 원이 그려지는 그래프를 그릴 수 있다. ggplot(mpg, aes(class, drv)) + geom_count() 8.8.5 범주형 변수와 수치형 변수의 그래프 범주형 변수와 수치형 변수의 관계를 살펴보는 가장 쉬운 방법은 범주형 변수에 따른 수치형 변수의 분포를 산점도로 나타내 보는 것이다. 다음은 클래스별 도심 연비의 산점도를 보여준다. 비슷한 데이터와 매핑으로 그래프를 여러번 그릴 것이므로 ggplot2 그래프를 변수에 할당하여 사용해 보자. p &lt;- ggplot(mpg, aes(class, cty)) p + geom_point() 그런데 실제 데이터보다 점이 더 적게 찍힌 것을 볼 수 있다. 이는 동일한 지점에 여러 데이터가 표현되었기 때문이다.geom_jitter() 함수는 앞서 설명하였드시 동일한 지점의 점을 임의로 조금씩 변동시켜 점을 표시한다. width와 height 인수를 설정하면 임의의 변동의 폭과 높이의 범위를 설정할 수 있다. 다음은 폭을 \\(\\pm 0.2\\)로 제한한 경우이다. 이산시간 변수는 한 칸이 1로 계산되므로 총 공간의 40% 정도에 임의로 변동된 점이 놓이게 된다. p + geom_jitter(width = 0.2) geom_jitter()로 범주별로 수치 변수의 대락적 분포를 확인할 수는 있으나 전체적인 분포를 요약하여 비교하긴 어렵다. geom_boxplot()를 이용하면 각 범주에서의 수치형 변수의 분포를 상자 그림으로 요약하여 보여준다. 상자의 상한은 3분위수, 상자의 하한은 1분위수, 상자 안의 가로선은 중위수를 나타낸다. 상자 밖의 위와 아래에 그려진 선은 상자 높이(IQR)의 1.5배 내의 데이터 중 최대값과 최소값을 보여준다. 그 범위 밖의 데이터는 이상치로 간주하여 별도의 점으로 나타낸다. p + geom_boxplot() 앞의 그래프는 자동차 종류 별로 도심 연비의 중위수가 차이가 나는지를 살펴볼 수 있게 해준다. 그런데, 그래프에 나타난 중위수는 조사된 데이터, 즉 표본의 중위수이므로 모집단의 중위수와 다를 수 있다. 모집단 중위수에 대한 신뢰구간을 같이 표시하고 싶으면 notch=TRUE로 하여 상자그림을 그린다. 만약 두 종류의 차의 V자 모양의 notch가 서로 겹치지 않는다면 두 종류의 차의 도심 연비의 중위수가 통계적으로 유의미하게 다르다는 것을 의미한다. 데이터가 적은 클래스의 경우에 notch의 크기가 너무 커져서 상자 바깥까지 그려지는 경우도 있다. 이 경우 경고 메시지가 출력된다. p + geom_boxplot(notch = T) Notch went outside hinges ℹ Do you want `notch = FALSE`? Notch went outside hinges ℹ Do you want `notch = FALSE`? Notch went outside hinges ℹ Do you want `notch = FALSE`? 상자 그래프 자주 같이 표시되는 정보가 수치 데이터의 평균에 대한 정보이다. stat_summary()를 이용하면 범주별 평균을 구할 수 있고, geom 함수로는 geom_point()를 설정하여 범주별 평균을 상자 그림 위에 점으로 덧붙일 수 있다. p + geom_boxplot(notch = T) + stat_summary(fun=mean, color=&quot;red&quot;, size=5, shape=&quot;*&quot;, geom = &quot;point&quot;) Notch went outside hinges ℹ Do you want `notch = FALSE`? Notch went outside hinges ℹ Do you want `notch = FALSE`? Notch went outside hinges ℹ Do you want `notch = FALSE`? 상자 그래프는 수치형 데이터를 분위수와 이상치로 요약된 정보를 주는 장점이 있지만 실제 분포를 파악하기 어렵다. 바이올린 차트는 상자 그래프의 이러한 단점을 보완해 준다. 바이롤린 차트는 수치 변수의 확률밀도를 추정하여 확률밀도가 높은 곳은 폭이 넓게, 확률밀도가 낮은 곳은 폭이 좁게 그래프를 그려주는데, 이 모향이 바이올린 모양을 닯아서 바이올린 차트라 한다. p + geom_violin() 그런데 바이올린 차트는 확률밀도를 계산할 때 확률밀도가 연속적이고 유한한 값을 가지는 함수라는 가정하에 각 지점에 작은 정규분포를 적합하여 이를 연결하여 확률밀도를 추정한다. 그런데 이런 가정이 적합하지 않을 때도 있으니 이 경우 바이올린 차트를 사용하지 않는 것이 좋다. 다음은 바이올린 차트와 상자그림을 겹쳐 그린 그래프이다. p + geom_boxplot(width=0.1) + geom_violin(alpha=0.3) 8.8.6 두 수치형 변수의 그래프 우리는 앞선 여러 예제에서 geom_point()를 이용하여 두 수치형 변수의 산점도와 geom_smooth()를 이용하여 평균 적합선을 그려보았다. 여기서는 다른 방식으로 두 수치형 변수의 관계를 그래프로 나나태 보자. geom_text() 두 수치형 변수의 데이터를 나타낼 때, 점 대신 텍스트로 표현하고 싶을 때가 있다. 다음 예는 geom_text()로 midsize 차의 2008년도의 도심 및 고속도로 연비 데이터를 모델명으로 보여주는 그래프이다. df &lt;- filter(mpg, class == &quot;midsize&quot;, year == 2008) ggplot(df, aes(cty, hwy)) + geom_text(aes(label=model)) 앞의 예는 동일한 데이터를 가지는 차의 이름이 겹쳐서 표현되어 구분이 어렵다. 이를 개선하기 위하여 글자의 크기(size 인수)를 줄이고 다음처럼 position 인수에 position_jitter() 함수를 이용하여 텍스트 위치에 임의적인 변동을 주어 같은 자리의 데이터가 겹치지 않도록 해 본다. ggplot(df, aes(cty, hwy)) + geom_text(aes(label=model), size=3, position=position_jitter(width=0.3, height=0.3)) 텍스트를 겹치지 않게 만드는 또다른 방법은 check_overlap=TRUE로 설정하여 이미 한 자리에 텍스트가 놓이면 같은 위치에 텍스트가 더 이상 쓰이지 않도록 하는 것이다. 이 경우 뒤에 나타나는 동일한 위치의 데이터는 그래프에 표시되지 못할 것이다. ggplot(df, aes(cty, hwy)) + geom_text(aes(label=model), check_overlap = T) 텍스트로 관측치의 위치를 표현하면, 텍스트의 길이가 가변적이라 관측치의 정확한 위치를 파악하기 어렵다. 따라서 관측치의 위치는 점으로 표현한 후, 점의 옆이나 위, 아래에 텍스트를 같이 표현하기도 한다. geom_text() 함수의 nudge_x와 nudge_y는 원래 관측치의 위치에서 정해진 크기만큼 표시할 텍스트의 위치를 이동시킨다. 다음은 텍스트를 점 위로 0.3 정도 이동시켜 표시한 예이다. ggplot(df, aes(cty, hwy)) + geom_point() + geom_text(aes(label=model), nudge_y=0.3, size=3) 위의 경우에는 동일한 위치에 여러 텍스트가 겹치므로 position_jitter()를 이용하여 임의로 위치로 텍스트를 조정할 수도 있다. 참고로 position_jitter()와 nudge_x/nudge_y는 함께 사용될 수 없다. ggplot(df, aes(cty, hwy)) + geom_point() + geom_text(aes(label=model), size=3, position=position_jitter(width=0.3, height=0.3)) geom_label() geom_label()은 geom_text()와 거의 유사한데, 텍스트를 박스 안에 넣어 글자를 구별하기 좀 더 쉽도록 해 준다. ggplot(df, aes(cty, hwy)) + geom_point() + geom_label(aes(label=model), nudge_y=0.2, size=3) geom_bin2d() 두 변수의 결합 분포를 확인하고 싶을 때는 geom_bin2d()를 이용하여 두 수치형 변수를 각각 구간으로 나눈 후, 각 셀별로 빈도수를 계산한다. 그리고 각 셀의 빈도에 따라 색상을 다르게 하여 그래프에 표시한다. binwidth 인수는 가로축과 세로축의 구간을 길이를 지정한다. ggplot(mpg, aes(cty, hwy)) + geom_bin2d(binwidth=c(2,2)) 8.8.7 세 변수 이상의 그래프 3개 변수 이상의 관계를 파악하고자 할 때 조건부 그래프이다. 조건부 그래프는 관심의 대상인 한 변수의 분포 또는 두 변수의 관계가 다른 변수의 값이 변함에 따라 어떻게 변하는지를 보여준다. ggplot2에서는 facet을 사용하여 이를 수행한다. 다음은 구동 방식(drv)의 차이에 따라 배기량(displ)과 도심 연비(cty)의 관계가 어떻게 변하는지를 보여주는 그래프이다. 전륜 구동(f)의 차일수록 배기량이 커짐에 따라 도심 연비의 감쇄가 크게 나타남을 볼수 있다. ggplot(mpg, aes(displ, cty)) + geom_point() + geom_smooth(method=&quot;lm&quot;) + facet_wrap(~drv) `geom_smooth()` using formula = &#39;y ~ x&#39; 위에서 사용된 facet_wrap() 함수는 그래프가 매우 많으면 그래프를 줄 바꾸기를 하여 배치를 한다. ggplot(mpg, aes(displ, cty)) + geom_point() + geom_smooth(method=&quot;lm&quot;) + facet_wrap(~class) `geom_smooth()` using formula = &#39;y ~ x&#39; 3개 변수 이상의 관계를 파악할 때 조건부 그래프뿐 아니라, 산점도 상에서 색상 등의 다른 aethetics를 사용하여 제 3의 변수의 영향을 살펴볼 수도 있다. 다음은 구동 방식의 차이를 색상으로 구분하여 한 산점도에 나타낸 예이다. ggplot(mpg, aes(displ, cty, col=drv)) + geom_point() + geom_smooth(method=&quot;lm&quot;) `geom_smooth()` using formula = &#39;y ~ x&#39; 색상 등의 aesthetics를 제 3의 변수에 매핑하여 그래프를 그리는 것은 한 그래프에 그래프가 모두 함께 표시되어 비교가 쉬운 장점이 있다. 그러나 제 3의 변수가 여러 값을 가지거나 제3, 4, 5의 변수들이 관심있는 두 변수에 영향을 미치는 것을 살펴보려면 너무 그래프가 복잡해서 파악이 어려운 단점이 있다. 다음은 구동방식뿐 아니라 조사 년도(year)가 배기량과 도심 연비의 관계에 어떤 영향을 미치는지 보기 위해 추가적으로 year 변수를 linetype에 매핑한 결과이다. 여러 그래프가 한 곳에 그려지다 보니 구분이 어려운 것을 볼 수 있다. 또한 연도별로 구동방식으로 나누어 비교를 하기도 어렵다. ggplot(mpg, aes(displ, cty, col=drv, linetype=factor(year))) + geom_point() + geom_smooth(method=&quot;lm&quot;) + labs(linetype=&quot;year&quot;) `geom_smooth()` using formula = &#39;y ~ x&#39; facet을 사용하면 제3, 4 변수의 값에 따라 그래프 각각 그린 후 행과 열로 배치해 주므로 그래프를 좀 더 체계적으로 비교해 볼 수 있다. 다음은 drv와 year의 값에 따라 displ와 cty의 관계가 어떻게 변하는지는 facet을 이용하여 그래프를 그린 예이다. facet_grid()은 수식 표현을 사용하여 그래프 배열의 행과 열의 기준이 되는 변수를 지정한다. ggplot(mpg, aes(displ, cty)) + geom_point() + geom_smooth(method=&quot;lm&quot;) + facet_grid(year~drv) `geom_smooth()` using formula = &#39;y ~ x&#39; facet_wrap()이 한 변수를 조건으로 하여 그래프를 그린다면 facet_grid()는 두 변수를 조건으로 그래프를 그려준다. 행이 될 변수를 수식의 왼편에 열이 될 변수를 수식의 오른편에 기술을 한다. 앞의 예에서는 조사 년도별 차이는 행으로, 구동 방식의 차이는 열로 구분되어 그래프를 표시하였다. 전륜 구동(f)의 차들의 연비 감쇄 현상이 더 가파른 것은 연도별로 차이가 없었지만, 1999년도에 비해 2008년도의 전륜구동(f)과 후륜구동(r)의 차들 중에 배기량이 큰 차들이 출시되었고 배기량에 따른 연비 감쇄 경향도 줄어들었음을 볼 수 있다. 8.9 그래프의 외양 바꾸기 ggplot2는 사용자가 데이터를 geom의 각 aesthetics 요소로 매핑하면 자동으로 가로축과 세로축의 스케일을 결정하고, 표시할 색상의 스케일도 결정하고, 축과 범례에 표시될 레이블도 결정하여 그래프를 그려준다. 이러한 ggplot2의 기능은 사용자가 그래프의 세부 사항이 아니라 그래프의 핵심적인 매핑과 형태에만 집중할 수 있게 해주므로 매우 편리하다. 그러나 가끔은 ggplot2가 생성한 그래프의 모양이 최종적으로 원하는 형태가 아닐 수 있다. 이러한 경우에 그래프의 세부적인 사항을 조정할 필요가 있다. 사실 발표용 그래프는 세심한 조정이 필요한 경우가 더 많다. 이 장에서는 ggplot2로 그래프를 그린 후 자주 조정하게 되는 요소를 어떻게 변경할 수 있는지를 살펴본다. 8.9.1 좌표축의 조정 ggplot2는 데이터가 x와 y aesthetics에 매핑되면, 이를 이용하여 가로축과 세로축의 축척(scale)를 생성한다. x와 y에 매핑된 변수가 수치형 변수이면 scale_x_continous()와 scale_y_continous()가, 범주형 변수이면 scale_x_discrete()와 scale_y_discrete()가 사용되어 가로축과 세로축의 축척을 생성한다. 좌표축의 축적을 위한 이러한 함수들은 매핑된 데이터의 값을 이용하여 다음 사항을 적절히 결정한다. name: 축의 이름 breaks: 축에 표시될 눈금의 위치 minor_breaks: 축에 표시될 세부 눈금의 위치 labels: 축 눈금에 씌여질 레이블 limits: 축의 상한과 하한 trans: 축에 별도의 변환을 적용할지 여부 position: 축의 그래프 상에서의 위치 등 ggplot2가 자동으로 설정한 이러한 요소가 원하는 것이 아니라면 직접 이를 조정해야 한다. midwest 데이터는 미국 중서부의 각 카운티(county)의 인구통계 정보이다. midwest # A tibble: 437 × 28 PID county state area poptotal popdensity popwhite popblack popamerindian &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 561 ADAMS IL 0.052 66090 1271. 63917 1702 98 2 562 ALEXAN… IL 0.014 10626 759 7054 3496 19 3 563 BOND IL 0.022 14991 681. 14477 429 35 4 564 BOONE IL 0.017 30806 1812. 29344 127 46 5 565 BROWN IL 0.018 5836 324. 5264 547 14 6 566 BUREAU IL 0.05 35688 714. 35157 50 65 7 567 CALHOUN IL 0.017 5322 313. 5298 1 8 8 568 CARROLL IL 0.027 16805 622. 16519 111 30 9 569 CASS IL 0.024 13437 560. 13384 16 8 10 570 CHAMPA… IL 0.058 173025 2983. 146506 16559 331 # ℹ 427 more rows # ℹ 19 more variables: popasian &lt;int&gt;, popother &lt;int&gt;, percwhite &lt;dbl&gt;, # percblack &lt;dbl&gt;, percamerindan &lt;dbl&gt;, percasian &lt;dbl&gt;, percother &lt;dbl&gt;, # popadults &lt;int&gt;, perchsd &lt;dbl&gt;, percollege &lt;dbl&gt;, percprof &lt;dbl&gt;, # poppovertyknown &lt;int&gt;, percpovertyknown &lt;dbl&gt;, percbelowpoverty &lt;dbl&gt;, # percchildbelowpovert &lt;dbl&gt;, percadultpoverty &lt;dbl&gt;, # percelderlypoverty &lt;dbl&gt;, inmetro &lt;int&gt;, category &lt;chr&gt; area: 면적 poptotal: 총 인수수 popdensity: 인구밀도 popwhite: 백인 거주자수 popblack: 흑인 거주자수 popamerindian: 인디언 거주자수 popasian: 아시아인 거주자수 popother: 다른 인종 거주자수 percwhite, percwhite, percamerindan, percasian, percother: 각 인종의 비율 popadults: 성인 거주자수 percollege: 대학 졸업자 비율 percprof: 전문직 비율 다음은 백인 거주자 비율과 대학 졸업자 비율에 대한 산점도이다. p &lt;- ggplot(midwest, aes(percwhite, percollege)) + geom_point() p 위의 그래프에서 가로축은 백인의 비율인데 25% 단위로 주눈금(breaks)과 눈금의 값이 레이블(labels)로 표시되어 있다. 아울러 주눈금 사이에 보조 눈금(minor.breaks)이 하나씩 그려져 있고 별도의 레이블은 표시되어 있지 않다. 위의 가록축을 10% 단위로 주눈금을 표시하고 보조눈금은 디폴트 값인 주눈금 사이에 하나의 보조눈금이 그려지도록 그래프를 조정해 보자. 또한 눈금에 표시되는 레이블도 숫자만이 아니라 %가 같이 표시되도록 해 본다. p + scale_x_continuous(breaks=seq(0, 100, by=10), labels=paste0(seq(0, 100, by=10),&quot;%&quot;)) 현재 x와 y 축은 데이터의 최소값과 최대값이 모두 표시될 수 있도록 적절히 그 범위가 설정되어 있다. 그런데 현재 백인의 비율은 대부분 80% 이상이어서 데이터가 서로 구분이 되지 않는다. 따라서 x축을 60에서 100%까지만 표시되도록 조정해 보자. 또한 y축의 이름을 “Percent college educated”로 바꾸어 보자. 이 경우 2개의 관측치가 그래프에 표시되지 않으므로 그에 대한 정보가 함께 출력된다. p + scale_x_continuous(breaks=seq(0, 100, by=10), labels=paste0(seq(0, 100, by=10),&quot;%&quot;), limits=c(60, 100)) + scale_y_continuous(name=&quot;Percent college educated&quot;) Warning: Removed 2 rows containing missing values or values outside the scale range (`geom_point()`). 아울러 position 인수를 사용하면 좌표축의 위치를 지정할 수 있다. “left”, “right”, “top”, “bottom”의 값이 사용되는데 다음 예는 가로축과 세로축을 좌표평면의 맨 위와 맨 오른쪽으로 조정한 예이다. p + scale_x_continuous(position=&quot;top&quot;) + scale_y_continuous(position=&quot;right&quot;) 다음은 각 카운티의 면적과 인구의 산점도이다. ap &lt;- ggplot(midwest, aes(area, poptotal)) + geom_point() + geom_smooth(method=&quot;lm&quot;) ap `geom_smooth()` using formula = &#39;y ~ x&#39; 대부분의 인구가 100만 미만에 몰려 있어서 그래프를 확인하기 어렵다. 이렇듯 한쪽으로 편향된 데이터를 가진 경우 로그 변환을 하면 데이터를 구분하기 좋은 때가 많다. 앞의 그래프의 y축을 로그 축적으로 변경해 보자. ap + scale_y_continuous(trans=&quot;log10&quot;) `geom_smooth()` using formula = &#39;y ~ x&#39; 8.9.2 좌표계의 변경 가끔은 그래프의 x와 y축을 변경하고 싶을 때가 있다. 산점도의 경우는 x와 y의 매핑을 바꾸면 간단히 축을 서로 바꿀 수 있지만 다음처럼 히스토그램의 가로축과 세로축을 바꾸려면 좀 복잡한 작업이 필요하다. p &lt;- ggplot(mpg, aes(cty)) + geom_histogram(binwidth=1) p 이럴 때 쉽게 사용할 수 있는 것이 coord_flip() 함수이다. coord_flip() 함수는 그래프의 가로축과 세로축을 바꾸어 준다. p + coord_flip() coord_flip() 함수 말고도 좌표계를 변경하는 함수들이 있다. coord_polar()는 직교좌표계를 극좌표계로 변경해 준다. p + coord_polar() ggplot(mpg, aes(class, fill=drv)) + geom_bar(position=&quot;fill&quot;) + coord_polar() 8.9.3 색상 척도(color scales)의 변경 ggplot2는 x와 y에 매핑되는 데이터 열의 값의 범위에 따라 좌표축을 자동 생성한다. 마찬가지로 color나 fill 등의 속성에 매핑되는 데이터 열에 따라 자동으로 색상의 척도를 자동으로 지정하여, 데이터의 값에 따라 적절한 색상을 선택하여 그래프를 그린다. ggplot2는 데이터 열을 색상 속성에 매핑할 때 데이터 열이 연속형 변수인지, 이산형 변수인지에 따라 색상 척도를 다르게 설정한다. 다음 두 그래프를 비고해 보자. 첫번째 그래프는 점의 color 속성에 이산형 변수인 drv가 매핑되었고, 두번재 그래프는 color에 연속형 변수인 cty가 매핑되었다. p &lt;- ggplot(mpg, aes(displ, hwy)) p + geom_point(aes(color=drv), size=2) p + geom_point(aes(color=cty), size=2) 이산형 변수는 구분되는 색상이 지정되는 반면, 연속형 변수는 색상의 그라데이션으로 매핑이 되는 것을 볼 수 있다. 그 이유는 이산형 변수는 구분되는 제한된 값만 가지므로 정해진 색상으로 그래프를 표현할 수 있는 반면, 연속형 변수는 무수히 많은 값을 가질 수 있으므로 색상의 그라데이션의 연속적인 변화로 표현하는 것이 더 적절하기 때문이다. 가끔 데이터의 열이 수치로 입력이 되었지만 이산형 데이터인 경우가 있다. 예를 들어 mpg 데이터의 year는 수치로 데이터가 입력되었지만 구분되는 두 개의 연도를 가진 변수이다. 이렇듯 이산형 변수가 수치로 입력이 되어 있으면 ggplot2는 이 데이터가 연속형 수치로 판단을 하여 그라데이션으로 색상을 표현한다. 이를 방지하려면 원래의 데이터를 factor로 변환하여 이산형 변수로 변환해 주면 구별되는 색상으로 그래프를 표현한다. p &lt;- ggplot(mpg, aes(displ, hwy)) p + geom_point(aes(color=year), size=2) p + geom_point(aes(color=factor(year)), size=2) ggplot2가 디폴트로 매핑한 색상이 마음에 들지 않으면 이를 직접 조정할 수 있다. 이를 위해서는 색상에 대한 기본적인 지식을 가지고 있어야 한다. 이 책에서는 세부적인 색상 지정과 관련된 내용은 다루지 않고, 대신 이산형 변수와 연속형 변수에 대해서 이미 만들어져 있는 색상 척도 중 하나로 색상 척도를 변경하는 방법만 다루도록 한다. 이산형 변수의 색상 매핑은 ColorBrewer에서 지정한 색상 매핑(팔레트)을 사용할 수 있다. RColorBrewer 패키지는 ColorBrewer에서 제공하는 다양한 색상 척도를 R에서 사용할 수 있도록 해 준다. RColorBrewer 패키지에서 사용할 수 있는 색상 팔레트를 확인해 보려면 다음 명령을 실행해 본다. RColorBrewer::display.brewer.all() 팔레트에 대한 좀 더 자세한 설명을 확인하려면 다음을 수행한다. maxcolors 열은 팔레트가 이산형 변수에 사용되었을 때 최대 몇 개의 범주를 나타낼 수 있는지를 나타낸다. colorblind 열은 해당 팔레트가 색맹 친화적인 팔레트인지 아닌지에 대한 정보를 준다. category 열은 팔레트의 종류를 나타낸다. Qualitative (qual) 팔레트는 명목형 범주를 나타내기에 좀 더 적합한 팔레트로, 수치형이나 순서형 변수를 표현하기에는 적합하지 않은 팔레트이다. Sequential (seq) 팔레트는 색상이 밝은 색상에서 어두운 색상으로 변화하는 팔레트로 수치형이나 순서형 변수를 표현하기에 적합한 팔레트이다. Diverging (div) 팔레트는 팔레트로 수치형이나 순서형 변수를 표현하기에 적합한 팔레트인 것은 seq 팔레트와 동일하지만, 가운데 값을 밝은 색상으로, 양 극단의 값을 어두운 색으로 표현하여 가운데에 분포한 값과 극단에 위치한 값을 구분하여 표현하고 싶을 때 사용한다. RColorBrewer::brewer.pal.info maxcolors category colorblind BrBG 11 div TRUE PiYG 11 div TRUE PRGn 11 div TRUE PuOr 11 div TRUE RdBu 11 div TRUE RdGy 11 div FALSE RdYlBu 11 div TRUE RdYlGn 11 div FALSE Spectral 11 div FALSE Accent 8 qual FALSE Dark2 8 qual TRUE Paired 12 qual TRUE Pastel1 9 qual FALSE Pastel2 8 qual FALSE Set1 9 qual FALSE Set2 8 qual TRUE Set3 12 qual FALSE Blues 9 seq TRUE BuGn 9 seq TRUE BuPu 9 seq TRUE GnBu 9 seq TRUE Greens 9 seq TRUE Greys 9 seq TRUE Oranges 9 seq TRUE OrRd 9 seq TRUE PuBu 9 seq TRUE PuBuGn 9 seq TRUE PuRd 9 seq TRUE Purples 9 seq TRUE RdPu 9 seq TRUE Reds 9 seq TRUE YlGn 9 seq TRUE YlGnBu 9 seq TRUE YlOrBr 9 seq TRUE YlOrRd 9 seq TRUE 이산형 변수로 매핑된 color 또는 fill의 ColorBrewer 척도를 바꾸려면 scale_color_brewer() 또는 scale_fill_brewer()를 사용한다. p_drv &lt;- p + geom_point(aes(color=drv), size=2) p_drv p_drv + scale_color_brewer(palette = &quot;Set1&quot;) p_drv + scale_color_brewer(palette = &quot;Accent&quot;) p_drv + scale_color_brewer(palette = &quot;Spectral&quot;) 연속형 변수로 매핑된 color 또는 fill도 ColorBrewer 척도를 이용하여 연속적인 그라데이션으로 연속형 변수의 값을 표현할 수 있다. ColorBrewer 척도를 바꾸려면 scale_color_distiller() 또는 scale_fill_distiller()를 사용한다. Distiller 척도는 팔레트의 색상을 내삽하여 부드러운 그라데이션을 만들어 준다. p_cty &lt;- p + geom_point(aes(color=cty), size=2) p_cty p_cty + scale_color_distiller(palette = &quot;RdPu&quot;) p_cty + scale_color_distiller(palette = &quot;YlOrBr&quot;) p_cty + scale_color_distiller(palette = &quot;Greens&quot;) 8.9.4 레이블 조정 ggplot2는 그래프의 좌표축과 범례의 이름을 자동으로 설정한다. 기본 설정은 사용된 열 이름이나 표현식이다. 데이터를 탐색하기 위해 그래프를 그리는 동안에는 이러한 레이블을 사용하는 것은 문제가 없지만, 발표를 위해서는 독자가 이해하기 쉬운 레이블로 그래프의 제목, 축 이름, 범례의 이름을 바꿔주는 것이 좋다. labs() 함수는 그래프의 제목, 축 이름, 범례의 이름을 쉽게 바꿀 수 있게 해준다. p &lt;- ggplot(mpg, aes(displ, cty, color=class, shape=factor(cyl))) + geom_point() p 위 그래프를 다음처럼 범례 이름, 축의 이름, 그래프의 제목을 좀 더 의미있는 내용으로 바꾸어 보자. p &lt;- p + labs(title=&quot;displacement vs. city fuel economy&quot;, x=&quot;displacement(liter)&quot;, y=&quot;city fuel economy(miles/gallon)&quot;, color=&quot;car class&quot;, shape=&quot;number of cylinders&quot;) p 8.9.5 테마 변경 테마는 ggplot2 그래프의 전체적인 외양을 결정한다. 테마는 그래프의 배경 색, 글자 폰트, 격자선 모양, 범례의 위치 등의 그래프의 외양을 결정한다. theme_gray()는 디폴트 테마이며, 다음처럼 테마 함수를 추가하면 관련 테마가 적용된다. p + theme_gray() p + theme_bw() p + theme_dark() p + theme_light() p + theme_linedraw() p + theme_classic() p + theme_minimal() 지금까지는 ggplot2 패키지가 자체적으로 제공하는 테마만 보았다. ggthemes 패키지를 설치하면 더 많은 테마를 사용할 수 있다. install.packages(&quot;ggthemes&quot;) ggthemes 패키지가 제공하는 테마는 매우 많지만 그 중에 몇 가지 예만 살펴본다. p + ggthemes::theme_base() # R의 기본 graphics과 유사한 테마 p + ggthemes::theme_economist() # The Economist 그래프와 유사한 테마 p + ggthemes::theme_excel() # MS Excel 그래프와 유사한 테마 p + ggthemes::theme_few() # Stephen Few가 주창한 가이드를 따르는 테마 p + ggthemes::theme_tufte() # Edward Turfte가 주창한 가이드를 따르는 테마 이 중에 어떤 테마를 사용하는가는 시각화의 목적과 사용자의 취향에 달려있다. 그런데 좋은 데이터 시각화의 원칙에서 보면 그래프는 높은 데이터 밀도를 가져야 한다. 높은 데이터 밀도란 사용된 잉크 대비 표현되는 데이터가 많은 것을 의미한다. 따라서 뒷 배경이 복잡하거난 색상이 많은 테마보다는 간결한 테마를 선택하는 것이 좋다. 그래야 시각화에서 강조하려는 부분을 강조할 수 있는 여유 공간이 그래프에 생기고, 독자가 더 빨리 그래프의 의미를 알아차릴 수 있다. 그런데 모든 그래프에 기본 테마가 아닌 테마를 일괄 적용하고 싶으면, 모든 그래프에 해당 theme 함수를 일일이 적용하기보다는 기본 테마 설정을 변경하는 것이 편리하다. theme_get() 함수는 현재의 기본 테마를 반환하고, theme_set() 함수는 기본 테마를 변경한다. 현재의 기본 테마를 임시 저장한 후, 새로운 테마로 그래프를 그리고, 다시 원해의 기본 테마를 복원하고자 할 때, 이 두 함수가 사용된다. (theme_set()은 현재의 기본 테마를 반환하기 때문에 다음 예에서 oldTheme 변수에 기존 테마를 저장하는 작업을 theme_set() 함수에서도 할 수도 있다.) oldTheme &lt;- theme_get() # 현재 기본 테마 저장 p # 현재의 기본 테마로 그래프 출력 theme_set(theme_classic()) # theme_classic으로 기본 테마 설정 p # 바뀐 기본 테마로 그래프 출력 p + labs(shape = &quot;실린더 수&quot;, color = &quot;분류&quot;) p + geom_hline(yintercept = mean(mpg$cty), linetype=2) theme_set(oldTheme) # 원래의 기본 테마 복원 p # 원래의 기본 테마로 그래프 출력 사용자는 테마를 바꾸는 것뿐만 아니라, 현재 적용된 테마에 설정된 각 요소를 theme() 함수를 사용하여 직접 변경할 수 있다. 테마에서 가장 빈번이 변경되는 요소가 범례의 위치이다. p + theme(legend.position = &quot;bottom&quot;) 이 외에도 그래프 레이블들의 형태와 백그라운드 색 등 다양한 요소를 조정할 수 있다. 더 자세한 내용을 알고싶으면 ??theme을 이용하여 관련 도움말을 확인하기 바란다. 만약 빈번히 사용되는 테마 요소가 있다면 다음 예처럼 변수에 저장을 해 둔 후, 여러 그래프에 적용시킬 수 있다. myTheme &lt;- theme( plot.title=element_text(face=&quot;bold.italic&quot;, size=16, color=&quot;orange&quot;, hjust=0.5), panel.background = element_rect(fill=&quot;lightyellow&quot;, color=&quot;green&quot;), legend.position = &quot;top&quot;) p + myTheme ggplot(mpg, aes(hwy, fill=drv)) + geom_histogram() + labs(title=&quot;A graph with my theme&quot;) + myTheme `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 그런데 다수의 그래프에 변경된 테마 요소를 적용하여 한다면, 테마 요소를 변수에 저장하였어도 매번 그래프에 일일이 적용해야 하므로 꽤 번거롭다. 이 경우 theme_update() 함수를 사용하면 기본 테마의 요소를 변경할 수 있다. theme_update() 함수는 theme_set() 함수와 마찬가지로 기존 기본 테마를 반환하므로 이를 저장하였다가 다시 원래의 테마를 복원할 수 있다. p oldTheme &lt;- theme_update( plot.title=element_text(face=&quot;bold.italic&quot;, size=16, color=&quot;orange&quot;, hjust=0.5), panel.background = element_rect(fill=&quot;lightyellow&quot;, color=&quot;green&quot;), legend.position = &quot;top&quot;) p p + geom_hline(yintercept = mean(mpg$cty), linetype=2) theme_set(oldTheme) 8.10 기타 유용한 팁들 8.10.1 여러 그래프를 한 도표에 넣기 ggplot2에서 그린 여러 그래프를 한 도표에 넣으려면 gridExtra 패키지의 grid.arrange() 함수를 이용하면 편리하다. gridExtra 패키지를 사용하려면 먼저 설치를 해야 한다. install.packages(&quot;gridExtra&quot;) 그리고 나서 메모리에 적재한다. library(gridExtra) 다음의 패키지를 부착합니다: &#39;gridExtra&#39; The following object is masked from &#39;package:dplyr&#39;: combine 다음처럼 4개의 그래프를 ggplot2로 그렸다고 해보자. grid.arrange() 함수는 다양한 방식으로 그래프를 조합하여 하나의 도표를 만들 수 있다. p1 &lt;- ggplot(mpg, aes(drv, displ)) + geom_jitter() p2 &lt;- ggplot(mpg, aes(drv, displ)) + geom_boxplot() p3 &lt;- ggplot(mpg, aes(drv, displ)) + geom_violin() grid.arrange(p1, p2, p3, ncol=3) grid.arrange(p1, p2, p3, nrow=2, ncol=2) grid.arrange(p1, p2, p3, ncol=3, widths=c(0.5, 0.25, 0.25)) grid.arrange(p1, p2, p3, nrow=3, heights=c(0.25, 0.25, 0.5)) 다음은 arrangeGrob() 함수로 그래프를 묶은 다음 다시 이를 grid.arrange()에 보내 좀더 다양한 레이아웃의 그래프를 그린 예이다. grid.arrange(p1, arrangeGrob(p2, p3, ncol=2, widths=c(0.6, 0.4)), nrow=2, heights=c(0.4, 0.6)) 그런데 gridExtra 패키지의 grid.arrange() 함수는 조합하는 그래프의 패널을 정렬하지 않는다. 따라서 조합된 각 그래프의 축들이 서로 정렬이 되어 나타나지 않을 수 있다. 아울러 조합되는 그래프에 공통된 범례가 있는 경우 하나의 법례를 공통으로 나타내기도 어렵다. ggpubr 패키지의 ggarrange()을 사용하면 조합되는 그래프의 패널을 정렬시키고 공통의 범례를 부여할 수 있다. ggpubr 패키지에 대한 자세한 내용은 ggpubr: ‘ggplot2’ Based Publication Ready Plots을 참조한다. 8.10.2 그래프 저장하기 RStudio 사용자가 R에서 그린 그래프를 저장하려면, RStudio의 [Plot] 패널에서 [Export]-[Save as Image…] 메뉴를 이용하면 된다. 이 메뉴를 사용하면 그래프를 저장할 파일 형식, 위치, 이름, 크기를 지정하여 저장할 수 있다. R 콘솔에서 그래프를 저장하려면 다음처럼 ggsave() 함수를 이용한다. p &lt;- ggplot(mpg, aes(cty, hwy)) + geom_point() ggsave(file=&quot;myplot.png&quot;, plot=p, width=5, height=4) 함수를 +로 결합시키는 것은 ggplot2에서만 사용하는 방식으로 다른 R 함수에는 적용되지는 않는다.↩︎ mapping에 범주형 변수가 맵핑되면 group 속성에 함께 이용되므로, group=``이 없으면 이 예에서는cut`의 수준별로 상대 빈도를 구하게 된다.↩︎ "],["ch-R-Advanced-Data-Mgmt.html", "Chapter 9 R 고급 데이터 변환 9.1 데이터의 단순 결합 9.2 관계형 데이터베이스처럼 데이터 결합하기 9.3 tidyr 패키지를 이용하여 정돈 데이터 형식으로 바꾸기 9.4 데이터 열의 형식 바꾸기", " Chapter 9 R 고급 데이터 변환 7 장과 8 장에서 정돈 형식의 데이터를 변환하고 시각화하는 방법을 배웠다. 그러나 실제 데이터 분석에서는 분석하고자 하는 데이터가 하나의 데이터 프레임에 정돈 형식으로 제공되는 경우가 많지 않다. 대부분의 경우 다음 두 가지 작업 중 하나 또는 두 가지 모두가 필요한 경우가 많다. [Merge] 다양한 원천에서 획득된 데이터를 하나의 정돈 형식의 데이터로 결합하기 [Reshape] 비정돈 형식의 데이터를 정돈 데이터 형식으로 변형하기 본 장에서는 이러한 데이터 전처리에 필요한 다양한 기법을 논의한다. 데이터의 결합을 위해서는 dplyr 패키지를 사용할 것이며, 비정돈 형식의 데이터를 정돈 데이터 형식으로 변형하기 위해서는 tidyr 패키지를 사용할 것이다. 이 두 패키지는 모두 tidyverse 패키지에 속해 있으므로, 이 두 패키지를 사용하기 위해서 tidyverse 패키지를 적재한다. library(tidyverse) 9.1 데이터의 단순 결합 행으로 결합 vs. 열로 결합 데이터에 대한 결합이 필요한 다음 두 가지 상황을 고려해 보자. 데이터가 동일한 열 형식으로 여러 파일로 나뉘어져 있는 경우: 예를 들어 판매 실적 데이터가 2021년 데이터는 2021.csv 파일에 2022년 데이터는 2022.csv 파일에 있다고 가정해 보자. 이 경우 각 파일을 별도의 데이터 프레임으로 읽어들인 후 행으로 결합시켜야 할 것이다. 데이터가 동일한 행으로 되어 있으나, 서로 다른 열을 가지고 있는 경우: 예를 들어 사원 번호 순으로 한 파일에는 입사시점의 개인 정보가, 다른 파일에는 작년 인사 평가 결과 데이터가 있다고 하자. 두 파일에 동일한 사원 번호 순으로 데이터가 기록되어 있다면 두 파일의 정보를 데이터 프레임으로 읽어들인 후 열로 결합하여야 할 것이다. 데이터 프레임을 행과 열로 결합하는 작업은 6 장에서 소개한 R의 기본 함수인 rbind()와 cbind()를 사용하여도 수행할 수 있다. 그러나 여기에서는 dplyr 패키지의 bind_rows()와 bind_cols() 함수를 사용하여 여러 데이터 프레임을 행과 열로 결합할 것이다. bind_rows()와 bind_cols() 함수를 사용하는 이유는 이 두 함수가 R의 기본 함수보다 처리 속도가 빠를 뿐 아니라, R의 기본 함수보다는 편리한 기능을 가지고 있기 때문이다. 9.1.1 데이터를 행으로 결합하기 열 구조가 다른 데이터를 행으로 결합하기 데이터를 행으로 결합하는 작업이 필요한 경우, 데이터가 동일한 열 구조를 가지고 있지 않은 경우가 종종 발생한다. 동일한 열을 가지고 있더라도 열 이름이 서로 다른 경우도 있다. 이런 경우에는 결합하려는 데이터 프레임을 동일한 열 구조로 변형하여 결합하여야 한다. 앞으로의 예제들은 다음 파일에 포함된 데이터를 사용하니 예제를 따라하고자 하는 분들은 내려받기를 하자. Download advancedDataMgmt.RData 내려받은 파일을 우클릭하여 RStudio로 열거나 내려받은 파일이 있는 폴더를 작업디렉토리로 설정한 후 다음 명령을 수행하면 class1과 class2 등의 데이터가 적재된다. 이 데이터는 대학의 어떤 강의의 두 분반의 중간 및 기말 고사 정보이다. load(&quot;advancedDataMgmt.RData&quot;) class1 ID Name Gender Year Address Midterm Final Team 1 15 김철수 M 1 서울 78 59 A 2 18 김영희 F 3 경기 85 87 A 3 25 이철수 M 3 충남 80 70 B 4 34 이영희 F 2 대전 92 89 B 5 151 홍길동 Male 4 세종 58 66 B class2 ID Mid Final Name Team Gen Year 1 12 75 79 장철수 C M 2 2 19 75 89 장영희 C F 2 3 28 87 76 최철수 D M 1 4 45 82 79 최영희 D F 30 두 데이터 모두 학번(ID), 중간고사(Midterm), 기말고사(Final), 프로젝트 팀(Team), 성별(Gender), 학년(Year)에 대한 정보를 포함하고 있으나, class1에는 학생의 주소(Address) 열이 포함되어 있고 class2는 그렇지 않다. 또한 두 데이터의 열의 위치와 이름도 조금 다르다. rbind()는 열의 개수가 다른 데이터 프레임을 행으로 결합하지 못한다. 두 분반 학생의 점수를 통합하여 성적 처리를 하기 위해 두 분반의 데이터를 결합하려고 한다고 하자. 이를 어떻게 수행하여야 할까? rbind()로 먼저 두 데이터 프레임을 통합하려고 시도해 보자. rbind(class1, class2) Error in rbind(deparse.level, ...): numbers of columns of arguments do not match 열의 수가 다르기 때문에 결합이 되지 않음을 알 수 있다. 따라서 rbind()로 두 데이터를 결합하려면 class1에만 있는 Address 열을 어떻게 처리할지를 결정해야 한다. 일반적으로 다음 둘 중 하나의 방법을 택하여 문제를 해결한다. 첫번째 방법은 class1의 Address 열을 제외하고 결합하는 것이고, 두번째 방법은 class2에 Address 열을 추가하고 결측치(NA)로 값을 준 후 결합하는 것이다. bind_rows()는 열의 개수가 다른 데이터 프레임임도 행으로 결합을 한다. 두 분반 학생의 데이터를 dplyr 패키지의 bind_rows() 함수를 사용하여 연결해 보자. bind_rows(class1, class2) ID Name Gender Year Address Midterm Final Team Mid Gen 1 15 김철수 M 1 서울 78 59 A NA &lt;NA&gt; 2 18 김영희 F 3 경기 85 87 A NA &lt;NA&gt; 3 25 이철수 M 3 충남 80 70 B NA &lt;NA&gt; 4 34 이영희 F 2 대전 92 89 B NA &lt;NA&gt; 5 151 홍길동 Male 4 세종 58 66 B NA &lt;NA&gt; 6 12 장철수 &lt;NA&gt; 2 &lt;NA&gt; NA 79 C 75 M 7 19 장영희 &lt;NA&gt; 2 &lt;NA&gt; NA 89 C 75 F 8 28 최철수 &lt;NA&gt; 1 &lt;NA&gt; NA 76 D 87 M 9 45 최영희 &lt;NA&gt; 30 &lt;NA&gt; NA 79 D 82 F 열의 개수가 달라도 결합이 이루어지는 것을 볼 수 있다. 두 데이터에서 서로 없는 열은 결측치 NA로 처리되어 결합이 이루어지는 것을 볼 수 있다. 그러나 사실 class1의 Midterm과 class2의 Mid는 중간고사 점수 열로 같은 정보가 다른 열 이름으로 표현된 것 뿐이다. bind_rows()는 이름이 다르면 서로 다른 열이라고 생각하여 각각 새로운 열을 만들어 결합을 한다. 그러므로 사실상 같은 열이 서로 다른 이름으로 되어 있다면 이름을 동일하게 바꾸어 주어서 결합을 하여야 한다. rbind()는 두 데이터의 열의 이름이 다른 경우 행으로 결합하지 못한다. class1 데이터의 Address 열을 제외하고 두 데이터를 다시 rbind()로 결합해 보자. rbind(select(class1, -Address), class2) Error in match.names(clabs, names(xi)): 이전에 사용된 이름들과 일치하지 않습니다. rbind()는 열의 개수가 동일하더라도 두 데이터 프레임의 열의 이름이 서로 다르면 행으로 결합하지 못함을 볼 수 있다. 지금 중간고사 점수 열과 성별 열의 이름이 서로 다르기 때문에 연결이 안되는 것이므로 다음처럼 열의 이름을 변경한 후 두 데이터 프레임을 행으로 연결시킨다. rbind(select(class1, -Address), rename(class2, Midterm = Mid, Gender = Gen)) ID Name Gender Year Midterm Final Team 1 15 김철수 M 1 78 59 A 2 18 김영희 F 3 85 87 A 3 25 이철수 M 3 80 70 B 4 34 이영희 F 2 92 89 B 5 151 홍길동 Male 4 58 66 B 6 12 장철수 M 2 75 79 C 7 19 장영희 F 2 75 89 C 8 28 최철수 M 1 87 76 D 9 45 최영희 F 30 82 79 D rbind()와 bind_rows()는 열의 순서를 자동으로 맞춘다. 이제 두 데이터 프레임의 열의 형태가 같아졌으므로 bind_rows()로 두 데이터를 원하는 방식으로 합칠 수 있다. 두 데이터 프레임의 열의 순서가 다른 경우 rbind()와 bind_rows()는 첫번째 데이터 프레임의 열 이름을 기준으로 열의 순서를 자동으로 맞추어 준다. class12 &lt;- bind_rows(select(class1, -Address), rename(class2, Midterm = Mid, Gender = Gen)) class12 ID Name Gender Year Midterm Final Team 1 15 김철수 M 1 78 59 A 2 18 김영희 F 3 85 87 A 3 25 이철수 M 3 80 70 B 4 34 이영희 F 2 92 89 B 5 151 홍길동 Male 4 58 66 B 6 12 장철수 M 2 75 79 C 7 19 장영희 F 2 75 89 C 8 28 최철수 M 1 87 76 D 9 45 최영희 F 30 82 79 D 합쳐지는 데이터에 식별자 부여하기 앞의 class1과 class2 데이터는 1분반과 2분반 학생의 데이터이다. 그런데 이 두 데이터를 행으로 결합한 데이터에서는 각 행이 어떤 데이터에서 온 것인지에 대한 정보가 없기 때문에 학생이 속한 분반을 확인할 수 없다. 이런 경우 bind_rows()의 .id 인수를 사용하면, 결합되는 데이터의 순서에 따라 일련번호를 부여하는 열을 생성할 수 있다. bind_rows(select(class1, -Address), rename(class2, Midterm = Mid, Gender = Gen), .id = &quot;Class&quot;) # class 열로 데이터 출처 식별 Class ID Name Gender Year Midterm Final Team 1 1 15 김철수 M 1 78 59 A 2 1 18 김영희 F 3 85 87 A 3 1 25 이철수 M 3 80 70 B 4 1 34 이영희 F 2 92 89 B 5 1 151 홍길동 Male 4 58 66 B 6 2 12 장철수 M 2 75 79 C 7 2 19 장영희 F 2 75 89 C 8 2 28 최철수 M 1 87 76 D 9 2 45 최영희 F 30 82 79 D bind_rows()에 두 개 이상의 데이터프레임으로 구성된 리스트를 제공하여도 데이터프레임을 행으로 잘 결합한다. dfs = list(select(class1, -Address), rename(class2, Midterm = Mid, Gender = Gen)) bind_rows(dfs) ID Name Gender Year Midterm Final Team 1 15 김철수 M 1 78 59 A 2 18 김영희 F 3 85 87 A 3 25 이철수 M 3 80 70 B 4 34 이영희 F 2 92 89 B 5 151 홍길동 Male 4 58 66 B 6 12 장철수 M 2 75 79 C 7 19 장영희 F 2 75 89 C 8 28 최철수 M 1 87 76 D 9 45 최영희 F 30 82 79 D 리스트의 요소인 데이터프레임에 이름을 부여하면 .id 인수로 만든 열이 생성될 때 이름을 사용한다. dfs = list(cls1=select(class1, -Address), cls2=rename(class2, Midterm = Mid, Gender = Gen)) bind_rows(dfs, .id=&quot;Class&quot;) Class ID Name Gender Year Midterm Final Team 1 cls1 15 김철수 M 1 78 59 A 2 cls1 18 김영희 F 3 85 87 A 3 cls1 25 이철수 M 3 80 70 B 4 cls1 34 이영희 F 2 92 89 B 5 cls1 151 홍길동 Male 4 58 66 B 6 cls2 12 장철수 M 2 75 79 C 7 cls2 19 장영희 F 2 75 89 C 8 cls2 28 최철수 M 1 87 76 D 9 cls2 45 최영희 F 30 82 79 D 실제 데이터를 행으로 결합하는 과정에는 훨씬 더 다양한 문제들이 발생한다. 예를 들어 동일한 키를 나타내는 열이 하나는 cm로 하나는 m 단위로 정보가 주어져 있으면 이를 하나의 단위로 통일해야 한다. 그러나 복잡한 문제들도 결국 서로 다른 열 구조를 행으로 결합하기 위해서 어떤 열을 추가하거나 제외할 것인지를 결정하고, 열의 형식과 이름을 어떻게 통일할 것인가를 고려하는 과정이라는 점에서 본질적으로는 앞의 예와 동일하다 할 수 있다. 9.1.2 데이터를 열로 결합하기 행 순서가 다른 데이터를 열로 결합하기 데이터를 열로 결합하는 경우 실제 데이터가 동일한 행 순서로 정렬되어 있지 않은 경우가 종종 있다. 예를 들어 앞의 예에서 성적 처리를 위해서는 학생의 중간, 기말 고사 점수와 함께 출석 점수를 고려해야 한다고 하자. 그리고 출석점수는 attendance 데이터 프레임에 다음과 같이 class1과 class2의 모든 학생의 학번(ID) 순으로 정렬되어 분반 정보(Class)와 출석 점수(Attend)가 저장되어 있다고 하자. attendance ID Class Attend 1 12 2 185 2 15 1 90 3 18 1 95 4 19 2 100 5 25 1 100 6 28 2 100 7 34 1 100 8 45 2 100 9 151 1 95 앞서 두 분반의 중간 및 기말 고사 데이터가 합쳐진 class12는 학번이 기준이 아니라 분반으로 정렬되어 있다. 따라서 이 두 데이터 프레임을 단순하게 열로 결합하면 출석점수가 엉뚱한 학생에게 부여된다. 정렬 후 열로 결합하기 이를 해결하는 가장 간단한 방법은 두 데이터 프레임을 동일한 기준으로 정렬한 후 cbind()나 bind_cols()를 수행하는 것이다. 먼저 class12를 ID 순으로 정렬한 후 열로 결합해 보자. 그런데 ID 열은 두 데이터 프레임에 모두 있으므로 하나는 불필요하다. 따라서 attendance 데이터 프레임의 ID 열을 제거한 후 결합한다. class12.a &lt;- bind_cols(arrange(class12, ID), select(attendance, -ID)) class12.a ID Name Gender Year Midterm Final Team Class Attend 1 12 장철수 M 2 75 79 C 2 185 2 15 김철수 M 1 78 59 A 1 90 3 18 김영희 F 3 85 87 A 1 95 4 19 장영희 F 2 75 89 C 2 100 5 25 이철수 M 3 80 70 B 1 100 6 28 최철수 M 1 87 76 D 2 100 7 34 이영희 F 2 92 89 B 1 100 8 45 최영희 F 30 82 79 D 2 100 9 151 홍길동 Male 4 58 66 B 1 95 다른 방법으로 attendance 데이터 프레임을 Class와 ID 열로 정렬한 후 class12 데이터 프레임과 결합할 수도 있다. attendence 데이터를 분반과 학번으로 정렬하여 class112와 순서를 맞춘 후 데이터를 열로 결합해 보자. class12.b &lt;- bind_cols(class12, attendance %&gt;% arrange(Class, ID) %&gt;% select(-ID)) class12.b ID Name Gender Year Midterm Final Team Class Attend 1 15 김철수 M 1 78 59 A 1 90 2 18 김영희 F 3 85 87 A 1 95 3 25 이철수 M 3 80 70 B 1 100 4 34 이영희 F 2 92 89 B 1 100 5 151 홍길동 Male 4 58 66 B 1 95 6 12 장철수 M 2 75 79 C 2 185 7 19 장영희 F 2 75 89 C 2 100 8 28 최철수 M 1 87 76 D 2 100 9 45 최영희 F 30 82 79 D 2 100 실제 데이터는 이보다 더 복잡한 문제를 가지고 있는 경우가 많다. 예를 들어 한 파일에 있는 행이 다른 파일에는 없는 경우도 있다. 이러한 경우엔 그 행의 정보를 모두 제거할 것인지, 아니면 그 행에 대해 없는 정보는 NA로 하여 결합을 할지 결정해야 한다. 결국 cbind()나 bind_rows()를 이용하여 열로 결합하기 위해서는 두 데이터의 행이 동일한 개체에 대한 정보가 되도록 일치시키는 것이 중요하다. 그런데 매번 두 데이터가 동일한 행으로 결합되도록 정렬하여 결합하는 작업을 사용자가 직접 하는 것은 오류 발생 가능성이 많다. 따라서 이 작업은 다음에 소개하는 ’관계형 데이터베이스처럼 데이터 결합하기’에 소개하는 방법을 사용할 것을 권장한다. 9.2 관계형 데이터베이스처럼 데이터 결합하기 관계형 데이터베이스에서는 서로 다른 열 정보를 담고 있는 두 데이터 테이블을 key를 사용하여 join이라는 방식을 이용하여 연결시킨다. 여기서 key란 앞서 성적 데이터와 출석 데이터에서 특정 학생 정보임을 식별할 수 있는 학번(ID) 등을 말한다. R에서도 두 데이터 프레임을 관계형 데이터베이스의 join과 같은 방식으로 결합시킬 수 있다. 이 작업은 R의 기본 함수인 merge() 함수를 이용하여 수행할 수도 있고, dplyr 패키지의 join 함수들을 사용하여 수행할 수도 있다. 이 책에서는 dplyr의 join 함수들을 이용하여 관계형 데이터베이스처럼 결합하기를 수행하는 방법을 설명하도록 한다. 9.2.1 Inner join과 outer join 앞의 예에서 우리는 중간, 기말 고사 점수를 가지고 있는 class12 데이터 프레임과 출석 점수를 가지고 있는 attendance 데이터 프레임을 합치기 위해 ID 열로 데이터 프레임을 정렬한 후 bind_cols()로 연결하였다. 이 작업은 dplyr의 inner_join() 함수를 이용하면 더 손쉽게 수행할 수 있다. inner_join() inner_join() 함수는 결합할 두 데이터 프레임을 인수로 먼저 기술한 다음 by 인수에 어떤 열을 기준으로 결합할 것인지를 열 이름으로 기술한다. inner_join() 함수는 두 데이터 프레임에서 by 인수로 주어진 열의 값이 동일한 행을 서로 연결하여 새로운 데이터 프레임을 만든다. 또한 새로 만들어진 데이터 프레임은 by 열을 기준으로 정렬이 이루어진다. inner_join(class12, attendance, by=&quot;ID&quot;) ID Name Gender Year Midterm Final Team Class Attend 1 15 김철수 M 1 78 59 A 1 90 2 18 김영희 F 3 85 87 A 1 95 3 25 이철수 M 3 80 70 B 1 100 4 34 이영희 F 2 92 89 B 1 100 5 151 홍길동 Male 4 58 66 B 1 95 6 12 장철수 M 2 75 79 C 2 185 7 19 장영희 F 2 75 89 C 2 100 8 28 최철수 M 1 87 76 D 2 100 9 45 최영희 F 30 82 79 D 2 100 만약 두 데이터 프레임이 결합의 기준이 되는 열의 이름이 다르면 `by = c(“key.x” = “key.y”) 형식으로 두 데이터 프레임의 키 열의 이름을 기술하여 결합하면 된다. 만약 결합의 기준이 되는 열이 두 개 이상이면 `by = c(“key1”, “key2”) 형식으로 기술한다. 만약 결합의 기준이 되는 열이 두 개 이상이고 서로 이름이 다르면 by = c(\"key1.x\" = \"key1.y\", \"key2.x\" = \"key2.y\") 형식으로 두 데이터 프레임의 키 열의 이름을 기술한다. 관련 정보는 inner_join() 함수의 도움말을 참조하라. 1:1 inner join 앞의 예처럼 데이터가 결합되는 방식을 1 대 1 inner join이라고 부른다. 두 데이터 프레임에 ID가 동일한 학생은 오직 한 명만 존재하고, 두 데이터 프레임의 학생의 ID가 일 대 일로 대응된다. 따라서 두 데이터 프레임의 행들이 일 대 일로 결합되어 새로운 데이터 프레임이 생성된다. by 인수가 주어지지 않으면 inner_join() 함수는 두 데이터 프레임에서 이름이 같은 열을 찾고 그 열을 기준으로 결합을 한다. 따라서 위의 경우 by 인수를 설정하지 않으면, 두 데이터 프레임에 공통으로 있는 ID 열을 기준으로 데이터가 결합된다. inner_join(class12, attendance) Joining with `by = join_by(ID)` ID Name Gender Year Midterm Final Team Class Attend 1 15 김철수 M 1 78 59 A 1 90 2 18 김영희 F 3 85 87 A 1 95 3 25 이철수 M 3 80 70 B 1 100 4 34 이영희 F 2 92 89 B 1 100 5 151 홍길동 Male 4 58 66 B 1 95 6 12 장철수 M 2 75 79 C 2 185 7 19 장영희 F 2 75 89 C 2 100 8 28 최철수 M 1 87 76 D 2 100 9 45 최영희 F 30 82 79 D 2 100 0:1 inner join 앞서 inner_join() 함수는 두 데이터 프레임에서 by 인수로 주어진 열의 값이 같은 행을 서로 연결한다고 했다. 그러면 한 데이터 프레임에는 해당 개체의 정보가 있으나 다른 데이터 프레임에는 해당 개체의 정보가 없는 경우에 두 데이터 프레임을 연결하면 어떻게 될까? 다음 예처럼 class1에는 1분반 학생의 데이터만 있고, attendance는 1, 2분반의 학생 데이터가 모두 있는 경우 두 데이터 프레임을 ID 열로 결합하는 경우를 고려해 보자. attendance에는 동일한 ID를 가지고 있는 학생이 오직 한 명만 존재하고, class1에는 attendance에 있는 학생 정보가 0개 또는 1개가 있는 경우이다. 이러한 데이터 결합 방식을 0 대 1 inner join이라고 부른다. Inner join은 두 데이터 프레임에서 by로 지정된 열이 값이 서로 대응이 되는 행만 남겨둔다. 따라서 위의 경우에는 class1에 있는 학생의 행으로만 구성된 데이터 프레임이 생성된다. 즉, by 인수에 주어진 열이 서로 동일한 값을 가진 행만 결합되어 결과가 나오므로 한 쪽 데이터 프레임에 없는 행은 제거되었음을 알 수 있다. inner_join(class1, attendance, by=&quot;ID&quot;) ID Name Gender Year Address Midterm Final Team Class Attend 1 15 김철수 M 1 서울 78 59 A 1 90 2 18 김영희 F 3 경기 85 87 A 1 95 3 25 이철수 M 3 충남 80 70 B 1 100 4 34 이영희 F 2 대전 92 89 B 1 100 5 151 홍길동 Male 4 세종 58 66 B 1 95 outer join 한 쪽 데이터 프레임에 해당 행이 없더라도 어느 한쪽의 데이터 프레임에 행이 있으면 그 행을 포함시킬 필요가 있는 경우가 있다. 예를 들어 앞의 예에서 2분반의 중간 및 기말 고사 정보가 나중에 획득되면 추후 보강하기로 하고 현재 출석 점수가 있는 모든 학생의 정보가 나오도록 중간과 기말 점수와 출석 데이터를 결합한다고 하자. 이러한 경우 outer_join 함수들을 사용한다. Outer join 함수는 다음 세 가지가 있다. left_join(x, y): x에 있는 행을 모두 유지하여 join을 수행한다. right_join(x, y): y에 있는 행을 모두 유지하여 join을 수행한다. full_join(x, y): x와 y의 모든 행을 유지하여 join을 수행한다. 대신 한 쪽에 없는 정보는 모두 결측치 NA가 입력되어 결합된다. 다음은 inner_join(), left_join(), right_join(), full_join()의 차이가 무엇인지를 보여주는 예이다. x &lt;- data.frame(id = 1:3, name = letters[1:3]); x id name 1 1 a 2 2 b 3 3 c y &lt;- data.frame(id = 2:4, addr = LETTERS[2:4]); y id addr 1 2 B 2 3 C 3 4 D inner_join(x, y) Joining with `by = join_by(id)` id name addr 1 2 b B 2 3 c C left_join(x, y) Joining with `by = join_by(id)` id name addr 1 1 a &lt;NA&gt; 2 2 b B 3 3 c C right_join(x, y) Joining with `by = join_by(id)` id name addr 1 2 b B 2 3 c C 3 4 &lt;NA&gt; D full_join(x, y) Joining with `by = join_by(id)` id name addr 1 1 a &lt;NA&gt; 2 2 b B 3 3 c C 4 4 &lt;NA&gt; D 다음은 class1과 attendance 데이터에서 attendance의 모든 행을 남겨두는 outer join을 수행한 결과이다. right_join(class1, attendance, by=&quot;ID&quot;) ID Name Gender Year Address Midterm Final Team Class Attend 1 15 김철수 M 1 서울 78 59 A 1 90 2 18 김영희 F 3 경기 85 87 A 1 95 3 25 이철수 M 3 충남 80 70 B 1 100 4 34 이영희 F 2 대전 92 89 B 1 100 5 151 홍길동 Male 4 세종 58 66 B 1 95 6 12 &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; NA NA &lt;NA&gt; 2 185 7 19 &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; NA NA &lt;NA&gt; 2 100 8 28 &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; NA NA &lt;NA&gt; 2 100 9 45 &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; NA NA &lt;NA&gt; 2 100 1:n inner join 만약에 한 데이터 프레임에서 결합의 기준이 되는 열에 동일한 값이 여러번 나오면 어떻게 될까? 다음의 예를 살펴보면서 그 결과가 어떻게 되는지 확인해 보자. 지금까지 우리는 class12.a라는 데이터 프레임에 중간, 기말, 출석 점수를 통합하였다. 그런데 다음과 같이 프로젝트 팀별로 프로젝트 평가 점수가 있다고 하자. pjt Team Project 1 A 80 2 B 90 3 C 85 4 D 75 한 프로젝트 팀에는 2, 3 명의 학생이 포함되고, 프로젝트 점수는 프로젝트 팀별로 주어지고 학생 개별로는 부여되지 않는다. 따라서 학생의 성적을 산정하려면 각 학생이 어떤 프로젝트 팀에 속한지를 확인한 후 학생이 속한 프로젝트 팀의 점수를 그 학생의 프로젝트 점수로 부여하는 작업이 필요하다. 이 경우 class12.a와 pjt 데이터 프레임이 결합되어야 하는데, 결합의 기준 열은 프로젝트 팀을 나타내는 Team 열이 되어야 한다. 그런데 pjt 데이터 프레임에는 한 팀에 해당되는 행이 오직 한 개만 존재하지만, class12.a 데이터 프레임에는 한 팀에 속한 학생이 여러 명 있으므로 여러 행이 존재한다. 이러한 경우의 데이터 결합 방식을 1 대 n inner join이라고 한다. 다음은 inner_join()를 사용하여 n 대 1의 관계의 두 데이터 프레임을 inner join 한 결과이다. class12.c &lt;- inner_join(class12.a, pjt, by=&quot;Team&quot;) class12.c ID Name Gender Year Midterm Final Team Class Attend Project 1 12 장철수 M 2 75 79 C 2 185 85 2 15 김철수 M 1 78 59 A 1 90 80 3 18 김영희 F 3 85 87 A 1 95 80 4 19 장영희 F 2 75 89 C 2 100 85 5 25 이철수 M 3 80 70 B 1 100 90 6 28 최철수 M 1 87 76 D 2 100 75 7 34 이영희 F 2 92 89 B 1 100 90 8 45 최영희 F 30 82 79 D 2 100 75 9 151 홍길동 Male 4 58 66 B 1 95 90 결과에서 보듯이 by 인수로 Team을 주게 되면, pjt 데이터 프레임에서 Team이 A인 행은 하나지만, class12.a에서 Team이 A이고 학번이 15번과 18번인 학생과 관련된 두 행이 존재하므로, pjt의 한 행이 이 두 행에 차례로 결합되어 새로운 행을 만들었음을 알 수 있다. 이처럼 inner_joint()는 by 인수로 주어진 행에 동일한 값이 여러번 있으면 해당 값으로 결합이 여러번 발생한다. 두 열 이상을 기준으로 join Join의 기준이 되는 열은 하나가 아니라 여러 개가 될 수 있다. 다음과 같은 두 개의 데이터 프레임이 있다고 하자. 그리고 이 두 데이터 프레임을 하나의 데이터 프레임으로 결합한다고 하자. cAge first.name last.name age 1 James Bolton 34 2 James Tiger 26 3 Goerge Tiger 47 cIncome first.name last.name income 1 Goerge Tiger 35 2 James Bolton 24 3 James Tiger 18 두 데이터 프레임 각각에는 한 사람에 대한 정보는 오직 한 행에만 정보가 기술되어 있다. 그러나 두 데이터 프레임에서 first.name이 동일한 사람이 2명, last.name이 동일한 사람이 2명이 있다. 그래서 first.name이나 last.name만으로 데이터를 결합한다면 동일한 이름을 가진 사람이 있어서 원하는 결과를 얻을 수 없다. 다음은 first.name으로 결합한 결과이다. inner_join(cAge, cIncome, by=&quot;first.name&quot;) Warning in inner_join(cAge, cIncome, by = &quot;first.name&quot;): Detected an unexpected many-to-many relationship between `x` and `y`. ℹ Row 1 of `x` matches multiple rows in `y`. ℹ Row 2 of `y` matches multiple rows in `x`. ℹ If a many-to-many relationship is expected, set `relationship = &quot;many-to-many&quot;` to silence this warning. first.name last.name.x age last.name.y income 1 James Bolton 34 Bolton 24 2 James Bolton 34 Tiger 18 3 James Tiger 26 Bolton 24 4 James Tiger 26 Tiger 18 5 Goerge Tiger 47 Tiger 35 결과에서 보듯이 cAge의 James Bolton 행은 cIncome의 James Bolton과 James Tiger 행과 first.name이 동일하므로 두 번 결합이 이루어진다. 마찬가지로 cAge의 James Tiger 행도 cIncome의 James Bolton과 James Tiger 행과 first.name이 동일하므로 역시 두 번 행 결합이 발생한다. 그래서 결합된 결과가 3건이 아니라 총 5건의 데이터 행을 갖는다. 그리고 cAge와 cIncome 모두 last.name 열이 있어서 어떤 last.name을 남겨두어야 할지 모르므로, 첫번째 데이터 프레임에서 온 열은 .x, 두번째 데이터 프레임에서 온 열은 .y라는 접미사를 붙여서 열을 만들었다. 이러한 경우는 first.name과 last.name이 모두 같은 경우에만 행이 결합되도록 하는 것이 더 바람직하다. 그렇게 하려면 이 두 열의 이름을 모두 by 인수로 전달하면 된다. inner_join(cAge, cIncome, by=c(&quot;last.name&quot;, &quot;first.name&quot;)) first.name last.name age income 1 James Bolton 34 24 2 James Tiger 26 18 3 Goerge Tiger 47 35 9.2.2 Filtering join 지금까지는 두 데이터 프레임의 키 값이 같은 행을 inner 또는 outer join으로 연결하는 방법을 살펴보았다. 그런데 어떤 경우에는 한 데이터 프레임의 데이터를 다른 데이터 프레임의 정보를 사용하여 필터링해야 하는 경우가 있다. 다음의 두 예를 고려해 보자. 어떤 도시의 거주자의 자산 데이터와 그 도시의 세금 체납자 데이터가 있다고 하자. 이 때 거주자의 자산 정보에서 세금 체납자의 자산 정보만 뽑아서 분석하려고 한다. 어떻게 이 정보를 뽑아낼 수 있을까? 어떤 텍스트에서 사용된 단어 데이터와 의마가 없는 단어인 불용어 데이터가 있다고 하자. 이 때 텍스트의 단어 데이터에서 불용어는 제외하고 데이터를 분석하려고 한다. 어떻게 이 정보를 뽑아낼 수 있을까? dplyr 패키지에는 이 작업을 위해 다음 두 함수를 제공한다. semi_join(x, y): x 데이터 프레임에서 y에 있는 데이터만 뽑아낸다. Inner join과 다른 점은 두 데이터 프레임의 정보를 결합하지 않는다는 것이다. x 데이터 프레임에서 남겨둘 행을 지정하기 위해서만 y를 사용한다. anti_join(x, y): x 데이터 프레임에서 y에 있는 행은 제외한다. semi_join(x, y, by = &quot;id&quot;) id name 1 2 b 2 3 c anti_join(x, y, by = &quot;id&quot;) id name 1 1 a 9.2.3 Join을 수행하는 다른 방법들 9.2.3.1 merge() 함수 R의 기본 함수인 merge() 함수는 dplyr 패키지의 inner와 outer join을 수행해 준다. merge(x, y) # inner join id name addr 1 2 b B 2 3 c C merge(x, y, all.x = TRUE) # left join id name addr 1 1 a &lt;NA&gt; 2 2 b B 3 3 c C merge(x, y, all.y = TRUE) # right join id name addr 1 2 b B 2 3 c C 3 4 &lt;NA&gt; D merge(x, y, all = TRUE) # full join id name addr 1 1 a &lt;NA&gt; 2 2 b B 3 3 c C 4 4 &lt;NA&gt; D sqldf 패키지 지금까지 dplyr의 join 함수를 이용하여 관계형 데이터베이스의 join과 유사한 데이터 결합을 어떻게 수행하는지 살펴보았다. 그런데 관계형 데이터베이스의 SQL에 익숙한 사람들은 R에서 SQL처럼 좀 더 다양한 방식으로 join을 수행할 수 없을까라는 의문을 가질 수 있다. sqldf 패키지는 SQL 문법을 이용하여 R의 데이터 프레임에서 데이터를 조회하거나 결합할 수 있도록 해 준다. 이러한 기능이 필요한 사람은 이 패키지의 문서를 참조하기 바란다. 그러나 R은 데이터 분석을 위한 도구이지 관계형 데이터베이스와 같은 일을 수행하기 위한 도구가 아님을 명심할 필요가 있다. 대량의 데이터의 결합이 필요하다면 관계형 데이터베이스에서 SQL을 이용하여 이를 먼저 수행한 후 최종 결과를 R로 보내어 분석을 수행하는 것이 일반적으로 더 효율적인 방법이다. 9.3 tidyr 패키지를 이용하여 정돈 데이터 형식으로 바꾸기 tidyr 패키지는 tidyverse 패키지에 포함된 패키지로 비정돈 형식의 데이터를 정돈 형식으로 바꾸어주는 함수를 가지고 있다. 9.3.1 pivot_longer: 여러 열에 걸친 한 변수의 데이터를 하나의 열로 길게 모으기 정돈 데이터는 한 열이 하나의 변수에 대응을 해야 한다. 그러나 현실의 데이터에서는 동일한 변수의 값이 여러 열에 흩뿌려져 있는 경우가 발생한다. 시계열 데이터들이 대표적인 사례라 할 수 있다. 다음은 tidyr에 포함된 table4a 데이터이다. 세 나라의 1999년도와 2000년도의 어떤 사건의 발생 건수를 보여주고 있다. 발생 건수를 나타내는 데이터 열이 두 개의 열로 나눠져 있음을 볼 수 있다. table4a # A tibble: 3 × 3 country `1999` `2000` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Afghanistan 745 2666 2 Brazil 37737 80488 3 China 212258 213766 ggplot2로 사건의 전체 건수에 대해 막대 그래프를 그리려고 해도 두 열로 나뉘어져 있어서 전체 건수에 대한 막대 그래프를 바로 그리기 어렵다. 물론 두 열을 합산한 열을 만들어 그릴 수도 있지만, 1999년도와 2000년도의 건수를 다른 색의 막대로 표현하기 어렵다. ggplot(table4a, aes(country, `1999`)) + geom_col() table4a를 정돈 데이터로 바꾸려면 두 열을 한 열로 모아야 한다. tidyr의 pivot_longer() 함수는 그러한 역할을 수행한다. table4a %&gt;% pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, values_to =&quot;cases&quot;) # A tibble: 6 × 3 country year cases &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Afghanistan 1999 745 2 Afghanistan 2000 2666 3 Brazil 1999 37737 4 Brazil 2000 80488 5 China 1999 212258 6 China 2000 213766 pivot_longer()에 모아야 할 열의 이름을 지정한다. 이 예에서는 1999와 2000이다. 두 열의 이름은 숫자로 시작하고 있어서 표준적인 형태를 따르지 않아서 ` `으로 둘러쌓여 표현되었다. 원 데이터의 열 이름을 표현할 변수를 names_to로 지정한다. 원 데이터의 열의 값을 표현할 변수를 values_to로 지정한다. 원 데이터의 열 이름은 변수로서 따옴표 없이 지정되고, 결과 데이터에 만들 열 이름은 아직 만들어진 변수가 아니므로 변수의 이름이 따옴표로 둘러쌓여 문자열로 전달된다. 이렇게 정돈된 데이터 형식으로 변형되면 데이터를 다양한 관점에서 분석할 수 있다. table4a %&gt;% pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, values_to =&quot;cases&quot;) %&gt;% ggplot(aes(country, cases, fill=year)) + geom_col() table4a %&gt;% pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, values_to =&quot;cases&quot;) %&gt;% ggplot(aes(year, cases, fill=country)) + geom_col() 다음 그림은 앞의 pivot_longer() 함수의 작동 방식을 보여준다. 원 데이터보다 길어진 형식으로 데이터가 변환되므로 longer라는 표현이 사용되었다. Figure 9.1: pivot_longer 작동 방식 (출처: R for Data Science) 마지막으로 pivot_longer()를 할 때 여러 열을 지정해야 하면, 이를 일일이 나열하는 것은 귀찮을 뿐만 아니라 오류 발생이 크다. 열의 나열은 select() 함수에서와 같이 :로 열의 범위를 설정하거나 열을 매칭하는 함수 등을 사용할 수 있다. table4a %&gt;% pivot_longer(`1999`:`2000`, names_to = &quot;year&quot;, values_to =&quot;cases&quot;) # A tibble: 6 × 3 country year cases &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Afghanistan 1999 745 2 Afghanistan 2000 2666 3 Brazil 1999 37737 4 Brazil 2000 80488 5 China 1999 212258 6 China 2000 213766 결측치가 있는 경우 table4a에서 중국의 2000년도 데이터가 조사되지 않아서 NA로 표시되어 있다면 pivot_longer()는 어떤 결과를 줄까? 다음 결과에서 보듯이 결측치가 있는 셀도 모두 별도의 행으로 표현이 된다. na_table4a &lt;- table4a na_table4a$`2000`[3] &lt;- NA na_table4a # A tibble: 3 × 3 country `1999` `2000` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Afghanistan 745 2666 2 Brazil 37737 80488 3 China 212258 NA na_table4a %&gt;% pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, values_to = &quot;cases&quot;) # A tibble: 6 × 3 country year cases &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Afghanistan 1999 745 2 Afghanistan 2000 2666 3 Brazil 1999 37737 4 Brazil 2000 80488 5 China 1999 212258 6 China 2000 NA 만약 긴 형식에서는 결측치인 행을 없애고 싶으면 values_drop_na 인수를 TRUE로 설정한다. na_long_table4a &lt;- na_table4a %&gt;% pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, values_to = &quot;cases&quot;, values_drop_na = T) na_long_table4a # A tibble: 5 × 3 country year cases &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Afghanistan 1999 745 2 Afghanistan 2000 2666 3 Brazil 1999 37737 4 Brazil 2000 80488 5 China 1999 212258 gather 함수 tidyr 패키지는 1.0 버전이 출시되면서 많은 변화가 있었다. 이전 버전의 에서는 gather() 함수가 pivot_longer() 함수의 역할을 수행하였다. 그리고 호환성을 위해 현재의 버전에서도 gather() 함수를 사용할 수 있다. 아직도 많은 R 관련 책에서 이 함수를 사용하고 있어서 사용법을 여기에 기술한다. table4a %&gt;% gather(`1999`, `2000`, key = &quot;year&quot;, value =&quot;cases&quot;) # A tibble: 6 × 3 country year cases &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Afghanistan 1999 745 2 Brazil 1999 37737 3 China 1999 212258 4 Afghanistan 2000 2666 5 Brazil 2000 80488 6 China 2000 213766 pivot_longer와 유사한 형식인데, gather에서는 합칠 열의 이름을 각각의 인수로 전달된다. names_to와 values_to라는 원 데이터 입장에서의 인수 이름이 gather에서는 합쳐진 데이터 입장에서의 인수 이름인 key와 value라고 기술된다. 9.3.2 pivot_wider: 한 열에 기술된 여러 변수의 데이터를 여러 열로 넓게 펼치기 정돈 데이터는 하나의 열은 하나의 변수에 대응을 해야 한다. 그러나 현실의 데이터에서는 한 열에 여러 변수의 값이 표현되어 있는 경우도 있다. 다음 데이터는 세 나라의 어떤 년도의 사건의 발생 건수와 인구수가 count라는 한 열에 표현되었다. 그렇기 때문에 count 열은 인구수와 사건 횟수라는 두 변수의 값을 모두 포함한 열이 되었다. table2 # A tibble: 12 × 4 country year type count &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Afghanistan 1999 cases 745 2 Afghanistan 1999 population 19987071 3 Afghanistan 2000 cases 2666 4 Afghanistan 2000 population 20595360 5 Brazil 1999 cases 37737 6 Brazil 1999 population 172006362 7 Brazil 2000 cases 80488 8 Brazil 2000 population 174504898 9 China 1999 cases 212258 10 China 1999 population 1272915272 11 China 2000 cases 213766 12 China 2000 population 1280428583 그렇기 때문에 인구수와 사건 횟수를 각각 합이나 평균을 구하거나, 인구 당 사건 횟수를 구하기 위하여 사건 회수를 인구 수로 나누는 작업도 하기가 불편하다. table2를 정돈 데이터로 바꾸려면 count 열의 데이터를 인구수와 사건 횟수를 나타내는 열로 분리하여 한다. tidyr의 pivot_wider() 함수는 그러한 역할을 수행한다. table2 %&gt;% pivot_wider(names_from = type, values_from = count) # A tibble: 6 × 4 country year cases population &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Afghanistan 1999 745 19987071 2 Afghanistan 2000 2666 20595360 3 Brazil 1999 37737 172006362 4 Brazil 2000 80488 174504898 5 China 1999 212258 1272915272 6 China 2000 213766 1280428583 pivot_wider()는 결과 펼쳐진 결과 데이터에서 열의 이름으로 사용될 변수를 names_from 인수로 지정한다. 펼쳐진 결과 데이터에서 열의 값으로 사용될 변수를 values_from 인수로 지정한다. names_from과 values_from 인수를 지정할 때, 원 데이터의 열을 지정하는 것이므로 따옴표 없이 변수로서 지정한다. 정돈 데이터 형식으로 변형되면 다음처럼 열별로 합과 평균을 구하기가 좋고 새로운 변수를 추가하기도 용이하다. table2 %&gt;% pivot_wider(names_from = type, values_from = count) %&gt;% group_by(country) %&gt;% summarise(totol_case=sum(cases), mean_pop=mean(population)) # A tibble: 3 × 3 country totol_case mean_pop &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Afghanistan 3411 20291216. 2 Brazil 118225 173255630 3 China 426024 1276671928. table2 %&gt;% pivot_wider(names_from = type, values_from = count) %&gt;% mutate(cases_per_capita = cases / population) # A tibble: 6 × 5 country year cases population cases_per_capita &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Afghanistan 1999 745 19987071 0.0000373 2 Afghanistan 2000 2666 20595360 0.000129 3 Brazil 1999 37737 172006362 0.000219 4 Brazil 2000 80488 174504898 0.000461 5 China 1999 212258 1272915272 0.000167 6 China 2000 213766 1280428583 0.000167 다음 그림은 앞의 pivot_wider() 함수의 작동 방식을 보여준다. Figure 9.2: pivot_wider의 작동 방식 (출처: R for Data Science) 결측치가 있는 경우 앞서 pivot_longer()에서 중국의 2000년도 데이터에 결측값이 있는 행을 제거하여 데이터 프레임을 만들었다. na_long_table4a # A tibble: 5 × 3 country year cases &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Afghanistan 1999 745 2 Afghanistan 2000 2666 3 Brazil 1999 37737 4 Brazil 2000 80488 5 China 1999 212258 만약 이 데이터를 넓은 형식으로 합치면 어떤 결과가 나올까? 결과에서 보듯이 결측이 있는 곳이 NA로 표시되고 데이터가 넓은 형식으로 변환된다. na_long_table4a %&gt;% pivot_wider(names_from = year, values_from = cases) # A tibble: 3 × 3 country `1999` `2000` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Afghanistan 745 2666 2 Brazil 37737 80488 3 China 212258 NA 결측치를 특정 값으로 대체할 수 있다. 앞의 데이터에서 China의 2000년 데이터가 없는 이유가 한 건도 사건이 발생하지 않은 것이라고 하면 0이라고 대체되는 것이 좋을 것이다. values_fill 인수를 사용하면 넓은 형식으로 데이터를 변형함에 따라 만들어지는 결측치를 특정 값으로 대체할 수 있다. na_long_table4a %&gt;% pivot_wider(names_from = year, values_from = cases, values_fill=0) # A tibble: 3 × 3 country `1999` `2000` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Afghanistan 745 2666 2 Brazil 37737 80488 3 China 212258 0 values_fill 인수에 요소에 이름이 부여된 리스트를 사용하면 새롭게 만들어지는 열별로 결측치가 다르게 대체할 수도 있다. spread 함수 tidyr 패키지는 1.0 버전이 출시되면서 많은 변화가 있었다. 이전 버전의 에서는 spread() 함수가 pivot_wider() 함수의 역할을 수행하였다. 그리고 호환성을 위해 현재의 버전에서도 spread() 함수를 사용할 수 있다. 아직도 많은 R 관련 책에서 이 함수를 사용하고 있어서 사용법을 여기에 기술한다. table2 %&gt;% spread(key = type, value = count) # A tibble: 6 × 4 country year cases population &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Afghanistan 1999 745 19987071 2 Afghanistan 2000 2666 20595360 3 Brazil 1999 37737 172006362 4 Brazil 2000 80488 174504898 5 China 1999 212258 1272915272 6 China 2000 213766 1280428583 pivot_wider와 유사한 형식인데 names_from와 values_from이라는 인수 이름이 spread에서는 key와 value라고 기술된다. 9.3.3 seperate: 한 셀을 여러 셀로 분리하기 한 셀에 여러 값이 기술되어 있으면 정돈 형식의 데이터가 아니다. table3의 rate 열은 사건의 수와 인구수 데이터가 문자열 형식으로 표현된 열이다. table3 # A tibble: 6 × 3 country year rate &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; 1 Afghanistan 1999 745/19987071 2 Afghanistan 2000 2666/20595360 3 Brazil 1999 37737/172006362 4 Brazil 2000 80488/174504898 5 China 1999 212258/1272915272 6 China 2000 213766/1280428583 9.3.3.1 특정 문자를 기준으로 분리하기 seperate()는 정해진 열을 sep에 지정된 문자를 기준으로 분리하여 분리된 값을 into에 지정된 열 이름으로 분리한다. 앞의 다른 함수와 마찬가지로 원 데이터의 열은 변수로서 따옴표 없이 지정되었고 결과 데이터에 사용될 열 이름은 따옴표를 사용하여 문자열로 전달되었다. table3 %&gt;% separate(rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot;) # A tibble: 6 × 4 country year cases population &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 1999 745 19987071 2 Afghanistan 2000 2666 20595360 3 Brazil 1999 37737 172006362 4 Brazil 2000 80488 174504898 5 China 1999 212258 1272915272 6 China 2000 213766 1280428583 다음 그림은 앞의 seperate() 함수의 작동 방식을 보여준다. Figure 9.3: separate의 작동 방식 (출처: R for Data Science) sep은 구분자로 사용할 일반 문자뿐 아니라 정규 표현식을 사용하여 문자를 분리할 수 있다. 9.3.3.2 분리한 열의 형변환 앞의 결과를 보면 rate 열의 데이터가 문자열이기 때문에 결과 열도 모두 문자열 형식임을 볼 수 있다. 그런데 cases와 population 열은 모두 숫자로서 의미를 가지고 있으므로 숫자로 변환되는 것이 좋다. 셀의 내용을 분리한 후 숫자나 논리값으로 변형이 가능하면 변형을 하려면 convert 인수를 TRUE로 설정한다. x &lt;- table3 %&gt;% separate(rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot;, convert = TRUE) x # A tibble: 6 × 4 country year cases population &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; 1 Afghanistan 1999 745 19987071 2 Afghanistan 2000 2666 20595360 3 Brazil 1999 37737 172006362 4 Brazil 2000 80488 174504898 5 China 1999 212258 1272915272 6 China 2000 213766 1280428583 x %&gt;% summarise(total_cases=sum(cases), mean_pop=mean(population)) # A tibble: 1 × 2 total_cases mean_pop &lt;int&gt; &lt;dbl&gt; 1 547660 490072924. 9.3.3.3 문자 수를 기준으로 분리하기 sep 인수에 문자 대신 숫자를 입력하면 문자 수를를 기준으로 열을 분리한다. 양수이면 왼쪽에서 시작하여 sep에 입력된 문자 수까지와 그 이후로 열을 분리하고, 음수이면 오른쪽을 기준으로 sep에 입력된 문자 수까지와 그 이전으로 열을 분리한다. table3 %&gt;% separate(rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=3) # A tibble: 6 × 4 country year cases population &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 1999 745 /19987071 2 Afghanistan 2000 266 6/20595360 3 Brazil 1999 377 37/172006362 4 Brazil 2000 804 88/174504898 5 China 1999 212 258/1272915272 6 China 2000 213 766/1280428583 table3 %&gt;% separate(rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=-3) # A tibble: 6 × 4 country year cases population &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 1999 745/19987 071 2 Afghanistan 2000 2666/20595 360 3 Brazil 1999 37737/172006 362 4 Brazil 2000 80488/174504 898 5 China 1999 212258/1272915 272 6 China 2000 213766/1280428 583 앞의 예에서 숫자열인 year에 적용하여 세기와 나머지 년도로 분리해 내보자. table3 %&gt;% separate(year, into=c(&quot;century&quot;, &quot;year&quot;), sep=2) # A tibble: 6 × 4 country century year rate &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 19 99 745/19987071 2 Afghanistan 20 00 2666/20595360 3 Brazil 19 99 37737/172006362 4 Brazil 20 00 80488/174504898 5 China 19 99 212258/1272915272 6 China 20 00 213766/1280428583 만약 세기와 연도를 숫자로 표현하는 것이 필요하다면 앞서 설명한 것처럼 convert 인수를 TRUE로 설정하면 된다. 이 경우 00년도가 모두 숫자 0으로 변환된 것을 볼 수 있다. table3 %&gt;% separate(year, into=c(&quot;century&quot;, &quot;year&quot;), sep=2, convert = T) # A tibble: 6 × 4 country century year rate &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; 1 Afghanistan 19 99 745/19987071 2 Afghanistan 20 0 2666/20595360 3 Brazil 19 99 37737/172006362 4 Brazil 20 0 80488/174504898 5 China 19 99 212258/1272915272 6 China 20 0 213766/1280428583 9.3.4 unite: 여러 셀의 데이터를 하나의 셀로 병합하기 separate() 함수와 반대 작용을 하는 함수가 unite() 함수이다. unite() 함수는 여러 셀의 내용을 하나의 셀로 합친다. table5는 년도 데이터가 세기(century)와 나머지 년도(year)로 나뉘어져 있는 데이터이다. 세기와 무관하게 년도 별로 데이터를 분석하려고 하면 이 두 열을 합쳐서 온전한 년도 데이터를 만들어야 한다. table5 %&gt;% unite(c(century, year), col = &quot;year&quot;) # A tibble: 6 × 3 country year rate &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 19_99 745/19987071 2 Afghanistan 20_00 2666/20595360 3 Brazil 19_99 37737/172006362 4 Brazil 20_00 80488/174504898 5 China 19_99 212258/1272915272 6 China 20_00 213766/1280428583 unite()의 기본 설정은 _을 구분자로 사용하여 합쳐진 셀의 내용을 연결한다. 이를 조정하려면, sep 인수를 설정하면 된다. 다음처럼 하면 구분자 없이 연결을 수행한다. table5 %&gt;% unite(c(century, year), col = &quot;year&quot;, sep=&quot;&quot;) # A tibble: 6 × 3 country year rate &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 1999 745/19987071 2 Afghanistan 2000 2666/20595360 3 Brazil 1999 37737/172006362 4 Brazil 2000 80488/174504898 5 China 1999 212258/1272915272 6 China 2000 213766/1280428583 9.4 데이터 열의 형식 바꾸기 어떤 스포츠팀의 홈 경기의 관중수를 조사한 다음과 같은 데이터를 고려해 보자. games = tribble( ~date, ~audience, &quot;2023/10/12&quot;, &quot;8,456&quot;, &quot;2023/10/19&quot;, &quot;13,412&quot;, &quot;2023/10/25&quot;, &quot;3,671&quot;, &quot;2023/12/12&quot;, &quot;12,460&quot;, &quot;2023/12/18&quot;, &quot;10,021&quot; ) games # A tibble: 5 × 2 date audience &lt;chr&gt; &lt;chr&gt; 1 2023/10/12 8,456 2 2023/10/19 13,412 3 2023/10/25 3,671 4 2023/12/12 12,460 5 2023/12/18 10,021 이 데이터의 문제는 날짜와 관중수가 모두 문자열로 되어 있어서 숫자 연산이 되지 않고, 날짜 간격에 따라 그래프가 적절한 간격으로 그려지지 않는다는 것이다. summarise(games, total=sum(audience)) Error in `summarise()`: ℹ In argument: `total = sum(audience)`. Caused by error in `sum()`: ! 인자의 &#39;type&#39; (character)이 올바르지 않습니다 숫자는 천 단위로 나뉘어지는 쉼표 때문에 파일에서 데이터를 읽으면 문자로 처리되는 경우가 있다. 이를 숫자로 바꾸려면 parse_number() 함수를 사용한다. games = mutate(games, audience = parse_number(audience, locale=locale(grouping_mark=&quot;,&quot;))) games # A tibble: 5 × 2 date audience &lt;chr&gt; &lt;dbl&gt; 1 2023/10/12 8456 2 2023/10/19 13412 3 2023/10/25 3671 4 2023/12/12 12460 5 2023/12/18 10021 summarize(games, total=sum(audience)) # A tibble: 1 × 1 total &lt;dbl&gt; 1 48020 관중수는 숫자로 변환되어서 합산이 잘 수행된다. 그러나 날짜가 문자로 되어 있어서 날짜 간격을 제대로 인식하지 않아서 관중수의 선 그래프의 간격이 일정하게만 그려진다. ggplot(games, aes(date, audience, group=1)) + geom_line() parse_datetime() 함수를 사용하면 다양한 형식으로 문자열로 표현된 날짜를 날짜 형식으로 변경할 수 있다. format 인수에 날짜 문자열의 형식을 지정하는 방식은 parse_datetime()의 도움말을 확인하자. parse_datetime(games$date, format=&quot;%Y/%m/%d&quot;) [1] &quot;2023-10-12 UTC&quot; &quot;2023-10-19 UTC&quot; &quot;2023-10-25 UTC&quot; &quot;2023-12-12 UTC&quot; [5] &quot;2023-12-18 UTC&quot; games = mutate(games, date = parse_datetime(date, format=&quot;%Y/%m/%d&quot;)) games # A tibble: 5 × 2 date audience &lt;dttm&gt; &lt;dbl&gt; 1 2023-10-12 00:00:00 8456 2 2023-10-19 00:00:00 13412 3 2023-10-25 00:00:00 3671 4 2023-12-12 00:00:00 12460 5 2023-12-18 00:00:00 10021 ggplot(games, aes(date, audience)) + geom_line() "],["ch-R-Programming-Structure.html", "Chapter 10 R 프로그래밍 구조 10.1 R 조건문 10.2 R 반복문 10.3 R 함수", " Chapter 10 R 프로그래밍 구조 R은 통계 및 데이터 처리를 위한 프로그래밍 언어이다. 모든 언어가 그렇지만 처음 언어를 배울 때는 여러 단어와 표현 패턴에 익숙해지는 과정을 거친다. 그러나 좀 더 정확하고 복잡한 표현을 하기 위해서는 단순히 표현 패턴을 익히는 것에서 벗어나 그 언어의 고유한 문법 체계를 이해하는 것이 필요하다. R은 프로그래밍 언어이므로 프로그램 흐름을 제어하는 조건문과 반복문을 가지고 있다. 조건문은 조건에 따라 프로그램 흐름을 분기하고, 반복문은 조건에 따라 프로그램의 부분을 계속 반복 수행한다. 10.1 R 조건문 10.1.1 if 조건문 if-else 조건문 R은 if를 이용하여 조건문을 만든다. 표준적인 if-else 조건문은 다음 형식을 취한다. if (statement1) statement2 else statement3 statement1은 TRUE 또는 FALSE의 논리값을 결과로 주는 표현식이어야 한다. 예로 \\(4 &gt; 2\\) 이나 \\(x &lt; 0\\) 처럼 참 또는 거짓으로 판별될 수 있어야 한다. statement1이 참이면 statement2가 실행되고 statement1이 거짓이면 else 다음의 statement3이 실행된다. 그림 10.1의 (a)는 if-else 조건문에 의해 발생하는 프로그램의 제어 흐름은 보여준다. Figure 10.1: 단순한 형태의 if 조건문에서의 제어 흐름 다음은 if-else 조건문의 예이다. x를 주사위를 굴려서 나온 눈금의 수라고 하자. 만약 x가 4 이상이면 상금 1을 받고, 4보다 작으면 오히려 벌금을 1을 내야 한다고 하자. y를 주사위 경기 한번 후의 손익이라고 하면, 주사위 눈금이 4일 때 y는 다음과 같이 계산할 수 있다. x &lt;- 4 if( x &gt;= 4 ) y &lt;- 1 else y &lt;- -1 y [1] 1 실제 주사위를 굴리는 것처럼 하기 위하여 sample() 함수를 사용하여 1에서부터 6까지의 수 중에서 임의로 한 개의 수를 추출하여 주사위 눈금과 손익을 출력해 보자. 매번 수행할 때마다 주사위 눈금이 달라지고, 그에 따라 손익이 달라지는 것을 확인할 수 있다. x &lt;- sample(1:6, size=1) if( x &gt;= 4 ) y &lt;- 1 else y &lt;- -1 x [1] 4 y [1] 1 만약 statement1 조건이 참이냐 거짓이냐에 따라 여러 문장이 함께 실행되어야 하면 다음과 같이 statment2나 statement3 표현식을 블록으로 만들면 된다. 다음 예에서 중괄호로 묶인 두 개의 블럭이 statement2와 statement3을 대체하고 있음을 볼 수 있다. 중괄호로 묶인 여러 표현식으로 구성된 블록은 마치 하나의 표현식처럼 동시에 평가가 이루어진다. 블록 표현식을 사용할 때 주의할 점은 statment2의 블록이 종료되는 같은 줄에 else가 기술되어야 한다는 것이다. 그래야 if-else 문이 하나의 명령으로 취급되어 처리된다. 다음은 cat() 함수를 사용하여 주사위 게임에서 주사위 눈금에 따라 이겼는지, 졌는지를 출력을 같이 하고 있다. x &lt;- sample(1:6, size=1) if (x &gt;= 4) { y &lt;- 1 cat(&quot;손님이 이겼습니다.\\n&quot;) } else { y &lt;- -1 cat(&quot;딜러가 이겼습니다.\\n&quot;) } cat(&quot;주사위 눈금:&quot;, x, &quot;\\n&quot;) cat(&quot;손익:&quot;, y, &quot;\\n&quot;) 손님이 이겼습니다. 주사위 눈금: 6 손익: 1 단순 if 조건문 어떤 경우에는 조건이 만족하면 어떤 작업을 수행하지만, 그렇지 않은 경우에는 아무 것도 하지 않아야 할 때가 있다. 그러한 경우에는 다음처럼 else 부분이 제외된 단순한 형태의 if 조건문을 사용하면 된다. statement1이 참이면 statement2가 실행되는 것은 if-else 조건문과 마찬가지이지만, statement1이 거짓이면 statement2를 건너띄고 if 조건문 다음으로 프로그램의 실행 흐름이 넘어간다(그림 10.1의 (b) 참조). if-else 조건문과 마찬가지로 statement2는 블럭 표현식으로 대체될 수 있다. if (statement1) statement2 다음 예는 주사위 눈금 x가 4 이상이면 승리 횟수 n을 하나씩 증가시키지만, 그렇지 않은 경우에는 n을 증가시키지 않는 예이다. n &lt;- 0 # 승리 횟수 초기화 x &lt;- sample(1:6, size=1) # 게임 1회 if (x &gt;= 4) n &lt;- n + 1 cat(&quot;x:&quot;, x, &quot;, n:&quot;, n, &quot;\\n&quot;) x: 5 , n: 1 x &lt;- sample(1:6, size=1) # 게임 2회 if (x &gt;= 4) n &lt;- n + 1 cat(&quot;x:&quot;, x, &quot;, n:&quot;, n, &quot;\\n&quot;) x: 2 , n: 1 x &lt;- sample(1:6, size=1) # 게임 3회 if (x &gt;= 4) n &lt;- n + 1 cat(&quot;x:&quot;, x, &quot;, n:&quot;, n, &quot;\\n&quot;) x: 4 , n: 2 우리는 나중에 for 문을 사용하여 게임을 원하는 만큼 반복시킬 것이다. 복합 조건문 지금까지는 하나의 조건에 의해서 두 가지 방향으로 프로그램 실행이 분기되는 경우를 살펴보았다. 그런데 어떤 경우에는 조건에 따라 세 개 이상으로 프로그램 실행을 분기하고 싶을 때가 있다. 예를 들어, 주사위 게임에서 게임의 규칙이 복잡해져서, 5, 6이 나오면 손님이 이기고, 1, 2가 나오면 딜러가 이기고, 3, 4가 나오면 아무도 이지기 않고 게임이 무효가 된다고 하자. 앞의 if-else 예에서는 주사위 눈금에 대한 두 조건을 고려하여 x가 4 이상이면 y에 1을 부여하고 x가 4 미만이면 -1을 부여하였는데, 이제는 주사위 눈금의 세 가지 조건을 고려하여 y에 1, 0, -1을 적절히 부여하여야 한다. 이럴 땐 어떻게 해야 할까? 이런 경우에는 다음처럼 else 다음의 statement3 부분에 또 다른 if 조건문을 넣으면 된다. 이렇게 else 이후에 또 다른 조건문을 실행하는 조건문을 복합 조건문이라고 한다. if (statement1) { statement2 } else if (statement3.1) { statement3.2 } else { statement3.3 } 이 경우 statement1이 TRUE이면 statement2가 실행되고 else 부분은 실행이 되지 않는다. statement1이 FALSE이면 statement2는 건너뛰고 첫번째 else 부분이 실행된다. 그런데 else 다음에 기술된 statement3이 단순한 실행문이 아니라 그 자체가 또 다른 if 조건문이다. 따라서 statement1이 FALSE인 경우에는 else의 if문이 실행되어 statement3.1 조건을 비교하고, statement3.1이 TRUE이면 statement3.2가 실행되고, FALSE이면 statement3.3이 실행된다. 그림 10.2의 (a)는 복합 조건문의 제어 흐름을 보여준다. Figure 10.2: 복잡한 형태의 if 조건문에서의 제어 흐름 다음 예는 변경된 주사위 경기에 따라 손익과 경기 결과를 알려주는 복합 조건문이다. 먼저 x가 5 이상인지를 비교하여 만족하면 손익을 1을 부여하고 복합 조건문을 종료된다. 만약에 첫 번째 조건을 만족하지 않으면 첫번째 else 부분이 실행된다. 그리고 두번째 if에서 x가 3 이상인지를 비교한다. 처음 조건은 FALSE이고 두번째 조건이 TRUE이면 손익은 0이 되고 복합 조건문은 종료된다. 만약 이 두 조건 모두 FALSE이면 손익에 -1을 부여한다. 여러 번 반복 실행하여 x의 값에 따라 어떤 부분이 실행되는지 확인해 보라. x &lt;- sample(1:6, size=1) if (x&gt;=5) { cat(&quot;손님이 이겼습니다.\\n&quot;) y &lt;- 1 } else if ( x &gt;=3 ) { cat(&quot;무승부입니다.\\n&quot;) y &lt;- 0 } else { cat(&quot;딜러가 이겼습니다.\\n&quot;) y &lt;- -1 } cat(&quot;주사위 눈금:&quot;, x, &quot;\\n&quot;) cat(&quot;손익:&quot;, y, &quot;\\n&quot;) 무승부입니다. 주사위 눈금: 4 손익: 0 복합 조건문의 조건은 계속 추가될 수 있다. 앞의 예는 세 개의 분기를 가지고 있지만, 두번째 else 부분에 다시 if 문을 연결하면 네 개의 분기가 되도록 조건을 더 세분화할 수 있다. 중첩 조건문 복합 조건문이 else 부분에 if 조건문으로 꼬리를 물듯이 이어 나가면서 분기를 세분화한다면, 중첩 조건문은 if문의 statement2와 statement3의 안에 또 다른 if 문을 두어 분기를 세분화하는 경우이다. 그림 10.2의 (b)는 중첩 조건문의 제어 흐름을 보여준다. if (statement1) { ... if (statement2.1) { statement2.2 } else { statement2.3 } ... } else { ... if (statement3.1) { statement3.2 } else { statement3.3 } ... } 다음 예를 살펴보자. if-else 조건문의 예처럼 x가 양수인지에 따라 y에 1 또는 0으로 부여하는 것뿐 아니라, x가 양수이고 홀수이면 z에 1을, 짝수이면 z에 2를 부여하고 싶다고 하자. 그리고 x가 0 이하이고 3의 배수이면 z에 3을, 3의 배수가 아니면 z에 4를 부여하고 싶다. 이러한 경우는 다음과 같은 중첩 조건문을 사용하면 쉽게 구현할 수 있다. 다음 예는 x에 -10부터 10 사이의 정수를 임의로 뽑은 후 x의 값에 따라 결과를 출력한 것이다. 여러 번 반복하여 x의 값에 따라 어떤 부분이 실행되는지 살펴보라. x &lt;- sample(-10:10, size=1) if (x&gt;0) { cat(x, &quot;은(는) 양수이고 &quot;) if (x %% 2 == 0) cat(&quot;짝수입니다.\\n&quot;) else cat(&quot;홀수입니다.\\n&quot;) } else { cat(x, &quot;은(는) 0 또는 음수이고 &quot;) if (x %% 3 == 0) cat(&quot;3의 배수입니다.\\n&quot;) else cat(&quot;3의 배수가 아닙니다.\\n&quot;) } -3 은(는) 0 또는 음수이고 3의 배수입니다. 중첩 조건문은 여러번 조건문을 중첩시킬 수 있다. 그러나 너무 많은 조건문을 중첩시키거나, 너무 복잡한 복합 조건문을 사용하는 것은 프로그램 흐름을 이해하기 어렵게 만들므로 되도록 피하는 것이 좋다. 조건문의 결과가 두 개 이상의 논리값을 주는 경우 지금까지 if 문의 statement1 조건에 들어가는 표현식이 하나의 논리값을 가진 경우만을 다루었다. 만약에 이 표현식의 결과가 길이가 2 이상인 논리값 벡터이면 어떻게 될까? 다음 예에서 보듯이 R은 조건의 논리값 결과가 2개 이상인 경우, 오류가 발생한다.9 x &lt;- c(5, 0, -5) x &gt; 0 [1] TRUE FALSE FALSE if (x &gt; 0) y &lt;- 1 else y &lt;- 0 Error in if (x &gt; 0) y &lt;- 1 else y &lt;- 0: the condition has length &gt; 1 y [1] 0 따라서 조건의 결과가 여러 개가 될 수 있는 경우에는 논리값 벡터의 어떤 요소를 사용할지를 특정하여 조건문을 실행하여야 한다. if (x[3] &gt; 0) y &lt;- 1 else y &lt;- 0 y [1] 0 복합 조건 지금까지의 예는 statement1에 단순 조건을 사용하였다. 어떨 때는 AND나 OR 등의 논리값 연산자로 단순 조건을 연결하여 복합 조건을 만들어 statement1에 부여하는 것이 프로그램을 간단하게 만들 수 있다. 다음 예를 살펴 보자. x와 y가 모두 0보다 크면 두 수의 합을 출력하지만 그렇지 않으면 두 수가 모두 0 이상이어야 한다는 경고 메시지를 출력하도록 해 보자. 물론 이를 다음처럼 중첩 또는 복합 조건문으로 구현할 수 있다. x &lt;- 3 y &lt;- -4 if ( x &gt;= 0 ) { if ( y &gt;= 0 ) { print(x + y) } else { warning(&quot;x와 y는 모두 0 이상이어야 합니다.&quot;) } } else { warning(&quot;x와 y는 모두 0 이상이어야 합니다.&quot;) } Warning: x와 y는 모두 0 이상이어야 합니다. 이러한 경우에는 동일한 경고 메시지를 여러 분기에서 출력하도록 해야 한다. 만약 경고의 방식이 바뀌면 x와 y가 0 이상인 분기를 제외하고 관련 부분을 모두 변경해야 한다. 동일한 코드를 여러 부분에 산재시키는 방식은 프로그램이 진화함에 따라 프로그램 유지 보수를 어렵게 만들고 오류 발생의 근원이 되므로 좋지 않은 방식이라 할 수 있다. 이 경우에는 두 조건을 AND로 연결하여 표현하면 if 조건문의 표현이 단순해진다. if ( x &gt;= 0 &amp;&amp; y &gt;= 0 ) { print(x + y) } else { warning(&quot;x와 y는 모두 0 이상이어야 합니다.&quot;) } Warning: x와 y는 모두 0 이상이어야 합니다. 그런데 여기서 논리값 벡터의 연산에서 설명한 AND 연산자인 &amp; 대신 &amp;&amp;를 사용하였다. &amp; 연산자는 논리값 벡터의 AND 연산자로 논리값 벡터들의 같은 위치의 요소별로 AND를 수행하여 그 결과를 반환한다. 반면 &amp;&amp; 연산자는 각 논리값 벡터의 첫번째 요소만 취하여 AND 결과를 제공하고, 대신 맨 처음 요소만 사용했다는 것을 경고한다.10 따라서 다음 예처럼 if() 함수 안의 논리값 벡터가 여러 개의 논리값을 가질 때에는 불필요한 오류나 경고가 발생되지 않도록 한 요소만 특정하여 논리값 연산을 수행하는 것이 좋다. a &lt;- c(T, F) b &lt;- c(T, T) a &amp; b [1] TRUE FALSE a &amp;&amp; b Error in a &amp;&amp; b: &#39;length = 2&#39; in coercion to &#39;logical(1)&#39; if (a &amp; b) print(&quot;TRUE&quot;) else print(&quot;FALSE&quot;) # 오류 발생 Error in if (a &amp; b) print(&quot;TRUE&quot;) else print(&quot;FALSE&quot;): the condition has length &gt; 1 if (a &amp;&amp; b) print(&quot;TRUE&quot;) else print(&quot;FALSE&quot;) # 경고 발생 Error in a &amp;&amp; b: &#39;length = 2&#39; in coercion to &#39;logical(1)&#39; if (a[1] &amp;&amp; b[1]) print(&quot;TRUE&quot;) else print(&quot;FALSE&quot;) [1] &quot;TRUE&quot; 마찬가지로 OR 연산자로는 | 대신 ||가 있다. a | b [1] TRUE TRUE a || b Error in a || b: &#39;length = 2&#39; in coercion to &#39;logical(1)&#39; if (a &amp; b) print(&quot;TRUE&quot;) else print(&quot;FALSE&quot;) # 오류 발생 Error in if (a &amp; b) print(&quot;TRUE&quot;) else print(&quot;FALSE&quot;): the condition has length &gt; 1 if (a &amp;&amp; b) print(&quot;TRUE&quot;) else print(&quot;FALSE&quot;) # 경고 발생 Error in a &amp;&amp; b: &#39;length = 2&#39; in coercion to &#39;logical(1)&#39; if (a[1] &amp;&amp; b[1]) print(&quot;TRUE&quot;) else print(&quot;FALSE&quot;) [1] &quot;TRUE&quot; 따라서 만약 앞의 예에서 x와 y 둘 중에 하나만 0 이상이면 합을 출력한다면 다음처럼 수정하면 된다. if ( x &gt;= 0 || y &gt;= 0 ) { print(x + y) } else { warning(&quot;x와 y 중 하나는 0 이상이어야 합니다.&quot;) } [1] -1 if-else 조건문은 ifelse() 함수와는 다르다. 그리고 본 절에서 배운 if-else 조건문은 ifelse() 함수와는 다르다는 것에 주의해야 한다. 이 절에서 배운 if-else 조건문은 프로그램의 흐름을 조건에 따라 분기하기 위한 표현식이다. 반면 ifelse() 함수는 첫번째 인수인 논리값 벡터에 따라 새로운 벡터를 만들어주는 함수이다. 다음은 벡터의 값이 음수이면 절대값으로 바꾸어 주는 예이다. (물론 우리는 절대값을 만들어주는 abs() 함수를 이용할 수 있지만 예제를 위하여 ifelse() 함수를 사용하였다.) ifelse() 함수는 요소별로 논리값에 따라 결과 요소를 선택함을 볼 수 있다. 반면 if-else 문은 조건에 대한 하나의 논리값에 따라 한번만 프로그램 실행 흐름에 대한 분기가 이루어지는 점이 다르다. e &lt;- c(5, -4, 3) ifelse(e &gt;=0, e, -e) [1] 5 4 3 10.1.2 switch 함수 switch()는 하나의 함수이지만 if-else 조건문처럼 프로그램 흐름 제어에 사용될 수 있다. switch() 함수는 다음의 함수 형식을 갖는다. switch(EXPR, expression_1, ..., expression_n) switch()의 EXPR 인수에는 하나의 숫자나 문자열로 평가되는 표현식이 부여된다. EXPR 인수 다음에는 표현식의 목록이 나온다. expression_1부터 expression_n까지 n 개의 표현식이 EXPR 인수 다음에 인수로 추가되어 있다고 하자. EXPR 인수의 평가 결과가 숫자이고 그 숫자가 1부터 n 사이이면, switch() 함수는 해당 숫자 위치에 있는 expression 표현식을 실행하고 실행 결과를 반환한다. 만약 EXPR의 결과가 그 외의 숫자라면 아무 것도 수행하지 않고 NULL을 반환한다. 다음 예를 살펴보자. i &lt;- 2 switch(i, 10, 1:5, pi) [1] 1 2 3 4 5 i &lt;- 3 switch(i, 10, 1:5, pi) [1] 3.141593 i &lt;- 4 switch(i, 10, 1:5, pi) switch()의 EXPR 인수의 결과가 하나의 문자열이 될 수 있는데, 그 경우에는 EXPR 뒤에 나오는 표현식 앞에 이름을 붙인다. EXPR 인수 뒤에 나오는 표현식 중 하나는 이름이 없을 수 있다. 이 경우 EXPR의 결과값과 같은 이름을 가진 표현식이 실행된 후 그 결과값이 반환된다. 만약 EXPR 결과값이 뒤에 나오는 어떠한 표현식의 이름과도 같지 않으면, 이름이 없는 expression_default 표현식이 실행된다. switch(EXPR, name_1=expression_1, ..., name_n=expression_n, expression_default) 다음은 사용자에게 메뉴를 선택하게 하여 사용자가 선택한 메뉴에 따라 다른 내용을 출력하는 예이다. 예에서 repeat 반복문이 사용되는 데 관련 내용은 다음 절을 참조하기 바란다. menu &lt;- c(&quot;(b)anana&quot;, &quot;(o)range&quot;, &quot;(s)trawberry&quot;) repeat{ price &lt;- 0 cat(&quot;\\n다음 중 메뉴를 골라주세요:&quot;, paste(1:3, menu, sep=&quot;.&quot;), &quot;\\n&quot;) choice &lt;- readline(&quot;메뉴 선택 [b|o|s] 또는 종료 [q]: &quot;) switch(choice, b = {cat(&quot;바나나가 나왔습니다.\\n&quot;); price &lt;- 1000}, o = {cat(&quot;오렌지가 나왔습니다.\\n&quot;); price &lt;- 1200}, s = {cat(&quot;딸기가 나왔습니다.\\n&quot;); price &lt;- 1500}, q = break, cat(&quot;번호를 잘못 눌렀습니다.\\n&quot;)) cat(&quot;이번 거래는 총&quot;, price, &quot;원 입니다.\\n&quot;) } 10.2 R 반복문 10.2.1 for 반복문 프로그램을 작성하다 보면 변수의 값을 변화시키면서 동일한 작업을 반복할 필요가 있는 경우가 있다. 이러한 경우 for 반복문을 이용하면 좋다. 벡터 또는 리스트의 각 요소별로 반복하기 for ( variable in vector ) statement for ( variable in list ) statement for문은 vector의 요소를 차례로 변수 variable에 넣은 후 statement를 vector의 요소별로 한번씩 반복 실행한다. 다음은 for 반복문을 이용하여 1부터 5까지의 합을 구한 예이다. n의 각 요소가 차례로 x에 들어가서 s에 x를 더하는 작업이 반복된다. (물론 우리는 sum() 함수로 이를 더 빨리 수행할 수 있다. 그러니 실제 프로그램에서는 이러한 방식의 반복문을 만들지 말라. 이 예는 단지 이해를 위해 만든 예제이다.) n &lt;- 1:5 s &lt;- 0 for (x in n) s &lt;- s + x s [1] 15 반복할 명령문이 여러개이면 statement 부분에 블록 표현식을 이용하면 된다. 위의 예에서 반복문이 실제로 어떻게 수행되었는지를 확인해보기 위해서 반복되는 부문에 몇 가지 명령문을 추가해 보자. cat() 함수는 나열된 인수를 차례로 콘솔에 출력하는 함수이다. 아래 결과에서 블록 표현식 부분이 x값이 바뀌면서 5번 실행되었음을 볼 수 있다. 그리고 왜 s가 x의 합이 되는지 그 이유도 보여주고 있다. s &lt;- 0 for (x in n) { cat(&quot;반복 시작: x =&quot;, x, &quot;, s =&quot;, s, &quot;\\n&quot;) s &lt;- s + x cat(&quot;반복 끝 : x =&quot;, x, &quot;, s =&quot;, s, &quot;\\n\\n&quot;) } 반복 시작: x = 1 , s = 0 반복 끝 : x = 1 , s = 1 반복 시작: x = 2 , s = 1 반복 끝 : x = 2 , s = 3 반복 시작: x = 3 , s = 3 반복 끝 : x = 3 , s = 6 반복 시작: x = 4 , s = 6 반복 끝 : x = 4 , s = 10 반복 시작: x = 5 , s = 10 반복 끝 : x = 5 , s = 15 다음은 복합 조건문을 설명할 때 사용한 예를 주사위 게임을 여러 번 주사위를 던진 결과를 이용하여 복합 조건문을 반복한 결과이다 예이다. 복합 조건문의 예에서 x의 값을 바꾸려면 사람이 일일이 재실행해 보아야 했다. 여기서는 for 반복문을 통해 한번에 이와 같은 일을 수행할 수 있다. 이를 위해서 sample() 함수의 size를 10을 설정하여 1에서 6까지의 임의의 숫자를 5번 반복하여 복원 추출하도록 하였다. 아울러 총 손익을 합산하기 위하여 total이라는 변수도 도입하였다. total &lt;- 0 # 총 손익 초기화 x_vec &lt;- sample(1:6, size=5, replace = T) x_vec [1] 3 4 2 5 2 for( x in x_vec) { if (x&gt;=5) { cat(&quot;손님이 이겼습니다.\\n&quot;) y &lt;- 1 } else if ( x &gt;=3 ) { cat(&quot;무승부입니다.\\n&quot;) y &lt;- 0 } else { cat(&quot;딜러가 이겼습니다.\\n&quot;) y &lt;- -1 } cat(&quot;주사위 눈금:&quot;, x, &quot;\\n&quot;) cat(&quot;이번 게임 손익:&quot;, y, &quot;\\n&quot;) total &lt;- total + y cat(&quot;지금까지의 총 손익:&quot;, total, &quot;\\n\\n&quot;) } 무승부입니다. 주사위 눈금: 3 이번 게임 손익: 0 지금까지의 총 손익: 0 무승부입니다. 주사위 눈금: 4 이번 게임 손익: 0 지금까지의 총 손익: 0 딜러가 이겼습니다. 주사위 눈금: 2 이번 게임 손익: -1 지금까지의 총 손익: -1 손님이 이겼습니다. 주사위 눈금: 5 이번 게임 손익: 1 지금까지의 총 손익: 0 딜러가 이겼습니다. 주사위 눈금: 2 이번 게임 손익: -1 지금까지의 총 손익: -1 벡터의 인덱스를 이용하여 벡터 요소 반복하기 for 반복문에서는 반복 실행의 대상이 되는 벡터의 요소를 변수 variable에 넣어 반복 실행을 수행한다. 그런데 어떤 경우는 벡터의 요소를 variable에 부여하는 것이 아니라 벡터의 인덱스를 variable에 부여하여 반복하는 것이 편리한 경우가 있다. 이 경우는 앞의 for 반복문의 vector 부분에 반복의 대상이 되는 벡터 자체가 아니라 벡터의 인덱스 벡터를 부여한다. 다음은 앞의 주사위 게임의 반복에서 인덱스 벡터를 사용하여 게임의 횟수를 같이 출력하였다. total &lt;- 0 # 총 손익 초기화 x_vec &lt;- sample(1:6, size=5, replace = T) x_vec [1] 5 4 5 5 5 for( idx in 1:length(x_vec) ) { cat(idx, &quot;번째 게임입니다.\\n&quot;) x &lt;- x_vec[idx] if (x&gt;=5) { cat(&quot;손님이 이겼습니다.\\n&quot;) y &lt;- 1 } else if ( x &gt;=3 ) { cat(&quot;무승부입니다.\\n&quot;) y &lt;- 0 } else { cat(&quot;딜러가 이겼습니다.\\n&quot;) y &lt;- -1 } cat(&quot;주사위 눈금:&quot;, x, &quot;\\n&quot;) cat(&quot;이번 게임 손익:&quot;, y, &quot;\\n&quot;) total &lt;- total + y cat(&quot;지금까지의 총 손익:&quot;, total, &quot;\\n\\n&quot;) } 1 번째 게임입니다. 손님이 이겼습니다. 주사위 눈금: 5 이번 게임 손익: 1 지금까지의 총 손익: 1 2 번째 게임입니다. 무승부입니다. 주사위 눈금: 4 이번 게임 손익: 0 지금까지의 총 손익: 1 3 번째 게임입니다. 손님이 이겼습니다. 주사위 눈금: 5 이번 게임 손익: 1 지금까지의 총 손익: 2 4 번째 게임입니다. 손님이 이겼습니다. 주사위 눈금: 5 이번 게임 손익: 1 지금까지의 총 손익: 3 5 번째 게임입니다. 손님이 이겼습니다. 주사위 눈금: 5 이번 게임 손익: 1 지금까지의 총 손익: 4 조건문을 설명할 때 사용한 x와 y 벡터가 모두 0 이상이면 합을 출력하지만 그렇지 않은 경우에는 경고를 출력하는 예를 고려해 보자. for 반복문을 이용하여 이 조건문을 테스트하려고 한다. 이 때는 테스트에 필요한 벡터가 x, y로 2개나 되어서 for 문의 vector에 어떤 벡터를 넣어야 할지 고민이 된다. 이런 경우 vector 부분에 인덱스 벡터를 넣어 for 반복문을 실행하면 문제가 해결된다. x의 모든 요소에 대한 자연수 인덱스 벡터를 구하기 위해서 seq() 함수를 이용하였다. seq() 함수는 along 인수에 주어진 벡터의 모든 요소에 대한 자연수 인덱스 벡터를 반환한다. x &lt;- rep(c(1, -1), each=2) y &lt;- rep(c(1, -1), times=2) x [1] 1 1 -1 -1 y [1] 1 -1 1 -1 for ( i in seq(along=x)) { cat(x[i], &quot;+&quot;, y[i], &quot;= &quot;) if ( x[i] &gt;= 0 || y[i] &gt;= 0 ) { cat(x[i] + y[i], &quot;입니다\\n&quot;) } else { warning(&quot;x와 y 중 하나는 0 이상이어야 합니다.&quot;) } } 1 + 1 = 2 입니다 1 + -1 = 0 입니다 -1 + 1 = 0 입니다 -1 + -1 = Warning: x와 y 중 하나는 0 이상이어야 합니다. 10.2.2 while 반복문 조건에 따라 반복하기 for 반복문처럼 처음부터 반복할 횟수가 벡터의 크기로 정해져 있는 경우도 있지만 어떤 경우에는 사전에 몇번을 반복할지 결정이 안되어 있는 경우도 있다. 어떤 조건이 만족될 때는 반복이 계속되지만 그렇지 않은 경우에는 반복이 종료되는 경우가 대표적인 예이다. 이러한 경우에는 while 문을 이용하여 반복문을 구현하는 경우가 많다. while (statement1) statement2 while 문은 statement1이 TRUE이면 statement2를 실행한다. 그리고 다시 while 문의 맨 앞으로 돌아와 다시 statement1 조건을 비교하는 작업을 수행한다. 만약 statement1이 FALSE가 되면 statement2를 실행하지 않고 반복문에서 빠져나온다. 다음은 for 문을 사용하여 1부터 5까지 더한 예를 while 문으로 다시 수행한 예이다. 다음 예에서 statement2 부분은 블록문으로 구현되었다. s &lt;- 0 x &lt;- 1 while ( x &lt;= 5 ) { s &lt;- s + x x &lt;- x + 1 } s [1] 15 무한 반복이 발생하는 경우 while 문에서는 statement2에서 statement1이 FALSE가 되도록 하는 부분이 있어야 한다. 만약 없다면 while 문은 무한 반복된다. 위의 예에서 반복이 일어나는 블록문에서 x를 하나씩 증가시키는 부분을 제외시켜 보라. 그러면 프로그램은 무한 반복에 빠질 것이다. (프로그램이 무한 반복에 들어가면 ESC 키를 눌러라. 그러면 프로그램의 실행에서 빠져나올 수 있다.) 사용자의 입력에 따라 반복할지 결정하기 while 문은 사용자 입력에 따라 반복을 할지 말지를 결정하는 경우에 자주 사용된다. 다음과 같은 예를 생각해 보자. iris 데이터 프레임에 대해 사용자에게 히스토그램을 그릴 열 번호를 입력받은 후, 해당 열에 대한 히스토그램을 그려주려고 한다. 사용자의 입력을 받아 히스토그램을 그린 후에는 다시 사용자의 입력을 받는 작업을 반복하고자 한다. 그리고 사용자의 입력이 숫자가 아니라 ‘q’이면 이러한 반복을 종료하고자 한다. 다음 예는 while 문을 이용하여 위에 설명한 기능을 구현한 예이다. 여기서는 사용자가 ’q’ 또는 0부터 4까지의 정수만 정확히 입력한다고 가정하여, 사용자가 이외의 값을 입력할 때의 예외 처리는 수행하지 않았다. 사용자의 입력은 readline() 함수를 이용하여 수행하였다. readline()은 콘솔 또는 파일에서 한 줄씩 입력을 받아 그 결과를 전달하는 함수이다. 이에 대한 자세한 설명은 R 도움말을 참조하라. num &lt;- &quot;1&quot; while ( num != &quot;0&quot;) { n &lt;- as.integer(num) hist(iris[[n]], main = names(iris)[n]) cat(&quot;히스토그램을 출력할 열을 선택하세요[1-4]. 종료를 원하면 0을 입력&quot;) num &lt;- readline() } 10.2.3 repeat 반복문 repeat 문은 다음과 같은 형식을 가진다. 벡터의 패턴을 반복하여 새로운 벡터를 만들어 주는 rep() 함수와 혼동하는 경우가 많으니 주의하길 바란다. repeat statement repeat 문의 무한 반복은 break 문으로 빠져나온다. while 문은 statement1 부분에 반복의 종료 조건이 명시적으로 기술되는데 반해, repeat 문은 반복의 종료 조건이 명시적으로 표시되지 않는다. repeat 문은 statement를 그저 무한 반복할 뿐이다. 반복을 중지하려면 repeat 문 안에 break 문을 넣어 반복에서 직접 빠져나와야 한다. 다음은 iris 데이터에 대한 히스토그램을 그리는 예를 repeat 문으로 수행한 예이다. while 문은 처음에 조건을 비교하여 반복을 결정하므로 초기에 num을 1로 설정하였으나 repeat 문을 이용하는 경우 그럴 필요가 없다. repeat 문 안에서 사용자 입력이 처음으로 이루어진 후 ’0’인지를 비교하여 빠져나올지 아닐지를 결정하면 된다. repeat { cat(&quot;히스토그램을 출력할 열을 선택하세요[1-4]. 종료를 원하면 0을 입력&quot;) num &lt;- readline() if (num == &quot;0&quot;) { cat(&quot;Bye~~!&quot;) break } n &lt;- as.integer(num) hist(iris[[n]], main = names(iris)[n]) } repeat 문은 블록문 내부 어디서나 반복 종료의 조건이 발생하면 break 문을 이용하여 자유롭게 빠져 나올 수 있으므로 매우 유연한 반복문을 만들 수 있는 장점이 있다. 하지만 반복문의 종료 조건이 무엇인지 파악하려면 repeat 문 전체를 살펴보아야 하는 단점이 있다. 특히 반복되는 부분이 길면 이를 파악하는 것이 쉽지가 않다. 반면 for 문과 while 문은 종료 조건이 반복문 앞에 명시적으로 놓이므로 이를 파악하기가 쉽다. 10.2.4 반복문의 제어 명령 우리는 앞서서 repeat 반복문에서 break 명령문을 이용하여 반복문을 빠져 나오는 방법을 배웠다. 사실 break 문은 모든 반복문에서 사용이 가능하다. for 문이나 while 문이 아직 종료 조건이 되지 않았다 하더라도 반복 중에 break 문을 만나면 즉시 실행이 종료된다. 보통 프로그램에서 복구할 수 없는 오류를 인지했을 때 종료 조건이 만족되지 않아도 break 문으로 프로그램 반복을 빠져 나오도록 하는 경우가 많다. break 문과 함께 반복문을 제어하는 명령문으로 next가 있다. 이 명령이 실행되면 반복문을 완전히 빠져나오지는 않지만, 이번 차의 반복에서 빠져 나와 다음번 차의 반복이 실행한다. 다음은 for 문을 사용하여 벡터에서 홀수만을 더한 예이다. a가 짝수이면 next 문을 이용하여 s에 a가 더해지는 부분을 건너띄고 다음번 회차의 반복으로 넘어가고 있다. x &lt;- c(5, 4, 8, 9, 10, 11) s &lt;- 0 for (a in x) { if( a %% 2 == 0) next cat(a, s, &quot;\\n&quot;) s &lt;- s + a } 5 0 9 5 11 14 s [1] 25 10.2.5 R에서 반복문 사용의 주의점 명시적 반복문은 되도록 피하는 것이 좋다. 지금까지 R의 다양한 반복문의 문법에 대해서 설명하였지만, 사실 R에서는 반복문이 꼭 필요한 경우가 아니라면 반복문의 사용을 피하는 것이 좋다. R은 사실 함수 프로그래밍 언어로서 앞의 모든 명령문은 함수 호출로 구현된다. 따라서 반복문의 반복 횟수가 커지면 엄청나게 많은 함수 호출이 발생한다. 일반적으로 프로그래밍 언어에서 함수 호출은 스택 프레임 등을 설정해야 하므로 계산 시간이 많이 요구되는 고비용 작업이다. 벡터화된 내장 함수로 암시적인 반복을 수행하라. 많은 R의 함수들은 벡터가 인수로 전달될 때, 벡터 요소 전체에 대해 암시적인 방식으로 반복 작업을 수행하여 결과를 제공한다. 이러한 R 함수를 벡터화(vectorized) 되었다고 하는데, 보통 벡터화된 내장 함수는 C로 구현되어 매우 빠른 계산 반복을 수행하므로, 명시적으로 반복문을 이용하는 것보다 훨씬 빠른 시간 내에 결과를 제공해 준다. 다음은 x와 y의 두 벡터의 같은 위치의 요소를 비교하여 둘 중 더 큰 요소만을 뽑아서 합을 구한 예이다. R의 ifelse()와 sum()를 이용하면 이를 쉽게 수행할 수 있다. 이 두 함수는 벡터화된 내장 함수이다. system.time() 함수는 함수의 인수로 전달된 표현식을 실행하고 이 표현식을 실행하는 데 걸린 시간을 반환해 준다. set.seed(123) n &lt;- 1000000 x &lt;- rnorm(n) y &lt;- rnorm(n) system.time(sum(ifelse(x &gt; y, x, y))) 사용자 시스템 elapsed 0.030 0.008 0.037 앞의 문제를 for 문을 이용하여 구현한 후, 실행 시간을 측정해 보자. 쉽게 두 방식의 시간 차이를 확인할 수 있을 것이다. s &lt;- 0 system.time({ for (i in 1:n){ if (x[i] &gt; y[i]) s &lt;- s + x[i] else s &lt;- s + y[i] } }) 사용자 시스템 elapsed 0.060 0.005 0.064 다음은 -1000부터 1000사이의 정수에서 복원 추출로 1,000,000 개의 수를 뽑은 후, 그 중 3의 배수가 되는 원소만 뽑아서 합을 구한 예이다. 첫번째 방식은 벡터 인덱싱과 sum() 함수를 이용했고, 두번째 방식은 for() 문을 이용해 각 원소별로 반복 작업을 하였다 그리고 이 두 방식의 실행 시간을 비교하였다. 마찬가지로 큰 시간 차이를 보임을 알 수 있다. set.seed(111) n &lt;- 1000000 x &lt;- sample(-1000:1000, n, replace=T) system.time({ sum( x[x %% 3 == 0] ) }) 사용자 시스템 elapsed 0.023 0.004 0.027 system.time({ s &lt;- 0 for (a in x) { if (a %% 3 == 0) s &lt;- s + a } print(s) }) [1] 198993 사용자 시스템 elapsed 0.162 0.000 0.163 apply 계열 함수로 암시적인 반복을 수행하라. R에서는 리스트의 요소에 대해 동일한 작업을 반복할 때, lapply나 sapply() 함수를 이용하여 암시적인 반복을 수행한다. 또한 행렬의 열이나 행에 반복 작업을 할 때에도 apply() 함수를 사용한다. 이러한 작업은 for 반복문 등을 이용해서도 수행할 수 있다. 사실 C나 다른 언어에 익숙한 사람이 R을 처음 접하게 되면 반복이 필요한 경우 for 반복문 등을 이용하여 명시적인 반복을 하는 경우가 많다. 그러면 이 두 가지 반복 방법 중 어느 것이 더 권장되어야 할까? 가끔 apply 종류 함수가 더 빠르게 실행하기 때문에 명시적 반복보다는 apply 계열 함수로 암시적 반복을 하라는 의견들을 볼 수 있는데, 이러한 주장은 신빙성이 크지는 않다. 다음은 예에서는 -1000부터 1000사이의 정수에서 복원 추출로 100,000 개의 수를 뽑아내는 작업을 100번 반복하여 x라는 리스트의 요소로 넣었다. 그 후 리스트의 각 요소에서 3의 배수의 합을 구한 후 합의 최대값을 구하였다. 필요한 반복 작업은 lappy, sapply 함수에 의해 수행되었다. set.seed(11) n &lt;- 100000 x &lt;- lapply(1:100, function(i) sample(-1000:1000, n, replace=T)) system.time( { s &lt;- sapply(x, function(y) sum(y[y %% 3 == 0])) print(max(s)) }) [1] 285816 사용자 시스템 elapsed 0.238 0.008 0.247 다음은 for 문을 이용하여 x의 요소에 대하여 같은 작업을 반복하였다. 계산 시간의 차이를 비교해 보자. 결과에서 보듯이 두 방법 모두 벡터화된 함수를 적절히 이용하면 속도의 차이는 거의 나지 않는다. system.time({ s.max &lt;- -Inf for(i in 1:length(x)) { s &lt;- sum(x[[i]][x[[i]] %% 3 == 0]) if(s &gt; s.max) s.max &lt;- s } print(s.max) }) [1] 285816 사용자 시스템 elapsed 0.248 0.001 0.249 그렇다면 두 방법 중 어느 것을 선택해도 될까? 일반적으로 이 두 방법 중 어느 것이 더 좋다고 확언하기는 어렵지만 다음의 두 가지 이유 때문에 apply 계열 함수를 이용하는 것이 더 선호된다. 첫째, apply 계열 함수를 이용하면 코드를 더 간단하게 작성할 수 있어 코드의 가독성이 증가한다. 둘째, apply 계열 함수는 데이터 요소에 적용할 함수를 인수로 전달하는 방식으로 암시적 반복이 이루어진다. 따라서 함수 프로그래밍의 특징인 반복 실행의 부수적인 효과(side effect)가 반복문 바깥으로 전달되지 않는다. 따라서 동일한 프로그램을 병렬 프로그램으로 전환하기가 더 용이하다. 그러므로 처리해야 할 데이터가 커지면 병렬 프로그래밍 기법을 이용하여 추가적인 속도 향상을 꾀할 수 있는 가능성이 커진다. 10.3 R 함수 함수의 필요성 우리는 앞서서 반복문을 사용하여 동일한 작업을 재입력 없이 원하는 횟수만큼 반복시킬 수 있음을 보았다. 그런데 어떤 경우에는 동일한 작업을 입력 변수에 따라 다른 출력 결과로 얻고 싶을 때가 있다. 예를 들어 1부터 시작하여 자연수 n까지의 홀수의 합을 구하고 싶은데, 매번 다른 n에 대하여 결과를 구하고 싶다고 하자. 이러한 경우에 함수를 이용하면 원하는 결과를 얻을 수 있다. 함수는 입력 변수에 따라 다른 결과를 반환하는 일련의 프로그램 덩어리라 할 수 있다. R은 함수를 closure 타입의 객체로 생성한다. R에서 제공하는 많은 함수들은 내장 함수(builtin functions)를 제외하고는 사용자가 생성하는 함수와 본질적으로 동일하다. 다음은 R에서 자주 사용되는 함수의 타입을 보여준다. sum() 함수를 제외하고는 모두 closure 타입임을 알 수 있다. typeof(sum) [1] &quot;builtin&quot; typeof(mean) [1] &quot;closure&quot; typeof(summary) [1] &quot;closure&quot; typeof(plot) [1] &quot;closure&quot; 10.3.1 함수의 생성과 호출 함수 정의하기 R에서 함수 만들기는 function() 함수의 호출에 의해 이뤄진다. (함수를 생성하는 것을 함수를 정의한다라고 한다.) function_name &lt;- function(formal_arg1, formal_arg2, ...) function_body_expression function() 함수를 호출하여 그 결과를 변수에 할당하는데, 그 변수 이름이 함수의 이름으로 사용된다. funtion()의 인수로는 새롭게 생성할 함수에 사용할 형식 인수(formal_arg 부분)가 나열된다. 그리고는 함수가 호출되면 실행될 함수 본문 표현식(function_body_expression 부분)을 기술한다. 함수 본문 표현식은 R의 어떠한 표현식도 가능하며 함수 본문 표현식이 실행된 결과가 함수의 결과값으로 반환된다. 보통은 함수가 실행될 때 여러 개의 명령문이 실행되어야 하는 경우가 많다. 이러한 경우 함수 본문 표현식을 { }을 이용한 블록 표현식으로 표현하다. 그러면 return() 함수로 명시적으로 반환한 결과값을 지정하지 않을 경우, 블록 표현식 안의 마지막 표현식의 실행 결과가 함수의 결과값으로 반환된다. 다음은 함수 g()를 생성한 예이다. g() 함수를 생성하려면 function()의 결과가 할당되는 변수의 이름이 g이어야 한다. 그리고 g() 함수의 형식 인수로 x, y, z가 정의되었고, 함수 본문 표현식은 \\(100x + 10y + z\\)로 정의되었다. 따라서 g() 함수는 호출될 때마다 x, y, z 인수에 값을 전달받아, \\(100x + 10y + z\\)를 계산하여 반환하도록 정의된 것이다. g &lt;- function(x, y, z) 100 * x + 10 * y + z 함수도 객체이다. 함수 객체가 잘 생성되었는지를 확인하기 위해 함수 객체 g를 출력해 보았다. R 콘솔에서 변수 이름을 입력하면 변수가 지정하고 있는 객체의 내용을 출력하게 되는데, closure 객체는 함수 정의를 출력한다. g function(x, y, z) 100 * x + 10 * y + z 함수 호출하기 함수에 정의된 프로그램 덩어리를 실행시키는 과정을 함수를 호출한다고 표현한다. 함수에 대한 호출은 다음의 형태로 이루어진다. 먼저 함수의 이름을 적고 괄호 안에 함수의 형식 인수에 전달할 값을 기술한다(이를 실질 인수라고 한다). 함수를 호출할 때, 다음처럼 실질 인수 값만 기술하여 함수를 호출할 수도 있고, 실질 인수가 어떤 형식 인수로 전달될지를 (형식 인수)=(실질 인수)의 쌍으로 기술하여 호출할 수도 있다. function_name(actual_arg1, actual_arg2, ...) function_name(formal_arg1=actual_arg1, formal_arg2=actual_arg2, ...) 형식 인수를 지정하지 않고 호출하기 형식 인수를 지정하지 않고 실질 인수를 기술하여 호출하면, 함수 정의 때 기술된 형식 인수 순으로 실질 인수가 차례로 전달된다. 다음은 실질 인수를 1, 2, 0으로 하여 g() 함수를 호출한 예이다. g() 함수의 정의에서 형식 인수가 x, y, z 순으로 정의되었으므로, x에 1, y에 2, z에는 0이 전달되어 함수 본문 표현식이 실행된다. 따라서, 함수 본문 표현식의 결과인 9가 함수 호출의 결과로 반환된다. g(1, 2, 0) [1] 120 다음은 실질 인수 값을 바꾸어 가면서 g() 함수를 호출한 결과이다. g(2, 1, 0) [1] 210 g(0, 7, 1) [1] 71 벡터화된 함수 그런데 g() 함수 본문 표현식에서 곱하기와 더하기 연산자만을 사용하였다. 이 연산자들은 벡터의 요소끼리 곱하기와 더하기를 수행해 주는 연산자이다. 따라서, g() 함수의 실질 인수에 숫자 하나뿐 아니라 여러 숫자를 가진 벡터가 전달되어도 요소끼리 계산이 수행되어 벡터로서 결과가 반환될 수 있다. g() 함수처럼 벡터가 인수로 전달되면 벡터의 인수별로 계산을 수행하여 벡터로 결과를 주는 함수를 벡터화(vectorization)된 함수라고 한다. 일반적으로 R의 기본 연산자와 함수는 벡터화되어 있는 경우가 많으므로, 이러한 함수와 연산자를 이용하여 함수를 만들면 이 함수 역시 벡터화된 함수가 된다. 다음 예에서는 벡터가 인수로 전달될 때, 벡터의 요소끼리 계산과 벡터의 재사용이 일어남을 볼 수 있다. 주의할 점은 모든 함수가 벡터화되어 있지는 않다는 것이다. 따라서 어떤 함수가 벡터화된 함수인지를 확인하려면 도움말을 참조하거나 직접 테스트를 해보아야 한다. g(1:3, 1, c(2, 4, 6)) [1] 112 214 316 형식 인수를 지정하여 함수 호출 하기 함수 호출 시에 실질 인수가 어떤 형식 인수로 전달할지를 지정할 수 있다. 그러면 함수 호출 시의 실질 인수의 순서는 중요하지 않고, 실질 인수에 지정된 형식 인수로 값이 전달되어 함수 본문이 실행된다. g(y=2, x=1, z=0) [1] 120 g(z=0, x=1, y=2) [1] 120 g(1, 2, x=3) [1] 312 g(x=1, 2, y=0) [1] 102 마지막 두 예에서 볼 수 있듯이 실질 인수에 형식 인수가 지정된 것과 그렇지 않은 실질 인수가 섞여서 호출이 이루어질 수도 있다. 이 경우 형식 인수가 지정된 실질 인수는 해당 형식 인수로 전달되지만, 나머지 실질 인수는 아직 실질 인수가 부여되지 않은 형식 인수에 함수 정의에 기술된 순서대로 차례로 전달된다. 형식 인수 수와 실질 인수의 수가 다르면 오류가 발생한다. 다음처럼 형식 인수 수와 호출 시 전달되는 실질 인수 수가 맞지 않으면 오류가 발생한다. 첫번째 예는 형식 인수 z에 전달되는 값이 없어서 오류가 발생하였고, 두번째 예는 실질 인수 4를 전달할 형식 인수가 없어서 오류가 발생하였다. g(1, x=2) Error in g(1, x = 2): 기본값이 없는 인수 &quot;z&quot;가 누락되어 있습니다 g(1, 2, 3, 4) Error in g(1, 2, 3, 4): 사용되지 않은 인자 (4) 형식 인수의 초기값 설정하기 그런데 함수를 정의할 때 형식 인수에 초기값을 설정할 수 있다. 이러한 경우에는 함수 호출 시 형식 인수에 실질 인수 값이 전달되지 않으면 초기값을 형식 인수에 부여한 후 함수 본문을 실행한다. 초기값은 함수 정의 시 형식 인수를 나열할 때, (형식 인수)=(초기값) 형태로 기술하면 된다.11 형식 인수의 초기값이 어떻게 작동하는지를 살펴보기 위해서 1부터 어떤 자연수 b까지 홀수의 합을 구하는 다음과 같은 oddsum() 함수를 고려해 보자. oddsum &lt;- function(b) sum(seq(from=1, to=b, by=2)) oddsum(5) [1] 9 oddsum(10) [1] 25 앞서 설명하였듯이 형식 인수 b에 값을 전달하지 않으면 oddsum() 함수의 호출은 오류가 난다. oddsum() Error in oddsum(): 기본값이 없는 인수 &quot;b&quot;가 누락되어 있습니다 그런데 다음처럼 형식 인수 b에 초기값으로 100을 설정해 두면, 형식 인수 b에 전달할 실질 인수가 없어도 b에 100이 전달되어 잘 실행됨을 볼 수 있다. 그리고 형식 인수 b에 실질 인수가 부여되면 초기값은 무시되고 실질 인수 값으로 함수가 수행됨을 볼 수 있다. oddsum &lt;- function(b=100) sum( seq(from=1, to=b, by=2) ) oddsum() [1] 2500 oddsum(3) [1] 4 위의 oddsum() 함수는 형식 인수 b를 이용하여 1부터 시작하는 홀수 수열의 종료 지점만을 입력받아 합을 구하도록 구현되어 있다. 이 함수의 범용성을 높이기 위해 홀수 수열의 시작 지점을 형식 인수 a에 입력받아 홀수 합을 구하도록 개선해 보자. 그런데, 이렇게 함수를 개선하면 기존에 이 함수를 이용하는 프로그램은 형식 인수 a에 값을 부여하지 않고 호출하기 때문에 모두 오류가 발생할 것이다. 따라서 앞서 작동하던 방식과 호환성을 유지하기 위해 호출시 시작 지점 a가 지정되지 않으면 1부터 시작하는 홀수 수열의 합을 구하도록 개선된 함수를 정의해 보자. oddsum &lt;- function(b=100, a=1) sum(seq(from=a, to=b, by=2)) oddsum(a=5, b=10) [1] 21 oddsum(3) [1] 4 위의 예의 마지막 oddsum() 함수 호출에서 실질 인수가 하나밖에 없으므로 형식 인수 정의 순서에서 가장 빠른 b에 3이 부여된다. 그러므로 a는 값이 지정되지 않았으므로 초기값 1이 부여되어 실행된다. b도 초기값이 지정되어 있으므로 a 값만 지정하여 호출도 가능하다. 이 경우 형식 인수 a가 형식 인수 b 뒤에 정의되어 있으므로 a에만 실질 인수를 전달하고 실질 인수 앞에 형식 인수 a를 지정하여 호출해야 한다. oddsum(a=97) [1] 196 R 기본 함수에서의 초기값 사용 이러한 원리로 R의 많은 함수들이 함수의 모든 인수를 일일이 지정하지 않아도 호출이 가능하도록 정의되어 있다. 예를 들어 수열을 만드는 seq() 함수는 from 인수는 초기값이 1, to 인수도 초기값이 1, by 인수는 to부터 from 사이를 1씩 증가하도록 초기값이 설정되어 있다. 그리고, 형식 인수의 정의 순서는 from, to, by 순으로 되어 있다. 이러한 사실을 고려하면 왜 다음의 seq() 호출이 해당 결과를 출력하는지 이해할 수 있을 것이다. seq() [1] 1 seq(by=2) [1] 1 seq(1, 5, 2) [1] 1 3 5 seq(to=4) [1] 1 2 3 4 seq(to=-5) [1] 1 0 -1 -2 -3 -4 -5 seq(to=10, by=2) [1] 1 3 5 7 9 또 다른 예로 CSV 파일에서 데이터 프레임을 읽어들이는 read.csv() 파일의 정의를 살펴보자. read.csv function (file, header = TRUE, sep = &quot;,&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;.&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) read.table(file = file, header = header, sep = sep, quote = quote, dec = dec, fill = fill, comment.char = comment.char, ...) &lt;bytecode: 0x563f417af2a8&gt; &lt;environment: namespace:utils&gt; 첫번째 형식 인수가 file로서 초기값이 없으므로 항상 read.csv() 호출시에는 파일 이름이 제공되어야 함을 알 수 있다. 두번째 형식 인수는 header인데 TRUE로 초기값을 가지고 있다. 따라서 header 인수를 지정하지 않고 호출하면 파일에 header가 있는 것으로 생각하고 파일을 읽어들인다. 그리고 sep 형식 인수는 파일이 데이터의 필드(열)를 무엇으로 분리하고 있는지를 전달하는 인수이다. 초기값이 ’,’로 되어 있어서 함수 호출시 특별한 지정이 없으면 쉼표로 데이터를 분리하여 인식한다는 것을 알 수 있다.12 ... 형식 인수 R 함수의 형식 인수 중에 ...라는 형식 인수가 있다. 이 형식 인수는 함수 정의 때 기술된 형식 인수 말고 다른 형식 인수 이름으로 실질 인수를 전달받을 수 있게 해준다. 다음 예에서 g()에서 w 형식 인수가 정의되어 있지 않아, 실질 인수 1을 형식 인수 w로 전달하려는 호출에 오류가 발생하는 것을 볼 수 있다. g(x=1, y=1, z=1, w=1) Error in g(x = 1, y = 1, z = 1, w = 1): 사용되지 않은 인자 (w = 1) 그런데 함수를 정의할 때, 형식 인수 목록에 ’...’를 지정하면, 정의된 형식 인수 말고 다른 이름의 형식 인수로 실질 인수를 전달받아도 오류가 나지 않음을 알 수 있다. g &lt;- function(x, y, z, ...) 100 * x + 10 * y + z g(x=1, y=1, z=1, w=1, r=2) [1] 111 그런데 위의 예에서는 전달 받은 w나 r을 함수 본문에서 전혀 사용하지 않았으므로 쓸모 없는 실질 인수의 전달이 되었다. 만약 위의 예가 x, y, z로 전달된 인수뿐 아니라 다른 이름으로 전달된 인수를 모두 출력한 후 그 인수들을 합산하여 결과에 반영한다고 하면 새롭게 전달된 형식 인수들이 의미를 가질 것이다. 다음은 ’...’를 이용하여 이름이 지정되지 않은 형식 인수를 전달받아 처리하는 예를 보여준다. g &lt;- function(x, y, z, ...) { cat(..., sep=&quot;,&quot;) cat(&quot;를 추가적으로 입력받았습니다.\\n&quot;) 100 * x + 10 * y + z + sum(...) } g(x=1, y=1, z=1, w=1, r=2) 1,2를 추가적으로 입력받았습니다. [1] 114 일반적으로 ... 인수는 다음 두 가지 경우에 많이 사용된다. c()나 sum() 함수처럼 개수가 지정되지 않은 여러 개의 요소를 받아서 일괄적인 처리가 필요한 경우이다. 이 경우 몇 개의 실질 인수가 전달될지 모르기 때문에 이름을 가진 형식 인수로 실질 인수를 전달받을 수 없다. c function (...) .Primitive(&quot;c&quot;) c(1:2, c(3, 6), 7:2) [1] 1 2 3 6 7 6 5 4 3 2 sum function (..., na.rm = FALSE) .Primitive(&quot;sum&quot;) sum(1:2, c(3, 6), 7:2) [1] 39 두번째는 자신에게 전달된 부차적인 인수들을 자신이 직접 처리하지 않고, 다른 함수에게 전달하여 처리하는 경우이다. plot()의 주요한 형식 인수는 그래프 상에서의 점을 그릴 x 축과 y 축의 좌표이다. x &lt;- 1:30 y &lt;- x^2 plot(x, y) plot() 함수는 이러한 주요 인수뿐 아니라 ... 인수를 이용하여 다양한 그래픽 매개변수를 선택적으로 전달받을 수 있다. plot function (x, y, ...) UseMethod(&quot;plot&quot;) &lt;bytecode: 0x563f41753d88&gt; &lt;environment: namespace:base&gt; plot(x, y, type=&quot;o&quot;, col=&quot;red&quot;, pch=&quot;*&quot;, lty=1, lwd=1.5) 실제로는 이렇게 전달받은 선택적인 인수는 자신이 직접 처리하는 것이 아니라 par() 함수 등에 전달하여 처리한다. 그런데 par() 함수에 전달될 수 있는 인수는 매우 다양하므로 이를 일일이 plot()의 형식 인수로 지정하는 것은 힘든 일이 될 것이다. 또한 이를 모두 지정할 수 있다 하더라도 par() 함수에 새로운 인수가 추가되면 plot() 함수의 정의도 변경되어야 한다. 이러한 경우 ... 인수를 이용하여 기타 선택적인 인수를 전달받은 후 모두 par() 함수에 전달하여 처리하면 편리하다. R의 기본 함수 중에는 자신이 받은 인수를 다른 함수에 전달하여 실행하는 경우가 많아서 의외로 ... 인수가 정의된 함수들이 많이 있다. 함수의 반환값 앞에서 함수가 반환하는 값은 함수 본문 표현식의 평가 결과라고 말하였다. 보통 함수 본문 표현식은 블록 표현식인 경우가 많으므로 블록 표현식의 평가 결과는 블록 표현식의 마지막 명령문의 평가 결과가 된다. 따라서 블록 표현식이 함수 본문인 경우 마지막 명령문의 실행 결과가 반환되게 된다. 다음은 어떤 물품의 주문수량(quantity)를 입력받아서 가격을 반환하는 함수이다. 주문수량이 500 개 미만이면 물품의 단가를 100원으로 500 개 이상이면 물품의 단가를 80원으로 하여 가격을 계산하여 반환한다. 함수에 여러 개의 실행문이 있는 경우에는 반복문과 마찬가지로 중괄호 { }를 이용하여 실행문을 묶어준다. 이 경우 중괄호 { } 안에서 마지막으로 실행된 실행문의 결과가 함수의 반환값으로 반환된다. calPrice &lt;- function(quantity) { if (quantity &lt; 500) { unitPrice &lt;- 100 } else { unitPrice &lt;- 80 } unitPrice * quantity } calPrice(100) [1] 10000 calPrice(1000) [1] 80000 그런데 함수 본문의 중간에서 결과를 반환한 필요가 있을 때가 있다. 이런 경우에는 return() 함수를 이용하여 명시적으로 함수를 종료하고 특정 표현식의 결과 값을 반환하도록 할 수 있다. 다음 예는 입력 변수 x의 값의 0이거나 양수이면 x의 제곱근의 값을 반환하지만 x가 음수이면 제곱근을 구할 수 없기 때문에 관련된 메시지를 출력하고 NULL을 반환하는 함수를 만든 예이다. h &lt;- function(x) { if (x &lt; 0) { cat(&quot;x must be positive.\\n&quot;) return(NULL) } sqrt(x) } h(2) [1] 1.414214 h(-2) x must be positive. NULL 위의 예에서 return()을 이용하여 함수 본문의 마지막에 도달하기 전에 함수를 종료시키고 원하는 값을 반환하였다. 함수 본문의 마지막 부분에도 명시적으로 return() 함수를 이용하여 값을 반환할 수 있다. calPrice2 &lt;- function(quantity) { if (quantity &lt; 500) { unitPrice &lt;- 100 } else { unitPrice &lt;- 80 } return(unitPrice * quantity) } calPrice2(100) [1] 10000 calPrice2(1000) [1] 80000 그러나 일반적으로 R에서는 마지막 평가식의 결과를 반환할 때는 return() 함수를 사용하지 않는 경향이 많다. 10.3.2 함수 객체를 인수로 사용하기 함수도 객체이므로 실질 인수가 될 수 있다. lapply() 함수와 sapply() 함수는 리스트의 각 요소에 원하는 함수를 반복적으로 적용할 수 있게 해준다. 이 때 리스트 요소에 적용할 함수를 lapply()와 sapply()의 실질 인수로 전달하였다. 이러한 일이 가능한 이유는 R에서는 함수도 객체이므로 일반 벡터나 행렬처럼 함수의 인수로 함수를 전달할 수 있기 때문이다. 다음은 숫자 벡터들을 요소로 하는 리스트에 대해, 각 요소의 평균을 구한 예이다. 이 예에서 sapply() 함수 호출 시 첫번째 인수로 리스트를, 두번째 인수로 mean() 함수 객체를 전달하고 있음을 볼 수 있다. a &lt;- list(x=x, y=y, z=sqrt(x)) sapply(a, mean) x y z 15.500000 315.166667 3.736095 mean function (x, ...) UseMethod(&quot;mean&quot;) &lt;bytecode: 0x563f3e5f7f20&gt; &lt;environment: namespace:base&gt; apply 계열 함수에 사용자 함수 적용하기 그런데 apply 계열 함수에는 R에서 기본적으로 제공하는 함수뿐만 아니라 사용자가 직접 정의한 함수를 포함한 어떠한 함수도 전달이 가능하다. 다음은 벡터에서 10 이상의 숫자의 개수를 세는 count10()이라는 사용자 함수를 정의한 후 이를 sapply()에 인수로 전달한 예이다. count10 &lt;- function(x) sum(x &gt;= 10) sapply(a, count10) x y z 21 27 0 무기명 함수 그런데 count10()이 다른 데서도 사용할 만한 범용적인 함수라면 이를 위의 예처럼 변수에 할당하여 계속 사용하는 것이 좋겠지만, 이 sapply() 함수 호출에만 이용하는 임시적인 함수라면 굳이 변수에 할당하여 메모리에 저장해 둘 이유가 없다. 이런 경우에는 sapply()의 두번째 인수 부분에 직접 함수 객체를 만들어 전달하는 것이 더 효율적이다. 이 함수는 변수로 저장되지 않았으므로 추후에 다시 호출할 수 있는 방법은 없다. 이러한 함수를 무기명 함수(anonymous functions)라고 한다. 다음은 무기명 함수를 이용하여 리스트의 요소에서 5이상의 수의 개수를 세는 예이다. sapply(a, function(x) sum(x &gt;= 5)) x y z 26 28 6 무기명 함수를 이용하면 한번만 사용될 함수를 메모리에 남겨두지 않을 수 있고, sapply() 호출 문장에 함수가 바로 정의되어 있어서 리스트 요소에 적용되는 함수의 내용을 바로 그 지점에서 파악이 가능한 장점이 있다. 사실 무기명 함수는 함수 객체를 변수에 부여하지 않는다는 측면에서, 다음처럼 한번만 사용될 데이터 객체를 굳이 변수에 넣지 않는 예와 일맥상통하다고 할 수 있다. 이 경우에도 sapply()에 사용된 리스트가 변수에 할당되지 않았으므로 다시 이 데이터에 접근할 수 있는 방법은 없다. sapply(list(x=1:5, y=x^2, z=sqrt(x)), mean) x y z 3.000000 315.166667 3.736095 10.3.3 R 연산자 R에서는 연산자도 사실 함수이다. 대신 연산자의 함수 이름을 쓰기 위해서는 ` ` 안에 연산자를 표현해야 한다. 1 + 3 [1] 4 typeof(`+`) [1] &quot;builtin&quot; `+`(1, 2) [1] 3 `-`(1, 2) [1] -1 R 사용자는 함수를 정의하는 방식과 같은 방법으로 자신만의 연산자를 정의할 수 있다. 다만 사용자가 정의하는 연산자의 함수이름은 %연산자이름% 형식으로 정의하여야 한다. 다음과 같은 f 연산자를 만들어 보자. `%f%` &lt;- function(x, y) x^2 - y 2 %f% 4 [1] 0 3 %f% 0 [1] 9 `%f%`(1, 2) [1] -1 10.3.4 변수 범위 프로그램이 복잡해지면 많은 변수를 사용하게 된다. 이 때 변수 이름 간에 서로 충돌이 나지 않도록 조심해야 한다. 중복된 이름을 사용하면 의도하지 않은 결과를 얻게 될 수 있다. 변수 범위의 필요성 혼자 프로그램을 할 때는 일정한 규칙에 따라 변수 이름을 부여해 나가면 변수 이름의 충돌을 어느 정도 방지할 수 있다. 그러나 여러 사람이 같이 협력하여 큰 프로그램을 완성하거나, 다른 사람이 이미 만들어둔 패키지나 함수들을 이용해야 한다면 변수 이름의 충돌은 빈번하게 발생할 가능성이 크다. 예를 들어 x라는 변수 이름은 많은 사람들이 즐겨 사용할 만한 이름이어서 프로그램의 서로 다른 부분에서 x를 다르게 정의하여 사용할 가능성이 커진다. 그러므로 내가 사용하는 변수 x와 다른 사람이 정의한 함수 내의 x를 서로 구분할 수 있는 방법이 필요하다. 그렇지 않다면 변수 이름을 하나 작명하는 데에도 다른 사람들이 이미 작성한 함수에서 사용한 변수의 이름을 먼저 조사해야 할 것이다. 실제 R에서는 엄청나게 많은 함수들이 존재하고 이를 수행한다는 것은 사실 불가능에 가깝다. 이러한 변수 이름의 충돌 문제를 거의 대부분의 고급 프로그래밍 언어는 변수의 범위(scope)라는 개념을 이용하여 해결한다. R도 예외는 아니다. 변수의 범위란 해당 변수가 유효한 영역을 의미하며, 서로 다른 범위에 있는 같은 이름의 변수는 서로 충돌이 나지 않도록 해준다. 사실 변수 범위와 관련된 내용은 매우 복잡한 주제이다. 이 절에서는 함수 내에서의 변수 사용과 관련된 기본적 문제에 관련해서만 변수 범위를 논하도록 한다.13 함수 본문에 사용되는 변수의 종류 함수의 본문에 나타나는 변수는 세 범주로 분류된다. 첫번째 범주는 함수의 형식 인수(formal arguments)로 함수의 인수 리스트로 표현된다. 함수의 형식 인수의 값은 함수 호출 시 함수의 실질 인수 값으로 바인딩이 이루어진다. 두번째 범주는 지역 변수(local variables)로 함수 본문 안에서 할당이 이루어진 변수이다. 세번째 범주는 자유 변수(free variables)로 형식 인수도 아니고 지역 변수도 아닌 변수이다. 자유 변수는 함수가 만들어진 환경에서 변수의 값을 찾는다. 자유 변수가 함수 안에서 할당이 이루어지면 지역 변수가 된다. 지역 변수, 형식 인수, 자유 변수의 순으로 변수의 평가가 이루어진다. R은 함수에서 어떤 변수의 값을 평가할 때, 맨 먼저 이 변수가 지역 변수인지 살펴본다. 지역 변수여서 함수 본문 내부에서 할당되어 있으면, 그 할당된 값으로 변수를 평가한다. 지역 변수가 아니라면 형식 인수인지 살펴본다. 형식 인수이면 형식 인수에 전달된 실질 인수의 값으로 그 변수를 평가한다. 형식 인수도 아니면 자유 변수로 간주하여 함수가 생성되었던 환경에서 변수를 찾는다. 함수의 외부 환경에서도 변수를 찾을 수 없으면 변수를 찾을 수 없다는 오류가 발생한다. 다음 예에선 함수 f는 변수 x, y, z의 합을 반환한다. 여기서 x는 형식 인수로 함수 f가 호출될 때마다 함수의 실질 인수의 값으로 바인딩된다. y는 지역 변수로 함수 본문 안에서 정의되어 10으로 할당이 되었다. 변수 z는 형식 인수도 지역 변수도 아닌 자유 변수이다. 자유 변수는 함수 내부에서 그 값을 찾을 수 없으므로 함수가 정의된 환경에서 그 값을 찾는다. 우리는 현재 R 콘솔에서 작업을 하고 있으므로 함수 f()는 R 콘솔의 전역 공간인 R_GlobalEnv에서 정의되었고 여기서 z의 값을 찾게 된다. rm(x, y, z) Warning in rm(x, y, z): 객체 &#39;z&#39;를 찾을 수 없습니다 f &lt;- function(x) { y &lt;- 10 x + y + z } 자유 변수는 함수가 정의가 이루어진 환경에서 함수가 호출될 때 평가가 이루어진다. 맨 처음 함수 f를 실행할 때 f를 정의한 작업 공간에 z에 대한 정의가 없으므로 함수 f를 호출하면 오류가 발생한다. R 콘솔에서 z라는 변수를 할당한 후 다시 f를 호출하면 외부 환경에 정의된 z의 값이 결과에 반영됨을 볼 수 있다. f(1) Error in f(1): 객체 &#39;z&#39;를 찾을 수 없습니다 z &lt;- 3 f(1) [1] 14 동일한 이름이어도 함수 내부의 변수와 외부의 변수는 별개의 변수이다. 그런데 함수의 형식 인수와 함수 내부의 지역 변수는 함수 내부에서만 의미를 갖는다. (즉 함수 내부로 범위가 설정된다). 따라서 함수 바깥 범위에서는 형식 인수 x와 지역 변수 y에 대해서는 알지 못한다. x Error in eval(expr, envir, enclos): 객체 &#39;x&#39;를 찾을 수 없습니다 y Error in eval(expr, envir, enclos): 객체 &#39;y&#39;를 찾을 수 없습니다 다음처럼 R 콘솔에서 x와 y를 정의한 후 다시 f()를 실행해 보자. x &lt;- 0; y &lt;- 0 f(2) [1] 15 x; y [1] 0 [1] 0 함수의 외부 환경에서 x와 y 변수가 만들어져서 0의 값이 할당되었지만, 함수를 호출하면 함수 본문에서 x, y는 모두 형식 인수에 부여된 실질 인수 값 2와 지역 변수로서 할당된 값 10으로 평가되었음을 확인할 수 있다. 왜냐하면 R은 함수 실행시 변수를 지역 변수와 형식 인수에서 먼저 찾기 때문에, 변수에 대한 값을 함수 내부에서 찾으면 전역 공간에 정의된 x, y는 참고하지 않기 때문이다. 그리고 함수 본문에서 x는 2와 y는 10으로 값이 주어졌지만, 함수 바깥의 x, y 변수에는 전혀 영향을 주지 못함을 볼 수 있다. 다만 z는 함수 내부에 정의된 변수가 아니고 함수 외부에서 찾아야 하는 자유 변수이므로 전역 공간에서 z의 값이 변경되면 함수의 평가시에도 그 변화가 반영됨을 알 수 있다. z &lt;- 10 f(2) [1] 22 자유 변수를 함수 내부에서 할당하면 새로운 지역 변수가 된다. 만약 자유 변수 z를 함수 내부에서 값을 변경하면 어떻게 될까? z &lt;- 10 f &lt;- function(x) { y &lt;- 10 a &lt;- x + y + z z &lt;- 0 b &lt;- x + y + z c(a, b) } f(2) [1] 22 12 z [1] 10 결과에서 보듯이 전역 변수 z의 값은 전혀 변화가 없다. 위의 예에서 a의 변수에 x, y, z의 합을 할당할 때까지는 함수 내부에서 z 변수에 대한 할당이 이루어지 않았으므로 전역 공간의 z를 참조하여 10이라는 값으로 z를 평가하여 계산한다. 그 다음에 z에 0을 할당하면 함수 내부에 z라는 별도의 지역 변수가 만들어지게 되고, 전역 변수 z와는 전혀 무관한 변수가 된다. 따라서 b에 x, y, z의 합을 할당하는 문장에서는 z를 먼저 지역 변수에서 찾으므로 지역 변수 z에 할당된 0의 값으로 평가하게 된다. 마지막으로 z가 함수 내부에서 0으로 할당된 것은 함수 내부의 지역 변수에 할당이 이루어진 것이므로 전역 변수 z에는 전혀 영향을 미치지 못한다. 함수 외부 환경의 변수에 값 할당하기 그런데 가끔은 함수 내부에서 함수 외부의 전역 변수의 값을 변경해야 할 경우가 있다. 함수 내부의 지역 변수와 형식 인수는 함수 호출 시에만 생성되었다가 함수 실행이 완료되면 사라진다. 따라서 함수 f() 내부의 x, y는 함수 f()가 실행될 때마다 새로 만들어지고 사라지게 된다. 따라서 함수의 호출과 무관하게 데이터를 유지해야 할 필요가 있을 때는 함수 외부 환경의 전역 변수를 사용해야 한다. 다음 예를 살펴보자. 다음의 call.count() 함수는 자신이 총 몇번 호출되었는지를 기록하는 함수이다. x &lt;- 0 call.count &lt;- function() { x &lt;- x + 1 cat(x, &quot;번 호출되었습니다.&quot;) } call.count() 1 번 호출되었습니다. call.count() 1 번 호출되었습니다. x [1] 0 call.count() 함수는 자신이 호출될 때마다 전역 변수 x의 값을 읽은 후 1을 더하여 다시 x에 할당하려고 한다. 그러나 x를 하나씩 증가시키는 할당문이 실행될 때, 오른편의 x는 아직 x가 함수 내부에 할당되기 전이기에 전역 변수 x를 참조하지만, 할당문 왼편의 x는 함수 내부에서 할당이 이루어진 것이므로, 함수 내부의 지역 변수가 되어 전역 변수와 무관해 진다. 따라서 함수의 지역 변수 x에만 1이 할당되었다. 그런데 첫번째 함수 호출이 끝나면 함수 내부의 지역 변수는 모두 사라진다. 따라서 두번째 호출시 할당문의 오른편이 실행될 때는 역시 지역 변수 x는 존재하지 않으므로 다시 전역 변수 x를 참조하게 된다. 전역 변수는 변화가 없었으므로 0의 값을 계속 가지고 있고 첫번째 호출과 같은 결과만 얻을 뿐이다. 수퍼 할당 연산자 이 문제를 해결하는 방법은 함수 내부에서 외부 전역 변수에 값을 할당할 수 있도록 하는 것이다. 일반 할당 연산자 &lt;-로는 지역 변수만 생성될 뿐이다. 그러나 수퍼 할당 연산자 &lt;&lt;-를 이용하여 할당을 하면 지역 변수가 아닌 함수의 외부 환경에서 변수를 찾아서 할당을 시도한다. 이를 이용하면 위의 call.count()는 다음처럼 개선될 수 있다. call.count &lt;- function() { x &lt;&lt;- x + 1 cat(x, &quot;번 호출되었습니다.&quot;) } call.count() 1 번 호출되었습니다. call.count() 2 번 호출되었습니다. x [1] 2 이번에는 함수 호출의 결과로 전역 변수가 변경되고 원하는 결과를 얻을 수 있었다. 수퍼 할당 연산자로 값을 부여하고자 하는 변수가 외부 환경에 없으면 외부 환경에 해당 변수를 만든다. 마치 외부 환경에서 변수에 할당할 때 변수가 없으면 새로운 변수를 만드는 것과 동일한 작용을 하게 된다. rm(w) Warning in rm(w): 객체 &#39;w&#39;를 찾을 수 없습니다 w Error in eval(expr, envir, enclos): 객체 &#39;w&#39;를 찾을 수 없습니다 sq &lt;- function(a) w &lt;&lt;- a^2 sq(10) w [1] 100 함수의 외부 환경이 함수인 경우 R에서는 함수 내부에서 벡터, 리스트 등의 객체를 변수에 할당할 수 있듯이, 함수 내부에서 함수를 정의하여 변수에 할당할 수 있다. 이런 경우 함수의 변수 범위는 계층 구조를 가지게 된다. 함수 내부에서 정의된 안쪽 함수의 외부 환경은 바깥쪽 함수가 된다. 그리고 바깥쪽 함수의 외부 환경은 R 콘솔의 전역 공간이 된다. 다음의 예를 살펴보자. f.out &lt;- function(y){ f.in &lt;- function(z){ x &lt;- 2 x + y + z } return(f.in) } x &lt;- 1; y &lt;- 10; z &lt;- 100 a &lt;- f.out(20) a(200) [1] 222 출력 결과를 이해하기 위해서는 f.out()을 정의한 후 일어나는 일들은 차례대로 따라가볼 필요가 있다. 만약에 f.out()에 다른 값을 실질 인수로 하여 호출하면 어떻게 될까? b &lt;- f.out(30) b(300) [1] 332 마찬가지로 f.out(30) 호출에 의해 f.in() 함수 객체가 반환되어 변수 b에 할당된다. b(300) 호출이 이루어지면, f.in() 함수가 실행되는데, x는 지역 변수이므로 함수 내부에서 정의된 2의 값이 할당되고, y는 자유 변수인데 이번에 생성된 함수 b는 f.out(30) 호출에 의해 만들어진 함수이므로 f.out(30)이 자신의 외부 환경이 된다. 따라서 y는 30의 값으로 평가된다. z는 자신의 형식 인수로 300이 호출시 주어졌다. 이것들이 합산되어 332의 결과가 반환된다. environment() f.out() 함수에서 생성되어 반환된 두 함수 객체 a, b의 외부 환경이 무엇인지 확인해 보자. environment() 함수는 인수로 전달된 함수 객체의 외부 환경이 무엇인지를 알려준다. environment(f.out) &lt;environment: R_GlobalEnv&gt; environment(a); parent.env(environment(a)) &lt;environment: 0x563f418fd7a8&gt; &lt;environment: R_GlobalEnv&gt; environment(b); parent.env(environment(b)) &lt;environment: 0x563f40d43c00&gt; &lt;environment: R_GlobalEnv&gt; environment(f.in) Error in eval(expr, envir, enclos): 객체 &#39;f.in&#39;를 찾을 수 없습니다 f.out() 함수는 전역 공간에서 정의하였으므로 전역 공간이 자신의 외부 환경임을 알려준다. a, b는 각자 서로 다른 외부 환경을 가지고 있음을 볼 수 있다. 그러나 a, b 각각의 외부 환경의 부모 외부 환경은 전역 공간임을 볼 수 있다. 참고로 f.in() 함수는 f.out() 함수의 호출 환경에서 정의된 함수 객체이므로 전역 공간에서는 모르는 함수이다. 따라서 전역 공간에서 f.in() 함수를 찾으면 찾을 수 없다는 결과가 나온다. ls()와 get() ls() 함수를 이용하면 환경에 정의되어 있는 변수 정보를 얻을 수 있고, get() 함수를 이용하면 변수 이름으로 변수 값을 확인할 수 있다. ls(environment(a)) [1] &quot;f.in&quot; &quot;y&quot; ls(environment(b)) [1] &quot;f.in&quot; &quot;y&quot; get(&quot;y&quot;, envir=environment(a)) [1] 20 get(&quot;y&quot;, envir=environment(b)) [1] 30 get(&quot;y&quot;, envir=.GlobalEnv) [1] 10 함수 객체 a와 b의 외부 환경인 f.out 호출 환경에는 y와 f.in이라는 변수가 모두 존재한다. 그러나 get() 함수로 확인한 이 두 환경에 있는 y 변수의 값을 서로 다름을 알 수 있다. 그리고 전역 공간인 .GlobalEnv에 있는 변수 y의 값과도 다름을 알 수 있다. 이처럼 R은 함수에 사용되는 변수를 먼저 자기 내부에서 조회해 보고, 없으면 자신이 정의된 외부 환경, 거기에도 없으면 외부 환경의 부모 환경으로 거슬러 올라가며 조회해 나간다. 만약 최상위 환경(여기서는 .GlobalEnv)에도 찾는 변수가 없으면, 그 다음에는 검색 경로(search path)를 거슬러 올라가며 변수를 찾는다. 변수 검색 경로는 현재의 전역 공간을 시작으로 적재된 R 패키지와 attach() 함수로 포함된 데이터 프레임들이 되며, 맨 마지막은 R의 기본 패키지인 base 패키지 환경이 된다. 이 모든 곳에서 해당 변수를 찾을 수 없으면, 변수를 찾을 수 없다는 오류를 발생시킨다. 검색 경로에 대한 설명은 데이터 프레임의 attach() 관련 절을 확인하기 바란다. 아울러 현 작업 공간의 검색 경로는 searchpaths() 함수로 확인할 수 있다. 4.2보다 앞선 버전에서는 첫번째 논리값만 사용하여 분기를 실행하고 경고 메시지를 출력하였는데, 4.2 버전부터는 오류를 발생하고 실행이 되지 않는다.↩︎ 4.2보다 앞선 버전에서는 경고를 하지 않았는데 4.2 버전부터는 &amp;&amp;와 || 연산처럼 오직 한 개의 논리값만 연산하는 논리값 연산자에서는 경고를 발생시키다.↩︎ 함수 정의 시 형식 인수의 초기값은 symbol=expression 형태로 정의된다. symbol은 함수 내에서 사용할 형식 인수의 이름이고, expression은 초기값이 계산되는 표현식이다. 따라서 단순히 정해진 상수만 초기값에 부여되는 것이 아니라 함수가 호출되는 시점에 expression에 대한 평가가 이루어져 그 결과가 초기값으로 부여될 수도 있다.↩︎ 아울러 함수 본문 표현식을 보면 read.csv() 함수는 함수 본문에서 read.table() 함수를 호출하여 작업을 처리한다는 것을 알 수 있다. read.table() 함수를 출력해 보면 형식 인수 sep의 초기값이 ‘`’’으로 정의되어 있음을 알 수 있다. read.table()은 sep 인수가 이 값일 때는 공백문자(space, tab, 줄바꿈 등)를 이용하여 데이터 필드를 분리해 낸다.↩︎ R은 대부분은 프로그래밍 언어처럼 정적 변수 범위 설정(static scoping 또는 lexical scoping)을 이용한다. 이 의미는 함수에서 사용되는 변수들은 함수가 정의되는 시점의 컨텍스트에 의해 평가된다는 것이다. 그러나 R 언어는 FPL로서 함수의 생성과 조작이 매우 동적으로 이루어지므로 사실 변수 범위 설정의 문제가 매우 복잡해진다.↩︎ "],["ch-R-OOP.html", "Chapter 11 R 객체 지향 프로그래밍 11.1 객체 지향 프로그래밍 11.2 S3 클래스 11.3 S4 클래스", " Chapter 11 R 객체 지향 프로그래밍 11.1 객체 지향 프로그래밍 객체 지향 프로그램(Object-Oriented Programming(OOP))이 무엇인지, 그것이 왜 필요한지를 논의하려면 별도로 한 장이 할애되어야 할 것이다. 여기서는 객체 지향 프로그래밍의 개요에 대해서만 간단히 짚어본다. OOP는 복잡한 프로그램을 구조화하는 방식에 대한 하나의 관점 또는 패러다임이라 할 수 있다. 간단한 프로그램은 어떠한 방식으로 작성하여도 이해하거나 수정이 어렵지 않다. 그러나 프로그램이 복잡해지면 프로그램을 적절한 단위로 구조화해야 프로그램 전체를 이해할 수 있고 유지보수가 가능해진다. 절차적 프로그래밍 vs. 객체 지향 프로그래밍 이러한 프로그램 구조화 패러다임 중 가장 오래된 방식이 절차적 프로그래밍(procedural programming) 패러다임이다. 절차적 프로그래밍은 프로그램을 기능적으로 유사한 부분으로 분절한다. 이러한 분절은 전체 프로그램을 기능에 따라 프로그램-모듈-함수/서브루틴/프로시저 등으로 계층적으로 구조화한다. 반복되어 사용되는 부분을 함수나 프로시저로 구현한 후, 필요할 때마다 해당 함수나 프로시저를 호출하여 사용할 수 있게 함으로써 비슷한 기능에 대한 구현이 프로그램 전체에 산재하여 유지보수하기 어렵게 되는 것을 막아 준다. 절차적 프로그래밍 방식을 비유적으로 말하자면, 어떤 복잡한 조직을 총무부, 인사부, 생산부, 자재부 등의 기능조직으로 나누어 구조화하는 방식과 비슷하다고 하겠다. 특화된 기능 조직이 비슷한 기능을 효율적으로 전담하여 반복수행하는 것처럼, 특화된 모듈과 함수는 비슷한 작업을 호출할 때마다 반복수행한다. 프로그래밍 언어와 프로그래밍 방식이 일 대 일로 대응되는 것은 아니지만, 절차적 프로그래밍 방식을 주로 사용하는 프로그래밍 언어로는 C 언어를 들 수 있다. 객체 지향 프로그래밍(OOP)는 복잡한 프로그램을 객체를 중심으로 구조화한다. 절차적 프로그래밍이 함수나 프로시저 등을 이용하여 기능 중심으로 프로그램을 분절한다면, OOP는 데이터를 중심으로 동일한 형식의 데이터를 처리하는 부분으로 프로그램을 분절한다. 이를 비유적으로 말하자면 절차적 프로그래밍이 기능 조직이어서 여러 사업과 관련된 동일한 기능이 하나의 기능 부서에 통합되어 있는 형식이라면, OOP는 사업부 조직으로서 하나의 사업이라는 내용을 중심으로 총무, 인사, 생산, 자재 등의 기능이 뭉쳐 있는 형식이라 할 수 있다. OOP를 따르는 주요 언어로는 C++, Java 등이 있다. R은 이러한 언어와는 조금 다르지만 기본적인 OOP 특성을 가지고 있다. OOP의 기본 특징 OOP가 가져야 하는 기본 특징은 다음과 같다. 11.2 S3 클래스 R은 OOP 개념을 처음에는 S3 클래스로 구현하였다. 그러나 S3 클래스는 캡슐화 및 데이터 보안에 취약한 점이 있으므로 이를 강화할 수 있는 S4 클래스를 나중에 도입하였다. 그러나 아직까지 대다수의 R 패키지는 S3 클래스에 의해 OOP를 구현하고 있고, 아직도 많은 R 사용자가 S3 클래스로 개발하는 것을 선호하고 있다. 11.2.1 S3 클래스 객체 만들기 본질적으로 S3 클래스 객체란 R의 리스트 객체에 class 속성을 부여한 것뿐이다. 앞서 본 lm() 함수의 결과 객체 a는 lm 클래스 객체였다. 이 객체를 unclass() 함수를 이용하여 클래스 속성을 제외하면 단순한 리스트임을 확인할 수 있다. S3 클래스 객체는 리스트에 class 속성 부여하여 만든다. 사용자도 리스트와 class() 함수를 이용하여 자신만의 S3 클래스를 만들 수 있다. 다음은 학생 관련 정보를 담는 student 클래스를 만든 예이다. st1 &lt;- list(name=&quot;Gildong&quot;, year=2, GPA=3.2) class(st1) &lt;- &quot;student&quot; st1 $name [1] &quot;Gildong&quot; $year [1] 2 $GPA [1] 3.2 attr(,&quot;class&quot;) [1] &quot;student&quot; student 객체를 출력해 보면 여느 리스트와 동일하게 각 요소를 출력하고, 마지막으로 부가 정보인 속성 정보를 출력하였다. 속성 정보는 오직 하나 class 속성만 있는 것을 확인할 수 있다. student 클래스는 print 메소드가 구현되어 있지 않았으므로, 객체가 출력될 때 객체의 타입인 리스트가 출력되는 형식으로 출력되었다. 11.2.2 포괄 함수(generic functions) 포괄 함수는 UseMethod()로 클래스에 따라 적절한 메소드를 호출한다. 포괄 함수란 print() 함수처럼 여러 클래스의 객체에 적용 가능한 함수를 의미한다. 포괄 함수는 인수로 주어진 객체의 클래스에 따라 클래스에 적합한 기능을 수행한다. 그러면 포괄 함수는 어떻게 객체에 따라 적절한 기능을 수행할 수 있는 것일까? 심지어 print() 함수 같은 포괄 함수는 자신이 구현된 이후에 새로운 클래스가 추가되어도 새로운 클래스에 적합한 기능을 수행할 수 있다. 포괄 함수는 사실 분배기의 역할만을 수행하기 때문에 이러한 기능이 가능한 것이다. 포괄 함수는 호출이 되면 UseMethod() 라는 분배 기능을 가지는 함수를 호출한다. 이 함수는 포괄 함수에 첫번째 인수로 부여된 객체의 클래스에 따라 포괄 함수를 대신하여 실행될 해당 클래스의 메소드를 호출한다. 그리고 포괄 함수는 해당 클래스의 메소드가 객체에 실행된 결과를 반환한다. 다음은 print() 함수가 호출되면 무엇이 수행되는지를 보여준다. UseMethod()가 호출되는 것을 볼 수 있다. print function (x, ...) UseMethod(&quot;print&quot;) &lt;bytecode: 0x55d3fd0b2f08&gt; &lt;environment: namespace:base&gt; methods() 그러면 클래스별로 print 메소드는 어디에 있는 것일끼? methods() 함수를 이용하면 각 포괄 함수에 대해 구현된 모든 메소드를 확인할 수 있다. 다음은 그 중 일부만을 보여주고 있다. head(methods(print)) [1] &quot;print.acf&quot; &quot;print.activeConcordance&quot; [3] &quot;print.AES&quot; &quot;print.anova&quot; [5] &quot;print.aov&quot; &quot;print.aovlist&quot; 메소드 이름 규칙 메소드 함수는 다음과 같은 이름으로 정의되어 있다. generic_function_name.class_name 따라서 data.frame 클래스의 print 메소드는 print.data.frame이 된다. 이 메소드를 data.frame 객체에 적용하나, 포괄 함수인 print를 data.frame 객체에 적용하나 동일한 결과를 얻는다. 사실 R 콘솔은 명령문을 평가한 후 자동으로 print() 함수를 실행하므로 클래스에 대한 print 메소드 구현은 매우 중요하다. 다음은 R 콘솔에서 print(f)나, print.data.frame(f)나, f는 동일한 결과를 주는 것을 보여준다. print(f) X1.3 X6.8 1 1 6 2 2 7 3 3 8 print.data.frame(f) X1.3 X6.8 1 1 6 2 2 7 3 3 8 f X1.3 X6.8 1 1 6 2 2 7 3 3 8 앞에서 확인할 수 있듯이 지금까지 객체가 R 콘솔에 출력될 때, 해당 객체의 클래스의 print 메소드들이 적절히 호출되어 해당 클래스에 적합한 형식으로 데이터를 보여 주었던 것이다. 그러면 integer, character, list 등을 위한 메소드들도 있을까? grep() 함수로 해당 이름의 메소드를 찾아보면 그렇지 않음을 알 수 있다. 그러면 이 클래스의 객체들은 어떻게 출력이 이루어지는 걸까? grep(&quot;integer&quot;, methods(print)) integer(0) grep(&quot;character&quot;, methods(print)) integer(0) grep(&quot;list&quot;, methods(print)) [1] 6 43 100 109 133 145 199 212 214 225 253 methods(print)[grep(&quot;list&quot;, methods(print))] [1] &quot;print.aovlist&quot; &quot;print.check_package_datalist&quot; [3] &quot;print.Dlist&quot; &quot;print.dummy_coef_list&quot; [5] &quot;print.htmltools.selector.list&quot; &quot;print.listof&quot; [7] &quot;print.rlang:::list_of_conditions&quot; &quot;print.shiny.tag.list&quot; [9] &quot;print.simple.list&quot; &quot;print.summary.aovlist&quot; [11] &quot;print.xfun_strict_list&quot; 해당 클래스의 메소드가 없으면 UseMethod() 분배 함수는 default 메소드를 호출한다. default 메소드는 generic_function_name.default 형식으로 이름이 주어진다. print 포괄 함수의 경우 print.defualt 메소드이다. 디폴트 메소드 print.default function (x, digits = NULL, quote = TRUE, na.print = NULL, print.gap = NULL, right = FALSE, max = NULL, width = NULL, useSource = TRUE, ...) { args &lt;- pairlist(digits = digits, quote = quote, na.print = na.print, print.gap = print.gap, right = right, max = max, width = width, useSource = useSource, ...) missings &lt;- c(missing(digits), missing(quote), missing(na.print), missing(print.gap), missing(right), missing(max), missing(width), missing(useSource)) .Internal(print.default(x, args, missings)) } &lt;bytecode: 0x55d3fbcd7428&gt; &lt;environment: namespace:base&gt; 보통 default 메소드는 데이터가 가지는 기본적 타입에 대해 적절한 포괄 함수 관련 처리를 수행하도록 구현되어 있다. print.default는 기본적인 데이터의 타입에 따라 적절한 출력을 보여준다. 앞서 우리는 student 클래스 객체를 만들었다. 그런나 print.student라는 메소드는 존재하지 않으므로 콘솔에서 해당 객체가 입력되었을 때, print.defualt가 student의 출력을 담당하였다. 따라서 student의 데이터 기본 타입인 list의 형식으로 데이터가 출력이 된것이다. methods() 함수의 class 인수를 이용하면 해당 클래스를 위해 정의된 모든 메소드의 목록을 볼 수 있다. student 클래스를 위한 어떠한 메소드도 구현되지 않았음을 볼 수 있다. methods(class=&quot;lm&quot;) [1] add1 alias anova case.names coerce [6] confint cooks.distance deviance dfbeta dfbetas [11] drop1 dummy.coef effects extractAIC family [16] formula hatvalues influence initialize kappa [21] labels logLik model.frame model.matrix nobs [26] plot predict print proj qr [31] residuals rstandard rstudent show simulate [36] slotsFromS3 summary variable.names vcov see &#39;?methods&#39; for accessing help and source code methods(class=&quot;student&quot;) no methods found print.default(st1) $name [1] &quot;Gildong&quot; $year [1] 2 $GPA [1] 3.2 attr(,&quot;class&quot;) [1] &quot;student&quot; 메소드 정의하기 다음처럼 student 클래스를 위한 print 메소드를 만들어 보자. S3 클래스에서는 함수의 이름을 (포괄 함수명).(클래스명)으로 부여하면 된다. 그러면 UseMethod()가 해당 클래스를 위해 정의된 메소드를 호출해 준다. print.student &lt;- function(x) { cat(x$name, &quot;\\n&quot;) cat(&quot;year&quot;, x$year, &quot;\\n&quot;) cat(&quot;GPA&quot;, x$GPA, &quot;\\n&quot;) } methods(class=&quot;student&quot;) [1] print see &#39;?methods&#39; for accessing help and source code print(st1) Gildong year 2 GPA 3.2 위의 예에서 보듯이 student 클래스를 위한 print 메소드가 구현되었으므로 이제는 default 메소드가 아니라 student 클래스를 위한 print 메소드가 실행된다. 일반적으로 복잡한 클래스일수록 자신만의 print 메소드를 구현한다. 그래야 복잡한 내부 데이터를 모두 출력하지 않고 필요한 정보만 효율적으로 보여줄 수 있기 때문이다. 그리고 R을 처음 접한 사람들이 의아해 하는 사항이 있다. 그것은 대부분의 클래스에서 print 메소드보다는 summary 메소드가 더 자세한 정보를 출력한다는 것이다. 문자 그대로 해석한다면 print() 함수는 모든 내용을 출력해야 하고, summary() 함수는 좀 더 요약된 정보를 제공해야 할 것 같은데 말이다. lm 클래스도 print() 함수 보다는 summary() 함수가 훨씬 더 자세한 정보를 제공한다. summary(a) Call: lm(formula = cars) Residuals: Min 1Q Median 3Q Max -7.5293 -2.1550 0.3615 2.4377 6.4179 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 8.28391 0.87438 9.474 1.44e-12 *** dist 0.16557 0.01749 9.464 1.49e-12 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 3.156 on 48 degrees of freedom Multiple R-squared: 0.6511, Adjusted R-squared: 0.6438 F-statistic: 89.57 on 1 and 48 DF, p-value: 1.49e-12 이러한 일이 발생하는 이유는 R에서 print() 함수는 R 콘솔에 사용자의 명령이 입력될 때마다 실행되는 함수이기 때문이다. 따라서 print() 함수의 결과가 자칫 필요 이상으로 길고 복잡해지면 R 콘솔 작업이 어려워질 수 있기 때문에 대부분의 클래스에서는 휠씬 요약된 정보만을 print 메소드가 제공하도록 하고 있다. 하지만 기본 데이타 타입의 경우는 print.defualt 메소드가 데이터의 내용을 가감 없이 보여주기 때문에 그러한 현상은 나타나지 않는다. 11.2.3 S3에서 상속성의 구현 상속성은 객체 지향 프로그래밍의 매력 중에 하나이다. 새로운 클래스를 만들 때 이전의 클래스를 상위 클래스로 하고 자신을 하위 클래스로 하면, 상위 클래스에 정의된 메소드들을 하위 클래스 객체가 이용할 수 있다. 상위 클래스와 하위 클래스 이 때 주의할 점은 하위 클래스 객체는 상위 클래스에 부분집합의 관계를 가져야 한다는 것이다. 예를 들어 MTB 자전거라는 하위 클래스를 자전거라는 상위 클래스를 상속받아 구현하였다면, MTB 자전거 객체는 역시 자전거 객체이기도 해야 한다는 것이다. 따라서 하위 클래스의 데이터 구조는 상위 클래스의 데이터 요소를 모두 포함하고 있어야 하고, 거기에 덧붙여 자신만의 데이터와 기능을 더 포함하는 구조이어야 한다. 상속성을 구현하는 방법 S3 클래스에서 상속성의 구현은 객체를 생성할 때 단지 class 속성에 하위 클래스 이름 다음에 상위 클래스 이름을 모두 나열하기만 하면 된다. 그러면 UseMethod() 분배 함수는 class 속성에 부여된 클래스 순으로 메소드를 찾아 실행한다. 따라서 하위 클래스를 위한 메소드가 없으면 다음에 정의되어 있는 상위 클래스의 메소드를 실행해 준다. 하위 클래스가 상속받은 상위 클래스가 또 다른 클래스를 상속 받았다면, class 속성에는 하위 클래스, 상위 클래스, 상위-상위 클래스 순으로 차례대로 기술해 주면 된다. S3 클래스에서 상속성이 어떻게 수행되는지 다음 예로 살펴보자. 현재 student 클래스를 이용하여 대학생과 대학원생 정보를 모두 처리하고 있다고 하자. 그런데 대학원생의 경우에는 student에 있는 데이터뿐 아니라 지도교수(advisor)에 대한 정보가 추가되어 관리되는 것이 편리하다고 판단되어, 지도교수 정보를 포함하는 gradstudent 클래스를 정의하고자 한다. 다음 예에서 st2 객체를 생성할 때 리스트에 advisor 요소가 추가되었다. 그리고 class 속성에 먼저 하위 클래스 이름인 gradstudent, 그리고 상위 클래스 이름인 student가 기술되었다. 물론 아직은 gradstudent 클래스에 대한 어떠한 메소드도 존재하지 않는다. st2 &lt;- list(name=&quot;Gilsan&quot;, year=1, GPA=3.8, advisor=&quot;Sejong&quot;) class(st2) &lt;- c(&quot;gradstudent&quot;, &quot;student&quot;) methods(class=&quot;gradstudent&quot;) no methods found 그러면 gradstudent 클래스인 st2를 출력해 보자. 그러면 UseMethod() 함수는 먼저 gradstudent 클래스를 위한 print 메소드를 찾는다. 해당 메소드가 없으므로 두번째로 기술되어 있는 student 클래스의 print 메소드를 찾는다. 해당 메소드가 있으므로 이 메소드로 출력을 수행한다. 이마저도 없으면 default 메소드가 수행될 것이다. 물론 student 클래스를 위한 print 메소드는 이미 구현되어 있기 때문에, 대학원생 정보인 st2도 student 클래스의 출력 형식에 맞추어 출력이 이루어진다. 따라서 gradstudent 객체는 student 클래스의 메소드를 상속 받았다고 볼 수 있다. st2 Gilsan year 1 GPA 3.8 메소드 overiding 만약 gradstudent 객체의 출력에 지도 교수 정보도 같이 출력되기를 원한다면, 다음처럼 gradstudent 클래스의 print 메소드를 구현하면 된다. 이 경우 gradstudent 클래스만의 메소드가 상속받은 student 클래스의 메소드를 overiding 하였다고 표현한다. print.gradstudent &lt;- function(x) { print.student(x) cat(&quot;Advisor&quot;, x$advisor, &quot;\\n&quot;) } st2 Gilsan year 1 GPA 3.8 Advisor Sejong 11.3 S4 클래스 S3 클래스의 안전성 문제 S3 클래스는 Java 같은 OOP 언어와 비교해 보면 다음과 같은 안전성(safety) 문제를 가지고 있다. 클래스 정의를 사전에 하지 않으므로 객체 생성시 필요한 요소가 누락되거나 이름이 잘못 부여될 수 있다. 클래스의 메소드도 이름으로 파악하므로, 메소드 구현시 함수 이름이 잘못 부여되어도 이를 바로 확인할 수 없다. 데이터가 근본적으로 리스트 객체이므로 클래스 내부 데이터에 대한 잘못된 접근을 막을 수 없다. 이러한 문제를 해결하기 위해 S4 클래스가 개발되었다. 표 11.114은 두 클래스의 차이를 보여준다. 이 절에서는 S4 클래스의 몇 가지 특징에 대해서만 짚어보기로 한다. Rows: 5 Columns: 3 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;&amp;&quot; chr (3): 작업 , S3 , S4 ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. Table 11.1: S3 클래스 vs. S4 클래스 (Source: The Art of R Programming) 작업 S3 S4 클래스 정의 명시적 정의 없음 setClass()로 클래스 정의 객체 생성 리스트 생성 후 class 속성 부여 new()로 명시적 객체 생성 클래스 요소 접근 $ @ f 메소드 구현 f.classname() 함수 정의 setMethod()로 명시적 구현 포괄 함수 구현 포괄 함수에 UseMethod() 이용 setGeneric()로 명시적 구현 클래스 정의 setClass() 다음은 setClass() 함수로 newstudent라는 새로운 클래스를 생성한 예이다. 데이터의 요소는 앞서 S3 클래스로 생성한 student 클래스와 동일하다. setClass()의 첫번째 인수로는 클래스 이름이, representation 인수는 클래스의 데이터 요소의 이름과 각 데이터 요소의 클래스가 명시된다. 이를 통해 해당 클래스 객체가 생성될 때 객체 요소의 데이터의 이름과 타입이 같아지도록 강제할 수 있다. setClass(&quot;newstudent&quot;, representation(name=&quot;character&quot;, year=&quot;numeric&quot;, GPA=&quot;numeric&quot; )) 객체 생성 new() 클래스로부터 새로운 객체를 생성할 때는 new() 함수를 이용한다. new() 함수는 첫번째 인수로 클래스 이름을, 나머지 인수로 객체의 각 데이터 요소를 정의한다. st3 &lt;- new(&quot;newstudent&quot;, name=&quot;Gildong&quot;, year=2, GPA=3.2) st3 An object of class &quot;newstudent&quot; Slot &quot;name&quot;: [1] &quot;Gildong&quot; Slot &quot;year&quot;: [1] 2 Slot &quot;GPA&quot;: [1] 3.2 setClass()에 의해 클래스의 형태가 이미 정의되어 있어서 new()로 객체 생성 시 틀린 이름이나 틀린 타입의 데이터가 입력되면 오류가 발생하므로 항상 정확한 이름과 형식으로 객체가 생성되도록 강제할 수 있다. st4 &lt;- new(&quot;newstudent&quot;, sname=&quot;Gildong&quot;, year=2, GPA=3.2) Error in initialize(value, ...): invalid name for slot of class &quot;newstudent&quot;: sname st4 &lt;- new(&quot;newstudent&quot;, name=&quot;Gildong&quot;, year=2, GPA=&quot;3.2&quot;) Error in validObject(.Object): 잘못된 클래스 &quot;newstudent&quot; 객체입니다: invalid object for slot &quot;GPA&quot; in class &quot;newstudent&quot;: got class &quot;character&quot;, should be or extend class &quot;numeric&quot; 객체 요소에 접근 slot() S4 클래스에서 객체의 각 데이터 요소(멤버 변수라고 한다)를 슬롯(slot)이라 하며, @ 또는 slot()으로 접근한다. S4 클래스는 정의되지 않은 멤버 변수의 생성을 허용하지 않는다. 반면 S3는 단순한 리스트 객체이므로 아무 제약 없이 새로운 요소를 추가하거나 기존 요소를 삭제할 수 있다. st3@name [1] &quot;Gildong&quot; slot(st3, &quot;GPA&quot;) [1] 3.2 st3@year &lt;- 4 st3@GPa &lt;- 4.0 Error in (function (cl, name, valueClass) : &#39;GPa&#39;는 클래스 &quot;newstudent&quot;내에 있는 슬롯이 아닙니다 st3 An object of class &quot;newstudent&quot; Slot &quot;name&quot;: [1] &quot;Gildong&quot; Slot &quot;year&quot;: [1] 4 Slot &quot;GPA&quot;: [1] 3.2 S4 클래스 메소드 생성 setMethod() S4 클래스에서는 메소드는 setMethod() 함수에 의해 정의된다. 앞에서 생성한 newstudent 객체에 summary() 함수를 적용하면 해당 클래스의 summary 메소드가 구현되지 않았으므로 디폴트로 제공되는 메소드에 의해 객체에 대한 매우 간략한 요약 정보만 출력한다. summary(st3) Length Class Mode 1 newstudent S4 newstudent 클래스에 summary 메소드를 다음과 같이 추가해 보자. setMethod() 함수는 첫번째 인수로 메소드 이름, 두번째 인수로 클래스 이름, 세번째 인수로 메소드 호출시 실행될 함수 객체를 받는다. setMethod(&quot;summary&quot;, &quot;newstudent&quot;, function(object){ cat(object@name, &quot; is a &quot;, object@year, &quot;th year student with GPA &quot;, object@GPA, &quot;\\n&quot;, sep=&quot;&quot;) }) summary(st3) Gildong is a 4th year student with GPA 3.2 만약 명시적으로 생성한 메소드를 제거하려면 removeMethod() 함수를 이용한다. removeMethod(&quot;summary&quot;, &quot;newstudent&quot;) [1] TRUE summary(st3) Length Class Mode 1 newstudent S4 Matloff, Norman. The Art of R Programming: A Tour of Statistical Software Design. No Starch Press, 2011.↩︎ "],["ch-R-import.html", "Chapter 12 R 데이터 수집 12.1 텍스트 파일에서 데이터 읽기 12.2 스프레드시트 파일에서 데이터 읽기 12.3 데이터베이스에서 데이터 가져오기 12.4 웹 스크래핑 (web scrapping): 웹 사이트에서 데이터 가져오기 12.5 공개 API에서 데이터 가져오기", " Chapter 12 R 데이터 수집 이 장에서는 다양한 원천에서 데이터를 R로 가져오는 방법을 다룬다. 텍스트 파일에서 데이터 가져오기 스프레드시트 파일에서 데이터 가져오기 데이터베이스에서 데이터 가져오기 웹 스크래핑 (web scrapping): 웹 사이트에서 데이터 가져오기 공개 API에서 데이터 가져오기 library(tidyverse) 12.1 텍스트 파일에서 데이터 읽기 R의 기본 기능을 사용하여 텍스트 파일을 읽고 쓰는 방법에 대해서는 6.6과 6.7 절에서 설명을 하였다. 이 절에서는 tidyverse 패키지에 포함된 readr 패키지의 read_csv() 함수를 사용하여 CSV 형식의 파일을 읽어오는 방법을 배운다. R의 기본 기능에 포함된 read.csv() 함수와의 차이는 다음과 같다. 읽어들인 파일을 data.frame 형식이 아니라 tibble 형식의 데이터로 반환한다. 데이터의 열의 데이터형과 변환을 더 상세히 조절할 수 있다. CSV 파일 CSV 파일은 데이터의 각 필드가 쉼표로 분리되어 있는 파일이다. 대부분의 통계 패키지뿐 아니라 다수의 SW에서 지원하는 파일 형식이다. Excel 등의 스프레드시트 파일도 CSV 파일로 저장할 수 있다. Excel의 버전에 따라 저장방식이 조금 차이가 있을 수 있으나, 대부분 ’다른 이름으로 저장’에서 파일 형식을 CSV 형식으로 지정해 주면 된다. CSV 파일을 읽어들이는 예제는 다음 파일을 사용하니 예제를 따라하고자 하는 독자는 내려받도록 하자. 텍스트 파일 내려받기 작업 디렉토리 설정 파일을 불러오기 전에 주의할 점은 파일의 이름만으로 파일을 읽어오고 싶으면 현재의 작업 디렉토리(폴더)에 파일이 있어야 한다는 것이다. 그렇지 않은 경우에는 파일의 절대 경로를 모두 써 주어야만 읽어올 수 있다. R 윈도우 버전에서 작업 디렉터리의 변경은 [파일]-[작업디렉토리변경] 메뉴를 이용하면 된다. RStudio에서는 [Session]-[Set Working Directory]-[Choose Directory] 메뉴를 이용하면 된다. 현재의 작업 디렉터리가 어디인지를 알기 위해서는 getwd() 명령을 이용하면 된다. 현재 작업 디렉터리의 파일을 보고 싶으면 list.files() 명령을 이용한다. R 명령으로 작업 디렉터리를 변경하려면 setwd()를 이용한다. 다음은 getwd()로 현재 작업 디렉토리를 얻은 후 setwd()로 data라는 하위 디렉토리(폴더)로 작업 디렉토리를 변경하고, 그 안에 있는 파일이름에 csv 확장자가 있는 파일 목록을 확인하는 예이다. WD &lt;- getwd() setwd(file.path(WD, &quot;data/import&quot;)) list.files(pattern = &quot;csv&quot;) [1] &quot;students_all.csv&quot; &quot;students-cp949.csv&quot; [3] &quot;students-with-comments.csv&quot; &quot;students-with-comments2.csv&quot; [5] &quot;students-with-problems.csv&quot; &quot;students.csv&quot; [7] &quot;students2.csv&quot; &quot;suicide_rates.csv&quot; read_csv() 다음은 suicide_rates.csv이라는 파일에 저장된 데이터를 읽어서 sr이라는 변수에 할당하는 예이다. sr &lt;- read_csv(&quot;suicide_rates.csv&quot;) Rows: 105 Columns: 4 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (1): Country dbl (3): Year, Males, Females ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. read_csv() 함수는 파일을 읽은 후에 파일의 데이터에 대한 다음의 정보를 출력한다. 데이터의 행과 열 수 열 구분자로 사용한 문자. 이 예에서처럼 read_csv()는 , 또는 Tab 문자를 기준으로 열을 분리한다. 이 외의 열 구분자를 사용하려면 delim 인수로 한 문자로 된 열 구분자를 따로 지정할 수 있다. 함수가 추정한 열 자료형과 열 이름: read_csv()는 사용자가 열의 자료형과 이름을 제공하지 않으면, 데이터 형식과 첫 행을 사용하여 이를 추정한다. 이 예에서는 데이터에서 Country라는 문자열 열과, Year, Males, Females라는 부동소수점 열을 읽어왔음을 보여준다. read_csv()는 열의 자료형, 열의 이름, 읽어올 열을 선택할 수 있다. spec() 함수를 사용하면 열에 대한 상세한 명세를 확인할 수 있다. read_csv()의 show_col_types=FALSE로 설정하면 출력은 생략된다. spec(sr) cols( Country = col_character(), Year = col_double(), Males = col_double(), Females = col_double() ) sr &lt;- read_csv(&quot;suicide_rates.csv&quot;, show_col_types =F) sr 변수를 출력해 보면 읽어들인 데이터를 확인할 수 있다. suicide_rates.csv는 총 105개 국(Country)의 남여 자살률(Males, Females)과 조사년도(Year)에 대한 데이터이다. read_csv()는 tibble` 형식으로 데이터를 반환하므로 처음 10 개 행만 출력하고, 열도 사용자의 콘솔의 폭이 충분하지 않으면 처음 몇 개의 열만 출력할 수 있다. sr # A tibble: 105 × 4 Country Year Males Females &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 ALBANIA 3 4.7 3.3 2 ANTIGUA AND BARBUDA 95 0 0 3 ARGENTINA 8 12.6 3 4 ARMENIA 8 2.8 1.1 5 AUSTRALIA 6 12.8 3.6 6 AUSTRIA 9 23.8 7.1 7 AZERBAIJAN 7 1 0.3 8 BAHAMAS 5 1.9 0.6 9 BAHRAIN 6 4 3.5 10 BARBADOS 6 7.3 0 # ℹ 95 more rows 읽어들인 각 국의 성별 자살률 데이터를 시각화해 보자. ggplot(sr) + geom_text(aes(Males, Females, label=Country), size=2, check_overlap = T) + theme_bw() 한글 파일 인코딩 students.csv와 students-cp949.csv는 동일한 데이터를 UTF-8과 CP949라는 인코딩 방식으로 저장한 파일이다. 두 파일을 Excel에서 열어보면 students.csv 파일의 한글은 깨져 보이는데, students-cp949.csv 파일의 한글은 제대로 보인다. 이러한 현상이 발생하는 이유는, 윈도우즈는 CP949라는 인코딩 방식으로 한글을 처리하기 때문이다. 이번엔 이 두 파일을 R로 읽어들여 보자. read_csv(&quot;students.csv&quot;) Rows: 5 Columns: 7 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (2): name, gender dbl (4): grade, midterm, final, hw lgl (1): retake ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 5 × 7 name grade gender midterm final retake hw &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; 1 김철수 1 M 74 91 TRUE 8 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M 67 88 FALSE 7 4 이영희 2 F 89 78 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 read_csv(&quot;students-cp949.csv&quot;) Rows: 5 Columns: 7 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (2): name, gender dbl (4): grade, midterm, final, hw lgl (1): retake ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 5 × 7 name grade gender midterm final retake hw &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; 1 &quot;\\xb1\\xe8\\xc3\\xb6\\xbc\\xf6&quot; 1 M 74 91 TRUE 8 2 &quot;\\xb1\\xe8\\xbf\\xb5\\xc8\\xf1&quot; 4 F 82 77 FALSE 9 3 &quot;\\xc0\\xcc\\xc3\\xb6\\xbc\\xf6&quot; 3 M 67 88 FALSE 7 4 &quot;\\xc0\\xcc\\xbf\\xb5\\xc8\\xf1&quot; 2 F 89 78 TRUE 8 5 &quot;\\xc8\\xab\\xb1\\xe6\\xb5\\xbf&quot; 1 M 50 86 FALSE 10 R에서 students.csv 파일의 한글은 잘 읽어오는데, students-cp949.csv 파일의 한글은 제대로 읽어오지 못했다. 이러한 현상이 발생하는 이유는 R은 디폴트로 UTF-8 인코딩으로 파일을 처리하기 때문이다. Windows를 제외하고 Mac, Linux, 그리고 많은 웹 문서들은 UTF-8을 기준으로 파일을 인코딩한다. 그렇기 때문에 R의 많은 함수들은 기본적으로 UTF-8으로 파일을 처리한다. 그러면 윈도우즈의 Excel에서 데이터를 CSV 파일로 저장하면 CP949로 인코딩되는데 R에서는 이 CSV 파일을 어떻게 읽어와야 할까? 가장 쉬운 방법은 Excel 파일의 데이터를 CSV 파일로 저장하지 않고 Excel 파일 그 자체로 읽어들이는 것이다. 이에 대해서는 12.2.1에서 설명한다. 다른 한 방법은 read_csv()의 locale 인수에 인코딩을 CP949로 지정하는 것이다. read_csv(&quot;students-cp949.csv&quot;, locale=locale(encoding=&quot;CP949&quot;)) Rows: 5 Columns: 7 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (2): name, gender dbl (4): grade, midterm, final, hw lgl (1): retake ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 5 × 7 name grade gender midterm final retake hw &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; 1 김철수 1 M 74 91 TRUE 8 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M 67 88 FALSE 7 4 이영희 2 F 89 78 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 locale 인수를 설정할 때는 locale() 함수를 사용하는데, 지역에 특화된 인코딩 방식(encoding)뿐만 아니라, 날짜와 시간의 형식, 숫자 형식 등도 지정할 수 있으니 도움말을 참조하기 바란다. 파일의 주석문 생략하기 students-with-comments.csv 파일을 read_csv() 파일로 읽어보자. read_csv(&quot;students-with-comments.csv&quot;) Warning: One or more parsing issues, call `problems()` on your data frame for details, e.g.: dat &lt;- vroom(...) problems(dat) Rows: 9 Columns: 1 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (1): # 이 파일은 어떤 과목을 수강하는 학생들에 대한 정보이다. ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 9 × 1 `# 이 파일은 어떤 과목을 수강하는 학생들에 대한 정보이다.` &lt;chr&gt; 1 # name은 이름, grade는 학년, gender는 성별, 2 # midterm과 final은 중간과 기말고사 점수 3 # retake는 재수강 여부, hw은 숙제 점수를 나타낸다. 4 name,grade,gender,midterm,final,retake,hw 5 김철수,1, M,74,91,TRUE,8 6 김영희,4,F,82,77,FALSE,9 7 이철수,3,M,67,88,FALSE,7 8 이영희,2,F,89,78,TRUE,8 9 홍길동,1,M,50,86,FALSE,10 이 파일의 앞 부분에는 파일을 설명하는 4 줄의 주석문(comments)이 있다. read_csv() 함수는 기본적으로 파일의 첫 줄은 열 이름을 나타내는 행으로, 그 다음 줄부터는 데이터의 행으로 간주한다. 앞의 예에서는 파일의 주석문을 열 이름으로 간주하여 오직 한 열만 있는 데이터로 파일을 읽어들였다. 이를 확인하려면 읽어들인 데이터의 행과 열수를 보면 된다. 이러한 현상이 발생한 이유는, 파일의 첫 줄에 쉼표(,)나 Tab이 사용되지 않았기 때문에 이 데이터는 오직 하나의 열로 구성된 데이터로 파악했기 때문이다. 그러므로 열의 자료형도 문자와 숫자를 모두 저장할 수 있는 문자열로 추정되었다. 파일의 앞부분에 주석문이 있는 경우에는 skip 인수를 사용하여 생략할 줄의 수를 지정하면, 열 이름이 시작되는 부분부터 데이터를 읽어들일 수 있다. read_csv(&quot;students-with-comments.csv&quot;, skip=4) Rows: 5 Columns: 7 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (2): name, gender dbl (4): grade, midterm, final, hw lgl (1): retake ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 5 × 7 name grade gender midterm final retake hw &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; 1 김철수 1 M 74 91 TRUE 8 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M 67 88 FALSE 7 4 이영희 2 F 89 78 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 원래의 7 개의 열로 잘 분리되어 읽어졌음을 확인할 수 있다. 데이터 파일의 주석문이 파일의 앞부분뿐 아니라 파일 중간에 나오는 경우도 발생할 수 있다. read_csv(&quot;students-with-comments2.csv&quot;) Warning: One or more parsing issues, call `problems()` on your data frame for details, e.g.: dat &lt;- vroom(...) problems(dat) Rows: 10 Columns: 1 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (1): # 이 파일은 어떤 과목을 수강하는 학생들에 대한 정보이다. ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 10 × 1 `# 이 파일은 어떤 과목을 수강하는 학생들에 대한 정보이다.` &lt;chr&gt; 1 # name은 이름, grade는 학년, gender는 성별, 2 # midterm과 final은 중간과 기말고사 점수 3 # retake는 재수강 여부, hw은 숙제 점수를 나타낸다. 4 name,grade,gender,midterm,final,retake,hw 5 김철수,1, M,74,91,TRUE,8 6 김영희,4,F,82,77,FALSE,9 # 데이터 확인 완료 7 이철수,3,M,67,88,FALSE,7 8 # 추가 등록 학생 9 이영희,2,F,89,78,TRUE,8 10 홍길동,1,M,50,86,FALSE,10 이 파일은 앞 부분의 4줄뿐 아니라 데이터 중간에도 주석문이 포함되어 있다. 그러므로 다음처럼 앞의 4 줄을 제외하여도 데이터가 올바르게 처리되지 않는다. read_csv(&quot;students-with-comments2.csv&quot;, skip=4) Warning: One or more parsing issues, call `problems()` on your data frame for details, e.g.: dat &lt;- vroom(...) problems(dat) Rows: 6 Columns: 7 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (3): name, gender, hw dbl (3): grade, midterm, final lgl (1): retake ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 6 × 7 name grade gender midterm final retake hw &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; 1 김철수 1 M 74 91 TRUE 8 2 김영희 4 F 82 77 FALSE 9 # 데이터 확인 완료 3 이철수 3 M 67 88 FALSE 7 4 # 추가 등록 학생 NA &lt;NA&gt; NA NA NA &lt;NA&gt; 5 이영희 2 F 89 78 TRUE 8 6 홍길동 1 M 50 86 FALSE 10 일반적으로 주석문은 특수한 문자로 주석을 시작하는데, #를 사용하는 경우가 많다. read_csv()는 comment 인수를 사용하여 특수한 문자열 다음에 있는 모든 텍스트를 주석문으로 간주하여 데이터에서 제외할 수 있다. read_csv(&quot;students-with-comments2.csv&quot;, comment=&quot;#&quot;) Rows: 5 Columns: 7 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (2): name, gender dbl (4): grade, midterm, final, hw lgl (1): retake ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 5 × 7 name grade gender midterm final retake hw &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; 1 김철수 1 M 74 91 TRUE 8 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M 67 88 FALSE 7 4 이영희 2 F 89 78 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 읽어들일 열 선택하기 파일의 데이터에 불필요한 열이 있을 수 있다. 데이터의 크기가 작으면 모든 데이터를 읽은 후에 (ch-dataTransformation)에서 배운 select() 함수를 사용하여 필요한 열만 선택해도 된다. 그러나 데이터가 매우 크면 불필요한 데이터를 위한 처리시간과 저장공간의 낭비가 너무 크게 발생할 수 있다. read_csv()는 col_select 인수로 읽어들일 열을 지정할 수 있다. 열을 지정하는 방식은 열의 위치, 열의 이름, 그리고 select()에서 열을 매칭하는 방식(7.7.4 참조)을 사용할 수 있다. 열을 지정하는 표현이 하나 이상이면 c()로 연결한다. read_csv(&quot;students.csv&quot;, col_select=2:4) # 2에서 4번째 열 Rows: 5 Columns: 3 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (1): gender dbl (2): grade, midterm ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 5 × 3 grade gender midterm &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 1 M 74 2 4 F 82 3 3 M 67 4 2 F 89 5 1 M 50 read_csv(&quot;students.csv&quot;, col_select=c(2:4, 6)) # 2에서 4번째 열과 6번재 열 Rows: 5 Columns: 4 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (1): gender dbl (2): grade, midterm lgl (1): retake ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 5 × 4 grade gender midterm retake &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; 1 1 M 74 TRUE 2 4 F 82 FALSE 3 3 M 67 FALSE 4 2 F 89 TRUE 5 1 M 50 FALSE read_csv(&quot;students.csv&quot;, col_select=-1) # 첫 번째 열 제외 Rows: 5 Columns: 6 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (1): gender dbl (4): grade, midterm, final, hw lgl (1): retake ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 5 × 6 grade gender midterm final retake hw &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; 1 1 M 74 91 TRUE 8 2 4 F 82 77 FALSE 9 3 3 M 67 88 FALSE 7 4 2 F 89 78 TRUE 8 5 1 M 50 86 FALSE 10 read_csv(&quot;students.csv&quot;, col_select=c(midterm, final, hw)) # 열 이름으로 Rows: 5 Columns: 3 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; dbl (3): midterm, final, hw ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 5 × 3 midterm final hw &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 74 91 8 2 82 77 9 3 67 88 7 4 89 78 8 5 50 86 10 read_csv(&quot;students.csv&quot;, col_select=c(name:grade, midterm:hw)) # 열 이름 범위로 Rows: 5 Columns: 6 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (1): name dbl (4): grade, midterm, final, hw lgl (1): retake ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 5 × 6 name grade midterm final retake hw &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; 1 김철수 1 74 91 TRUE 8 2 김영희 4 82 77 FALSE 9 3 이철수 3 67 88 FALSE 7 4 이영희 2 89 78 TRUE 8 5 홍길동 1 50 86 FALSE 10 read_csv(&quot;students.csv&quot;, col_select=starts_with(&quot;g&quot;)) # 이름이 g로 시작하는 열만 Rows: 5 Columns: 2 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (1): gender dbl (1): grade ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 5 × 2 grade gender &lt;dbl&gt; &lt;chr&gt; 1 1 M 2 4 F 3 3 M 4 2 F 5 1 M 열의 자료형 지정하기 read_csv()는 앞에서 설명한 바와 같이 대부분의 경우에 열의 데이터를 파악하여 적절한 자료형으로 읽어들인다. students &lt;- read_csv(&quot;students.csv&quot;) Rows: 5 Columns: 7 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (2): name, gender dbl (4): grade, midterm, final, hw lgl (1): retake ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. students # A tibble: 5 × 7 name grade gender midterm final retake hw &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; 1 김철수 1 M 74 91 TRUE 8 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M 67 88 FALSE 7 4 이영희 2 F 89 78 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 midterm과 final, hw 등의 열은 모두 숫자로 잘 처리되었기 때문에 summary()를 해보면 평균 등이 잘 계산된다. summary(students) name grade gender midterm Length:5 Min. :1.0 Length:5 Min. :50.0 Class :character 1st Qu.:1.0 Class :character 1st Qu.:67.0 Mode :character Median :2.0 Mode :character Median :74.0 Mean :2.2 Mean :72.4 3rd Qu.:3.0 3rd Qu.:82.0 Max. :4.0 Max. :89.0 final retake hw Min. :77 Mode :logical Min. : 7.0 1st Qu.:78 FALSE:3 1st Qu.: 8.0 Median :86 TRUE :2 Median : 8.0 Mean :84 Mean : 8.4 3rd Qu.:88 3rd Qu.: 9.0 Max. :91 Max. :10.0 그러나 데이터가 깔끔하게 정리되어 있지 않으면 read_csv()가 추정하는 열의 자료형이 부정확할 수 있다. 이러한 경우에는 직접 열의 자료형을 지정하여야 한다. students_prob &lt;- read_csv(&quot;students-with-problems.csv&quot;) Rows: 5 Columns: 7 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (3): name, gender, final dbl (3): grade, midterm, hw lgl (1): retake ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. students_prob # A tibble: 5 × 7 name grade gender midterm final retake hw &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; &lt;dbl&gt; 1 김철수 1 M 74 91 TRUE 8 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M NA 88 FALSE 7 4 이영희 2 F 89 - TRUE 8 5 홍길동 1 M 50 86 FALSE 10 위의 예를 보면 midterm과 final에 결측치가 있지만 데이터가 잘 읽어들여진 것으로 보인다. 그러나 summary()를 해보면 midterm은 평균들이 적절히 구해지지만, final은 문자열로 처리되어 평균이 구해지지 않는 것을 볼 수 있다. summary(students_prob) name grade gender midterm Length:5 Min. :1.0 Length:5 Min. :50.00 Class :character 1st Qu.:1.0 Class :character 1st Qu.:68.00 Mode :character Median :2.0 Mode :character Median :78.00 Mean :2.2 Mean :73.75 3rd Qu.:3.0 3rd Qu.:83.75 Max. :4.0 Max. :89.00 NA&#39;s :1 final retake hw Length:5 Mode :logical Min. : 7.0 Class :character FALSE:3 1st Qu.: 8.0 Mode :character TRUE :2 Median : 8.0 Mean : 8.4 3rd Qu.: 9.0 Max. :10.0 왜 이러한 현상이 발생하는 걸까? 그것은 데이터 파일의 final 열에 결측치를 표현하기 위해 -라는 문자가 사용되었기 때문이다. read_csv()는 이 열에 숫자뿐 아니라 문자가 있기 때문에 이를 모두 표현할 수 있는 문자열로 final 열을 처리했다. read_csv()의 col_types라는 인수로 각 열의 자료형을 직접 지정할 수 있다. 직접 자료형을 지정할 열은 열_이름=열_자료형 형식으로 리스트로 전달한다. (또는 cols() 함수를 사용하여 전달할 수 있다. 자세한 내용은 도움말은 참조한다.) 열의 자료형을 표현하는 다양한 함수와 이에 대응하는 축약어가 있다. 함수 축약어 열 자료형 col_logical() “l” 논리 열 col_integer() “i” 정수 열 col_double() “d” 부동소수점 열 col_character() “c” 문자 열. 데이터는 숫자지만 문자 열로 인식하고 싶을 때 주로 사용 col_factor() “f” 요인 열. 열을 요인으로 변환 col_date(), col_time(), col_datetime() “D”, “T”, “DT” 날짜, 시간, 날짜와 시간 열. 이 함수들은 format 인수로 날짜와 시간의 표시 형식을 지정할 수 있다. col_number() “n” 비숫자 표현은 무시하고 숫자로 변환. 천 단위 , 등 처리에 주로 사용 col_skip() “-” 열을 무시 col_guess() “?” 열의 데이터로 자료형 추정 final 열을 숫자로 지정하여 데이터를 다시 읽어보자. students_prob &lt;- read_csv(&quot;students-with-problems.csv&quot;, col_types=list(final=col_number())) Warning: One or more parsing issues, call `problems()` on your data frame for details, e.g.: dat &lt;- vroom(...) problems(dat) students_prob # A tibble: 5 × 7 name grade gender midterm final retake hw &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; 1 김철수 1 M 74 91 TRUE 8 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M NA 88 FALSE 7 4 이영희 2 F 89 NA TRUE 8 5 홍길동 1 M 50 86 FALSE 10 final을 숫자로 인식하여 처리는 하였지만 데이터에 문제가 있다고 경고한다. 경고에서 제시한 것처럼 어떤 문제인지 problems() 함수로 살펴보자. problems(students_prob) # A tibble: 1 × 5 row col expected actual file &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 5 5 a number - /home/sys4ppl/Dropbox/Work/Writing/R-programming-… 5행의 5열의 데이터로 숫자(number)가 예상되었는데(exptected) 실제(actual)은 -가 입력되었다는 것이다. col_number()로 지정된 열은 숫자 이외의 문자는 모두 무시되므로 이 셀의 데이터는 결측치(NA)로 처리되었다. 특정 문자를 결측치로 처리하려면 다음처럼 na 인수를 사용하여 결측치로 간주할 문자열을 지정한다. midterm에 있는 빈 문자열과 final의 “-”로 표시된 문자열을 모두 결측치로 지정해 보자. 그러면 앞에서 본 경고는 사라진다. students_prob &lt;- read_csv(&quot;students-with-problems.csv&quot;, col_types=list(final=col_number()), na=c(&quot;-&quot;, &quot;&quot;)) students_prob # A tibble: 5 × 7 name grade gender midterm final retake hw &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; 1 김철수 1 M 74 91 TRUE 8 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M NA 88 FALSE 7 4 이영희 2 F 89 NA TRUE 8 5 홍길동 1 M 50 86 FALSE 10 동일한 형식의 파일을 한번에 읽어들이기 students2.csv 파일은 students.csv와 동일한 형식의 데이터인데 다른 분반의 학생들에 대한 정보이다. read_csv(&quot;students2.csv&quot;, show_col_types=F) # A tibble: 2 × 7 name grade gender midterm final retake hw &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; 1 강철수 2 M 70 81 FALSE 8 2 홍영희 3 F 92 79 FALSE 9 만약 이 두 분반의 데이터를 합쳐서 분석한다면 두 파일을 각각 읽어들인 후, 9.1에서 설명한 bind_rows() 함수로 병합을 하면 된다. file_list &lt;- c(&quot;students.csv&quot;, &quot;students2.csv&quot;) lapply(file_list, read_csv, show_col_types=F) %&gt;% bind_rows(.id=&quot;cls&quot;) # A tibble: 7 × 8 cls name grade gender midterm final retake hw &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; 1 1 김철수 1 M 74 91 TRUE 8 2 1 김영희 4 F 82 77 FALSE 9 3 1 이철수 3 M 67 88 FALSE 7 4 1 이영희 2 F 89 78 TRUE 8 5 1 홍길동 1 M 50 86 FALSE 10 6 2 강철수 2 M 70 81 FALSE 8 7 2 홍영희 3 F 92 79 FALSE 9 read_csv()는 여러 개의 파일명을 받아서 병합시키는 기능이 있으므로 위의 과정을 다음과 같이 처리할 수 있다. id 인수는 여러 개의 파일을 읽을 때 파일의 경로를 저장할 열 이름을 지정한다. read_csv(file_list, id=&quot;file&quot;) Rows: 7 Columns: 8 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (2): name, gender dbl (4): grade, midterm, final, hw lgl (1): retake ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 7 × 8 file name grade gender midterm final retake hw &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; 1 students.csv 김철수 1 M 74 91 TRUE 8 2 students.csv 김영희 4 F 82 77 FALSE 9 3 students.csv 이철수 3 M 67 88 FALSE 7 4 students.csv 이영희 2 F 89 78 TRUE 8 5 students.csv 홍길동 1 M 50 86 FALSE 10 6 students2.csv 강철수 2 M 70 81 FALSE 8 7 students2.csv 홍영희 3 F 92 79 FALSE 9 한번에 처리해야 할 파일이 매우 많은 경우에는 list.files() 함수에 pattern을 정의하여 패턴에 맞는 모든 파일을 한번에 처리하는 것이 편리하다. (pattern 인수에는 정규표현식으로 파일 이름의 패턴을 지정할 수 있다.) 만약 월별로 저장된 24 개의 파일이 있으면 파일을 일일이 나열하는 것보다 이러한 방법이 매우 편리할 것이다. 다음은 “students”로 시작하여 숫자 패턴 후에 “.csv”로 끝나는 모든 파일을 지정하여 데이터를 읽는 예이다. list.files(pattern=&quot;students\\\\d*[.]csv&quot;) [1] &quot;students.csv&quot; &quot;students2.csv&quot; students_all &lt;- read_csv(list.files(pattern=&quot;students\\\\d*[.]csv&quot;), id=&quot;file&quot;) Rows: 7 Columns: 8 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (2): name, gender dbl (4): grade, midterm, final, hw lgl (1): retake ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. students_all # A tibble: 7 × 8 file name grade gender midterm final retake hw &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; 1 students.csv 김철수 1 M 74 91 TRUE 8 2 students.csv 김영희 4 F 82 77 FALSE 9 3 students.csv 이철수 3 M 67 88 FALSE 7 4 students.csv 이영희 2 F 89 78 TRUE 8 5 students.csv 홍길동 1 M 50 86 FALSE 10 6 students2.csv 강철수 2 M 70 81 FALSE 8 7 students2.csv 홍영희 3 F 92 79 FALSE 9 데이터를 파일에 쓰기 데이터프레임 형식의 데이터를 CSV 형식의 파일로 저장하려면 R의 기본 기능이 제공하는 write.csv() 함수나 readr에서 제공하는 write_csv() 함수를 사용한다. 여기서는 write_csv() 함수를 설명하는데, 두 함수의 차이는 그리 크지 않다. write_csv(students_all, &quot;students_all.csv&quot;) 12.2 스프레드시트 파일에서 데이터 읽기 이 절에서는 MS Excel이나 Google Sheets 등의 스프레드시트 파일의 데이터를 읽어오는 법을 다룬다. 12.2.1 Excel 파일에서 데이터 읽기 Excel에는 Excel 파일을 CSV 파일로 저장하는 기능이 있다. 이 기능을 사용하여 CSV 파일로 변환을 하면 앞에서 설명한 read_csv() 함수를 이용하여 데이터를 읽어들일 수 있다. 만약 Excel 데이터를 변환 없이 그대로 읽어들이고 싶으면, readxl 패키지의 read_excel() 함수를 사용한다. readxl 패키지는 tidyverse 패키지가 설치되면 자동으로 설치된다. 만약 설치되어 있지 않다면 다음 명령이나 RStudio의 Packages 패널의 기능을 사용하여 설치한다. install.packages(&quot;readxl&quot;) Download dataMerge.xlsx 위의 파일을 내려받으면, 다음과 같이, 4 개의 워크시트가 있는 Excel 파일에서 project라는 이름의 워크시트를 데이터프레임으로 읽어들이는 예를 살펴보자. readxl은 tidyverse 패키지가 적재될 때 자동으로 적재되지는 않으므로, 직접 적재를 해야 한다. readxl은 Excel 파일을 읽어들이는 다음 세 함수를 제공한다. read_xls(): xls 형식의 Excel 파일을 읽어들인다. read_xlsx(): xlsx 형식의 Excel 파일을 읽어들인다. read_excel(): xls와 xlsx` 형식의 Excel 파일을 모두 읽어들인다. 이 함수들은 read_csv()와 공유하는 인수들이 있다. 대표적인 예로 col_names, col_types, na, skip 등이 있다. 여기서는 read_excel() 함수만 다루도록 한다. 워크시트의 데이터 읽기 한 파일에 여러 워크시트를 저장할 수 있는 것이 Excel 파일과 텍스트 파일의 가장 큰 차이라 할 수 있다. 그렇기 때문에 read_excel()함수는 첫 번째 인수로 파일명을, 두 번째sheet인수로 읽어들일 워크시트를 지정한다.read_excel()함수는 데이터를tibble`이라는 일종의 개량된 data.frame 형식으로 데이터를 반환한다. library(readxl) project &lt;- read_excel(&quot;dataMerge.xlsx&quot;, sheet = &quot;project&quot;) project # A tibble: 4 × 2 Team Project &lt;chr&gt; &lt;dbl&gt; 1 A 80 2 B 90 3 C 85 4 D 75 sheet 인수에 아무것도 지정하지 않으면, 맨 처음 워크시트의 데이터를 읽어들인다. class1 &lt;- read_excel(&quot;dataMerge.xlsx&quot;) class1 # A tibble: 5 × 6 ID Name Adress Midterm Final Team &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1 015 김철수 서울 78 59 A 2 018 김영희 경기 85 87 A 3 025 이철수 충남 80 70 B 4 034 이영희 대전 92 89 B 5 151 홍길동 세종 58 66 B Excel 파일에 있는 모든 워크시트 정보를 확인하려면 excel_sheets() 함수를 사용한다. excel_sheets(&quot;dataMerge.xlsx&quot;) [1] &quot;class1&quot; &quot;class2&quot; &quot;project&quot; &quot;attendance&quot; 워크시트의 특정 범위의 데이터 읽기 다음은 제공된 Excel 파일의 4 번째 워크시트를 보여준다. 지금까지의 워크시트는 데이터가 모두 좌상단부터 시작하고, 열 이름과 데이터를 제외하고는 다른 정보가 저장되어 있지 않았다. 그러나 대부분의 워크시트는 데이터 저장의 용도뿐 아니라 문서로서 역할도 하기 때문에 위의 그림처럼 데이터와 무관한 내용들이 있을 수 있다. 이런 경우에는 워크시트의 특정 범위를 지정하여 데이터를 읽어와야 한다. read_excel()의 range 인수는 Excel의 범위 지정 문법을 사용하여 특정 범위를 지정한다. att &lt;- read_excel(&quot;dataMerge.xlsx&quot;, sheet = &quot;attendance&quot;, range=&quot;B3:C12&quot;) att # A tibble: 9 × 2 ID Attendance &lt;chr&gt; &lt;dbl&gt; 1 012 85 2 015 90 3 018 95 4 019 100 5 025 100 6 028 100 7 034 100 8 045 100 9 151 95 다음처럼 range에 워크시트가 포함된 범위를 지정하면 sheet 인수는 무시되므로 이를 지정하지 않는다. read_excel(&quot;dataMerge.xlsx&quot;, range=&quot;attendance!B3:C12&quot;) # A tibble: 9 × 2 ID Attendance &lt;chr&gt; &lt;dbl&gt; 1 012 85 2 015 90 3 018 95 4 019 100 5 025 100 6 028 100 7 034 100 8 045 100 9 151 95 자료형에 대한 주의 사항 CSV 파일은 모든 데이터가 단순한 텍스트로 저장되지만, Excel 파일은 그렇지 않다. Excel 파일의 데이터를 읽어들일 때 다음 세 가지 사항을 주의해야 한다. Excel은 실제 자료형과 표현되는 형태가 다를 수 있다. Excel에는 정수형이 없다. 숫자는 모두 부동소수점의 자료형이다. 단지 소수점 몇 째 자리까지 표현할지에 따라 Excel에서 보여지는 숫자 형식이 달라질 뿐이다. 날짜와 시간도 1970년 1월 1일 이후의 경과된 초를 기준으로 숫자로 저장된다. 단지 표현될 때 날짜 형식으로 보여질 뿐이다. 그러므로 Excel에서 보여지는 형식과 다르게 R에서 읽혀질 수 있다는 것을 이해해야 한다. read_excel() 함수는 각 열의 데이터로 R에서 적절한 자료형으로 추정하지만 이러한 추정이 만족스럽지 않으면 col_types 인수에 자료형을 적절히 지정해 주어야 한다. 관련된 내용은 read_excel() 함수의 도움말을 참조한다. Excel은 셀별로 데이터 형식을 지정한다는 것이다. 그러므로 한 열이 여러 데이터가 혼합된 형태일 수 있다. 만약에 혼합된 형식의 데이터를 모두 이용하려면 열의 자료형을 \"list\"로 설정한다. Excel의 셀은 배경색, 텍스트의 서식 등의 다양한 정보를 가지고 있다. 이는 시트의 데이터를 사람에게 보기 좋은 문서로서 표현한 것이지만, 컴퓨터가 처리하기에 적절한 데이터 저장 방식은 아니다. 또한 피벗 테이블처럼 복잡한 형식으로 데이터가 저장되어 있을 수도 있다. 만약 Excel 파일에 표현된 이러한 정보가 데이터 분석에 필요하다면, tidyxl 패키지의 기능을 검토해 볼 필요가 있다. 12.2.1.1 데이터를 Excel 파일에 쓰기 Excel 파일에 데이터를 저장하려면 writexl 패키지가 필요하다. install.packages(&quot;writexl&quot;) write_xlsx() 파일은 R의 데이터프레임(들)을 xlsx 형식의 Excel 파일에 저장한다. 첫 번째 인수에 데이터프레임 또는 데이터프레임을 요소로 하는 리스트를 제공한다. 리스트로 제공하는 경우 요소의 이름이 워크시트의 이름이 된다. path 인수는 저장될 파일의 경로를 지정한다. 파일명만 지정하면 작업 디렉토리에 저장된다. col_names 인수는 열 이름을 저장할지를 지정한다. 디폴트 값은 TRUE이다. format_headers 인수는 열 이름을 가운데 정렬하고 굵은 글자로 표시할지를 지정한다. 디폴트 값은 TRUE이다. 다음은 데이터프레임 하나만 제공하는 경우이다. 보통의 Excel 파일처럼 Sheet1라는 이름의 워크시트에 데이터가 저장된다. library(writexl) write_xlsx(students_all, path=&quot;students_all.xlsx&quot;) excel_sheets(&quot;students_all.xlsx&quot;) [1] &quot;Sheet1&quot; 다음처럼 요소에 이름을 부여한 리스트를 인수로 제공하면 요소 이름을 워크시트 이름으로 하여 데이터가 저장된다. write_xlsx( list(students=students_all, project=project, attendance=att), path=&quot;students_all.xlsx&quot; ) excel_sheets(&quot;students_all.xlsx&quot;) [1] &quot;students&quot; &quot;project&quot; &quot;attendance&quot; writexl 패키지는 Excel 파일에 데이터를 저장하는 기능만을 제공한다. 만약 Excel 파일에 데이터와 함께 다양한 스타일을 같이 지정하고자 하면 openxlsx 패키지를 참고하지 바란다. 12.2.2 Google Sheets에서 데이터 읽기 Google Sheets에서 데이터를 읽어오는 방식은 Excel에서 데이터를 읽어오는 것과 유사하다. 그러나 Excel은 기본적으로 PC 환경의 SW이고 Google Sheets는 인터넷 환경에서의 서비스이기 때문에 차이점이 존재한다. googlesheets4 패키지 Google Sheets에서 데이터를 읽고 쓰려면 googlesheets4 패키지가 필요하다. 이 패키지는 Google Sheets API v4의 R 인터페이스를 제공한다. googlesheet4 패키지는 다음의 두 패키지에 의존하고 있다. gargle 패키지: 250 여개의 Google API의 공통 기능에 대한 R 인터페이스를 제공한다. googlesheets4에서는 Oauth 등의 기능을 사용한다. googledirve 패키지: Google Drive API와 관련된 R 인터페이스를 제공한다. 이 패키지는 tidyverse 패키지를 설치하였으면 설치가 되어 있을 것이다. 그렇지 않다면 다음 명령으로 설치를 한다. install.packages(&quot;googlesheets4&quot;) library(googlesheets4) 워크시트 읽기 googlesheets4로 Google Sheets의 시트에 접근하려면 디폴트로 사용자 인증을 진행한다. 만약 공개되어 있는 시트를 읽는 경우에는 Oauth를 사용하여 인증 과정을 거치지 않아도 된다. R에서 불필요한 인증을 하지 않으려면 먼저 gs4_deauth() 함수를 호출한다. gs4_deauth() Gapminder에서 제공하는 기대 수명과 1인당 GDP 데이터에 접근해 보자. read_sheet() 함수는 Google Sheets 문서에서 데이터를 읽어들인다. read_sheet()는 range_read()라고도 불리는데 두 함수는 동일한 함수이다. ss 인수는 첫 번째 인수로 Google Sheets 문서를 지정한다. URL, ID 등을 입력받는다. sheet 인수는 읽을 워크시트를 지정한다. 이름, 위치 등으로 지정한다. range 인수에 워크시트가 지정되면 이 인수는 무시된다. 디폴트값은 문서의 첫 시트이다. range 인수는 Excel과 마찬가지로 셀 범위로 워크시트에서 읽어들일 데이터 범위를 지정한다. 디폴트 값은 비어있지 않은 모든 셀을 읽어들인다. read_csv()와 read_excel()처럼 col_names, col_types, na, skip 등의 인수를 가지고 있다. 자세한 정보는 read_sheet()에 대한 도움말을 참조한다. url &lt;- &quot;https://docs.google.com/spreadsheets/d/1U6Cf_qEOhiR9AZqTqS3mbMF3zt2db48ZP5v3rkrAEJY/&quot; life_exp_africa &lt;- read_sheet(url) ✔ Reading from &quot;gapminder&quot;. ✔ Range &#39;Africa&#39;. life_exp_africa # A tibble: 624 × 6 country continent year lifeExp pop gdpPercap &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Algeria Africa 1952 43.1 9279525 2449. 2 Algeria Africa 1957 45.7 10270856 3014. 3 Algeria Africa 1962 48.3 11000948 2551. 4 Algeria Africa 1967 51.4 12760499 3247. 5 Algeria Africa 1972 54.5 14760787 4183. 6 Algeria Africa 1977 58.0 17152804 4910. 7 Algeria Africa 1982 61.4 20033753 5745. 8 Algeria Africa 1987 65.8 23254956 5681. 9 Algeria Africa 1992 67.7 26298373 5023. 10 Algeria Africa 1997 69.2 29072015 4797. # ℹ 614 more rows sheet 인수를 지정하지 않았기 때문에 첫 번째 워크시트인 Africa 지역의 나라들의 기대수명(lifeExp)과 일인당GDP(gdpPercap) 등을 제공한다. Google Sheets 문서의 URL은 다음의 구조로 되어 있다. https://docs.google.com/spreadsheets/d/문서ID/edit#gid=워크시트ID 그러므로 다음처럼 URL을 참조하여 문서 ID로 데이터를 읽어올 수도 있다. sheet_id &lt;- &quot;1U6Cf_qEOhiR9AZqTqS3mbMF3zt2db48ZP5v3rkrAEJY&quot; life_exp_asia &lt;- read_sheet(sheet_id, sheet=&quot;Asia&quot;) ✔ Reading from &quot;gapminder&quot;. ✔ Range &#39;&#39;Asia&#39;&#39;. life_exp_asia # A tibble: 396 × 6 country continent year lifeExp pop gdpPercap &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. 2 Afghanistan Asia 1957 30.3 9240934 821. 3 Afghanistan Asia 1962 32.0 10267083 853. 4 Afghanistan Asia 1967 34.0 11537966 836. 5 Afghanistan Asia 1972 36.1 13079460 740. 6 Afghanistan Asia 1977 38.4 14880372 786. 7 Afghanistan Asia 1982 39.9 12881816 978. 8 Afghanistan Asia 1987 40.8 13867957 852. 9 Afghanistan Asia 1992 41.7 16317921 649. 10 Afghanistan Asia 1997 41.8 22227415 635. # ℹ 386 more rows Google Sheets에 대한 메타정보를 확인하려면 gs4_get() 함수를 사용한다. 이 함수는 Google Sheets 문서에 대한 정보, 워크시트에 대한 정보, 그리고 이름이 부여된 범위에 대한 정보를 제공한다. gs4_get(sheet_id) ── &lt;googlesheets4_spreadsheet&gt; ───────────────────────────────────────────────── Spreadsheet name: &quot;gapminder&quot; ID: 1U6Cf_qEOhiR9AZqTqS3mbMF3zt2db48ZP5v3rkrAEJY Locale: en_US Time zone: America/Los_Angeles # of sheets: 5 # of named ranges: 1 ── &lt;sheets&gt; ──────────────────────────────────────────────────────────────────── (Sheet name): (Nominal extent in rows x columns) &#39;Africa&#39;: 625 x 6 &#39;Americas&#39;: 301 x 6 &#39;Asia&#39;: 397 x 6 &#39;Europe&#39;: 361 x 6 &#39;Oceania&#39;: 25 x 6 ── &lt;named ranges&gt; ────────────────────────────────────────────────────────────── (Named range): (A1 range) &#39;canada&#39;: &#39;Americas&#39;!A38:F49 Google Sheets의 모든 워크시트의 이름만 확인하려면 sheet_names() 함수를 사용한다. sheet_names(sheet_id) [1] &quot;Africa&quot; &quot;Americas&quot; &quot;Asia&quot; &quot;Europe&quot; &quot;Oceania&quot; sheet_properties() 함수를 사용하면 모든 워크시트의 속성을 확인할 수 있다. sheet_properties(sheet_id) # A tibble: 5 × 8 name index id type visible grid_rows grid_columns data &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; &lt;int&gt; &lt;int&gt; &lt;list&gt; 1 Africa 0 780868077 GRID TRUE 625 6 &lt;NULL&gt; 2 Americas 1 45759261 GRID TRUE 301 6 &lt;NULL&gt; 3 Asia 2 1984823455 GRID TRUE 397 6 &lt;NULL&gt; 4 Europe 3 1503562052 GRID TRUE 361 6 &lt;NULL&gt; 5 Oceania 4 1796776040 GRID TRUE 25 6 &lt;NULL&gt; gs4_get() 함수 결과에서 보듯이 Gapmider의 문서에는 \"canada\"라는 이름으로 정의되어 있는 범위가 존재한다. 이 범위는 캐나다와 관련 데이터의 셀 범위를 가리키고 있다. 문서에 이미 정의된 범위는 range 인수에 해당 이름을 지정하여 가져올 수 있다. 이 범위에는 열 이름을 나타내는 머리행이 없으므로, col_names 인수에 열 이름을 지정해야 한다. read_sheet(sheet_id, range=&quot;canada&quot;, col_names=names(life_exp_africa)) ✔ Reading from &quot;gapminder&quot;. ✔ Range &#39;canada&#39;. # A tibble: 12 × 6 country continent year lifeExp pop gdpPercap &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Canada Americas 1952 68.8 14785584 11367. 2 Canada Americas 1957 70.0 17010154 12490. 3 Canada Americas 1962 71.3 18985849 13462. 4 Canada Americas 1967 72.1 20819767 16077. 5 Canada Americas 1972 72.9 22284500 18971. 6 Canada Americas 1977 74.2 23796400 22091. 7 Canada Americas 1982 75.8 25201900 22899. 8 Canada Americas 1987 76.9 26549700 26627. 9 Canada Americas 1992 78.0 28523502 26343. 10 Canada Americas 1997 78.6 30305843 28955. 11 Canada Americas 2002 79.8 31902268 33329. 12 Canada Americas 2007 80.7 33390141 36319. Gapminder의 문서는 모든 워크시트가 동일한 구조로 되어 있다. 그러므로 하나의 데이터로 모두 통합할 수 있다. 다음은 sheet_names()로 모든 워크시트의 이름 받은 후, 차례대로 워크시트를 읽어와 하나의 데이터프레임으로 병합한 예이다. life_exp_all &lt;- sheet_names(sheet_id) %&gt;% lapply(function(sheet) read_sheet(sheet_id, sheet=sheet)) %&gt;% bind_rows() ✔ Reading from &quot;gapminder&quot;. ✔ Range &#39;&#39;Africa&#39;&#39;. ✔ Reading from &quot;gapminder&quot;. ✔ Range &#39;&#39;Americas&#39;&#39;. ✔ Reading from &quot;gapminder&quot;. ✔ Range &#39;&#39;Asia&#39;&#39;. ✔ Reading from &quot;gapminder&quot;. ✔ Range &#39;&#39;Europe&#39;&#39;. ✔ Reading from &quot;gapminder&quot;. ✔ Range &#39;&#39;Oceania&#39;&#39;. life_exp_all # A tibble: 1,704 × 6 country continent year lifeExp pop gdpPercap &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Algeria Africa 1952 43.1 9279525 2449. 2 Algeria Africa 1957 45.7 10270856 3014. 3 Algeria Africa 1962 48.3 11000948 2551. 4 Algeria Africa 1967 51.4 12760499 3247. 5 Algeria Africa 1972 54.5 14760787 4183. 6 Algeria Africa 1977 58.0 17152804 4910. 7 Algeria Africa 1982 61.4 20033753 5745. 8 Algeria Africa 1987 65.8 23254956 5681. 9 Algeria Africa 1992 67.7 26298373 5023. 10 Algeria Africa 1997 69.2 29072015 4797. # ℹ 1,694 more rows 이 데이터에서 2007 년도 데이터만 추출하여 일인당GDP, 기대수명, 인구수(pop)을 이용하여 버블 차트를 그려보자. 대륙별로 다른 색상의 버블이 되도록 하였고, 일인당GDP는 로그 스케일로 변환하였다. filter(life_exp_all, year==2007) %&gt;% ggplot(aes(gdpPercap, lifeExp)) + geom_point(aes(size=pop, color=continent)) + geom_text(aes(label=country), size=2, nudge_y=1, check_overlap=T) + scale_x_continuous(trans=&quot;log10&quot;) + labs(x=&quot;일인당 GDP&quot;, y=&quot;기대수명&quot;, size=&quot;인구&quot;, color=&quot;대륙&quot;) + theme_bw() 마지막으로 한국 데이터만 필터링 하여 시간에 따라 어떻게 변화하였는지를 시각화해 보자. life_exp_korea &lt;- life_exp_all %&gt;% filter(country == &quot;Korea, Rep.&quot;) life_exp_korea # A tibble: 12 × 6 country continent year lifeExp pop gdpPercap &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Korea, Rep. Asia 1952 47.5 20947571 1031. 2 Korea, Rep. Asia 1957 52.7 22611552 1488. 3 Korea, Rep. Asia 1962 55.3 26420307 1536. 4 Korea, Rep. Asia 1967 57.7 30131000 2029. 5 Korea, Rep. Asia 1972 62.6 33505000 3031. 6 Korea, Rep. Asia 1977 64.8 36436000 4657. 7 Korea, Rep. Asia 1982 67.1 39326000 5623. 8 Korea, Rep. Asia 1987 69.8 41622000 8533. 9 Korea, Rep. Asia 1992 72.2 43805450 12104. 10 Korea, Rep. Asia 1997 74.6 46173816 15994. 11 Korea, Rep. Asia 2002 77.0 47969150 19234. 12 Korea, Rep. Asia 2007 78.6 49044790 23348. ggplot(life_exp_korea, aes(gdpPercap, lifeExp)) + geom_line(aes(color=year)) + geom_point(aes(size=pop, color=year)) + labs(x=&quot;일인당 GDP&quot;, y=&quot;기대수명&quot;, size=&quot;인구&quot;, color=&quot;조사년도&quot;) + theme_bw() Google Sheets에 데이터 쓰기 Google Sheets 문서에 데이터를 쓰려면 인증 절차를 거쳐야 한다. gs4_auth() 함수를 사용하여 인증을 시작한다. gs4_auth() ! Using an auto-discovered, cached token. To suppress this message, modify your code or options to clearly consent to the use of a cached token. See gargle&#39;s &quot;Non-interactive auth&quot; vignette for more details: &lt;https://gargle.r-lib.org/articles/non-interactive-auth.html&gt; ℹ The googlesheets4 package is using a cached token for &#39;mexrcise@gmail.com&#39;. gs4_auth()를 실행하면 다음과 같은 메시지가 출력된다. (메시지는 버전에 따라 조금씩 다를 수 있다.) OAuth 인증을 캐시 폴더에 저장하여 다음 번 실행 시에는 인증을 생략할지를 묻는 질문이다. Is it OK to cache OAuth access credentials in the folder ~/.cache/gargle between R sessions? 1: Yes 2: No Selection: Selection:에 1을 입력하여 저장하든지, 2를 입력하여 항상 인증을 할지를 결정한다. 사용할 Google 계정을 선택하거나 아직 로그인이 되어 있지 않으면 Google 이메일 계정과 암호를 입력하여 인증을 진행한다. 이 과정은 Google에서 직접 수행되는 것으로 R에는 관련 정보가 저장되지 않는다. 로그인된 Google 계정이 오직 하나이면 이 과정은 생략될 수 있다. Tidyverse API Packages 서비스 로그인이 내 계정에 접근할 수 있는 권한을 줄 것인지를 묻는다. 계속을 클릭하여 진행한다. Tidyverse API Packages가 내 계정의 Google Sheets의 문서를 수정하고 생성할 권한을 줄지를 묻는다. write_sheet() 함수가 여러분의 계정에 워크시트를 생성하거나 수정하려면 이 권한을 부여하여야 한다. 체크박스를 체크한 후 계속을 클릭한다. 그러면 인증이 끝났고 R로 돌아가라는 안내 페이지가 나타난다. write_sheet() 함수는 데이터프레임의 데이터를 새로운 Google Sheets 문서의 워크시트에 저장하거나 기존의 워크시트의 내용을 덮어쓰기한다. sheet_write() 함수라고도 한다. 두 함수는 동일한 함수이다. data 인수: 첫 번째 인수로 저장할 데이터프레임이 지정된다. ss 인수: Google Sheets 문서의 URL이나 문서 ID 등이 지정된다. 디폴트 값은 NULL로 임의로 파일 이름으로 데이터를 저장한 새로운 Google Sheets 문서가 생성된다. sheet 인수: Google Sheets 문서의 어느 워크시트에 데이터를 저장할지 지정한다. 워크시트의 이름이나 위치로 지정한다. write_sheet() 함수는 자신이 데이터를 저장한 문서의 ID를 반환한다. Gapmider의 데이터 중에서 한국 데이터만 새로운 Google Sheets 문서에 저장해보자. 가장 단순한 방법은 임의의 이름으로 새로운 Google Sheets 문서를 만들어 저장하는 것이다. ss &lt;- write_sheet(life_exp_korea) ✔ Creating new Sheet: &quot;kimberlite-toad&quot;. 저장된 문서의 메타정보를 확인해 보자. gs4_get(ss) ── &lt;googlesheets4_spreadsheet&gt; ───────────────────────────────────────────────── Spreadsheet name: &quot;kimberlite-toad&quot; ID: 1MButhx4JALykA4NRtAFHnED4XNAF6zCQc1aZIig5YiI Locale: ko_KR Time zone: Etc/GMT # of sheets: 1 ── &lt;sheets&gt; ──────────────────────────────────────────────────────────────────── (Sheet name): (Nominal extent in rows x columns) &#39;life_exp_korea&#39;: 13 x 6 임의의 문서 이름이 부여되어 있고, 워크시트의 이름으로 데이터프레임의 변수명이 사용되었음을 볼 수 있다. 여러분의 구글 드라이브에 가보면 이 Google Sheets 문서를 확인할 수 있다. 여기서는 워크시트를 읽어서 데이터가 제대로 저장되었는지 확인해 보자. read_sheet(ss) ✔ Reading from &quot;kimberlite-toad&quot;. ✔ Range &#39;life_exp_korea&#39;. # A tibble: 12 × 6 country continent year lifeExp pop gdpPercap &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Korea, Rep. Asia 1952 47.5 20947571 1031. 2 Korea, Rep. Asia 1957 52.7 22611552 1488. 3 Korea, Rep. Asia 1962 55.3 26420307 1536. 4 Korea, Rep. Asia 1967 57.7 30131000 2029. 5 Korea, Rep. Asia 1972 62.6 33505000 3031. 6 Korea, Rep. Asia 1977 64.8 36436000 4657. 7 Korea, Rep. Asia 1982 67.1 39326000 5623. 8 Korea, Rep. Asia 1987 69.8 41622000 8533. 9 Korea, Rep. Asia 1992 72.2 43805450 12104. 10 Korea, Rep. Asia 1997 74.6 46173816 15994. 11 Korea, Rep. Asia 2002 77.0 47969150 19234. 12 Korea, Rep. Asia 2007 78.6 49044790 23348. 임의의 문서명과 워크시트명이 아니라 원하는 이름으로 Google Sheets 문서를 만드려면 gs4_create() 함수를 사용한다. name 인수에 문서명을 sheets 인수에 워크시트명을 지정한다. (워크시트의 이름을 지정하는 인수가 지금까지 사용했던 sheet가 아니라 sheets임에 주의한다. 여러 워크시트 명을 전달할 수 있기 때문에 복수형으로 인수 이름이 지어졌다.) ss &lt;- gs4_create(name=&quot;기대수명&quot;, sheets=&quot;Korea&quot;) ✔ Creating new Sheet: &quot;기대수명&quot;. 새로 만들어진 문서에 한국 데이터를 저장해 보자. write_sheet(life_exp_korea, ss=ss, sheet=&quot;Korea&quot;) ✔ Writing to &quot;기대수명&quot;. ✔ Writing to sheet &#39;Korea&#39;. 이 외에도 워크시트에 행을 추가하거나 복사할 수 있으며, 워크시트와 범위를 지우는 등의 다양한 작업을 할 수 있다. 관련된 내용은 도움말이나 googlesheets4 문서를 참조한다. 12.3 데이터베이스에서 데이터 가져오기 추후 공개 예정 12.4 웹 스크래핑 (web scrapping): 웹 사이트에서 데이터 가져오기 웹 스크래핑은 웹 페이지에서 필요한 정보를 추출하는 것을 의미한다. 일부 웹 사이트는 공개 API(Application Programming Interface)를 이용하여 웹 사이트의 데이터를 JSON이나 XML 등의 구조화된 형식으로 제공하기도 한다. 공개 API를 사용하여 웹 사이트에서 정보를 획득하는 방법은 12.5 절에서 다룰 것이다. 그러나 대부분의 웹 사이트는 별도의 API를 제공하지 않으므로 웹 페이지에 나타난 정보를 웹 스크래핑 방법을 사용하여 직접 추출해야 한다. 웹 스크래핑 시 주의 사항 타인의 웹 사이트에서 데이터를 수집하는 행위는 윤리적, 법적 문제를 만들 수 있다. 공개되어 있고, 개인정보가 아니고, 사실과 관련된 데이터를 수집하는 것은 일반적으로 법적 문제에 결부될 확률이 낮다. 특히 학술, 비영리적 목적으로 위와 같은 정보를 수집하는 것은 대부분 법적인 문제의 소지가 낮다. 그러나 이는 어디까지나 일반적인 지침이지 확립된 규칙은 아니다. 만약 데이터 수집이 법적, 윤리적 문제를 발생시킬 가능성이 있다고 판단된다면 전문가의 확인을 받는 것이 좋다. 특히 공개되지 않고 로그인이 필요한 서비스에서 데이터를 수집하거나, 개인정보가 포함된 정보를 수집하거나, 저작권을 침해할 소지가 있는 정보를 수집하고자 할 때에는, 해당 사이트의 운영 방침을 확인하는 것이 좋다. 또한 웹 스크래핑을 할 때 웹 사이트의 운영에 최대한 피해를 주지 않아야 한다. 다량의 웹 페이지에서 데이터를 수집하는 것은 웹 사이트에 많은 부하를 줄 수 있다. 그러므로 연속적으로 여러 웹 페이지에서 데이터를 수집할 때는, 수집 사이에 일정한 시간 간격으로 수집을 중지하는 시간이 필요하다. rvest 패키지 rvest 패키지는 웹페이지에서 데이터를 스크래핑하게 도와준다. tidyverse 패키지를 설치하였으면 이 패키지가 이미 설치되었을 것이다. 만약 설치되어 있지 않다면 다음 명령으로 설치를 한다. install.packages(&quot;rvest&quot;) rvest 패키지는 tidyverse의 핵심 패키지가 아니므로 tidyverse 패키지와는 별도로 메모리에 적재해야 한다. library(rvest) 다음의 패키지를 부착합니다: &#39;rvest&#39; The following object is masked from &#39;package:readr&#39;: guess_encoding HTML 기초 모든 웹 페이지는 HTML(HyperText Markup Language)이라는 언어로 만들어진다. 다음은 매우 단순한 웹 페이지를 표현하는 HTML 문서를 보여준다. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;초간단 웹페이지&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id=&quot;first&quot;&gt;단순한 웹 페이지&lt;/h1&gt; &lt;p class=&quot;plain&quot;&gt; 요즘에는 이렇게 간단한 웹 페이지는 &lt;b&gt;실습&lt;/b&gt; 아니면 만들지 않는다. 다음 그림은 &lt;i&gt;Copilot&lt;/i&gt;에서 생성한 &lt;b&gt;HTML&lt;/b&gt; 관련 이미지이다. &lt;/p&gt; &lt;img src=&quot;img/html.png&quot; width=300 height=250&gt; &lt;/body&gt; &lt;/html&gt; 이 HTML 문서로 구현된 웹 페이지를 확인하려면 링크를 클릭한다. HTML 문서는 다음 구조를 가진다. HTML 문서는 태그(tags) 또는 노드(nodes)라고도 불리는 요소(elements)들로 계층적으로 구성된다. 태그는 &lt;태그명&gt;으로 시작하여 &lt;\\태그명&gt;으로 끝난다. 위의 예에서 최상위 요소는 &lt;html&gt;요소이다. &lt;html&gt; 요소는 &lt;head&gt;와 &lt;body&gt;라는 두 자식 요소(하위 요소)를 가진다. &lt;head&gt; 요소는 HTML 문서에 대한 메타정보를 저장한다. 대표적인 자식 요소로 브라우저 상단에 표시되는 웹 문서의 제목과 동적인 웹 문서를 만들기 위해서 사용되는 자바스크립트 등이 있다. &lt;body&gt; 요소에는 웹 브라우저에서 표현되는 컨텐츠들이 포함된다. &lt;body&gt; 요소 아래에는 웹 문서에 볼 수 있는 다양한 블록 요소들이 정의된다. 위의 예에서는 &lt;body&gt; 요소는 제목을 나타내는 &lt;h1&gt; 요소, 문단을 나타내는 &lt;p&gt; 요소를 자식 요소로 포함한다. 블록 요소 아래에 또 다른 블록 요소들이 포함될 수 있으며, &lt;b&gt;, &lt;i&gt;, &lt;a&gt; 처럼 텍스트의 형식을 등을 지정하는 인라인(inline) 요소들도 포함될 수 있다. 블록 요소들은 새로운 블록이 시작될 때 새로운 줄에서 시작되지만 인라인 요소들은 줄바꿈 하지 않는다. 태그들은 태그의 시작과 끝 사이에 텍스트 등의 컨텐츠를 포함할 수 있다. 태그에는 속성(attributes)이 정의될 수 있다. 속성은 시작 태그에 속성이름=속성값의 형식으로 정의된다. 위의 예에서는 &lt;h1&gt; 태그에 id라는 속성이, &lt;img&gt; 태그에 src 등의 속성이 정의되어 있다. id와 class 속성은 매우 중요한 속성인데, 웹 페이지의 스타일을 지정하는 CSS(Cascading Style Sheets)를 사용하여 특정 id와 class의 요소의 스타일을 지정할 수 있기 때문이다. id 속성은 요소에 유일한 값이 지정된다. 모든 요소에 id 속성이 지정되는 것은 아니다. class 속성은 동일한 종류의 스타일을 공유하는 여러 요소들에게 같은 값이 지정된다. 모든 요소에 class 속성이 지정되는 것은 아니다. HTML 문서 가져오기 rvest 패키지의 read_html() 함수는 웹 페이지를 R로 가져온다. 첫 번째 인수로 웹 페이지의 유일한 주소인 URL을 지정해 준다. URL은 웹 브라우저의 주소창에 나타나는 문자열이다. 앞의 단순한 웹 페이지의 URL로 페이지를 가져오자. html &lt;- read_html(&quot;https://scrap-examples.netlify.app/simple.html&quot;) html {html_document} &lt;html&gt; [1] &lt;head&gt;\\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8 ... [2] &lt;body&gt;\\r\\n &lt;h1 id=&quot;first&quot;&gt;단순한 웹 페이지&lt;/h1&gt;\\r\\n &lt;p class=&quot;plain&quot;&gt;\\r\\n ... read_html() 함수는 xml_document 객체로 HTML 문서의 정보를 반환한다. xml_document 클래스는 rvest가 의존하고 있는 xml2 패키지에 정의된 자료형이다. 반환된 정보는 &lt;html&gt; 요소가 이 문서의 최상위 요소임을 보여준다. 그리고 그 아래 두 요소가 있고 각각 &lt;head&gt;와 &lt;body&gt; 요소라는 것도 보여준다. HTML 요소 찾기 일반적으로 HTML 문서는 매우 복잡한 계층 구조를 가지고 있으므로 내가 원하는 정보를 가진 요소만 뽑아내는 것이 쉽지 않다. 웹 스크래핑에서는 특정한 요소를 지정하기 위하여 CSS 선택자(selectors)를 사용한다. CSS 선택자는 원래 웹 페이지의 특정 요소를 지정하여 스타일을 적용하기 위해 사용된다. 매우 정밀하게 페이지 내의 요소를 정의해야 하기 때문에 CSS 선택자를 잘 사용하면 대부분의 경우 내가 원하는 요소를 정확하게 지정할 수 있다. CSS 선택자는 핵심적으로 다음 세 가지 방식으로 특정한 요소를 지정한다. 태그명으로 요소 지정: p는 &lt;p&gt; 요소를 지정한다. .클래스명으로 요소 지정: .plain는 class=plain 속성을 가진 모든 요소를 지정한다. #ID로 요소 지정: #first는 id=first 속성을 가진 요소를 지정한다. CSS 선택자는 이 세가지 방식을 자유롭게 조합하여 정밀하게 특정한 요소를 지정할 수 있다. 이에 대해서는 나중에 논의하기로 한다. html_elements()는 CSS 선택자와 매칭되는 모든 요소를 반환한다. 다음은 최상위의 &lt;html&gt; 요소 아래에 있는 모든 &lt;p&gt; 요소를 찾는 예이다. html %&gt;% html_elements(&quot;p&quot;) {xml_nodeset (1)} [1] &lt;p class=&quot;plain&quot;&gt;\\r\\n 요즘에는 이렇게 간단한 웹 페이지는 &lt;b&gt;실습&lt;/b&gt; 아니면 만들지 않는다.\\r\\n ... 다음은 최상위의 &lt;html&gt; 요소 아래에 있는 모든 &lt;b&gt; 요소를 찾는 예이다. html %&gt;% html_elements(&quot;b&quot;) {xml_nodeset (2)} [1] &lt;b&gt;실습&lt;/b&gt; [2] &lt;b&gt;HTML&lt;/b&gt; 이번에는 class 속성이 \"plain\"인 모든 요소를 찾는 예이다. html %&gt;% html_elements(&quot;.plain&quot;) {xml_nodeset (1)} [1] &lt;p class=&quot;plain&quot;&gt;\\r\\n 요즘에는 이렇게 간단한 웹 페이지는 &lt;b&gt;실습&lt;/b&gt; 아니면 만들지 않는다.\\r\\n ... 마지막으로 id 속성이 \"first\"인 모든 요소를 찾는 예이다. html %&gt;% html_elements(&quot;#first&quot;) {xml_nodeset (1)} [1] &lt;h1 id=&quot;first&quot;&gt;단순한 웹 페이지&lt;/h1&gt; html_elements()와는 조금 다른 기능을 하는 html_element()라는 함수도 있다. (복수를 의미하는 s가 없다.) 이 함수는 최상위 노드에서 매칭되는 요소를 오직 하나만 반환한다. 만약 매칭되는 요소가 여러 개 있으면 첫 번째로 매칭되는 요소를 반환한다. html %&gt;% html_element(&quot;b&quot;) {html_node} &lt;b&gt; 만약 최상위 요소가 여러 개이면 html_element()는 입력된 최상위 요소별로 매칭되는 하나의 요소를 반환하다. 만약 매칭되는 요소가 없으면 NA라는 결측치를 반환한다. 다음은 단순한 웹 페이지에는 포함되지 않은 순서 없는 목록을 나타내는 &lt;ul&gt; 요소를 html_element()로 찾는 예이다. html %&gt;% html_element(&quot;ul&quot;) {xml_missing} &lt;NA&gt; html_elements()는 어떠한 요소도 매칭이 되지 않으면 무엇을 반환할까? html %&gt;% html_elements(&quot;ul&quot;) {xml_nodeset (0)} 해당되는 요소가 없으면 html_elements() 함수는 길이가 0인 벡터를 반환한다. 두 함수의 이러한 차이는 여러 요소에서 데이터를 추출할 때 매우 중요한 차이를 만든다. 이 두 함수의 쓰임새의 차이를 확인하기 위하여 다음 예를 살펴보자. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;목록 웹페이지&lt;/title&gt; &lt;link href=&quot;css/scrap.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;목록이 있는 웹페이지&lt;/h1&gt; &lt;p&gt;다음은 최근 대한민국의 4 명의 대통령에 대한 목록이다.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;이명박&lt;/b&gt; &lt;i&gt;17대&lt;/i&gt; 대통령의 재임기간은 &lt;span class=&quot;period&quot;&gt;1827일&lt;/span&gt;이다.&lt;/li&gt; &lt;li&gt;&lt;b&gt;박근혜&lt;/b&gt; &lt;i&gt;18대&lt;/i&gt; 대통령의 재임기간은 &lt;span class=&quot;period&quot;&gt;1475일&lt;/span&gt;이다.&lt;/li&gt; &lt;li&gt;&lt;b&gt;문재인&lt;/b&gt; &lt;i&gt;19대&lt;/i&gt; 대통령의 재임기간은 &lt;span class=&quot;period&quot;&gt;1827일&lt;/span&gt;이다.&lt;/li&gt; &lt;li&gt;&lt;b&gt;윤석열&lt;/b&gt; &lt;i&gt;20대&lt;/i&gt; 대통령은 현재 재임 중이다.&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 이 HTML 문서로 구현된 웹 페이지를 확인하려면 링크를 클릭한다. 이 웹 페이지는 목록을 가지고 있고 목록의 내용 중 class=period인 요소에 다음과 같은 CSS 스타일이 적용되어 있다. .period { color: purple; background-color: lightyellow; } 먼저 이 웹 페이지를 가져온 후 목록의 항목을 나타내는 &lt;li&gt; 요소를 모두 추출해 보자. html &lt;- read_html(&quot;http://scrap-examples.netlify.app/list.html&quot;) presidents &lt;- html %&gt;% html_elements(&quot;li&quot;) presidents {xml_nodeset (4)} [1] &lt;li&gt;\\n&lt;b&gt;이명박&lt;/b&gt; &lt;i&gt;17대&lt;/i&gt; 대통령의 재임기간은 &lt;span class=&quot;period&quot;&gt;1827일&lt;/span&gt;이 ... [2] &lt;li&gt;\\n&lt;b&gt;박근혜&lt;/b&gt; &lt;i&gt;18대&lt;/i&gt; 대통령의 재임기간은 &lt;span class=&quot;period&quot;&gt;1475일&lt;/span&gt;이 ... [3] &lt;li&gt;\\n&lt;b&gt;문재인&lt;/b&gt; &lt;i&gt;19대&lt;/i&gt; 대통령의 재임기간은 &lt;span class=&quot;period&quot;&gt;1827일&lt;/span&gt;이 ... [4] &lt;li&gt;\\n&lt;b&gt;윤석렬&lt;/b&gt; &lt;i&gt;20대&lt;/i&gt; 대통령은 현재 재임 중이다.&lt;/li&gt; 목록 항목에서 대통령의 이름을 추출해 보자. 항목이 여러 개이고 항목별로 대통령의 이름을 하나씩 추출해야 하므로 html_element() 함수의 사용이 적절하다. name &lt;- presidents %&gt;% html_element(&quot;b&quot;) name {xml_nodeset (4)} [1] &lt;b&gt;이명박&lt;/b&gt; [2] &lt;b&gt;박근혜&lt;/b&gt; [3] &lt;b&gt;문재인&lt;/b&gt; [4] &lt;b&gt;윤석렬&lt;/b&gt; 다음으로 대통령의 취임 순서와 재임기간 데이터를 추출해 보자. orders &lt;- presidents %&gt;% html_element(&quot;i&quot;) orders {xml_nodeset (4)} [1] &lt;i&gt;17대&lt;/i&gt; [2] &lt;i&gt;18대&lt;/i&gt; [3] &lt;i&gt;19대&lt;/i&gt; [4] &lt;i&gt;20대&lt;/i&gt; periods &lt;- presidents %&gt;% html_element(&quot;.period&quot;) periods {xml_nodeset (4)} [1] &lt;span class=&quot;period&quot;&gt;1827일&lt;/span&gt; [2] &lt;span class=&quot;period&quot;&gt;1475일&lt;/span&gt; [3] &lt;span class=&quot;period&quot;&gt;1827일&lt;/span&gt; [4] NA 현 대통령은 재임 중이므로 재임기간 정보가 없다. 그러므로 해당 요소가 없는 항목은 결측치(NA)로 처리되었다. 만약 이 경우에서 html_elements()를 사용하면 어떻게 될까? presidents %&gt;% html_elements(&quot;.period&quot;) {xml_nodeset (3)} [1] &lt;span class=&quot;period&quot;&gt;1827일&lt;/span&gt; [2] &lt;span class=&quot;period&quot;&gt;1475일&lt;/span&gt; [3] &lt;span class=&quot;period&quot;&gt;1827일&lt;/span&gt; 위의 결과에서 보듯이 해당 요소가 없으면 추출되지 않는 것을 볼 수 있다. 만약 한 항목에 class=period인 요소가 2 개가 있었다면 이 두 요소가 모두 추출되었을 것이다. 그렇기 때문에 앞의 대통령의 이름과 취임순서의 개수와 순서가 맞지 않으므로 표 형식의 데이터로 정리하기 어려울 것이다. 정리하자면, html_elements()는 특정 조건에 맞는 모든 요소를 찾을 때 사용하고, html_element()는 추출된 최상위 요소에서 오직 한 개의 결과만을 얻고자 할 때 사용한다. 텍스트 추출과 처리 앞의 예에서 HTML에서 추출된 요소들은 HTML 태그를 포함하고 있다. HTML 요소에서 태그를 제외하고 텍스트만 추출하고자 하면 html_text2() 함수를 사용한다. html_text() 함수도 텍스트를 추출하지만, 이 함수는 태그 안의 텍스트를 그대로 추출하는 반면, html_text2()는 태그 안의 하위 태그들을 고려하여 적절한 텍스트 형식으로 변환하여 추출해 준다. 그렇기 때문에 html_text2()는 html_text()보다 처리시간이 더 길지만 일반적으로 사용자가 원하는 형태로 텍스트를 추출해 준다. name %&gt;% html_text2() [1] &quot;이명박&quot; &quot;박근혜&quot; &quot;문재인&quot; &quot;윤석렬&quot; orders %&gt;% html_text2() [1] &quot;17대&quot; &quot;18대&quot; &quot;19대&quot; &quot;20대&quot; periods %&gt;% html_text2() [1] &quot;1827일&quot; &quot;1475일&quot; &quot;1827일&quot; NA 추출된 텍스트로 tibble 형식의 데이터프레임을 만들어 보자. tibble( name=name %&gt;% html_text2(), n=orders %&gt;% html_text2(), period=periods %&gt;% html_text2() ) # A tibble: 4 × 3 name n period &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 이명박 17대 1827일 2 박근혜 18대 1475일 3 문재인 19대 1827일 4 윤석렬 20대 &lt;NA&gt; 그런데 이 데이터는 취임순서와 재임기간이 모두 문자로 처리되어 있기 때문에, 수치로서 처리할 수 없으므로 평균 등을 구할 수 없다. tidyverse에 포함되어 있는 readr 패키지는 문자열을 다양한 자료형으로 변환하는 함수를 가지고 있다. 12.1 절에서 파일을 읽을 때 열의 자료형을 지정하여 열의 데이터를 적절한 자료형으로 변환할 수 있다고 하였다. 사실 이 변환 작업에는 다음과 같은 함수들이 이용된다. parse_number(): 텍스트에서 숫자만 추출하여 수치형으로 변환한다. parse_logical(): 텍스트를 논리값으로 변환한다. parse_factor(): 텍스트에서 유일한 값만 추출하여 요소(factors)로 변환한다. parse_date(), parse_time(), parse_datetime(): 텍스트를 날짜, 시간, 날짜와 시간 형식으로 변환한다. 텍스트에 표현된 날짜와 시간 형식을 지정할 수 있다. orders %&gt;% html_text2() %&gt;% parse_number() [1] 17 18 19 20 그러므로 다음처럼 텍스트를 수치로 변환하여 데이터프레임을 만들 수 있다. df &lt;- tibble( name=name %&gt;% html_text2(), n=orders %&gt;% html_text2() %&gt;% parse_number(), period=periods %&gt;% html_text2() %&gt;% parse_number() ) df # A tibble: 4 × 3 name n period &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 이명박 17 1827 2 박근혜 18 1475 3 문재인 19 1827 4 윤석렬 20 NA 재임기간이 수치로 저장되었기 때문에 다음처럼 재임기간의 평균을 구할 수 있다. mean(df$period, na.rm=T) [1] 1709.667 조합 선택자로 웹 문서에서 요소 지정하기 현실의 웹 문서는 지금까지 보았던 단순한 형식보다 훨씬 더 복잡하다. 동일한 태그, 클래스가 여러 군데에서 다른 의미로 사용될 수 있다. 그러므로 내가 원하는 정보만 정확하게 지정하는 것이 쉬운 일이 아니다. 복잡한 웹 문서에서 원하는 요소만 지정하려면 CSS 선택자에 대한 더 심화된 이해와 관련된 도구의 사용법을 학습하여야 한다. 지금까지 태그, .클래스, #ID 등의 기본 선택자를 사용하여 요소를 지정하는 방법을 살펴보았다. 이 외에도 요소를 지정하는 두 가지 기본 선택자가 더 있다. [속성] 선택자는 특정 속성이 있는 요소만 매칭한다. [속성=값]을 사용하여 특정 속성이 특정 값인 요소만 매칭한다. 또는 특정 속성이 특정 값으로 시작하거나 특정 값을 포함하는 요소를 매칭할 수도 있다. :의사클래스 선택자는 특정 상태에 있는 요소만 매칭한다. 예를 들어 특정 태그 요소 중에 맨 처음인 요소, 맨 마지막 요소, 마우스가 머물러 있는 요소 등을 지정할 수 있다. 이러한 기본 선택자들은 공백 없이 결합되어 모든 조건을 만족하는 특정 요소를 선택할 수 있다. 예로, 태그.클래스, .클래스1.클래스2, 태그[속성], 태그:의사클래스 등의 결합이 있을 수 있다. CSS 선택자는 태그, 클래스, ID, 속성, 의사클래스 등의 기본 선택자를 조합하여 원하는 요소를 매우 정교하게 지정하도록 구성할 수 있다. 그룹 선택자: 선택자1, 선택자2, ..., 선택자n 나열된 선택자 중 하나 이상과 매칭되는 요소를 선택 자식 선택자: 부모선택자 &gt; 자식선택자 부모 선택자와 매칭되는 요소들의 자식 요소 중에서 자식선택자와 매칭되는 요소를 선택 후손 선택자: 상위선택자 하위선택자 상위선택자와 매칭되는 요소의 하위 요소 중에서서 하위선택자와 매칭되는 요소를 선택 인접 형제 선택자: 선택자1 + 선택자2 선택자1과 매칭되는 요소와 동일 계층에 있는 다음 요소 중에서 선택자2를 만족하는 요소를 선택 일반 형제 선택자: 선택자1 ~ 선택자1 선택자1과 매칭되는 요소와 동일 계층에 있는 형재 요소 중에서 선택자2를 만족하는 요소를 선택 다음 표는 다양한 기본 선택자와 조합 선택자를 보여준다. 선택자 Desc a a 태그 요소를 추출 div, a div 태그와 a 태그 요소를 추출 div a div 태그 하위의 a 태그 요소를 추출 div + a div 태그 바로 다음에 나타나는 a 태그 요소를 추출 .cls 요소의 class 속성이 cls인 모든 요소를 추출 .cls1.cls2 요소의 class 속성이 cls1과 cls2를 모두 가진 요소를 추출 .cls1 .cls2 class 속성이 cls1인 요소의 후손 중 class 속성이 cls2인 요소를 추출 #myid id 속성이 myid인 요소를 추출 a.cls a 태그 요소 중 class 속성이 cls인 모든 요소 추출 a.cls1.cls2 a 태그 요소 중 class 속성이 cls1과 cls2를 모두 가진 요소를 추출 a.cls1.cls2 a 태그 요소 중 class 속성이 cls1과 cls2를 모두 가진 요소를 추출 CSS 선택자에 대한 자세한 설명은 CSS 기초를 다루는 MDN 사이트를 참조하기 바란다. 복잡한 웹 문서에서 내가 원하는 요소의 CSS 선택자를 탐색할 때 사용할 수 있는 유용한 도구가 두 가지가 있다. Chrome 브라우저의 검사 메뉴 Chrome의 SelectorGadget 확장 프로그램 Chrome 브라우저에서 웹 문서에서 추출하고자 하는 부분에 마우스를 위치한 후 컨텍스트 메뉴에서 검사(inspect) 를 선택해 보자. 그러면 개발자 도구가 나타나며, 현재의 웹 페이지의 HTML 문서와 마우스로 선택한 요소의 HTML 태그 부분이 강조되어 표시된다. 강조된 HTML 부분에 마우스를 가져가면 웹 페이지에 이 요소를 추출하기 위한 CSS 선택자가 툴팁으로 표시된다. 툴팁의 CSS 실렉터로 요소를 추출해 보자. 결과에서 보듯이 선택된 요소가 추출되지만, 동일한 CSS 선택자에 매칭되는 다른 요소들도 선택되는 경우가 자주 있다. html %&gt;% html_elements(&quot;span.period&quot;) {xml_nodeset (3)} [1] &lt;span class=&quot;period&quot;&gt;1827일&lt;/span&gt; [2] &lt;span class=&quot;period&quot;&gt;1475일&lt;/span&gt; [3] &lt;span class=&quot;period&quot;&gt;1827일&lt;/span&gt; SelectorGadget을 이용한 CSS 선택자 추출 추출하고자 하는 요소의 CSS 선택자를 쉽게 추출하는 방법은 Chrome의 확장 프로그램인 SelectorGadget을 사용하는 것이다. SelectorGadget을 설치하는 방법은 다음과 같다. Chrome 메뉴에서 [확장 프로그램]-[Chrom 웹 스토어 방문하기]를 선택한다. SelectorGadget을 검색하여 확장 프로그램으로 추가한다. 설치 후 브라우저 메뉴바에 나타나는 확장 프로그램 아이콘을 클릭한 후 SelectGadget을 메뉴 바에 고정한다. 데이터를 추출하려는 웹 페이지로 이동한 후 Chrome 메뉴 바의 SelectorGadget을 클릭하여 실행한다. 그러면 다음 그림처럼 웹 페이지 하단에 SelectorGadget 메뉴창이 나타난다. SelectorGadget에서 원하는 요소에 대한 CSS 선택자를 추출하는 절차는 다음과 같다. 웹 페이지에서 추출할 요소 선택 SelectorGadget이 실행된 상태에서 추출한 요소를 마우스로 클릭한다. 그러면 선택된 요소는 녹색으로 변경된다. 선택된 요소를 지정하는 CSS 선택자가 웹 페이지 하단의 SelectorGadget 메뉴창에 나타난다. 현재의 CSS 선택자로 추출되는 모든 요소가 노란색으로 표현된다. 웹 페이지에서 추출할 요소를 추가 선택 현재의 CSS 선택자로 아직 선택이 안된가 있으면 마우스로 요소를 클릭한다. 그러면 현재 선택된 요소뿐 아니라 새롭게 클릭된 요소를 포함하도록 CSS 선택자가 변경된다. 새롭게 변경된 CSS 선택자로 추출되는 모든 요소가 노란색으로 표현된다. 웹 페이지에서 요소 선택 해제 선택된 요소를 해제하려면 다시 마우스로 클릭한다. 선택된 요소는 빨간색으로 변경된다. 이 요소가 선택되지 않도록 CSS 선택자가 변경된다. 새롭게 변경된 CSS 선택자로 추출되는 모든 요소가 노란색으로 표현된다. 모든 선택 해제 처음부터 다시 시작하려면 SelectorGadget 메뉴창에서 Clear를 선택한다. 원하는 요소의 조합을 얻었으면 SelectorGadet 메뉴창에 나타나는 CSS 선택자를 복사하여 요소를 추출한다. SelectorGadget을 중지하려면 SelecorGadget 메뉴창에서 X를 선택한다. SelectorGadget에 대한 자세한 사용법은 rvest 홈페이지의 SelectorGadget 글을 참조한다. 다음은 SelectorGadget을 사용하여 목록의 첫 번째 재임기간만 선택하는 CSS 선택자를 얻은 후 실행한 결과이다. html %&gt;% html_elements(&quot;li:nth-child(1) .period&quot;) {xml_nodeset (1)} [1] &lt;span class=&quot;period&quot;&gt;1827일&lt;/span&gt; 일반적으로 웹 페이지의 동일한 요소들을 여러 개의 다른 CSS 선택자로 추출할 수 있다. 그러므로 선택하고자 하는 요소와 제외하고자 하는 요소를 클릭하는 순서 등에 따라 동일한 요소의 CSS 선택자가 다르게 출력될 수 있다. 영화 순위 페이지 스크래핑 현재 다음과 네이버는 영화 서비스를 중단한 상태이다. 여기서는 과거 웹 페이지를 저장하는 web.archive.org에서 2023년 다음 영화 페이지를 가져오도록 한다. 이 페이지는 2023년 2월 중의 박스오피스 순위 정보 페이지이다. target &lt;- &quot;https://web.archive.org/web/20230208141058/https://movie.daum.net/ranking/boxoffice/yearly&quot; html &lt;- read_html(target) html {html_document} &lt;html lang=&quot;ko&quot;&gt; [1] &lt;head&gt;\\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8 ... [2] &lt;body class=&quot;&quot;&gt; \\n &lt;div class=&quot;direct-link&quot;&gt; \\n &lt;a href=&quot;#mainC ... 박스오피스에 있는 영화 이름을 추출해보자. SelectGadget을 구동한 후 ‘다음’ 영화 랭킹 페이지에서 영화 이름을 클릭한다. 영화 이름뿐 아니라 페이지 마지막의 요소도 선택된다. 이 요소들을 클릭하여 제외시킨다. 페이지의 영화 이름만 노란색으로 선택되고 다른 요소는 선택되지 않았는지를 확인한다. SelectGadget에 나타난 정보를 html_elements()에 문자열 인수로 제공하여 영화 이름을 추출한다. title &lt;- html %&gt;% html_elements(&quot;#mainContent .link_txt&quot;) %&gt;% html_text() title [1] &quot;범죄도시2&quot; [2] &quot;탑건: 매버릭&quot; [3] &quot;아바타: 물의 길&quot; [4] &quot;한산: 용의 출현&quot; [5] &quot;공조2: 인터내셔날&quot; [6] &quot;닥터 스트레인지: 대혼돈의 멀티버스&quot; [7] &quot;헌트&quot; [8] &quot;올빼미&quot; [9] &quot;쥬라기 월드: 도미니언&quot; [10] &quot;마녀(魔女) Part2. The Other One&quot; [11] &quot;토르: 러브 앤 썬더&quot; [12] &quot;미니언즈2&quot; [13] &quot;블랙 팬서: 와칸다 포에버&quot; [14] &quot;비상선언&quot; [15] &quot;스파이더맨: 노 웨이 홈&quot; [16] &quot;육사오(6/45)&quot; [17] &quot;헤어질 결심&quot; [18] &quot;외계+인 1부&quot; [19] &quot;영웅&quot; [20] &quot;해적: 도깨비 깃발&quot; [21] &quot;브로커&quot; [22] &quot;신비한 동물들과 덤블도어의 비밀&quot; [23] &quot;인생은 아름다워&quot; [24] &quot;더 배트맨&quot; [25] &quot;데시벨&quot; [26] &quot;정직한 후보2&quot; [27] &quot;씽2게더&quot; [28] &quot;극장판 짱구는 못말려: 수수께끼! 꽃피는 천하떡잎학교&quot; [29] &quot;블랙 아담&quot; [30] &quot;킹메이커&quot; [31] &quot;자백&quot; [32] &quot;언차티드&quot; [33] &quot;경관의 피&quot; [34] &quot;오늘 밤, 세계에서 이 사랑이 사라진다 해도&quot; [35] &quot;극장판 주술회전 0&quot; [36] &quot;압꾸정&quot; [37] &quot;극장판 포켓몬스터DP: 기라티나와 하늘의 꽃다발 쉐이미&quot; [38] &quot;이상한 나라의 수학자&quot; [39] &quot;명탐정 코난: 할로윈의 신부&quot; [40] &quot;동감&quot; [41] &quot;모비우스&quot; [42] &quot;늑대사냥&quot; [43] &quot;뽀로로 극장판 드래곤캐슬 대모험&quot; [44] &quot;특송&quot; [45] &quot;니 부모 얼굴이 보고 싶다&quot; [46] &quot;놉&quot; [47] &quot;리멤버&quot; [48] &quot;킹스맨: 퍼스트 에이전트&quot; [49] &quot;배드 가이즈&quot; [50] &quot;뜨거운 피&quot; 이번에는 영화 개봉일 데이터를 추출해 보자. Clear 단추를 사용하여 현재 선택된 내용을 삭제한다. 웹 페이지에서 개봉일만 선택되도록 클릭한다. 원하는 요소만 선택되었는지 확인한다. SelectGadget에 나타난 정보를 html_elements()에 문자열 인수로 제공하여 정보를 추출한다. html %&gt;% html_elements(&quot;.txt_num&quot;) %&gt;% html_text() %&gt;% head() [1] &quot;22.05.18&quot; &quot;22.06.22&quot; &quot;22.12.14&quot; &quot;22.07.27&quot; &quot;22.09.07&quot; &quot;22.05.04&quot; 개봉일은 날짜 정보이므로 parse_date()로 이를 날짜 형식으로 변환한다. 날짜 형식에 사용되는 포맷 문자는 parse_date의 도움말에서 확인할 수 있다. release &lt;- html %&gt;% html_elements(&quot;.txt_num&quot;) %&gt;% html_text() %&gt;% parse_date(format=&quot;%y.%m.%d&quot;) release [1] &quot;2022-05-18&quot; &quot;2022-06-22&quot; &quot;2022-12-14&quot; &quot;2022-07-27&quot; &quot;2022-09-07&quot; [6] &quot;2022-05-04&quot; &quot;2022-08-10&quot; &quot;2022-11-23&quot; &quot;2022-06-01&quot; &quot;2022-06-15&quot; [11] &quot;2022-07-06&quot; &quot;2022-07-20&quot; &quot;2022-11-09&quot; &quot;2022-08-03&quot; &quot;2021-12-15&quot; [16] &quot;2022-08-24&quot; &quot;2022-06-29&quot; &quot;2022-07-20&quot; &quot;2022-12-21&quot; &quot;2022-01-26&quot; [21] &quot;2022-06-08&quot; &quot;2022-04-13&quot; &quot;2022-09-28&quot; &quot;2022-03-01&quot; &quot;2022-11-16&quot; [26] &quot;2022-09-28&quot; &quot;2022-01-05&quot; &quot;2022-09-28&quot; &quot;2022-10-19&quot; &quot;2022-01-26&quot; [31] &quot;2022-10-26&quot; &quot;2022-02-16&quot; &quot;2022-01-05&quot; &quot;2022-11-30&quot; &quot;2022-02-17&quot; [36] &quot;2022-11-30&quot; &quot;2022-06-01&quot; &quot;2022-03-09&quot; &quot;2022-07-13&quot; &quot;2022-11-16&quot; [41] &quot;2022-03-30&quot; &quot;2022-09-21&quot; &quot;2022-07-28&quot; &quot;2022-01-12&quot; &quot;2022-04-27&quot; [46] &quot;2022-08-17&quot; &quot;2022-10-26&quot; &quot;2021-12-22&quot; &quot;2022-05-04&quot; &quot;2022-03-23&quot; 영화 관객수를 추출해 보자. Clear 단추를 사용하여 현재 선택된 내용을 삭제한다. 웹 페이지에서 관객수 클릭하면 개봉일 정보도 같이 선택된다. 개봉일을 클릭하면 빨간 색으로 바뀌면서 관객수 정보만 선택되는 것을 확인한다. SelectGadget에 나타난 정보를 html_elements()에 문자열 인수로 제공하여 정보를 추출한다. html %&gt;% html_elements(&quot;.info_txt+ .info_txt&quot;) %&gt;% html_text() %&gt;% head() [1] &quot;관객수12,693,415명&quot; &quot;관객수8,177,452명&quot; &quot;관객수10,581,515명&quot; [4] &quot;관객수7,264,934명&quot; &quot;관객수6,982,940명&quot; &quot;관객수5,884,595명&quot; 관객수는 수치이므로 텍스트에서 숫자만 추출한다. parse_number() 함수로 문자를 숫자로 변환 숫자의 자릿수 형식을 지정하기 위해 locale() 함수 사용 audience &lt;- html %&gt;% html_elements(&quot;.info_txt+ .info_txt&quot;) %&gt;% html_text() %&gt;% parse_number(locale = locale(grouping_mark = &quot;,&quot;)) audience [1] 12693415 8177452 10581515 7264934 6982940 5884595 4352407 3327105 [9] 2837413 2806501 2716306 2269033 2105834 2058869 7551990 1980773 [17] 1895856 1539364 3154410 1339242 1261131 1195443 1171648 904238 [25] 901426 899684 885419 837647 779489 783567 738122 730847 [33] 684667 1051490 663158 608639 581223 534291 490869 490145 [41] 475928 458720 447777 444417 416524 415969 412836 1029365 [49] 400329 398105 지금까지 추출된 정보를 이용하여 데이터프레임을 생성한다. movies &lt;- tibble(title, release, audience) movies # A tibble: 50 × 3 title release audience &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; 1 범죄도시2 2022-05-18 12693415 2 탑건: 매버릭 2022-06-22 8177452 3 아바타: 물의 길 2022-12-14 10581515 4 한산: 용의 출현 2022-07-27 7264934 5 공조2: 인터내셔날 2022-09-07 6982940 6 닥터 스트레인지: 대혼돈의 멀티버스 2022-05-04 5884595 7 헌트 2022-08-10 4352407 8 올빼미 2022-11-23 3327105 9 쥬라기 월드: 도미니언 2022-06-01 2837413 10 마녀(魔女) Part2. The Other One 2022-06-15 2806501 # ℹ 40 more rows 개봉일과 관객수의 분포를 시각화해 보자. ggplot(movies) + geom_histogram(aes(release), bins=12) ggplot(movies) + geom_histogram(aes(audience), bins=10) + scale_x_continuous(trans=&quot;log10&quot;) 상영 기간이 서로 다른 영화들이므로 일일 평균 영화 관객수로 영화의 흥행도를 분석해 보자. movies %&gt;% mutate( days = as.Date(&quot;20230206&quot;, &quot;%Y%m%d&quot;) - release, aud_per_day = audience / as.numeric(days, units=&quot;days&quot;) ) %&gt;% arrange(desc(aud_per_day)) # A tibble: 50 × 5 title release audience days aud_per_day &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;drtn&gt; &lt;dbl&gt; 1 아바타: 물의 길 2022-12-14 10581515 54 days 195954. 2 영웅 2022-12-21 3154410 47 days 67115. 3 범죄도시2 2022-05-18 12693415 264 days 48081. 4 공조2: 인터내셔날 2022-09-07 6982940 152 days 45940. 5 올빼미 2022-11-23 3327105 75 days 44361. 6 한산: 용의 출현 2022-07-27 7264934 194 days 37448. 7 탑건: 매버릭 2022-06-22 8177452 229 days 35709. 8 헌트 2022-08-10 4352407 180 days 24180. 9 블랙 팬서: 와칸다 포에버 2022-11-09 2105834 89 days 23661. 10 닥터 스트레인지: 대혼돈의 멀티버스 2022-05-04 5884595 278 days 21168. # ℹ 40 more rows 웹 페이지의 표 데이터 수집하기 네이버 SPORTS의 배구 섹션의 기록/순위 페이지에서 여자부 선수들의 기록을 수집해 보자. 배구 섹션의 순위 페이지에서 [여자부]를 선택한다. 기록을 가져올 시즌을 선택한다. [2023-2024] 시즌을 선택해 보자. 페이지의 URL 브라우저에서 확인 후 R 스크립트에 복사한다. target &lt;- &quot;https://sports.news.naver.com/volleyball/record/index?category=wkovo&amp;year=2022&quot; html &lt;- read_html(target) 웹 페이지의 표는 &lt;table&gt; 태그로 되어 있고, rvest는 웹 문서의 표를 데이터프레임으로 추출할 수 있다. html_table() 함수를 사용하면 HTML 또는 특정 노드 아래에 있는 모든 table을 추출이 가능하다. 각 table은 tibble로 저장된다. 여러 개의 table이 있는 경우 리스트로 저장된다. tables &lt;- html %&gt;% html_table() length(tables) [1] 2 tables[[1]] # 첫 번째 테이블블 tables[[2]] # 두 번째 테이블블 웹 페이지에 표가 여러 개 있는 경우에 표 하나를 특정하여 데이터를 수집할 수도 있다. 웹 페이지에서 선택하고자 하는 표를 선택한 후 컨텍스트 메뉴에서 검사를 선택한다. 개발자 도구의 HTML 문서에서 데이터를 수집하려는 표에 상응하는 태그를 찾아서 우클릭하여 [Copy]-[Copy Xpath]를 복사한다. Xpath는 웹 페이지에서 각 요소를 유일하게 지정하는 방법이다. html_element() 함수의 xpath 인수에 복사한 Xpath 값을 설정한다. Xpath에 큰따옴표가 포함되어 있는 경우가 많다. 그러므로 xpath 인수에 설정할 때 작은 따옴표로 감싸준다. html_element()의 결과에 html_table()을 적용하여 데이터프레임으로 추출한다. players &lt;- html %&gt;% html_element(xpath=&#39;//*[@id=&quot;content&quot;]/div[3]/div/div[4]/table&#39;) %&gt;% html_table() players # A tibble: 20 × 9 X1 X2 X3 X4 X5 X6 X7 X8 X9 &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 엘리자벳(KGC인삼공사) 1015 43.0 0.28 0.54 2.13 0.09 0 2 2 모마(GS칼텍스) 879 43.7 0.25 0.36 2.42 0.09 0 3 3 옐레나(흥국생명) 821 42.8 0.25 0.49 3.08 0.17 0 4 4 니아 리드(페퍼저축은행) 717 36.2 0.06 0.46 2.89 0.05 12.5 5 5 김연경(흥국생명) 669 45.8 0.16 0.3 5.53 0.4 46.8 6 6 산타나(IBK기업은행) 606 38.4 0.13 0.3 6.44 0.13 49.0 7 7 표승주(IBK기업은행) 529 34.8 0.09 0.36 6.83 0.21 36.4 ...... 추출된 표의 열 이름이 제대로 설정되지 않은 경우에는 직접 열 이름 설정한다. names(players) &lt;- c(&quot;rank&quot;, &quot;player&quot;, &quot;score&quot;, &quot;attack&quot;, &quot;serve&quot;, &quot;blocking&quot;, &quot;defence&quot;, &quot;sets&quot;, &quot;receive&quot;) players # A tibble: 20 × 9 rank player score attack serve blocking defence sets receive &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 엘리자벳(KGC인삼공사) 1015 43.0 0.28 0.54 2.13 0.09 0 2 2 모마(GS칼텍스) 879 43.7 0.25 0.36 2.42 0.09 0 3 3 옐레나(흥국생명) 821 42.8 0.25 0.49 3.08 0.17 0 4 4 니아 리드(페퍼저축은… 717 36.2 0.06 0.46 2.89 0.05 12.5 5 5 김연경(흥국생명) 669 45.8 0.16 0.3 5.53 0.4 46.8 6 6 산타나(IBK기업은행) 606 38.4 0.13 0.3 6.44 0.13 49.0 7 7 표승주(IBK기업은행) 529 34.8 0.09 0.36 6.83 0.21 36.4 ...... 반응형 웹 페이지 예전의 웹 페이지들은 사용자의 시스템, 브라우저에 상관없이 동일한 웹 페이지를 제공하였다. 최근에는 모바일 환경이 가속화되고 다양한 웹 브라우저들이 사용되어서 하나의 웹 페이지를 여러 버전으로 제공하는 것이 바람직한다. 예를 들어 PC로 접속하는 사용자와 스마트폰으로 접속하는 사용자에게 서로 다른 버전의 웹 페이지를 제공하면 훨씬 사용자 환경에 적합한 서비스를 제공할 수 있다. 반응형 웹은 자바스크립를 사용하여 사용자의 환경을 감지하여 사용자에 적절한 웹 페이지를 동적으로 생성하는 기술이다. 그러므로 반응형 웹 기술이 사용된 페이지를 스크래핑 하려면 실제 사용자와 동일한 브라우저를 페이지에 접속해야만 생성된 페이지에서 데이터를 수집할 수 있다. 그렇기 때문에 반응형 웹 페이지를 스크래핑할 때는 RSelenium이나 chromote 패키지 등을 사용하는데, 이 패키지들은 R에서 웹 브라우저를 제어하게 하여 페이지를 동적으로 생성해 가며 데이터를 수집할 수 있게 해 준다. 12.5 공개 API에서 데이터 가져오기 추후 공개 예정 "],["ch-R-documents.html", "Chapter 13 R 동적 문서 13.1 Quarto 설치 13.2 Quarto 문서 만들기 13.3 Quarto의 출력 형식 13.4 마크다운 기초 13.5 코드 모듬", " Chapter 13 R 동적 문서 매주 월요일마다 지난 주 판매 데이터를 분석하여 보고서를 작성한다고 가정해 보자. 이를 위해 다음과 같은 작업을 수행한다고 하자. 데이터베이스에서 주별 판매 데이터를 CSV 파일로 내려받는다. CSV 파일을 R에 적재하여 제품별 판매를 집계한다. R로 요일별 판매량에 대한 막대 그래프를 작성하여 보고서에 삽입한다. R로 판매 상위 20 개 품목의 판매량, 판매액에 대한 통계를 구하여 보고서에 표로 정리한다. 지난 주 판매에 대해 평가와 개선 방안을 텍스트로 간략히 작성한다. 이러한 문서 작업의 문제점은 다음과 같다. 매주 동일한 형식의 표와 그래프를 문서에 넣는 수작업을 반복하여야 한다. 보고서 작성이 수작업으로 이루어지다 보니 오류 발생 가능성이 크다. 표에 잘못된 수치를 기입할 수 있으며, 잘못된 그래프가 삽입될 수도 있다. 보고서 작성 후에 데이터에 오류가 발견되거나 변경되면, 문서 작업을 다시 해야 한다. 동적 문서(dynamic documents)를 사용하여 데이터 분석과 관련된 문서 작업을 효율화할 수 있다. 동적 문서에는 일반적인 문서 내용과 함께 프로그램 코드가 포함된다. 동적 문서를 컴파일하면 문서의 코드가 실행되어, 코드의 실행 결과가 표, 그래프, 텍스트 등의 형태로 문서에 자동으로 삽입된다. 그러므로 주별 판매 보고서도 데이터만 변경하면, 변경된 데이터에 대한 그래프와 표를 포함한 문서를 동적으로 생성할 수 있다. 또한 동적 문서는 코드와 코드의 실행 결과를 문서에 포함시킬 수 있으므로 데이터 분석 노트로서의 역할도 수행할 수 있다. 데이터 분석에서는 선행 분석 과정에서 얻은 중간 분석 결과를 바탕으로 후속 분석 방안이 도출되어 새로운 분석이 반복적으로 수행된다. 그런데 이러한 분석 과정이 R 콘솔이나 R 스크립트를 사용하여 수행되면, 중간 분석 결과를 문서화하기 어려워 추후에 왜 이러한 방식으로 데이터 분석이 수행되었는지 기억하기 어렵다. 별도의 문서에 중간 분석 결과를 기록할 수도 있겎지만, 분석에 사용된 R 명령어와 실행 결과, 실행 결과에 대한 해석 등이 별도로 생성되고 저장되므로 관리가 어렵다. 동적 문서를 사용하면 코드와 실행 결과, 실행 결과에 대한 해석, 후속 분석의 계획 등이 하나의 문서에 관리될 수 있다. R에서 동적 문서를 만드는 방법은 두 가지이다. R Markdown: R에서 rmarkdown 패키지를 설치한 후, R 코드와 마크다운으로 구성된 R Markdown 원본 문서를 생성하여, HTML, MS Word, PDF 문서와 각종 프리젠테이션 문서를 동적으로 생성한다. Quarto: R Markdown에서 얻은 아이디어와 경험을 R뿐 아니라 Julia, Python 등의 코드를 포함하는 동적 문서를 생성할 수 있도록 확장한 기술이다. R과 독립적으로 사용될 수 있다. 프로그램 코드와 마크다운으로 구성된 Quarto 문서를 생성하여 HTML, MS WOrd, PDF 문서와 각종 프리젠테이션 문서를 동적으로 생성한다. R Markdown은 이미 성숙한 기술로서, 이 책도 R Markdown을 이용하여 작성되었다. 이미 R Markdown을 사용하고 있는 사용자라면 Quarto로 굳이 전환을 하지 않아도 된다. (R Markdown과 Quarto의 관계에 대해서는 With Quarto Coming, is R Markdown Going Away? No. 글을 참고하기 바란다.) 그러나 새롭게 동적 문서와 관련된 기술을 배우는 사용자라면 Quarto를 이용할 것을 추천한다. Quarto는 지금 계속 계발되고 있는 기술로서 새로운 요소들이 계속 추가되고 있고, R뿐 아니라 Python 등의 언어로도 동적 문서를 만들 수 있기 때문이다.15 그러므로 여기서는 Quarto를 사용하여 동적 문서를 만드는 방법을 설명한다. 13.1 Quarto 설치 Quarto는 다중 언어 플랫폼을 지향하는 독립적인 시스템이므로 R이나 RStudio와 무관하게 설치될 수 있다. 또한 RStudio뿐 아니라, VS Code, Jupyter, Neovim 등의 도구를 사용하여 Quarto 문서를 만들고 변환할 수 있다. 그러나 R 사용자라면 RStudio를 사용하여 Quarto를 설치하고 사용하는 것이 가장 편리하다. RStudio는 Quarto와 통합되어 있어서 별도의 설치 과정이 필요 없고 Quarto 문서를 가장 손쉽게 작성할 수 있는 편의기능을 제공하기 때문이다. RStudio 이외에서 Quarto를 사용하려면 Quarto의 Get Started 페이지에서 자신의 시스템 환경에 맞는 설치파일을 다운로드 받아 설치하하고, 자신이 선택한 도구에서 Quarto를 사용하는 방법을 확인하기 바란다. 13.2 Quarto 문서 만들기 다음 절차에 따라 Quarto 문서를 만들어 보자. RStudio에서 [File]-[New File]-[Quarto Document...] 메뉴를 선택한다. New Quarto Document 윈도우가 팝업되면 필요한 정보를 입력하고 [Create Empty Document]를 클릭한다. Title에는 만들 문서의 제목을 입력한다. (문서에 표시될 전체 제목을 의미하는 것이지 문서 파일명이 아니다.) Author에는 작성자의 이름을 입력한다. 선택 사항이므로 입력하지 않아도 된다. Quarto 문서로 만들어낼 출력 문서의 형식을 지정한다. HTML, PDF, Word 문서를 지정할 수 있다. PDF 문서를 만드려면 LaTex가 설치되어 있어야 한다. 초심자에게 LaTex 설치는 까다로울 수 있다. 그러므로 HTML이나 Word 문서를 선택할 것을 권장한다. Engine: 문서의 코드를 실행하여 그 결과를 마크다운으로 변환할 때 사용할 엔진을 지정한다. R을 사용하는 문서는 Knitr을 선택한다. Editor: Quarto 문서는 마크다운 문법으로 기술된다. Use visual markdown editor가 체크되어 있으면 마크다운 문법을 모르더라도 워드나 한글 문서를 작성하듯이 Quarto 문서를 작성할 수 있다. 초심자는 이 항목이 체크되도록 한다. [Create]를 클릭하면 생성된 문서에 문서 작성 예가 포함된다. 예를 보고 싶은 독자는 [Create]를 클릭해 보기 바란다. 여기서는 [Create Empty Document]를 클릭하여 문서 작성 예가 포함되지 않은 빈문서를 생성한다. 문서를 생성하면 문서에 대한 메타정보를 표현하는 YAML 헤더(---으로 둘러쌓인 부분)만 작성된 빈 Quarto 문서가 생성된다. YAML 헤더 아래에 문서 컨텐츠를 작성한다. Quarto 문서는 컨텐츠를 마크다운 요소로 표현한다. Ctrl + / 또는 / 키를 입력한다. 그러면 문서에 입력할 수 있는 마크다운 요소가 나타난다. 또는 문서 위의 메뉴를 사용하여 원하는 마크다운 요소를 입력할 수 있다. 다음은 문서에 장 제목을 추가하기 위하여 Heading 1을 요소를 선택한 예이다. 문서에 텍스트를 표시하려면 텍스트를 그대로 입력하면 된다. R 코드 입력하려면 Ctrl + Alt + I 키 조합을 사용하거나 메뉴에서 Run 옆에 있는 +C라고 표현된 부분을 클릭한다. 그러면 다음처럼 R 코드를 입력하는 모듬(chunk)이 생성된다. 코드 모듬은 회색 부분으로 표시된다. 실행하고자 하는 R 코드를 모듬에 입력한다. 입력된 코드를 실행하려면 코드 모듬의 우상단의 실행 버튼을 클릭하거나 Ctrl + Shift + Enter 키 조합을 사용한다. 그러면 실행 결과가 코드 모듬 아래에 표시된다. 문서에 필요한 컨텐츠와 코드 모듬을 추가한다. 문서 작성이 완료되었으면 문서 상단의 메뉴에서 [Render]를 클릭하거나 Ctrl _ Shift + K 키 조합으로 출력 문서로 변환(render)한다. Quarto 문서를 지금까지 저장하지 않았으면 저장할 파일명을 물어본다. 적절한 파일명으로 문서를 저장한다. 문서 변환에 필요한 패키지가 설치되어 있지 않으면 문서 상단에 필요 패키지를 설치하라는 노란색 경고 표시가 나타나고 변환에 실패한다. 이 경우에는 경고 표시에서 Install을 클릭하여 필요한 패키지를 설치한 다음에 다시 변환을 시도한다. 출력 문서로의 변환이 성공적이면 별도의 창이나 RStudio의 Viewer 탭에 출력 문서가 나타난다. 출력 문서를 별도의 창과 Viewer 중 어디로 출력할지는 문서 위의 메뉴의 설정 아이콘을 클릭하여 변경할 수 있다. Priview in Window가 체크되어 있으면 별도의 창에 Priview in Viewer가 선택되어 있으면 RStudio의 Viewer 탭에 변환된 문서가 나타난다. 13.3 Quarto의 출력 형식 Quarto 문서는 크게 다음 세 가지 요소로 구성된다. YAML 헤더: 문서의 메타정보를 저장한다. 주로 Quarto 문서가 어떤 방식으로 변환될지 설정하는 용도로 사용된다. 마크다운 요소: 텍스트, 표, 이미지 등 문서의 정적인 컨텐츠를 기술한다. 마크다운은 경량화된 마크업 언어이다. HTML에 비해 매우 간략한 문법만으로 문서의 서식을 지정할 수 있다. 코드 모듬: R, Julia, Python 언어 등으로 작성된 코드가 기술된다. 코드의 실행 결과가 동적으로 출력 문서에 포함된다. R 코드를 포함한 Quarto 문서는 다음 과정을 거쳐 출력 문서로 변환된다. knitr 패키지는 새로운 R 세션에서 Quarto 문서에 포함된 R 코드 모듬을 순서대로 실행하여 그 결과를 마크다운 서식으로 변환한다. 이 과정을 거치면 Quarto 문서는 코드를 포함하지 않은 정적인 마크다운 문서로 변환된다. Pandoc 프로그램은 마크다운 문서를 HTML, MS Word, PDF 문서 등으로 변환한다. Quarto 등의 동적 문서의 장점은 코드 실행 결과를 동적으로 문서에 포함시킬 수 있는 것뿐 아니라, 하나의 원본으로 여러 형식의 출력 문서를 생성할 수 있다는 것이다. Pandoc은 Quarto와는 독립적인 기술로서 마크다운을 매개로 다양한 형식의 문서를 상호변환한다. Quarto는 HTML, MS Word, PDF뿐 아니라 프리젠테이션 형식을 포함한 다양한 형식으로 변환을 지원한다. Quarto가 지원하는 모든 출력 형식은 Quarto 사이트의 All Formats 페이지를 참조한다. 출력 형식 바꾸기 Quarto 문서의 출력 형식을 바꾸려면 YAML 헤더의 format의 값을 수정하거나 추가하면 된다. (Quarto를 독립적으로 설치하며 명렬줄에서 변환 명령을 실행한는 경우에는 출력 형식에 대한 옵션을 지정하여 출력 문서의 형식을 변경할 수도 있다.) 다음은 13.2 절에서 만든 Quarto 문서의 출력 형식을 HTML에서 MS Word로 바꾸는 예를 보여준다. YAML 헤더의 format의 값을 html에서 docx로 변경한다. 문서 상단 메뉴에서 [Render]를 클릭하여 출력 문서로 변환한다. 만약 출력 문서 파일을 저장할 파일이름을 요청하는 윈도우가 팝업되면 적절한 이름으로 저장한다. 13.3.1 여러 출력 형식으로 문서 변환하기 동일한 Quarto 문서를 여러 출력 형식으로 변환하려면, 다음처럼 format 헤더 아래에 한 수준 들여쓰기로 출력 형식을 한 줄씩 차례로 기술한다. --- title: &quot;Quarto 문서 실습&quot; author: &quot;김길환&quot; format: html: default docx: default editor: visual --- YAML 헤더를 변경한 후 문서를 저장하면, 문서 상단 메뉴의 [Render] 옆의 드롭다운 메뉴가 활성화되어 나열한 형식 중 하나를 선택하여 Quarto 문서를 변환할 수 있다. 13.3.2 출력 옵션 조정하기 지금까지는 출력 형식의 기본값을 사용하여 Quarto 문서를 변환하였다. 출력 형식의 하위에 옵션을 지정하는 헤더를 추가하면 출력 문서의 형태를 조정할 수 있다. 다음은 HTML 문서는 code-fold라는 헤더로 코드가 접혀있다가 클릭하면 나오도록 형식을 변경하고, MS Word 문서는 number-sections 헤더로 장과 절에 번호가 붙도록 조정한 예이다. RStudio에서는 YAML 헤더의 일부만 타이핑하면 헤더를 자동완성하도록 도와주고, 경우에 따라서는 각 헤더에 설정할 수 있는 적절한 값을 나열해 준다. --- title: &quot;Quarto 문서 실습&quot; author: &quot;김길환&quot; format: html: code-fold: true docx: number-sections: true editor: visual --- HTML, MS Word뿐 아니라 다른 출력 형식에서 설정할 수 있는 다양한 옵션은 Quarto Reference의 각각의 출력 형식에 대한 내용을 참조한다. 13.4 마크다운 기초 Quarto 문서에서 코드와 상관없는 컨텐츠는 마크다운을 이용하여 기술한다. RStudio의 Visual 편집 모드를 사용하면 마크다운 문법을 모르더라도 / 키나 문서 위의 메뉴를 사용하여 쉽게 마크다운 요소를 생성할 수 있다. 그러나 다른 편집기를 사용하거나 좀 더 효율적으로 Quarto 문서를 생성하려면 마크다운의 기본적인 문법을 습득하여야 한다. 이 절에서는 마크다운의 기본적인 문법을 소개한다. 마크다운 언어는 몇 가지 변형이 존재하는데, Quarto는 Pandoc 마크다운 언어를 사용하여 문서의 정적 요소를 표현한다. 텍스트 서식 텍스트에 서식을 설정할 때는 다음 문법을 사용한다. *이탤릭체*, **볼드체**, ***볼드 이탤릭*** 윗첨자^11^ 아래첨자~22~ ~~삭제~~ `입력된 그대로 출력` 그러면 다음과 같이 출력된다. 이탤릭체, 볼드체, 볼드 이탤릭체 윗첨자11 아래첨자22 삭제 입력된 그대로 장과 절의 제목 장과 절의 제목을 표현할 때는 다음 문법을 사용한다. # 장 제목 (제목 1 단계) ## 절 제목 (제목 2 단계) ### 제목 3 단계 #### 제목 4 단계 ##### 제목 5 단계 ###### 제목 6 단계 장과 절의 제목을 입력할 때 주의사항은 #와 제목 사이에 공백이 있어야 한다. 공백이 없으면 문서를 변환할 때 장과 절의 제목으로 인식되지 않는다. 목록 번호가 없는 목록은 다음과 같이 -, +, * 등으로 각 항목을 시작한다. 장과 절 제목처럼 문자 -, +, * 등과 항목 사이에 공백이 있어야 한다. 계층적인 목록을 표현하려면 하위 Tab을 사용하여 들여쓰기하여 표현한다. - 과일 - 사과 - 배 - 귤 - 채소 - 상추 - 적상추 - 청상추 - 시금치 그러면 다음과 같이 출력된다. 과일 사과 배 귤 채소 상추 적상추 청상추 시금치 번호가 있는 목록은 다음과 같이 1., i) 등으로 항목을 시작한다. 마찬가지로 번호를 나타내는 1., i)와 항목 사이에 공백이 있어야 한다. 계층적인 목록을 표현하려면 하위 Tab을 사용하여 들여쓰기하여 표현한다. 번호가 있는 목록의 하위에 번호가 업는 목록이 위치할 수도 있다. 1. 과일 i) 사과 i) 배 i) 귤 2. 채소 - 상추 - 적상추 - 청상추 - 시금치 그러면 다음과 같이 출력된다. 과일 사과 배 귤 채소 상추 A. 적상추 A. 청상추 시금치 다음과 같이 체크박스 목록을 만들 수도 있다. - [ ] 비행기표 예약 - [ ] 호텔 예약 - [X] 여권 연장 비행기표 예약 호텔 예약 여권 연장 RStudio의 Visual 편집 모드에서는 문서 위의 메뉴로 MS Word나 한글에서처럼 단계층의 번호 없는 목록과 번호 있는 목록을 쉽게 추가할 수 있다. 13.4.1 URL 링크 웹 페이지에 대한 URL 링크를 문서에 삽입하려면 다음 문법을 사용한다. &lt;https://kilhwan.github.io/rprogramming/&gt; https://kilhwan.github.io/rprogramming/ 다음처럼 임의의 페이지명으로 URL 링크를 문서에 표시하려면 다음과 같은 문법을 사용한다. [R 프로그래밍](https://kilhwan.github.io/rprogramming/) R 프로그래밍 그림 문서와 같은 폴더에 gogh.png 파일이 있다고 하자. 그러면 다음의 문법을 사용하여 그림 파일을 문서에 포함시킨다 ![최북 초상화와 빈센트 반 고흐 자화상](gogh.png) 그러면 출력 문서에서 다음과 같이 표현된다. 최북 초상화와 빈센트 반 고흐 자화상 (그림 출처: 조선시대의 빈센트 반 고흐, Jae Hwang, https://koreanvalley.net/archives/2184) 그림의 크기와 문서에서 정렬 방식을 지정할 수 있다. 다음 예에서는 그림의 크기를 문서 폭의 50%로 지정하고 가운데로 정렬한다. 이번에는 [ ] 안에 그림의 캡션을 지정하지 않았다. ![](gogh.png){width=&quot;50%&quot; fig-align=&quot;center&quot;} Quarto Guide의 Figures 페이지를 참조하면 다양한 형식으로 그림을 입력할 수 있다. 또한 RStudio의 Visual 편집 모드에서는 Figure / Image 아이콘을 클릭하면 MS Word나 한글에서처럼 쉽게 그림을 문서에 넣을 수 있다. 표 마크다운으로 표를 표현하는 문법은 다음과 같다. | 기본 열 | 왼쪽 정렬 | 오른쪽 정렬 | 가운데 정렬 | |--------|:------------|-----------:|:------------:| | 가나다 | 가나다 | 가나다 | 가나다 | | 라마바 | 라마바 | 라마바 | 라마바 | | 123 | 123 | 123 | 123 | | 456 | 456 | 456 | 456 | 그러면 다음과 같은 표가 표현된다. 기본 열 왼쪽 정렬 오른쪽 정렬 가운데 정렬 가나다 가나다 가나다 가나다 라마바 라마바 라마바 라마바 123 123 123 123 456 456 456 456 Pandoc 마크다운에는 표를 생성하는 4 가지 다른 문법이 존재한다(Pandoc User’s Guide 참조). 앞에서 소개한 방식은 pipe 형식이라 하고 행과 열이 교차하는 곳에 하나의 셀이 있는 단순한 표를 생성할 때 주로 사용된다. Pipe 형식이라고 하는 이유는 열을 파이프 문자 |로 분리하기 때문이다. Pipe 형식에서는 행의 구분으로 텍스트의 줄 바꿈을 사용하기 때문에, 한 행이 반드시 한 줄에 기술되어야 한다. 또 다른 형식은 multiline 형식이다. Multiline 형식에서는 한 행이 여러 줄의 텍스트로 표현될 수 있다. Multiline 형식에서 표는 일련의 -로 시작과 끝이 표현된다. 열은 공백으로 구분되고, 행은 빈 줄로 분리된다. 행이 빈줄로 구분되기 때문에 여러 줄의 텍스트가 하나의 행을 표현할 수 있다. ----------------------------------------------- 데이터 설명 비고 열이름 ----------- ------------- ----------------- age 고객 나이 고객의 나이는 만 나이로 기술 한다. income 고객 연봉 연봉은 천원을 단위로 표현한다. ------------------------------------------------ 데이터 열이름 설명 비고 age 고객 나이 고객의 나이는 만 나이로 기술 한다. income 고객 연봉 연봉은 천원을 단위로 표현한다. Grid 형식에서는 셀을 아래처럼 +, -, =, |를 사용하여 격자 모양으로 명확히 명시한다. 그러므로 한 셀이 여러 행 또는 여러 열에 걸쳐 나타날 수 있다. +-----------+--------------+-----------+ | 데이터 열 | 설명 | 비고 | +===========+==============+===========+ | age | 고객 나이 | | | | (만 나이) | | +-----------+--------------+ | | income | 고객 연봉 | | | | (단위: 천원) | | +-----------+--------------+-----------+ 데이터 열 설명 비고 age 고객 나이 (만 나이) income 고객 연봉 (단위: 천원) Simple 형식은 가장 단순한 형식으로 pipe 형식과 유사하게 한 행을 한 줄로 표현하는데 열은 |가 아니라 공백으로 구분한다. 그리고 열의 정렬을 열 이름과 아래의 - 선의 상대적 위치로 지정한다. 그런데 영어 문자들은 코드 편집기에서 -와 폭이 동일하여 Quarto 문서에서 정렬을 지정하기가 쉬운데, 한글 문자는 영어 문자와 - 문자의 폭과 서로 다른 경우가 대부분이어서 열의 정렬이 어렵다. 그렇기 때문에 한글이 들어간 표는 pipe 형식을 사용할 것을 권한다. Quarto Guide의 Tables 페이지를 참조하면 더 정교하게 표의 형식을 지정할 수 있다. 또한 RStudio의 Visual 모드에서는 Table 메뉴로 MS Word나 한글에서처럼 쉽게 표를 입력하고 수정할 수 있다. 블록 인용문 블록은 다음과 같이 표현한다. &gt; A Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions. – John Gruber A Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions. – John Gruber 행 블록(line block)은 텍스트 내의 공백과 줄바꿈이 출력 문서에서 그대로 표현된다. | 공백과 줄 바꿈이 | 그대로 | 표현된다. | 일반 텍스트는 그렇지 않다.   공백과 줄 바꿈이       그대로           표현된다. 일반 텍스트는 그렇지 않다. 같은 텍스트를 | 없이 기술하면 공백과 줄바꿈이 무시되고 다음과 같이 하나의 문단으로 표현된다. 공백과 줄 바꿈이 그대로 표현된다. 일반 텍스트는 그렇지 않다. 공백과 줄 바꿈이 그대로 표현된다. 일반 텍스트는 그렇지 않다. 마크다운에서 텍스트의 문단을 나누려면 빈 줄이 사이에 있어야 한다. 공백과 줄 바꿈이 그대로 표현된다. 일반 텍스트는 그렇지 않다. 공백과 줄 바꿈이 그대로 표현된다. 일반 텍스트는 그렇지 않다. 새로운 문단이 아니라 단순히 줄바꿈을 표현하려면 줄의 마지막에 둘 이상의 공백을 추가한다. 공백과 줄 바꿈이 그대로 표현된다. 일반 텍스트는 그렇지 않다. 공백과 줄 바꿈이 그대로 표현된다. 일반 텍스트는 그렇지 않다. 지금까지 설명한 내용 이외에도 다양한 마크다운 요소가 있다. RStudio의[Help]-[Markdwon Quick Reference] 메뉴에서 마크다운 문법에 대한 빠른 참조를 할 수 있고, Quarto 사이트의 Markdown Basics나 Pandoc Markdown 페이지에서 더 상세한 내용을 참조할 수 있다. 13.5 코드 모듬 Quarto 문서에 코드 모듬(code chunks)을 추가하는 세 가지 방법이 있다. Ctrl + Alt + I 키 조합 메뉴에서 삽입 아이콘 클릭 수작업으로 ```{r}로 시작하고 ```로 끝나는 블록을 작성한다. R 코드 모듬에 실행할 R 코드를 입력한다. 코드 모듬에 작성된 R 코드를 실행하는 방법은 두 가지가 있다. 스크립트에서 마찬가지로 Ctrl + Enter 단추키로 코드를 한 줄씩 실행할 수 있다. 코드 모듬의 모든 코드를 한번에 실행시킬 수도 있다. Ctrl + Shift + Enter 단축키 또는 코드 모듬의 오른쪽 마지막에 있는 실행 아이콘을 클릭한다. 코드 모듬의 실행 결과는 디폴트로 Quarto 문서 안에 표시된다. 스크립트에 있는 R 코드처럼 콘솔에 실행 결과가 나타나게 하려면, 문서 위의 설정 메뉴에서 [Chunk Output in Console]을 선택한다. 어떤 코드 모듬 위에 있는 모든 코드 모듬을 실행하려면 코드 모듬의 오른쪽에서 두 번째 있는 아이콘을 클릭한다. 문서 위의 Run 메뉴를 사용하면 문서 내의 코드 모듬을 다양한 방식으로 실행할 수 있다. Run All을 선택하면 모든 코드 모듬이 차례로 실행된다. Restart R and Run All Chunks를 선택하면 새로운 R 세션이 시작되고 새 세션에서 모든 코드 모듬이 차례로 실행된다. 이 외에도 현재 모듬 실행, 이전 모듬 모두 실행, 이후 모듬 모두 실행하는 방법들도 있으니 Run 메뉴를 살펴보기 바란다. Restart R and Run All Chunks는 전체 코드 모듬에서 오류가 없는지 확인할 때 유용하다. knitr이 Quarto 문서를 변환할 때 처럼 새로운 R 세션을 시작하여 코드 모듬을 차례로 모두 수행하기 때문이다. 그런데 Restart R and Run All Chunks를 실행했을 때는 오류가 발생하지 않았는데, Quarto 문서를 변환할 때 코드 모듬에서 오류가 발생하는 경우가 있다. 또는 그 반대의 경우도 발생한다. 이러한 차이가 발생하는 이유의 대부분은 작업 디렉토리 설정과 관련될 때가 많다. knitr은 Quarto 문서를 실행할 때 새로운 R 세션의 작업 디렉토리를 Quarto 문서가 저장된 폴도로 설정한다. 반면 RStudio에서 Quarto 문서를 편집하는 중에 코드 모듬을 실행하면, RStudio의 현재 R 세션의 작업 디렉토리 설정이 적용된다. 따라서 작업 디렉토리에서 파일을 읽거나 쓰는 작업을 하는 경우에는 Quarto 문서가 있는 폴더를 RStudio의 현재 세션의 작업 디렉토리로 설정하면 이러한 차이를 방지할 수 있다. 13.5.1 코드 모듬 옵션 Quarto 문서는 다양한 목적으로 사용될 수 있다. Quarto 문서가 생성할 문서가 의사결정자를 위한 보고 문서라면 코드 모듬이 생성한 그래프와 표는 문서에 포함시키지만 코드를 문서에 포함시키고 싶지는 않을 것이다. 그리고 R에서 사용자에게 정보를 주기 위해 출력하는 메시지도 문서에 포함시키고 싶지 않을 것이다. Quarto 문서가 데이터 분석 프로젝트를 같이 수행하는 동료에게 전달될 것이라면 실행 결과뿐 아니라 코드도 문서에 포함시키고 싶을 것이다. Quarto 문서가 강의에 사용되는 것이면 오류가 발생하는 경우를 보여주기 위하여 코드에 일부러 오류를 발생시키기도 한다. 그런데 Quarto 문서를 변환할 때 코드에 오류가 있으면 변환이 중지되고 출력 문서를 생성할 수 없다. 강의 문서를 만드는 경우에는 오류가 있더라도 코드가 모두 실행되고, 오류도 문서에 포함되기를 원할 수 있다. 코드 모듬에는 코드의 실행과 실행 결과를 문서에 포함시키는 방법을 조정하는 옵션을 지정할 수 있다. 코드 모듬의 옵션은 모듬 맨 윗부분에 정의되는데 #|로 시작하여 코드가 아니라 옵션임을 나타낸다. 다음은 코드 실행과 관련된 옵션들이다. eval: false로 지정되면 코드 모듬이 변환 과정에서 수행되지 않는다. 문서 생성 시에 실행시키기 어렵거나 출력이 너무 길어서 코드만 문서에 포함하고 싶을 때 주로 사용된다. echo: false로 지정되면 코드 모듬은 실행되어 결과는 문서에 포함되지만 코드는 문서에 포함되지 않는다. warning: false, message: false로 지정되면 코드 실행 시에 출력되는 경고와 메시지가 문서에 포함되지 않는다. include: false로 지정되면 실행되지만 코드와 코드의 실행 결과는 모두 문서에 포함되지 않는다. error: true로 지정되면 코드 모듬에서 오류가 발생하여도 문서 변환이 계속 수행되고 오류 출력이 문서에 포함된다. result: hide로 지정되면 텍스트 출력은 문서에 나타나지 않는다. fig-show: hide로 지정되면 코드 모듬이 생성한 그래프가 문서에 나타나지 않는다. 다음 코드 모듬의 코드는 문서에 나타나지만 문서 변환 시에는 실행되지 않는다. ```{r} #| eval: false 1:10 ``` 다음 코드 모듬은 코드는 실행되 결과는 문서에 포함되지만, 코드와 실행 중에 출력되는 메시지는 문서에 포함되지 않는다. 메시지란 코드의 실행 결과가 아니지만 사용자게 정보를 주기 위해서 출려되는 정보이다. geom_smooth() 함수는 추세선을 추정한 방법에 대하여 메시지를 출력한다. ```{r} #| echo: false #| message: false library(ggplot2) ggplot(mpg) + geom_smooth(aes(displ, hwy)) ``` 코드 모듬 옵션으로 코드가 생성한 그래프의 크기를 지정할 수 있다. 그런데 그래프의 크기에는 두 가지 기준이 있다. R에서 그리는 그래프의 크기 출력 문서에서 삽입되는 그래프의 크기 이 두 크기가 잘 조화되어야 그래프의 가독성이 좋아진다. 코드 모듬에서 R이 그래픽 장치에 그리는 그래프의 크기는 다음 세가지 옵션으로 조정된다. fig-width: 그래프의 가로폭이 인치로 지정된다. fig-height: 그래프의 세로폭이 인치로 지정된다. fig-asp: 그래프의 가로 대비 세로의 비율이 지정된다. 셋 중 둘이 결정되면 나머지 하나도 결정되므로, 세 옵션 중 두 옵션만 지정하면 된다. 일반적으로 문서 내의 그래프가 동일한 가로폭으로 그려지는 것이 시각적으로 일관성을 줄 수 있으므로 fig-width: 6와 fig-asp: 0.618 (황금 비율) 설정이 자주 사용된다. 그런데 R이 그리는 그래프의 크기는 그래프에 어떤 영향을 미칠까? 1/72 인치를 포인트(pt)라 하고 그래프에 표시되는 글씨들은 포인트 단위로 정의되어 있다. 그래프의 레이블에는 9~12 pt 정도의 글씨가 사용된다. 그러므로 그래프의 크기가 너무 크게 설정하고 글씨 크기를 조정하지 않으면 그래프의 레이블이 너무 작아 보이게 된다. 반대로 그래프의 크기가 너무 작으면 글씨가 너무 크게 보이게 된다. fig-width: 6과 fig-asp=0.618 fig-width: 9와 fig-asp=0.618 fig-width: 4과 fig-asp=0.8 문서에 삽입되는 그래프의 크기는 R에서 그린 그래프의 크기와는 다르다. 그려진 그래프가 크더라도 문서에는 작게 삽입될 수 있다. 출력 문서에 들어가는 그래프의 크기는 out-width와 out-height 옵션으로 조정된다. 둘 줄에 하나를 지정하면 그래프의 원래 비례에 맞추어 나머지 하나가 결정된다. 일반적으로 동일한 유형의 그래프의 가로폭을 일정하게 유지하므로 out-width가 주로 설정된다. out-width는 문서의 가로폭 대비 비율이 %로 지정될 수도 있고, cm 등의 물리적 길이, 픽셀수로도 정의될 수 있다. 그래프가 문서의 가로폭보다 작으면 fig-align 옵션을 사용하여 그래프의 정렬 방식을 지정하는 것이 좋다. 디폴트 값은 왼쪽 정렬이다. 다음은 5인치의 가로폭으로 생성된 그래프를 문서에 다양한 크기와 정렬 방식으로 삽입한 예이다. fig-width=6, out-width=70%, fig-align=\"center\" fig-width=6, out-width=70%, fig-align=\"right\" fig-width=6, out-width=35%, fig-align=\"right\" 두 번째와 세 번째 예에서 보듯이, 문서에 삽입되는 그래프의 크기와 그래프가 생성된 크기가 적절히 조화되어야 그래프의 점과 레이블들이 시각적으로 보기가 좋다. 마지막 예처럼 문서에서 그래프를 작게 삽입하려면 그래프를 생성하는 크기도 줄여서 그래프에서 레이블과 점의 상대적 크기를 키우는 것이 좋다. fig-width=3, out-width=35%, fig-align=\"right\" 그래프의 크기에 대해 더 깊은 이해를 원하는 독자는 Taking Control of Plot Scaling을 읽어볼 것을 권한다. 그래프와 관련된 몇 개의 다른 옵션을 설명한다. layout-ncol: 2로 설정하고 코드 모듬에서 두 개 이상의 그래프를 생성하면 두 그래프가 문서의 50% 크기로 나란히 배치된다. 2 대신 3 이상의 수가 설정될 수도 있다. 설정된 수만큼 그래프가 나란히 배치된다. fig-show: hold로 설정하면 코드 모듬의 모든 코드가 출력된 후에 그래프가 출력된다. fig-cap을 설정하면 그래프에 캡션이 추가된다. fig-format: png로 설정하면 R에서 그래프를 PNG 그래프로 생성한다. PDF 문서를 생성할 때는 그래프의 디폴트 장치도 PDF가 된다. PDF는 고품질의 그래프를 그릴 수 있지만 수천 개의 점을 표현해야 하는 그래프를 그려야 하면 느려지고 저장용량이 매우 커진다. 이럴 때 PNG로 그래프를 생성하면 품질은 약간 저하되지만 처리속도와 저장용량이 훨씬 감소한다. 이 외에도 knitr을 다양한 코드 모듬 옵션을 지원한다. Quarto Reference의 Code Cells: Knitr를 참조하기 바란다. 13.5.2 실행 옵션 (Excution Options) 코드 모듬 옵션은 모듬 단위로 설정되는 것뿐 아니라 문서 전체에 설정될 수도 있다. 문서 전체에 옵션이 설정되면 문서 내의 모든 코드 모듬에 해당 옵션이 적용된다. 만약 코드 모듬에도 동일한 옵션이 설정되어 있으면 해당 코드 모듬은 자신이 설정한 옵션이 적용된다. 문서 전체 옵션은 YAML 헤더에 정의된다. 코드 모듬의 실행과 관련된 옵션은 다음처럼 execute 헤더 아래 정의된다. title: &quot;My Document&quot; execute: echo: false message: false execute 헤더 아래에 정의될 수 있는 옵션은 다음과 같다. eval: 문서 전체의 코드를 실행할지 안할지를 지정 echo: 문서 전체의 코드를 출력할지를 지정 output: 문서 전체의 코드 실행 결과를 문서에 포함시킬지, 어떤 형식으로 포함시킬지를 지정 warning: 문서 전체의 코드 실행 경고를 포함시킬지 지정 error: 문서 전체에서 코드 실행 오류가 발생하여도 변환을 끝까지 수행하고 오류를 문서에 포함시킬지 지정 include: 문서 전체의 코드와 실행 결과 모두를 포함시킬지를 지정 문서의 모든 코드 모듬에 다른 옵션도 지정할 수 있다. 관련된 내용은 Quarto Guide의 Execution Options를 참조한다. 13.5.3 데이터프레임과 행렬을 표로 출력하기 Quarto 문서의 코드 모듬에서 데이터프레임이나 행렬을 출력하면 R 콘솔에서 출력되는 형태대로 출력 문서에 나타난다. df &lt;- mpg %&gt;% filter(manufacturer==&quot;hyundai&quot;) %&gt;% select(, model, manufacturer, year, displ, cty, hwy) df # A tibble: 14 × 6 model manufacturer year displ cty hwy &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; 1 sonata hyundai 1999 2.4 18 26 2 sonata hyundai 1999 2.4 18 27 3 sonata hyundai 2008 2.4 21 30 4 sonata hyundai 2008 2.4 21 31 5 sonata hyundai 1999 2.5 18 26 6 sonata hyundai 1999 2.5 18 26 7 sonata hyundai 2008 3.3 19 28 8 tiburon hyundai 1999 2 19 26 9 tiburon hyundai 1999 2 19 29 10 tiburon hyundai 2008 2 20 28 11 tiburon hyundai 2008 2 20 27 12 tiburon hyundai 2008 2.7 17 24 13 tiburon hyundai 2008 2.7 16 24 14 tiburon hyundai 2008 2.7 17 24 이를 표 형식으로 출력하려면 knitr::kable() 함수를 사용한다. knitr::kable(df, caption=&quot;현대자동차 모델의 연비&quot;) Table 13.1: 현대자동차 모델의 연비 model manufacturer year displ cty hwy sonata hyundai 1999 2.4 18 26 sonata hyundai 1999 2.4 18 27 sonata hyundai 2008 2.4 21 30 sonata hyundai 2008 2.4 21 31 sonata hyundai 1999 2.5 18 26 sonata hyundai 1999 2.5 18 26 sonata hyundai 2008 3.3 19 28 tiburon hyundai 1999 2.0 19 26 tiburon hyundai 1999 2.0 19 29 tiburon hyundai 2008 2.0 20 28 tiburon hyundai 2008 2.0 20 27 tiburon hyundai 2008 2.7 17 24 tiburon hyundai 2008 2.7 16 24 tiburon hyundai 2008 2.7 17 24 13.5.4 인라인 코드 Quarto 문서에 R 코드를 코드 모듬뿐 아니라 텍스트 내부에 포함시킬 수도 있다. 텍스트 내부에 포함된 인라인 코드는 문서 변환 시에 실행되어 실행 결과가 텍스트 안에 포함된다. 인라인 코드와 코드 모듬은 문서 변환 시에 순서대로 실행된다. 인라인 코드를 포함시키는 방법은 다음과 같다. ```{r} radius &lt;- 5 area &lt;- round(pi * radius^2, digits=2) ``` 원의 반지름은 `{r} radius`이고 면적은 `{r} area`입니다. radius &lt;- 5 area &lt;- round(pi * radius^2, digits=2) 원의 반지름은 5이고 면적은 78.54입니다. R Markdown에서도 reticulate 패키지를 사용하여 Python이 포함된 동적 문서를 만들 수 있다. 그러나 R을 거쳐서 Python에 접근하는 것이므로 Python만 사용한다면 Quarto를 사용하여 동적 문서를 만드는 것이 좋다.↩︎ "],["ch-R-dimension-reduction.html", "Chapter 14 R 차원 축소 14.1 차원 축소 (Dimension Reduction) 14.2 주성분 분석 (Principal Components Analysis)", " Chapter 14 R 차원 축소 이 장에서는 다음 내용을 다룬다. 데이터 분석에서 차원 축소의 개념 대표적인 차원 축소 방법인 주성분 분석을 R을 이용하여 수행하는 방법 14.1 차원 축소 (Dimension Reduction) 14.1.1 데이터의 차원 일반적으로 데이터는 다음의 5 명의 고객 데이터베이스처럼 행과 열로 구성된다. 행은 관측대상인 각각의 고객을, 열은 나이, 거래기간, 소득처럼 관측대상의 특징을 나타낸다. 나이 거래기간 소득 35 10 45 45 15 55 30 5 70 25 20 30 50 25 60 그리고 관측대상의 특징을 나타내는 각각의 열을 특성(features) 또는 변수(variables)라고 한다.16 우리는 데이터프레임의 열을 변수라고 부르도록 한다. 그러므로 앞의 고객 정보는 3 개의 변수로 구성된 데이터이다. 데이터에서 변수의 수를 차원이라고 한다. 앞의 고객 데이터베이스는 3 개의 변수가 있으므로 3차원 데이터라 할 수 있다. 변수의 수를 차원이라 부르는 이유는, 관측대상을 변수의 수만큼의 차원으로 이루어진 공간에서 한 점으로 표현할 수 있기 때문이다. 다음은 5 명의 고객을 3차원 공간의 한 점으로 표시한 예이다. 고차원 데이터 데이터 분석에서 변수의 수가 매우 큰 고차원 데이터를 다루어야 하는 경우가 자주 있다. 고차원 데이터가 생성되는 이유는 크게 두 가지이다. 원래 데이터에 측정치가 많은 경우: 종양의 유전자 분석 데이터에서 유전자의 수가 수만에서 수십만 개일 수 있으며, 생산 공정 데이터에서 측정센서의 수가 수백에서 수천 개일 수 있다. 원래 데이터에 변수가 많지 않더라도 새로운 변수가 추가되는 경우: 유도 변수(derived variables)의 추가: 데이터 분석을 할 때 이미 측정된 변수뿐 아니라, 분석의 정확성을 높이기 위하여 측정된 변수를 조합한 새로운 변수를 추가하는 경우가 많다. 예를 들어, 기업의 재무 데이터를 분석할 때, 기본적인 매출, 손익 등의 변수를 사용하여, 수익률, 유동성 비율, 전년 동월 매출 증가율 등의 변수들의 추가하여 기업의 수익성, 안전성, 성장성 등을 측정할 수 있다. 범주가 많은 범주형 변수의 변환: 데이터에는 수치형 변수뿐 아니라, 남, 녀의 성별처럼 범주를 나타내는 범주형 변수가 자주 포함된다. 일반적으로 회귀 모형 같은 데이터 분석 모형은 수학 함수로 모델링 되므로, 분석 모형에 입력되지 전에 범주형 변수는 수치형 변수로 변환되어야 한다. 범주형 변수는 범주의 수만큼의 지시변수 또는 가변수17로 변환된다. 그러므로 범주가 100 개인 하나의 범주형 변수가 있으면 100개의 새로운 변수가 추가된다. 다음은 한국프로야구(KBO) 2024 정규 시즌의 타자 기록에 대한 데이터이다.18 KBO 2024 타자 기록 내려받기 앞의 CSV 파일을 내려받은 후, 데이터를 읽어보자. library(tidyverse) batters &lt;- read_csv(&quot;kbo-2024.csv&quot;, na = c(&quot;-&quot;)) Rows: 100 Columns: 38 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (3): 선수명, 팀명, 포지션 dbl (35): 경기, 타석, 타수, 안타, 단타, 2루타, 3루타, 홈런, 득점, 타점, 볼넷, 고4, HBP, 삼진, 희플, 희타,... ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. batters # A tibble: 100 × 38 선수명 팀명 포지션 경기 타석 타수 안타 단타 `2루타` `3루타` 홈런 득점 &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 김도영 KIA 내야수 141 625 544 189 112 29 10 38 143 2 로하스 KT 외야수 144 670 572 188 116 39 1 32 108 3 구자욱 삼성 외야수 129 568 493 169 96 39 1 33 92 4 송성문 Hero 내야수 142 602 527 179 127 29 4 19 88 5 최정 SSG 내야수 129 550 468 136 70 27 2 37 93 6 에레… SSG 외야수 136 591 541 195 142 31 1 21 82 7 홍창기 LG 외야수 139 637 524 176 150 18 3 5 96 8 데이… NC 내야수 131 567 504 154 82 25 1 46 90 9 레이… 롯데 외야수 144 632 574 202 144 40 3 15 88 10 오스틴 LG 내야수 140 604 527 168 101 32 3 32 99 # ℹ 90 more rows # ℹ 26 more variables: 타점 &lt;dbl&gt;, 볼넷 &lt;dbl&gt;, 고4 &lt;dbl&gt;, HBP &lt;dbl&gt;, # 삼진 &lt;dbl&gt;, 희플 &lt;dbl&gt;, 희타 &lt;dbl&gt;, 병살 &lt;dbl&gt;, 도루 &lt;dbl&gt;, 도실 &lt;dbl&gt;, # 타율 &lt;dbl&gt;, BABIP &lt;dbl&gt;, `볼넷%` &lt;dbl&gt;, `삼진%` &lt;dbl&gt;, `볼/삼` &lt;dbl&gt;, # ISO &lt;dbl&gt;, `타수/홈런` &lt;dbl&gt;, OPS &lt;dbl&gt;, RC &lt;dbl&gt;, `RC/27` &lt;dbl&gt;, # wRC &lt;dbl&gt;, SPD &lt;dbl&gt;, wSB &lt;dbl&gt;, wOBA &lt;dbl&gt;, wRAA &lt;dbl&gt;, WAR &lt;dbl&gt; 이 데이터는 총 100 명의 타자에 대한 정보인데, 38 개의 열, 즉, 변수로 구성되어 있다. 선수명, 팀명, 포지션 변수: 문자열 데이터로 타자의 소속팀과 포지션 정보를 나타낸다. 경기부터 도실까지의 19 개 변수: 경기의 기록원들에 의해 직접 기록되는 타자의 기본통계 정보를 나타낸다. 타율부터 WAR까지의 16 개 변수: 타자의 기본통계를 사용하여 타자에 대한 유용한 정보를 만들어 내는 유도변수이다. 타자 기록에 대한 통계의 의미를 자세히 알고자 하는 독자는 KBReport의 타자 스탯 등을 참조하기 바란다. 다음은 batters 데이터를 쉽게 살펴볼 수 있도록 표 형식으로 제공한 것이다. 웹 브라우저에서 이 책을 보는 독자는 네비게이션 메뉴를 이용하여 100 명의 타자에 대한 38 개 열을 차례로 살펴볼 수 있을 것이다. 타자는 WAR라는 기록의 내림차순으로 정렬되어 있다. 한 가지 주의 사항으로, 열 이름을 보면 R의 변수 이름에 사용할 수 없는 %나 / 등의 특수문자가 사용된 것을 볼 수 있다. 이러한 열을 R에서 사용하려면 열 이름을 다음처럼 `으로 감싸주어야 한다. mean(batters$`삼진%`) # 삼진율의 평균 [1] 17.887 mean(batters$`타수/홈런`, na.rm=T) # 홈런 하나 당 경기수의 평균 [1] 56.91917 우리는 이 장에서 batters 데이터를 사용하여 고차원 데이터를 차원축소하는 방법을 살펴볼 것이다. 고차원 데이터의 문제점 데이터 분석에서 고차원 데이터를 다룰 때는 다음과 같은 어려움이 있다. 시각적인 탐색이 어렵다. 데이터를 탐색하는 가장 중요한 방법은 그래프 등을 이용하여 시각화하는 것이다. 변수들이 너무 많으면 변수들의 분포나 변수들의 관계를 모두 시각적으로 파악하기 어렵다. 아울러 관측대상의 특징을 시각적으로나 통계적인 방법으로 비교하기 어렵다. batters 데이터에 있는 100 명의 타자의 특징을 비교하고자 할 때 35 개나 되는 통계치가 있기 때문에 어떤 변수를 기준으로 유사점과 차이점을 비교해야 하는지 어렵다. 변수들이 서로 중복된 정보를 가지거나 상관성이 높아질 가능성이 커진다. batters 데이터에서 안타 열은 단타, 2루타, 3루타, 홈런의 합이기 때문에 이 5 개의 변수는 서로 독립적이지 않다. 이렇게 서로 독립적이지 않은 열들이 있으면 선형 회귀 등의 데이터 분석에서 문제가 발생한다. batters는 기본 통계에서 유도된 다양한 유도 변수들이 있다보니, 관점이 다른 유도 변수들과 기본 통계치 사이에 높은 중복성이 발생할 수 있다. 데이터가 충분하지 않은 경우에 이렇게 중복된 변수로 예측 모형 등을 만들면 모형의 안전성이 저하된다. 유사한 변수들의 효과가 중첩되어 나타나 특정 변수의 효과가 무엇인지 인지하기 어려워진다. 다음은 batters의 변수들 간의 Pearson 상관성을 시각화한 그림이다. 변수들은 상관계수의 유사성으로 계층적 군집화되어 나열되어 있다. 상관성은 [-1, 1] 사이의 값을 가지는데, 1에 가깝거나 -1에 가까우면 양과 음의 상관성이 매우 크다는 것을 의미한다. 그래프에서 보듯이 상관성이 큰 변수들이 꽤 있음을 확인할 수 있다. library(corrplot) select(batters, -(1:3)) %&gt;% # 수치형 열만 선택 cor(use=&quot;pairwise.complete.obs&quot;) %&gt;% # 상관계수 행렬 계산 corrplot(order=&quot;hclust&quot;) # 상관계수 행렬 시각화 변수가 많아지면 관심있는 이슈와 상관없는 변수들이 포함될 가능성이 커진다. 불필요한 변수가 많아지면 데이터에 있는 우연적 패턴을 모형이 과적합되는 현상이 발생하여 모형의 예측력이 낮아진다. 예를 들어, 어떤 종양에 대한 유전자 분석을 한다고 가정해 보자. 수많은 유전자 중에서 종양의 발생과 관련된 유전자는 한정된 수일 것이고, 대부분의 유전자는 종양 발생과 관련성이 없을 것이다. 그러나 관측치 수가 충분하지 않을 때, 모든 유전자를 변수에 포함하여 종양 발생을 예측하는 모형을 만들면 관련 없는 유전자 중 일부의 패턴과 종양 발생 패턴이 우연히 일치하거나 유사할 확률이 높아지게 된다. 이런 현상이 발생하면 모형은 우연한 패턴을 실제적 패턴으로 오인하여 학습될 수 있다. 변수의 처리 비용이 증가한다. 데이터 분석을 할 때 계산량이 늘어나 처리 시간이 길어진다. 향후에 새로운 데이터를 수집할 때에도 모든 변수를 수집해야 하므로 수집 비용이 증가한다. 차원의 저주 (The cusrse of dimension) 차원의 저주란 데이터의 차원이 증가하면 변수 공간에 관측치가 기하급수적으로 희박해지는 현상을 말한다. 10,000 명의 고객에 대한 마케팅 데이터베이스가 있다고 하자. 고객이 마케팅 캠페인에 반응할지를 예측하는 반응예측 모형을 만드는데, 예측하려는 고객과 유사한 과거 사례로 예측을 하려고 한다. 즉, A라는 고객이 캠페인에 반응할지를 예측하려면, A와 유사한 고객을 10명을 선택하여 이 10 명이 과거에 수행한 유사한 마케팅 캠페인에 반응할지를 조사한다. 만약 A와 유사한 고객 중에 마케팅에 반응한 고객이 더 많다면 A 고객은 반응할 것으로 예측하고, 그렇지 않으면 반응하지 않는다고 예측한다. 이러한 예측 방법을 k-최근접이웃(k-nearest neighbors) 방법이라고 하는데, 이 방법의 핵심은 예측하고자 하는 사례와 유사한 과거의 사례를 찾는 것이다. 그런데 데이터의 차원이 커지면 유사한 사례들이 희박해지는 현상이 발생한다. 고객데이터베이스에 고객의 특징을 나타내는 변수가 ‘소득’ 한 개인 경우를 고려해 보자. 소득을 10 분위로 나누어 동일 분위의 과거 고객의 반응률을 측정하여 예측을 할 수 있다. 그러한 하나의 고객 그룹에 평균적으로 1,000 명의 관측치가 존재하므로 반응률의 신뢰성이 매우 높게 된다. 이번에는 고객을 나타내는 변수가 ’소득’과 ’나이’로 두 개인 경우를 고려해 보자. 소득과 나이를 각각 10 분위로 나누면, 소득과 나이가 동일한 분위인 한 그룹에는 평균 100 개의 관측치가 존재한다. 다시 변수가 ‘소득’, ‘나이’, ’거래기간’인 세 개인 경우를 고려해 보자. 각각 10 분위로 나누면, 한 그룹에 평균적으로 오직 10 개 관측치만 존재한다. 그러므로 10 명의 과거 고객의 우연적 특성이 예측에 반영될 가능성이 매우 커진다. 예측 변수가 p 개이고, 각 변수를 10 개의 분위로 나눠진다면, 한 그룹에 평균적으로 \\(10,000 / 10^p\\) 개의 관측치가 존재한다. 따라서 데이터에서 변수의 수가 증가하면, 근처의 사례 수가 기하급수적으로 감소하여 신뢰성있는 예측이 어려워지는 차원의 저주가 발생하게 된다. 14.1.2 차원 축소 방법 차원 축소란 데이터에 포함된 정보의 손실을 최소화 하면서 데이터에서 변수의 수를 줄이는 작업이다. 차원 축소를 하는 방법은 다음과 같다. 투영법(projection techniques): 고차원의 데이터를 더 낮은 차원의 초평면으로 투영한다. 대표적인 방법이 이 장에서 살펴볼 주성분 분석이다. 다양체법(manifold techniques): 고차원의 데이터를 저차원의 다양체로 투영한다. 다양체란 지역적으로 보면 평면에 가까우나 전체적으로 보면 비선형적인 모양을 의미한다. 대표적인 방법으로 LLE(locally linear embedding)이나 MDS(multidimensional scaling) 등이 있다. 14.2 주성분 분석 (Principal Components Analysis) 주성분 분석은 다수의 수치형 변수를 소수의 주성분으로 차원을 축소하는 방법으로, 데이터의 변동을 가장 잘 설명하면서 서로 독립인 주성분을 찾는다. 주성분 분석은 PCA(principal components analysis)라는 영어 약자로 자주 지칭된다. 14.2.1 주성분 분석에 대한 직관적 이해 다음은 한국인 인체지수조사 (사이즈코리아)에 게재된 8차 인체치수조사(2020-23)에서 1-2차년도 직접측정 데이터에서 남자의 신체 치수 데이터 중 100 개를 임의 추출한 것이다. 이 예에서는 키, 몸무게, 가슴둘레, 허리둘레만 살펴보지만 원 데이터에는 관측대상에 대한 150 여개의 신체 측정치를 가지고 있다. 이 데이터를 사용하여 주성분 분석이 무엇인지에 대한 직관적 이해를 도모해 보자. 출처: 사이즈코리아 측정 항목 검색의 이미지 다음은 100 명의 성인 남자의 키와 몸무게의 산점도이다. 키와 몸무게의 두 측정항목이 있으므로 2차원 좌표공간에서 점으로 관측대상을 표현할 수 있다. 만약 관측대상의 이러한 2차원적 특징을 하나의 특징-즉, 변수로 요약한다면 어떻게 요약하면 좋을까? 앞의 산점도를 살펴보면, 같은 키인 사람도 몸무게의 차이가 꽤 나긴 하지만 전반적으로 키가 클수록 몸무게가 커지는 양의 상관성이 있다. 그러므로 우리는 키와 몸무게를 아우르는 ’체격’이라는 종합적 개념을 상정할 수 있을 것이다. 체격이 큰 사람은 키와 몸무게가 크고, 체격이 왜소한 사람은 키와 몸무게가 작다고 할 수 있다. 그렇다면 키와 몸무게처럼 측정될 수 있는 일차적 요인이 아닌, 체격 같은 이차적, 잠재적 요인을 수치화하려면 어떻게 해야 할까? 우리는 키와 몸무게라는 정보를 체격이라는 하나의 요인으로 종합했을 때, 원래의 2차원 정보가 최대한 손실되지 않는 것을 원할 것이다. 주성분 분석은 고차원 데이터-이 예에서는 2차원의 키와 몸무게-를 저차원의 주성분-이 예에서는 1차원의 체격-으로 요약할 때 기존의 데이터의 정보의 손실이 가장 작아지는 주성분을 찾는다. 다음은 키와 몸무게 데이터의 변동을 가장 잘 설명하는 축으로 주성분을 설정한 예이다. 각각의 점은 주성분 축에 직교투영(orthogonal projection) 되고, 해당 관측치는 주성분 축의 한 점으로 요약된다. 관측대상을 원래의 2차원으로 설명하는 것과 1차원인 주성분만으로 설명하는 것은 정보의 차이가 있으므로 오차가 발생한다. 오차는 원래의 관측점과 주성분에 투영된 점 사이에는 거리로 평가되며, 주성분 분석은 오차의 제곱의 합이 최소화되는 주성분 축을 찾는다. 다음은 주성분을 다른 방향의 축으로 설정했을 때의 오차를 보여준다. 주성분의 방향이 데이터의 변동과는 무관한 방향으로 설정되었기 때문에 주성분 축으로 직교투영된 후의 오차가 커지는 것을 볼 수 있다. 따라서 주성분 분석이란 원래의 데이터가 저차원의 주성분 공간으로 직교투영되었을 때 오차가가 최소화되는 주성분 방향을 찾는 것이라고 할 수 있다. 마찬가지로 관측대상의 몸무게와 허리둘레라는 2차원 데이터를 하나의 주성분으로 요약하는 것도 생각해 볼 수 있을 것이다. 몸무게와 허리둘레를 공통적으로 설명하는 비만이라는 잠재요인으로 주성분을 설명할 수도 있을 것이다. 14.2.2 3차원 이상의 데이터로의 주성분 분석의 확장 주성분 분석은 지금까지 본 2차원 데이터를 주성분으로 요약하는 것뿐 아니라, 3차원 이상의 데이터에도 적용할 수 있다. 다음은 100 명의 남자의 키, 몸무게, 허리둘레 데이터를 3차원 공간에 시각화한 것이다. threejs::scatterplot3js(as.matrix(men_sizes[c(&quot;키&quot;, &quot;몸무게&quot;, &quot;허리둘레&quot;)]), size=0.5) 웹 브라우저에서 이 책을 보는 독자는 여러 각도로 축을 변화시키며 그래프를 살펴보자. 키와 몸무게의 데이터와 마찬가지로, 키, 몸무게, 허리둘레도 공간 상에 무작위적으로 분포하는 것이 아니라 상관관계를 가지고 있기 때문에 특정한 평면 상에 데이터가 몰려서 분포해 있음을 확인할 수 있다. 따라서 이 데이터의 변동을 가장 잘 설명하는 2차원의 평면을 찾으면 정보의 손실을 최소화하면서 3차원 데이터를 2차원 데이터로 요약할 수 있을 것이다. 다음은 두 개의 주성분으로 요약한 결과이다. 다음은 100 명 남자의 몸무게, 허리둘레, 가슴둘레 데이터를 시각화한 결과이다. 이 세 변수는 상관성이 매우 높아 하나의 직선으로도 요약해도 정보의 손실이 적을 것으로 보인다. 이 경우에는 3차원 데이터를 하나의 주성분-즉, 1차원 데이터로도 요약하는 것을 시도해 볼 수 있을 것이다. threejs::scatterplot3js(as.matrix(men_sizes[c(&quot;가슴둘레&quot;, &quot;몸무게&quot;, &quot;허리둘레&quot;)]), size=0.5) 다음은 하나의 주성분으로 3차원 데이터를 요약한 결과이다. 3차원보다 차원이 더 큰 데이터도 요약할 수 있다. 150 개의 측정치로 이루어진 신체 측정 데이터를 중요한 5 개의 주성분으로 요약하여, 옷의 사이즈를 타나내는 기준으로 사용할 수도 있다. 35 개의 통계치로 이루어진 타자의 기록을 주요한 2 개의 주성분으로 요약하여 이차원 좌표에 타자를 시각화할 수도 있다. 20~30 개의 문항으로 이루어진 고객만족도에 대한 점수를 유형성, 신뢰성, 대응성, 확신성, 공감성 등의 주성분으로 변환하여 고객만족도의 개선 방안을 탐색할 수도 있다. 지금까지는 수치형 변수로만 이루어진 데이터를 차원축소하는 것을 보여주었다. 범주형 변수로 이루어진 데이터를 차원축소하는 대응분석(correspondance analysis)이라는 방법도 있다. 여기서는 수치형 변수로만 이루어진 데이터를 PCA를 이용하여 차원축소하는 방법만을 다룬다. 14.2.3 주성분 분석의 간략한 이론 수치형 변수 \\(X_1, X_2, \\dots, X_p\\)로 이루어진 \\(p\\)-차원의 데이터를 고려해 보자. 주성분 분석은 \\(Z_1, Z_2, \\dots, Z_q\\) 개의 \\(q\\) 개의 주성분을 찾는다. \\(q \\le p\\)로, 일반적으로 주성분의 차원 \\(q\\)는 \\(p\\)보다 매우 작다. 주성분 \\(Z_k\\)는 원 변수 \\(X_1, X_2, \\dots, X_p\\)의 다음과 같은 선형변환이다. \\[ Z_k = a_{1k} (X_1 - \\bar{X}_1) + a_{2k} (X_2 - \\bar{X}_2) + \\cdots + a_{pk} (X_p - \\bar{X}_p) \\quad k=1,2,\\dots,q. \\] \\(\\bar{X}_j\\)는 원 변수 \\(X_j\\)의 평균이다. \\(a_{jk}\\)는 \\(k\\)-번째 주성분 \\(Z_k\\)의 방향과 원 변수의 축 \\(X_j\\)의 일치 정도를 나타내는 계수로서, 주성분 분석은 주성분이 데이터의 변동을 최대한 설명하도록 주성분 방향, 즉, 계수를 계산해 낸다. 한 주성분의 계수의 제곱의 합은 1이다. 즉, \\[ a_{1k}^2 + a_{2k}^2+ \\cdots + a_{pk}^2 = 1, \\quad k=1, 2, \\dots, q. \\] 주성분 \\(Z_1, Z_2, \\dots, Z_q\\)가 원래 데이터의 변동성을 가장 잘 설명하면서, 주성분이 서로 독립이도록-즉, 정보가 중복되지 않도록-다음과 같은 절차로 주성분을 도출한다. 첫 번째 주성분 \\(Z_1\\)은 데이터의 변동성을 최대로 하는 방향으로 설정된다. 두 번째 주성분 \\(Z_2\\)는 \\(Z_1\\)과 직교하면서, \\(Z_1\\)이 설명하지 못한 데이터의 나머지 변동성을 최대로 설명하는 방향으로 설정된다. \\(k\\)-번째 주성분은 이전의 주성분 \\(Z_1, Z_2, \\dots, Z_{k-1}\\)과 직교하면서, 데이터의 나머지 변동성을 최대로 설명하는 방향으로 설정된다. 이러한 과정을 \\(q\\) 개의 주성분이 모두 찾아질 때까지 수행한다. 주성분 \\(Z_k\\)의 계수 \\(a_{jk}\\)를 주성분 \\(Z_k\\)의 변수 \\(X_j\\)에 대한 적재량 또는 로딩(loading)이라한다. 로딩 \\(a_{jk}\\)는 원래 변수 \\(X_j\\)가 한 단위 변할 때 주성분 \\(Z_k\\)의 변화량을 의미한다. \\(X_j\\)에 대한 로딩 \\(a_{jk}\\)의 절대값이 크다면, 주성분 \\(Z_k\\)와 \\(X_j\\) 상관성이 크다는 것을 의미한다. 다시 말하면, 주성분 \\(Z_k\\)의 방향이 \\(X_j\\)의 축 방향에 가깝다는 것을 의미한다. 주성분의 의미를 해석하려면 로딩 값을 확인하여야 한다. 어떤 원래 변수와 연관된 성분인지를 파악하여 주성분의 의미를 해석한다. 14.2.4 R로 주성분 분석하기 다음은 batters 데이터에서 타자의 삼진과 타점 수를 산점도로 시각화한 것이다. 삼진과 타점의 양의 상관성을 확인할 수 있다. ggplot(batters, aes(삼진, 타점)) + geom_point() 삼진과 타점으로만 되어 있는 타자의 데이터를 한 점으로 요약한다면 어떤 점으로 요약하여야 할까? 삼진과 타점의 평균점으로 요약하는 것이 좋은 방법일 것이다. 왜냐하면 평균점으로 요약하면 요약한 점과 데이터의 거리(오차)의 제곱의 합이 최소가 되기 때문이다. 다음은 타자의 삼진과 타점의 평균점을 계산한 결과이다. mean_point &lt;- batters %&gt;% summarise(삼진=mean(삼진), 타점=mean(타점)) mean_point # A tibble: 1 × 2 삼진 타점 &lt;dbl&gt; &lt;dbl&gt; 1 71.1 57.1 다음은 삼진과 타점 데이터와 함께 평균점을 시각화한 것이다. ggplot(batters, aes(삼진, 타점)) + geom_point() + geom_segment(aes(xend=mean_point$삼진, yend=mean_point$타점), alpha=0.1, linetype=2) + geom_point(data=mean_point, size=10, shape=&quot;*&quot;, color=&quot;red&quot;) 데이터를 평균점으로 요약하게 되면 정보의 손실이 발생한다. 파선은 실제 데이터와 평균점의 거리를 보여준다. 실제 데이터와 평균점의 거리의 평균은 분산으로 측정될 수 있다. variance_from_point &lt;- batters %&gt;% summarise(삼진=var(삼진), 타점=var(타점)) variance_from_point # A tibble: 1 × 2 삼진 타점 &lt;dbl&gt; &lt;dbl&gt; 1 1224. 949. total_variance &lt;- sum(variance_from_point) total_variance [1] 2173.298 결과에서 보듯이 평균점으로 데이터를 요약하는 것은 큰 분산을 보인다. 데이터를 하나의 주성분으로 요약하면 분산이 얼만큼 감소하는지 살펴보자. R에서 주성분 분석은 R의 기본 패키지인 stat 패키지의 prcomp() 함수를 사용한다. 다음처럼 차원을 축소할 원 데이터를 함수의 인수로 주면 주성분 분석을 한다. 주성분 분석의 결과는 여러 요소로 구성되어 있으므로 변수에 저장하자. result &lt;- select(batters, 삼진, 타점) %&gt;% prcomp() result Standard deviations (1, .., p=2): [1] 43.12096 17.71670 Rotation (n x k) = (2 x 2): PC1 PC2 삼진 -0.7675167 0.6410290 타점 -0.6410290 -0.7675167 주성분 분석 결과를 출력하면 다음 두 가지 정보를 제공한다. standard deviations: 주성분의 표준편차를 보여준다. 주성분의 표준편차는 주성분이 데이터의 변동성을 얼만큼 설명하는지를 보여준다. 이 예에서는 첫 번재 주성분이 두 번째 주성분보다 훨씬 더 많은 데이터의 변동을 설명하는 것을 확인할 수 있다. rotation: 주성분의 로딩을 보여준다. 열의 PC1, PC2는 첫 번째 주성분과 두 번째 주성분을 의미하며, 행은 원래 변수를 보여준다. 따라서 PC1 열의 값이 첫 번째 주성분의 로딩 값이다. 이 예에서는 첫 번째 주성분은 삼진의 로딩의 절대값이 타점보다 더 크므로 삼진의 좌표축에 더 가깝게 주성분의 방향이 설정되었다. 주성분이 데이터의 변동을 어느 정도나 설명하고 있는지는 주로 분산을 사용하여 계산한다. summary() 함수로 주성분 결과를 출력하면 각 주성분이 설명하는 데이터 분산의 비중을 출력한다. summary(result) Importance of components: PC1 PC2 Standard deviation 43.1210 17.7167 Proportion of Variance 0.8556 0.1444 Cumulative Proportion 0.8556 1.0000 Standard deviation은 주성분 분석의 결과를 출력했을 때와 같은 내용이다. Proportion of Variance는 각각의 주성분이 전체 데이터의 변동을 나타내는 분산을 설명하는 비율을 나타낸다. 이 예에서는 첫 번째 주성분(PC1)이 전체 데이터 변동의 85.6%를 설명하는 것을 볼 수 있다. Cumulative Proportion은 첫 번째부터 지금의 주성분까지 모두 합하여 전체 데이터 변동을 설명하는 누적 비율을 나타낸다. 이 에에서 보듯이 2차원 데이터는 두 개의 주성분을 사용하면 원래의 데이터와 마찬가지의 2차원 데이터가 되므로 전체 데이터의 100%를 설명한다. 이 수치는 데이터의 차원이 클 때 데이터의 변동을 충분히 설명하도록 주성분의 수를 결정할 때 유용하게 사용된다. 주성분 분석 결과는 리스트라는 형식의 데이터이다. 리스트는 여러 요소로 구성되어 있다. 리스트의 요소는 데이터프레임의 열을 지정하듯이 $ 연산자를 사용하여 지정할 수 있다. result$rotation # 주성분의 로딩 행렬 PC1 PC2 삼진 -0.7675167 0.6410290 타점 -0.6410290 -0.7675167 result$center # 원 데이터의 평균점 삼진 타점 71.07 57.14 result$x %&gt;% head() # 관측치의 주성분 좌표 (Z_1, Z_2). 6 개만 출력 PC1 PC2 [1,] -63.12319 -14.84816 [2,] -68.88386 -13.94556 [3,] -38.57124 -43.17133 [4,] -38.42758 -28.95938 [5,] -64.91120 -10.74901 [6,] -40.49433 -45.47388 다음은 주성분 결과를 사용하여 원래 데이터와 평균점, 그리고 첫 번째 주성분을 시각화한 것이다. \\[ \\begin{split} Z_1 &amp;= a_{11} (X_{삼진} - \\bar{X}_{삼진}) + a_{21} (X_{타점} - \\bar{X}_{타점})\\\\ &amp;= (-0.641) (X_{삼진} - 71.07) + (-0.768) (X_{타점} - 57.14) \\end{split} \\] ggplot(batters, aes(삼진, 타점)) + geom_point() + geom_abline(slope = result$rotation[2,1] / result$rotation[1,1], intercept = result$center[2] - result$center[1] * result$rotation[2,1] / result$rotation[1,1] , color =&quot;blue&quot;, linewidth=1) + geom_point(x = result$center[1], y = result$center[2], color=&quot;red&quot;, size=10, shape=&quot;*&quot;) + geom_vline(xintercept = result$center[1], linetype=2) + geom_hline(yintercept = result$center[2], linetype=2) 첫 번째 주성분 \\(Z_1\\)의 분산을 구해보자. var(result$x[,1]) [1] 1859.417 우리가 데이터를 첫 번째 주성분으로 표현하면 전체 데이터의 변동 중에 다음의 비율을 설명하게 된다. var(result$x[,1]) / total_variance [1] 0.8555737 이 수치는 summary(result)의 Proportion of Variance의 값과 같다. 만약 우리가 첫 번째 주성분을 타점의 축과 동일하게 설정하였다면 타점의 분산만큼의 설명력을 가질 것이다. 분산이 더 큰 삼진과 동일하게 첫 번재 주성분을 설정하였다면 삼진의 분산만큼을 설명할 수 있다. 이 두 방향보다는 PCA가 찾은 주성분 방향의 분산이 더 크다는 것을 확인할 수 있다. 왜냐하면 첫 번째 주성분이 삼진과 타점의 변동성을 종합적으로 아울르면 데이터의 변동성을 설명하기 때문이다. 두 번째 주성분 \\(Z_2\\)는 평균점을 관통하며 \\(Z_1\\)과 직교하는 성분으로서, \\(Z_1\\)이 설명하지 못하는 나머지 데이터의 변동성을 가장 잘 설명하는 방향으로 설정된다. 우리는 삼진과 타점이라는 2차원 데이터에 대하여 주성분 분석을 하였으므로, 두 개의 주성분을 사용하면 원래의 데이터와 차원이 같아져서 원래 데이터의 변동성의 100%를 설명하게 된다. 다음은 주성분 결과를 사용하여 원래 데이터, 평균점, 첫 번째 주성분과 함께, 두 번째 주성분을 시각화한 것이다. \\[ \\begin{split} Z_2 &amp;= a_{12} (X_{삼진} - \\bar{X}_{삼진}) + a_{22} (X_{타점} - \\bar{X}_{타점}) \\\\ &amp;= (-0.768) (X_{삼진} - 71.07) + (0.641) (X_{타점} - 57.14) \\end{split} \\] ggplot(batters, aes(삼진, 타점)) + geom_point() + geom_abline(slope = result$rotation[2,1] / result$rotation[1,1], intercept = result$center[2] - result$center[1] * result$rotation[2,1] / result$rotation[1,1] , color =&quot;blue&quot;, linewidth=1) + geom_abline(slope = result$rotation[2,2] / result$rotation[1,2], intercept = result$center[2] - result$center[1] * result$rotation[2,2] / result$rotation[1,2] , color =&quot;orange&quot;, linewidth=1) + geom_point(x = result$center[1], y = result$center[2], color=&quot;red&quot;, size=10, shape=&quot;*&quot;) + geom_vline(xintercept = result$center[1], linetype=2) + geom_hline(yintercept = result$center[2], linetype=2) 두 번째 주성분 \\(Z_1\\)의 분산을 구해보자. var(result$x[,2]) [1] 313.8814 우리가 데이터를 첫 번째와 두 번째 주성분으로 모두 사용하여 표현하면 전체 데이터의 변동을 모두 설명하게 된다. (var(result$x[,1]) + var(result$x[,2])) / total_variance [1] 1 이번에는 batters에서 기본 통계치를 사용하여 주성분 분석을 수행해 보자. basic_stat &lt;- select(batters, 경기:도실) result &lt;- prcomp(basic_stat) summary(result) Importance of components: PC1 PC2 PC3 PC4 PC5 PC6 Standard deviation 227.6116 28.88217 18.90857 14.39375 12.9006 11.28303 Proportion of Variance 0.9646 0.01553 0.00666 0.00386 0.0031 0.00237 Cumulative Proportion 0.9646 0.98010 0.98676 0.99061 0.9937 0.99608 PC7 PC8 PC9 PC10 PC11 PC12 PC13 Standard deviation 9.13151 5.99410 5.6753 5.04602 3.2435 2.84558 2.39047 Proportion of Variance 0.00155 0.00067 0.0006 0.00047 0.0002 0.00015 0.00011 Cumulative Proportion 0.99764 0.99830 0.9989 0.99938 0.9996 0.99972 0.99983 PC14 PC15 PC16 PC17 PC18 PC19 Standard deviation 1.91996 1.52211 1.24551 1.22170 0.1335 4.264e-15 Proportion of Variance 0.00007 0.00004 0.00003 0.00003 0.0000 0.000e+00 Cumulative Proportion 0.99990 0.99994 0.99997 1.00000 1.0000 1.000e+00 plot() 함수를 사용하면 PCA의 주성분이 데이터의 변동을 설명하는 비중을 그래프로 시각화해 준다. plot(result, type=&quot;l&quot;) summary() 결과를 보면 처음 세 개의 주성분(PC1, PC2, PC3)이 데이터 변동의 98.68%를 설명하고 있다. 이 세 주성분의 로딩을 확인해 보자. 로딩은 주성부 분석 결과의 rotation이라는 요소에 행렬 형태로 저장되어 있다. 데이터프레임으로 변환하는 것이 시각화 등에서 편리하므로 변환을 수행하자. 행렬의 행 이름으로 원래의 변수가 표현되어 있는데, rownames_to_column() 함수로 데이터프레임의 열로 변환을 한다. loading &lt;- data.frame(result$rotation[,1:3]) %&gt;% rownames_to_column(var=&quot;variable&quot;) loading variable PC1 PC2 PC3 1 경기 -0.125983774 -0.013544269 -0.33194698 2 타석 -0.704644447 0.003368865 -0.19191550 3 타수 -0.623752796 0.032913208 0.12185395 4 안타 -0.194600279 0.236792796 0.31571466 5 단타 -0.129040730 0.415025349 -0.02651686 6 2루타 -0.034525170 -0.010192594 0.12910632 7 3루타 -0.003342892 0.010972214 -0.01774042 8 홈런 -0.027691486 -0.179012173 0.23086562 9 득점 -0.107494823 0.029021018 -0.04003317 10 타점 -0.115939578 -0.250816175 0.68806952 11 볼넷 -0.065314415 -0.042563889 -0.21406433 12 고4 -0.004787537 -0.010953884 0.02603029 13 HBP -0.008193194 -0.016966541 -0.03257435 14 삼진 -0.110173671 -0.809192507 -0.21746615 15 희플 -0.008178617 -0.005321719 0.03185580 16 희타 -0.007265888 0.029155389 -0.06875657 17 병살 -0.010816449 0.006844707 0.04062143 18 도루 -0.017027679 0.124889703 -0.28989259 19 도실 -0.005289567 0.029150508 -0.07838461 첫 번째 주성분에서 로딩의 절대값이 가장 큰 변수 5 개를 확인해 보자. abs() 함수는 수치 벡터를 절대값으로 변환한다. slice_max(loading, abs(PC1), n=5) variable PC1 PC2 PC3 1 타석 -0.7046444 0.003368865 -0.19191550 2 타수 -0.6237528 0.032913208 0.12185395 3 안타 -0.1946003 0.236792796 0.31571466 4 단타 -0.1290407 0.415025349 -0.02651686 5 경기 -0.1259838 -0.013544269 -0.33194698 마찬가지로 두 번째, 세 번재 주성분에 대하여도 로딩의 절대값이 큰 순서대로 정렬해 볼 수 있다. slice_max(loading, abs(PC2), n=5) variable PC1 PC2 PC3 1 삼진 -0.11017367 -0.8091925 -0.21746615 2 단타 -0.12904073 0.4150253 -0.02651686 3 타점 -0.11593958 -0.2508162 0.68806952 4 안타 -0.19460028 0.2367928 0.31571466 5 홈런 -0.02769149 -0.1790122 0.23086562 slice_max(loading, abs(PC3), n=5) variable PC1 PC2 PC3 1 타점 -0.11593958 -0.25081617 0.6880695 2 경기 -0.12598377 -0.01354427 -0.3319470 3 안타 -0.19460028 0.23679280 0.3157147 4 도루 -0.01702768 0.12488970 -0.2898926 5 홈런 -0.02769149 -0.17901217 0.2308656 주성분의 로딩을 다음처럼 막대 그래프로 시각화할 수도 있다. pivot_longer(loading, cols=PC1:PC3, names_to=&quot;component&quot;, values_to=&quot;loading&quot;) %&gt;% ggplot() + geom_col(aes(x=variable, y=loading)) + coord_flip() + facet_wrap(~component) 첫 번째 주성분과 가장 상관성이 높은 변수는 타석, 타수, 안타 등이다. 두 번째 주성분과 가장 상관성이 높은 변수는 삼진, 단타, 타점 등이다. 세 번째 주성분과 가장 상관성이 높은 변수는 타점, 경기, 안타 등이다. 14.2.5 데이터 정규화 후 주성분 분석하기 다음은 basic_stat의 모든 변수의 표준편차를 구한 결과이다. summarise(basic_stat, across(everything(), sd)) %&gt;% pivot_longer(everything(), names_to=&quot;variable&quot;, values_to=&quot;sd&quot;) %&gt;% arrange(desc(sd)) # A tibble: 19 × 2 variable sd &lt;chr&gt; &lt;dbl&gt; 1 타석 161. 2 타수 142. 3 안타 45.6 4 삼진 35.0 5 단타 32.3 6 경기 31.3 7 타점 30.8 8 득점 26.8 9 볼넷 18.6 10 도루 11.3 11 홈런 9.99 12 2루타 9.38 13 HBP 4.97 14 병살 4.01 15 희타 3.89 16 도실 3.25 17 희플 2.88 18 3루타 1.97 19 고4 1.93 위의 결과에서 보듯이 변수들의 표준편차의 차이가 크며, 주성분은 표준편차가 큰 변수에 강한 영향을 받는 것을 볼 수 있다. 또한 변수의 표준편차는 변수의 측정 단위가 바뀌면 크게 변동하고, 변수의 표준편차는 다시 주성분 분석의 결과에 영향을 준다. 그러므로 변수의 스케일에 무관하게 주성분 분석 결과를 얻으려면 변수의 스케일이 일치하도록 조정할 필요가 있다. 변수의 스케일을 일치시키는 방법 중 하나가 정규화이다. 정규화는 변수의 평균을 0, 표준편차를 1로 일치시킨다. 정규화가 수행된 변수는 대부분의 값이 \\(\\pm 2, 3\\) 사이의 값을 가진다. 정규화를 하는 방법은 변수 \\(X_j\\)를 변수의 평균 \\(\\bar{X}_j\\)로 빼준 후, 변수의 표준편차 \\(sd(X_j)\\)로 나누는 것이다. \\[ \\frac{X_j - \\bar{X}_j}{sd(X_j)} \\] 데이터를 정규화한 후 주성분 분석을 하는 것은 매우 간단하다. precomp() 함수의 scale.=TRUE 인수를 설정하면 된다. result_scaled &lt;- prcomp(basic_stat, scale.=T) 정규화한 후에 주성분이 데이터의 변동성을 얼만큼 설명하고 있는지를 살펴보자. summary(result_scaled) Importance of components: PC1 PC2 PC3 PC4 PC5 PC6 PC7 Standard deviation 3.2495 1.5816 1.13714 0.95805 0.8954 0.79789 0.72791 Proportion of Variance 0.5558 0.1316 0.06806 0.04831 0.0422 0.03351 0.02789 Cumulative Proportion 0.5558 0.6874 0.75548 0.80378 0.8460 0.87949 0.90737 PC8 PC9 PC10 PC11 PC12 PC13 PC14 Standard deviation 0.64978 0.57198 0.54130 0.46935 0.4249 0.36803 0.30069 Proportion of Variance 0.02222 0.01722 0.01542 0.01159 0.0095 0.00713 0.00476 Cumulative Proportion 0.92960 0.94681 0.96224 0.97383 0.9833 0.99046 0.99522 PC15 PC16 PC17 PC18 PC19 Standard deviation 0.21916 0.15362 0.13853 0.001388 2.28e-16 Proportion of Variance 0.00253 0.00124 0.00101 0.000000 0.00e+00 Cumulative Proportion 0.99775 0.99899 1.00000 1.000000 1.00e+00 plot(result_scaled, type=&quot;l&quot;) 정규화한 후에는 데이터 변동의 90% 이상을 설명하려면 7 개의 주성분이 필요하다. 정규화 전에는 1 개의 주성분만 필요하였는데, 크게 증가하였다. 그 이유는, 정규화 전에는 분산이 큰 몇몇 변수의 영향력이 크기 때문에 주성분이 해당 변수를 중심으로 데이터를 설명하면 데이터의 분산을 대부분 설명할 수 있는데, 정규화하면 그럴 수 없기 때문이다. 다음은 처음 3 개의 주성분의 로딩을 보여준다. loading_scaled &lt;- data.frame(result_scaled$rotation[,1:3]) %&gt;% rownames_to_column(var=&quot;variable&quot;) loading_scaled %&gt;% slice_max(abs(PC1), n=5) variable PC1 PC2 PC3 1 타석 -0.3030404 -0.004139004 -0.022100118 2 타수 -0.3013726 0.005585644 -0.005310627 3 안타 -0.2967228 -0.006587956 0.015430763 4 득점 -0.2866023 -0.090381468 0.187380225 5 경기 -0.2800935 -0.045186016 -0.141002475 loading_scaled %&gt;% slice_max(abs(PC2), n=5) variable PC1 PC2 PC3 1 도루 -0.1134233 -0.5079514 0.18455243 2 도실 -0.1191901 -0.4837412 0.04390768 3 3루타 -0.1272447 -0.3518211 0.32741455 4 홈런 -0.2085227 0.3326075 0.22543196 5 희타 -0.1455764 -0.2850001 -0.52411397 loading_scaled %&gt;% slice_max(abs(PC3), n=5) variable PC1 PC2 PC3 1 희타 -0.1455764 -0.28500009 -0.5241140 2 병살 -0.1859317 0.19893070 -0.3731692 3 고4 -0.1912357 0.18442274 0.3377673 4 3루타 -0.1272447 -0.35182109 0.3274145 5 HBP -0.1193420 0.04119159 -0.3055655 pivot_longer(loading_scaled, cols=PC1:PC3, names_to=&quot;component&quot;, values_to=&quot;loading&quot;) %&gt;% ggplot() + geom_col(aes(x=variable, y=loading)) + coord_flip() + facet_wrap(~component) 첫 번째 주성분은 타자의 모든 기본 통계치와 음의 상관성을 가진다. 따라서 첫 번째 주성분의 크기가 크면 모든 통계치의 값이 전반적으로 낮은 타자이고, 주성분의 크기가 작으면 모든 통계치의 값이 전반적으로 높은 타자이다. 이러한 특성을 고려해 보건데, 첫 번째 주성분은 타자가 주전 선수인지 비주전 선수인지와 관련된 성분으로 보인다. 주전 선수는 이 주성분의 값이 낮을 것이고, 비주전 선수는 이 성분의 값이 높을 것이다. 두 번째 주성분은 홈런, 타점, 삼진, 병살, 고의사구, 2루타와 양의 상관성을, 희생타, 도실, 도루, 3루타와는 음의 상관성을 가진다. 이러한 특서을 보건데 발은 빠르지 않지만 힘이 있는 거포형 타자와 관련된 성분으로 보인다. 따라서 이 성분이 높으면 거포형 타자, 이 성분이 낮으면 발이 빠른 타자일 가능성이 있다. 세 번째 주성분은 홈런, 득점, 도루, 고의4구, 3루타 등과 양의 상관성을, 희생플라이, 희생타, 병살, HBP와는 음의 상관성을 보인다. 이 타자는 발도 빠르면서 홈런 등도 때려낼 수 있는 중거리형 타자로 보인다. 주로 팀의 테이블 세터로서 상위 타선에 배치될 만한 타자들이다. 14.2.6 주성분 분석의 시각화 biplot() 함수를 사용하면 주성분 분석의 결과를 시각화할 수 있다. 첫 번째 인수로 주성분 분석의 결과를 전달한다. choice 인수에 시각화할 두 개의 주성분을 지정한다. 디폴트 값을 1:2로 처음 두 개의 주성분으로 시각화를 수행한다. scale 인수는 시각화할 때 주성분의 표준편차의 크기를 어느 정도 고려하여 그릴지를 지정한다. 주성분 \\(Z_k\\)의 표준편차는 특이값 \\(\\lambda_k\\)에 의해 결정되는데, 관측치를 시각화할 때 주성분을 \\(\\lambda_k^{1-scale}\\) 스케일로 표현한다. scale=1이 디폴트 값으로 모든 주성분이 동일한 스케일로 그려진다. 0부터 1 사이로 지정되는데 scale=1이면 주성분의 표준편차에 비례하는 스케일로 관측치가 표현된다. scale이 0에서 1로 증가할수록 주성부 사이의 스케일이 비슷해진다. scale 인수는 변수의 로딩값을 시각화하는 스케일도 지정한다. 변수의 로딩값은 \\(\\lambda^{scale}\\) 스케일로 표현되며, scale=0이면 주성분이 동일한 스케일로, scale=1이면 주성분이 표준편차에 비례하는 스케일로 시각화 된다. 다음은 처음 두 주성분을 동일한 스케일로 하여 관측치를 시각화한 것이다. biplot(result_scaled, choice=1:2, scale=1) 번호로 표시된 것은 관측대상인 타자들이고, 빨간 선분은 원래 변수를 주성분으로 표현한 벡터이다. 변수 벡터에서 보듯이 PC1이 줄어드는 방향이 모든 변수가 증가하는 방향임을 보여준다. PC2가 증가하는 방향으로는 홈런, 병살, 타점, 병살이 증가하는 방향이고, PC2가 감소하는 방향이 도루, 도실, 3루타, 희생타가 증가하는 방향임을 확인할 수 있다. 그런데 타자들이 번호로만 표시되고 이름으로 표시되지 않아서 그래프를 해석하는데 한계가 있다. biplot()에서 관측대상이 이름으로 표시되게 하려면, prcomp()에 전달되는 데이터프레임의 행이름(row.names)이 설정되어 있어야 한다. row.names(basic_stat) # 현재의 행 이름 [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; [13] &quot;13&quot; &quot;14&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; &quot;21&quot; &quot;22&quot; &quot;23&quot; &quot;24&quot; [25] &quot;25&quot; &quot;26&quot; &quot;27&quot; &quot;28&quot; &quot;29&quot; &quot;30&quot; &quot;31&quot; &quot;32&quot; &quot;33&quot; &quot;34&quot; &quot;35&quot; &quot;36&quot; [37] &quot;37&quot; &quot;38&quot; &quot;39&quot; &quot;40&quot; &quot;41&quot; &quot;42&quot; &quot;43&quot; &quot;44&quot; &quot;45&quot; &quot;46&quot; &quot;47&quot; &quot;48&quot; [49] &quot;49&quot; &quot;50&quot; &quot;51&quot; &quot;52&quot; &quot;53&quot; &quot;54&quot; &quot;55&quot; &quot;56&quot; &quot;57&quot; &quot;58&quot; &quot;59&quot; &quot;60&quot; [61] &quot;61&quot; &quot;62&quot; &quot;63&quot; &quot;64&quot; &quot;65&quot; &quot;66&quot; &quot;67&quot; &quot;68&quot; &quot;69&quot; &quot;70&quot; &quot;71&quot; &quot;72&quot; [73] &quot;73&quot; &quot;74&quot; &quot;75&quot; &quot;76&quot; &quot;77&quot; &quot;78&quot; &quot;79&quot; &quot;80&quot; &quot;81&quot; &quot;82&quot; &quot;83&quot; &quot;84&quot; [85] &quot;85&quot; &quot;86&quot; &quot;87&quot; &quot;88&quot; &quot;89&quot; &quot;90&quot; &quot;91&quot; &quot;92&quot; &quot;93&quot; &quot;94&quot; &quot;95&quot; &quot;96&quot; [97] &quot;97&quot; &quot;98&quot; &quot;99&quot; &quot;100&quot; row.names(basic_stat) &lt;- batters$선수명 # 행 이름 부여 Warning: Setting row names on a tibble is deprecated. result_scaled &lt;- prcomp(basic_stat, scale.=T) # 주성분 분석 biplot(result_scaled, scale=1) # 주성분 시각화 다음으로 두 번째와 세 번째 주성분으로 타자들을 시각화해 보자. biplot(result_scaled, choice=2:3, scale=1) 다음처럼 PCA 결과를 데이터프레임으로 변환한 후, ggplot2를 이용하여 직접 시각화를 수행할 수도 있다. Z &lt;- data.frame(result_scaled$x) %&gt;% rownames_to_column(var=&quot;선수명&quot;) ggplot(Z, aes(PC1, PC2)) + geom_text(aes(label=선수명, color=batters$팀명)) + labs(color=&quot;팀명&quot;) + theme_bw() ggbiplot 등의 패키지를 사용하면 ggplot2 형식으로 여러 가지 형태의 biplot을 좀 더 쉽게 그릴 수 있다. ggbiplot이 설치되어 있지 않다면 먼저 설치하자. install.packages(&quot;ggbiplot&quot;) ggbiplot() 함수는 PCA 결과를 첫 번째 인수로 받아서 biplot을 ggplot2 형식으로 그려준다. choices 인수와 scale 인수는 biplot() 함수와 동일하다. library(ggbiplot) ggbiplot(result_scaled) varname.color는 변수 벡터의 색상을 지정한다. labels 인수를 설정하면 관측대상이 점 대신 lables에 설정된 값으로 그래프에 표시된다. ggbiplot(result_scaled, varname.color=&quot;magenta&quot;, labels=batters$선수명, labels.size=3) groups 인수를 설정하면 이 인수에 설정된 값에 따라 관측치가 다른 색상으로 표시된다. 다음은 선수의 소속팀에 따라 다른 색상으로 선수를 표현한다. ggbiplot(result_scaled, labels=batters$선수명, groups=batters$팀명) groups이 설정되어 있고 ellipse=TRUE이면 동일 그룹의 데이터의 분포를 타원으로 표시한다. ellipse.alpha는 타원의 채우기 색의 투명도를 조정하고, ellipse.linewidth는 타원의 선 굵기를 지정한다. ggbiplot(result_scaled, labels=batters$선수명, groups=batters$팀명, ellipse=T, ellipse.alpha=0.1, ellipse.linewidth=0.5) + theme_classic() 다음은 선수의 포지션으로 그룹화하여 색상을 달리 표현하고 분포를 나타내는 타원을 그린다. ggbiplot(result_scaled, labels=batters$선수명, groups=batters$포지션, ellipse=T, ellipse.alpha=0.1, ellipse.linewidth=0.5) + theme_bw() 데이터베이스에서는 필드(fields)라고도 한다.↩︎ 특정 범주이면 1, 아니면 0의 값을 가지는 변수이다.↩︎ 데이터 출처: 야구기록실 케이비리포트↩︎ "],["ch-R-clustering.html", "Chapter 15 R 군집 분석 15.1 군집 분석이란? 15.2 k-평균 군집화 15.3 병합 군집화", " Chapter 15 R 군집 분석 15.1 군집 분석이란? 군집 분석(cluster analysis or clustering)이란 데이터에서 자연스럽게 묶이는 그룹을 찾아내는 기술이다. 15.1.1 군집 분석의 필요성 데이터를 분석하다 보면 데이터에서 유의미한 패턴을 찾기 어려울 때가 있다. 이러한 경우가 발생하는 이유는 다음 두 가지일 수 있다. 데이터에 일반적인 패턴이 없는 경우: 불연속적인 소음에서 음악적 선율 패턴을 찾을 수 없는 것처럼 데이터가 랜덤하게 형성된 것이라면 그 안에서 유의미한 패턴을 찾을 수 없을 것이다. 데이터에 복잡한 패턴이 중첩되어 있는 경우: 제각기 다른 음악을 동시에 연주하는 수십 명의 악사가 있을 때 선율을 제대로 파악할 수 있을까? 다른 패턴들이 서로를 상쇄하여 숨겨져 있는 패턴을 찾기 어려울 것이다. 데이터에도 서로 다른 특성의 데이터가 중첩되어 있으면 유의미한 패턴을 찾아내기 어렵다. 데이터가 여러 패턴이 중첨되어 있다면 군집 분석으로 이러한 패턴을 나누어 볼 수 있다면 각각의 패턴이 뚜렷하게 인지될 수 있을 것이다. 데이터에 중첩된 패턴을 그룹화하여 각각의 패턴을 인식한 예로 Berry and Linoff (2004) 책에서 소개된 HR-다이어그램을 들 수 있다. HR 다이어그램은 헤르츠스프롱과 러셀이 별의 밝기와 온도 데이터를 도표로 표현한 것이다. 20세기 초 천문학자들은 별의 밝기와 온도 사이의 관계를 이해하려고 시도하였다. 그러나 별의 온도와 밝기의 일관된 관계가 보이지 않아 천문학의 미해결 문제였다. 별들의 밝기와 온도로 군집화하면 열과 빛을 생성하는 방법이 다른 별들을 설명할 수 있다. 태양의 크기와 유사한 별들은 크게 다음의 군집으로 설명할 수 있다. 주계열(main sequence): 80%의 별들이 속한 군집으로 수소를 헬륨으로 핵융합하여 에너지를 생성한다. 적색거성(red giants): 별의 중심에서 수소가 모두 소모된 후 별들은 질량에 따라 헬륨 융합이나 표면의 수소 융합으로 팽창하여 온도는 낮아지고 적색의 가시광성을 많이 방출하며 별의 밝기는 밝아진다. 백색왜성(white dwarfs): 헬륨 융합 과정 후의 적색 거성은 질량에 따라 더 이상의 핵 융합을 하지 못하고 외부 대기는 모두 우주공간에 방출되고 탄소와 산소로 이루어진 핵만 남는다. 백색왜성은 핵융합을 하지 못하므로 점차 식어가고 중력에 의해 붕괘되어 밀도가 높은 상태가 된다. 다음은 Berry and Linoff (2004) 책에서 별을 주계열, 적색거성, 백생왜성으로 군집화하는 예를 보여준다. 이렇게 군집을 하면 주계열에서 별의 온도와 밝기의 비례 패턴을 확인할 수 있다. 군집 분석을 하는 또 다른 이유는, 서로 특징이 다른 관측대상을 군집화하여 군집 별로 차별화된 대응을 하기 위함이다. 대표적인 예가 고객 세그멘테이션(customer segmentation)이라고 할 수 있다. 일반적으로 하나의 마케팅 전략이 어떤 그룹의 고객에게는 잘 작동하지만, 다른 그룹에는 잘 작동하지 않는다. 왜냐하면 고객은 하나로 뭉뚱그려질 수 있는 단일한 특성의 집단이 아나다. 그렇기 때문에 마케팅에서는 고객의 인구통계학적 특성, 거래 패턴 등을 고려하여 자연스럽게 뭉쳐지는 군집으로 나누어 군집의 특성에 맞추어 차별화된 마케팅 전략을 개발하려고 노력한다. 다음은 Linoff and Berry (2011) 책에 나오는 군집 분석이 차별화된 대응을 위해 사용된 예이다. 1990년대 미국 육군에서 여군의 군복과 관련된 디자인 문제에 직면했다. 다양한 치수의 군복 재고를 줄이면서, 각 군인에게 잘 맞는 군복 제공 방법을 찾고자 하였다. 사람의 신체 크기는 팔, 어깨, 가슴, 목 길이 등이 동일한 비율로 증가하고 감소하기 보다는 사람마다 다른 비율을 가진다. 따라서 일률적인 비율로 크기가 다른 군복을 만들기 보다는 여군의 다양한 체형에 맞는 군복 치수를 개발하고자 하였다. 이를 위해 3천여 명의 여군에게서 100가지 수치를 측정하여 군집 분석을 수행하고, 각 대표 군집에 맞는 군복 치수를 개발하여 여군의 군복 만족도를 높였다. 군집 분석은 데이터의 특이치를 발견하기 위해서도 사용된다. 특이치가 있는 데이터를 군집화 하면, 다음 그림처럼 소수의 큰 중심 군집(주류)과 바깥에 작은 군집(특이치)이 나타난다. 그러므로 군집화를 하면 데이터에 있는 특이치를 발견할 수 있다. 특이치를 찾기 위한 군집화는 다음과 같은 활용 영역이 있다. 신용카드 거래 중 사기성 거래의 발견 제조 라인 초기 제품의 제조 불량의 인식 독거 노인의 활동에서 이상 징후 발견 15.1.2 군집 분석의 유형 군집 분석은 확률 모형을 기반으로 하는 기법과 거리/유사성을 기반으로 하는 기법으로 나눠볼 수 있다. 확률 모형 기반 군집화 기법 군집에 대한 확률 모형을 가정하고, 데이터의 사례들이 이 확률 모형에 따라 발생한다고 가정한다. 대표적인 기법으로 가우시안 혼합 모형(Gaussian Mixture Models)이 있다. 데이터를 가장 잘 설명하는 군집 모형의 모수를 추정한다. 군집 모형의 모수를 추정하는 방법으로는 기대값 최대화 알고리즘(EM algorithm) 등이 사용된다. 거리/유사성 기반 군집화 기법: 데이터가 발생하는 확률 모형을 가정하지 않는다. 데이터의 사례들 사이의 거리/유사성을 계산하는 방법을 정의한다. 거리가 가까운, 유사한 사례를 서로 군집화 한다. 주요 기법으로 K-평균 군집 방법, 계층적 군집 방법 등이 있다. 이 장에서는 거리/유사성 기반 군집화 기법만을 다루도록 한다. 15.2 k-평균 군집화 k-평균 군집화(k-means clustering)는 가장 흔히 사용되는 군집 분석 알고리즘이다. 데이터 사례의 유사성에 기초하여 고정된 수(k)의 군집을 발견해 낸다. 군집의 중심점을 평균을 사용하여 계산하기 때문에 k-평균이라는 이름이 붙여졌다. 평균 대신 중위수로 군집의 중심을 계산하는 k-중위수(k-median) 기법 등도 있다. 15.2.1 알고리즘 k-평균 군집화 기법은 알고리즘이 매우 단순하다. 1단계: 변수 공간에서 임의의 k 개의 점을 시드(seeds)로 선택한다. 시드는 임의의 점일 수도 있고 사례 중에 하나가 선택될 수도 있다. 무작위적으로 선택할 수도 있고 변수 공간에서 최대한 흩어지도록 시드를 선택할 수도 있다. 2단계: 데이터의 각 사례를 가장 가까운 시드에 배정한다. 이 단계를 위해서는 거리 측정 방법이 정의되어야 한다. 동일한 시드에 배정된 사례들이 하나의 군집을 이룬다. 3단계: 군집의 중심점을 계산하여 군집의 시드로 선택한다. 중심점은 군집에 포함된 사례의 평균으로 구한다. 2단계로 돌아가 더 이상 군집의 변화가 없을 때까지 2, 3 단계를 반복한다. k-군집화 기법이 작동하는 방식을 이해하기 위하여 다음 데이터를 고려해 보자. X Y label 5.53 3.86 1 6.59 3.57 2 5.47 5.01 3 3.85 4.39 4 6.31 4.51 5 5.46 3.96 6 7.36 3.31 7 7.43 6.07 8 5.99 7.60 9 8.44 8.22 10 6.37 6.06 11 7.46 6.42 12 8.09 8.99 13 6.04 8.12 14 10.14 5.93 15 8.16 5.01 16 7.42 5.59 17 9.50 5.24 18 9.20 3.05 19 8.81 3.62 20 10.13 5.55 21 다음은 위의 데이터를 산점도로 표현한 것이다. 위와 같은 데이터를 \\(k=3\\)으로 군집화를 한다고 하자. 알고리즘의 시작은 변수 공간에서 임의의 3 개의 시드를 선택하는 것에서 시작한다. 다음 그래프에서 X로 표시된 지점이 시드로 선택되었다고 하자. 이 예에서는 데이터의 한 점을 초기 시드로 선택하였다. 시드가 결정되면 시드와 21 개의 데이터 사이의 거리를 계산한다. seed1 seed2 seed3 1 1.91 4.29 4.20 2 0.81 4.58 3.35 3 2.54 3.16 4.03 4 3.67 4.33 5.71 5 1.60 3.61 3.26 6 2.01 4.20 4.23 7 0.00 4.99 2.88 8 2.76 2.47 2.23 9 4.51 0.52 4.23 10 5.03 2.40 3.17 11 2.92 2.09 3.23 12 3.11 2.22 2.35 13 5.73 2.23 4.01 14 4.99 0.00 4.50 15 3.82 4.65 0.95 16 1.88 3.76 1.35 17 2.28 2.88 2.11 18 2.88 4.50 0.00 19 1.86 5.98 2.21 20 1.48 5.28 1.75 21 3.57 4.83 0.71 그리고는 가장 가까운 시드로 사례들이 군집화 된다. 그런데 군집 1의 맨 오른편의 두 점은 군집 1의 다른 사례들다는 군집 3의 사례들과 더 가깝다. 우연히 군집 1의 시드가 오른편으로 치우쳐져 있기 때문에 군집 1에 배속되었을 뿐이다. k-평균에서는 군집의 평균점을 사용하여 군집의 시드를 갱신한다. 그리고는 갱신된 시드를 이용하여 사례들과의 거리를 다시 계산하여 사례를 다시 군집화 한다. 다음 그래프에서 X로 표현된 점은 이전의 군집 결과로 계산한 군집의 평균점이고, 사례들은 이 평균점을 시드로 하여 다시 군집화된 것이다. 앞서 군집 1로 배정되었던 맨 오른편의 두점이 새로운 군집에서는 군집 3으로 이동한 것을 볼 수 있다. 다시 현재의 군집으로 군집의 평균점을 구하고, 이 평균점을 시드로 하여 다시 군집화를 한 결과이다. 오른쪽 하단의 두 점이 군집 3에 배정되었으므로 군집 3의 평균점이 아래로 이동하여 군집 2와 3의 경계에 있던 점이 군집 2에서 3으로 이동한 것을 볼 수 있다. 한번 더 현재의 군집의 평균점으로 시드를 갱신한 후 군집화를 하면 더 이상 군집이 바뀌는 점이 없다. 그러므로 군집의 평균점도 더 이상 바뀌지 않고 군집화 결과도 더 이상 변화하지 않는다. 이 지점에서 k-평균 군집화 결과는 종료된다. 이 문제에서는 데이터가 매우 적어서 위치가 겹치는 데이터들이 많지 않기 때문에 3 번의 반복만으로 군집 결과가 수렴되었다. 그러나 대규모의 데이터에서는 군집화의 결과가 수렴되기까지는 매우 긴 시간이 걸린다. 따라서 현실에서는 군집화 결과가 수렴될 때가지 반복을 수렴하기 보다는 일정 횟수까지만 군집화를 반복한 후 알고리즘을 종료한다. 15.2.2 k-평균 군집화의 장점 및 단점 k-평균 군집화는 다음과 같은 장점이 있다. 다른 군집화 방법에 비해 이해하기 쉽고 계산 시간이 비교적 짧다. 병렬처리가 용이하여 대규모 데이터의 군집화에 적합하다. 그러나 다음과 같은 단점이 있다. 군집의 수 k에 따라 매우 상이한 군집 결과가 발생한다. 그러므로 군집의 수를 적절히 결정하는 방법이 필요하다. 초기 시드의 결정에 따라 비효율적인 군집이 발생할 가능성이 있다. 이러한 문제를 해결하기 위하여 k-평균 군집화에서는 초기 시드를 여러 번 바꾸어 가면 군집화를 수행한 후 가장 좋은 결과를 선택한다. 데이터의 분포가 군집의 중심점 주위로 균일하지 않으면 비효율적이고 해석이 어려운 군집이 발생할 수 있다. k-평균 군집화는 거리를 사용하여 군집화를 수행하므로 데이터가 군집 중심에서 원형으로 분포되었을 때 군집화가 잘 수행된다. 만약 데이터가 군집 중심에서 비스듬한 길쭉한 타원형으로 분포되어 있으면 데이터가 군집을 중심으로 분포하지 않을 수도 있다. 이러한 경우에는 가우시안 혼합 분포를 이용하는 확률 모형 기반의 군집화를 수행하는 것이 좋다. 15.2.3 R을 이용한 k-평균 군집 분석 14.1 절에서 소개한 한국프로야구(KBO) 2024 정규 시즌의 타자 기록을 사용하여 k-평균 군집화를 수행해 보자. batters &lt;- read_csv(&quot;kbo-2024.csv&quot;, na=&quot;-&quot;) Rows: 100 Columns: 38 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (3): 선수명, 팀명, 포지션 dbl (35): 경기, 타석, 타수, 안타, 단타, 2루타, 3루타, 홈런, 득점, 타점, 볼넷, 고4, HBP, 삼진, 희플, 희타,... ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. 변수 정규화 14.1 절에서 살펴본 바와 같이 타자들의 기록은 스케일이 서로 다르다. 다음은 타자들의 기본통계 열들의 표준편차를 보여준다. select(batters, 경기:도실) %&gt;% summarise(across(everything(), sd)) %&gt;% pivot_longer(everything(), names_to=&quot;variable&quot;, values_to=&quot;sd&quot;) %&gt;% mutate(variable = reorder(variable, sd)) %&gt;% ggplot() + geom_col(aes(x=variable, y=sd)) + coord_flip() 스케일이 다른 변수로된 사례들의 거리를 계산하며, 스케일이 큰 변수가 다른 변수들을 압도하여 특정 변수의 차이만 거리에 과대하게 반영된다. 그러므로 사례들 사이의 거리를 계산하기 전에 변수의 스케일을 통일해 준다. 변수의 스케일을 통일하는 방법으로는 모든 변수의 범위를 [0, 1] 사이로 만드는 표준화나, 모든 변수의 표준편차를 1로 만드는 정규화가 자주 사용된다. 우리는 정규화를 사용하여 변수들의 스케일을 통일할 것이다. 정규화릏 하는 방법은 변수 \\(X_j\\)를 변수의 평균 \\(\\bar{X}_j\\)로 빼준 후, 변수의 표준편차 \\(sd(X_j)\\)로 나누는 것이다. \\[ \\frac{X_j - \\bar{X}_j}{sd(X_j)} \\] R에서 정규화를 하는 방법은 scale() 함수를 사용하는 것이다. 다음은 batters 데이터의 수치변수들을 scale() 함수로 정규화하는 예를 보여준다. batters_scaled &lt;- select(batters, 경기:도실) %&gt;% scale() scale() 함수가 적용되면 행렬이라는 형식의 데이터로 반환한다. 다음은 행렬의 모든 열에서 표준편차를 구하는 방법을 보여준다. 모든 변수의 표준편차가 1이 되었다. apply(batters_scaled, 2, sd) 경기 타석 타수 안타 단타 2루타 3루타 홈런 득점 타점 볼넷 고4 HBP 1 1 1 1 1 1 1 1 1 1 1 1 1 삼진 희플 희타 병살 도루 도실 1 1 1 1 1 1 거리 계산 함수 수치형 변수로 이루어진 데이터에서 사례들 사이의 거리를 계산하는 방법은 여러 가지가 있다. 가장 대표적인 방법이 유클리드 거리와 맨해튼 거리이다. 유클리드 거리는 직교좌표계의 두 점 사이의 거리를 계산하는 방식으로 \\(i\\)-번째 점 \\((x_{i1}, x_{i2}, \\dots, x_{im})\\)와 \\(j\\)-번째 점 \\((x_{j1}, x_{j2}, \\dots, x_{jm})\\) 사이의 거리 \\(d_{ij}\\)는 다음처럼 계산된다. \\[ d_{ij} = \\sqrt{(x_{i1} - x_{j1})^2 + (x_{i2} - x_{j2})^2 + \\dots + (x_{im} - x_{jm})^2} \\] 반면 맨해튼 거리는 다음과 같이 계산된다. \\[ d_{ij} = |x_{i1} - x_{j1}| + |x_{i2} - x_{j2}| + \\dots + |x_{im} - x_{jm}| \\] 두 거리 계산 방식의 차이는 다음과 같이 시각화할 수 있다. 유클리드 거리는 두 점 사이의 물리적인 최단 경로의 거리가 되고, 맨해튼 거리는 격자 모양의 길을 따라 두 점 사이를 이동할 때 지나가야 할 거리가 된다. 비유적으로 맨해튼 거리는 맨해튼의 빌딩숲에서 두 지점 사이를 이동하기 위해서 걸어가야할 거리라 할 수 있다. 어떤 경로를 택하든 일부러 돌아가지 않는 한 모든 경로의 거리가 7로 동일하다. 유클리드 거리와 맨해튼 거리의 특성은 다음과 같다. 유클리드 거리는 변수의 차이의 제곱의 합으로 거리를 계산하므로 나머지 변수가 매우 가깝더라도 한두 변수의 차이가 크면 거리가 커진다. 반면 맨해튼 거리는 변수의 차이의 합으로 거리를 계산하므로 한두 변수에서 차이가 나더라도 대다수의 변수에서 차이가 적으면 거리가 그리 멀지 않다. 그러므로 유클리드 거리는 변수들의 거리가 균등한 경우에 더 가깝게 계산되는 반면, 맨해튼 거리는 변수의 거리 차이의 합만 동일하면 변수들 사이의 거리가 불균등하더라도 동일한 거리가 된다. 유클리드와 맨해튼 거리 이외에도 다음 거리 함수가 수치형 데이터의 거리 계산에 사용된다. 최대좌표거리: 두 점 \\(i\\)와 \\(j\\)에서 가장 차이가 큰 변수의 차이가 두 점의 거리가 된다. \\[ d_{ij} = \\max_{1 \\le k \\le m} | x_{ik} - x_{jk} | \\] 민코프스키 거리: 유클리드, 맨해튼, 최대좌표거리 등을 일반화한 것으로 두 점 사이의 p-norm이라는 다음 식으로 거리를 계산한다. \\[ d_{ij} = \\sqrt[p]{(x_{i1} - x_{j1})^p + (x_{i2} - x_{j2})^p + \\dots + (x_{im} - x_{jm})^p} \\] \\(p=1\\)이면 맨해튼 거리가 되고, \\(p=2\\)이면 유클리드 거리, \\(p=\\infty\\)이면 최대좌표거리가 된다. 따라서 \\(p\\)가 커질수록 거리에서 가장 차이가 큰 변수의 영향력이 커지고, \\(p\\)가 1에 가까워질수록 영향력이 균등해 진다. 마할로노비스 거리: 변수 사이의 상관성을 고려하여 나머지 변수와 상관성이 적은 변수의 차이는 크게, 나머지 변수와 상관성이 높아서 중복된 정보인 변수의 차이는 작게 반영하여 거리를 계산한다. \\(\\mathbf{S}\\)를 변수들의 공분산 행렬이라고 하고 \\(\\mathbf{x}_i\\)와 \\(\\mathbf{x}_j\\)를 변수 공간의 두 점이라고 한다면 두 점의 거리는 다음처럼 계산된다. \\[ d_{ij} = \\sqrt{(\\mathbf{x}_i - \\mathbf{x}_j)^\\top \\mathbf{S}^{-1}(\\mathbf{x}_i - \\mathbf{x}_j)} \\] 상관계수로 유사도 측정: 관측치의 절대적인 크기는 무시하고 두 관측치가 평균을 중심으로 유사한 방향에 있는지를 Pearson 상관계수로 측정한다. 1에 가까워질수록 두 관측치의 유사도는 커지고, -1일 수록 두 관측치의 유사도는 작아진다. \\(i\\)-번째 점 \\((x_{i1}, x_{i2}, \\dots, x_{im})\\)와 \\(j\\)-번째 점 \\((x_{j1}, x_{j2}, \\dots, x_{jm})\\) 사이의 유사도 \\(r_{ij}\\)는 다음과 같이 계산된다. \\[ r_{ij} = \\frac{\\sum_{k=1}^{m}(x_{ik} - \\bar{x}_k)(x_{jk} - \\bar{x}_k)} {\\sqrt{\\sum_{k=1}^{m}(x_{ik} - \\bar{x}_k)^2 \\sum_{k=1}^{m}(x_{jk} - \\bar{x}_k)^2}} \\] 단, \\(\\bar{x}_{k}\\)는 \\(k\\)-번째 변수의 평균이다. 유사도가 커지면 가까운 점이므로 거리로 나타낼 때에는 \\(d_{ij} = 1 - r_{ij}\\)로 정의한다. 코사인 유사도: 관측치를 벡터로 표현하여 두 벡터 사이각의 코사인 값으로 유사도 \\(r_{ij}\\)를 계산한다. 두 벡터가 원점에서 동일한 방향이면 유사도가 커져 1에 가까워지고 반대 방향이면 유사성이 낮아져 -1에 가까워진다. \\[ r_{ij} = \\frac{\\sum_{k=1}^{m}x_{ik} x_{jk} } {\\sqrt{\\sum_{k=1}^{m} x_{ik}^2 \\sum_{k=1}^{m} x_{jk}^2}} \\] 범주형 변수로만 이루어진 데이터는 매칭 계수나 자카드 계수 등이 주로 사용된다. 그리고 범주형 변수와 수치형 변수가 섞여 있는 데이터는 범주형 변수의 범주가 같으면 거리 0, 다르면 1로 하여 수치형 변수와 동일한 방식으로 유클리드나 맨해튼 거리를 계산하거나, Gower 유사도 등을 사용한다. 범주형 변수가 포함된 데이터에서 거리 계산은 여기서는 다루지 않는다. dist() 함수 R에서 거리를 계산할 때는 dist() 함수를 사용한다. 첫 번째 인수로 거리를 계산할 데이터를 행렬 또는 데이터프레임 형식으로 전달한다. method 인수는 거리를 계산하는 방법을 지정한다. \"euclidean\": 유클리드 거리. 디폴트 값이다. \"manhattan\": 맨해튼 거리 \"maximum\": 최대 좌표 거리 \"minkowski\": 민코프스키 거리 이 외에도 \"canberra\" 거리와 \"binary\" 거리가 있다. \"binary\"는 자카드 거리를 계산한다. p: 민코프스키 거리를 계산할 때 사용할 승수를 지정한다. 다음은 정규화된 타자 데이터에서 처음 6 타자 사이의 유클리드 거리를 계산하는 예이다. d &lt;- dist(batters_scaled[1:6, ]) d 1 2 3 4 5 2 6.414634 3 6.209822 4.353452 4 5.638388 5.424104 3.730241 5 7.197932 6.098121 3.593338 5.036222 6 7.224850 5.722043 3.374603 4.158341 4.324725 \\(i\\)-번째 사례에서 \\(j\\)-번째 사례까지의 거리나, \\(j\\)-번째 사례에서 \\(i\\)-번째 사례까지의 거리는 동일하므로 두 쌍의 사례들 사이의 거리 행렬에서 아래 삼각형 영역만 출력을 한다. 거리 계산 결과를 행렬 형태로 얻고자 하면 as_matrix() 함수로 행렬 형식으로 변환한다. 대각선은 자기 자신과의 거리이므로 0, 대각선을 사이에 두고 마주보는 요소는 모두 동일한 값이다. as.matrix(d) 1 2 3 4 5 6 1 0.000000 6.414634 6.209822 5.638388 7.197932 7.224850 2 6.414634 0.000000 4.353452 5.424104 6.098121 5.722043 3 6.209822 4.353452 0.000000 3.730241 3.593338 3.374603 4 5.638388 5.424104 3.730241 0.000000 5.036222 4.158341 5 7.197932 6.098121 3.593338 5.036222 0.000000 4.324725 6 7.224850 5.722043 3.374603 4.158341 4.324725 0.000000 다음은 동일한 데이터에 대해 맨해튼 거리를 계산한 결과이다. dist(batters_scaled[1:6, ], method=&quot;manhattan&quot;) 1 2 3 4 5 2 17.28656 3 18.21640 14.88897 4 17.04361 18.26457 12.92524 5 21.17416 18.67688 12.17618 15.69214 6 21.83729 18.29603 11.29198 13.20593 15.60397 사례들 사이의 거리 계산 결과를 이용하여 군집은 가까운 사례들 사이의 군집화를 수행한다. 병합 군집화에서는 dist() 함수로 모든 사례에 대하여 거리 계산을 한 후, 그 결과를 입력받아서 군집화를 수행한다. 반면 k-평균 군집화에서는 시드의 위치가 계속 변하기 때문에 알고리즘 자체에서 거리 계산을 수행한다. kmeans()를 이용한 군집화 R의 기본 stat 패키지의 kmeans()는 k-평균 군집화를 수행한다. 첫 번째 인수로 데이터가 수치 행렬 또는 수치로만 이루어진 데이터프레임 형식으로 지정된다. centers 인수에 군집의 수 \\(k\\)를 설정하거나, 초기 시드로 사용할 \\(k\\) 개의 관측점을 지정한다. 군집의 수가 지정되면 데이터에서 \\(k\\) 개의 행이 시드로 무작위 추출된다. iter.max 인수는 최대 반복 횟수를 지정한다. 기본값은 10이다. nstart 인수는 초기 시드를 달리하여 k-평균 군집화를 몇 번 시도할지를 지정한다. 기본값은 1로 한 번만 수행된다. algorithm 인수로 조금씩 구현 방법이 다른 알고리즘을 선택할 수 있다. 우리는 기본값으로 설정된 Hartigan and Wong이 개발한 알고리즘을 사용할 것이다. 다음 예는 정규화된 타자 데이터를 \\(k=3\\) 개의 군집을 생성한다. result &lt;- kmeans(batters_scaled, 3) result K-means clustering with 3 clusters of sizes 38, 32, 30 Cluster means: 경기 타석 타수 안타 단타 2루타 3루타 1 0.2156607 0.1818939 0.1817526 0.1044683 0.1177994 0.1082262 -0.1940637 2 0.8407483 0.9873874 0.9850705 1.0250550 0.9495607 0.8631870 0.6675124 3 -1.1699685 -1.2836122 -1.2809619 -1.2257185 -1.1620774 -1.0578194 -0.4661991 홈런 득점 타점 볼넷 고4 HBP 삼진 1 0.0322832 -0.03534549 0.1500764 0.0994473 -0.1978942 0.3047498 0.1739876 2 0.6649128 1.12095542 0.8201901 0.8210738 0.7829001 0.2173607 0.6472846 3 -0.7501324 -1.15091484 -1.0649662 -1.0017787 -0.5844275 -0.6178679 -0.9108211 희플 희타 병살 도루 도실 1 0.05035605 -0.01124327 0.3708959 -0.3162716 -0.2251868 2 0.69634113 0.54499385 0.3487327 0.7821202 0.7323434 3 -0.80654820 -0.56708530 -0.8417830 -0.4336508 -0.4959297 Clustering vector: [1] 2 2 2 2 2 2 2 2 2 2 2 2 1 2 1 2 1 2 2 1 1 2 1 1 1 1 1 1 2 2 2 1 1 2 1 2 3 [38] 2 2 2 1 2 2 2 1 1 2 1 1 1 1 1 1 3 1 1 3 1 1 1 3 1 1 1 1 2 1 3 1 3 3 3 3 3 [75] 1 1 3 3 3 3 1 1 3 3 2 3 2 3 3 3 3 3 3 3 3 3 3 3 3 3 Within cluster sum of squares by cluster: [1] 302.2123 498.8580 175.0282 (between_SS / total_SS = 48.1 %) Available components: [1] &quot;cluster&quot; &quot;centers&quot; &quot;totss&quot; &quot;withinss&quot; &quot;tot.withinss&quot; [6] &quot;betweenss&quot; &quot;size&quot; &quot;iter&quot; &quot;ifault&quot; 결과를 출력해 보면 매우 복잡하다. 첫 줄에는 군집의 수와 각 군집에 배정된 사례의 수를 출력한다. Cluster.means 영역은 군집의 평균점에 대한 정보를 제공한다. 이 데이터는 19 개의 변수가 있으므로 군집 별로 변수의 평균을 보여준다. 정규화된 데이터의 경우 평균이 0보다 크다는 것은 전체 집단보다 군집의 해당 변수의 값이 평균적으로 크다는 것을 의미하고 0보다 작다는 것은 전체 집답보다 평균적으로 작다는 것을 의미한다. Clustering vector 영역은 사례들이 어떤 군집에 배정되었는지 보여준다. Within cluster sum of squares by cluster 영역은 군집 내 거리를 의미하며, 군집의 평균점과 사례의 거리의 제곱의 합(within_SS)이다. total_SS는 전체 평균점과 사례의 거리의 제곱의 합을 의미한다. between_SS는 군집 사이의 거리를 의미하며, 다음과 같다. \\[ \\text{between_SS} = \\text{total_SS} - \\text{within_SS} \\] 그러므로 between_SS / total_SS는 회귀분석의 \\(R^2\\)와 마찬가지의 의미이며 데이터의 전체 변동성을 군집이 설명한 비율을 의미한다. 이 비율이 높을수록 군집화가 데이터의 변동을 많이 설명한 것이라 할 수 있다. Available components 영역은 kmeans() 함수의 결과가 가지고 있는 요소들이다. 이미 출력된 정보뿐 아니라 다른 정보를 가진 요소들도 있다. 군집화 결과의 요소들을 하나씩 탐색해 보자. result$cluster # 사례의 군집 배정 결과 [1] 2 2 2 2 2 2 2 2 2 2 2 2 1 2 1 2 1 2 2 1 1 2 1 1 1 1 1 1 2 2 2 1 1 2 1 2 3 [38] 2 2 2 1 2 2 2 1 1 2 1 1 1 1 1 1 3 1 1 3 1 1 1 3 1 1 1 1 2 1 3 1 3 3 3 3 3 [75] 1 1 3 3 3 3 1 1 3 3 2 3 2 3 3 3 3 3 3 3 3 3 3 3 3 3 result$centers # 군집의 평균점 경기 타석 타수 안타 단타 2루타 3루타 1 0.2156607 0.1818939 0.1817526 0.1044683 0.1177994 0.1082262 -0.1940637 2 0.8407483 0.9873874 0.9850705 1.0250550 0.9495607 0.8631870 0.6675124 3 -1.1699685 -1.2836122 -1.2809619 -1.2257185 -1.1620774 -1.0578194 -0.4661991 홈런 득점 타점 볼넷 고4 HBP 삼진 1 0.0322832 -0.03534549 0.1500764 0.0994473 -0.1978942 0.3047498 0.1739876 2 0.6649128 1.12095542 0.8201901 0.8210738 0.7829001 0.2173607 0.6472846 3 -0.7501324 -1.15091484 -1.0649662 -1.0017787 -0.5844275 -0.6178679 -0.9108211 희플 희타 병살 도루 도실 1 0.05035605 -0.01124327 0.3708959 -0.3162716 -0.2251868 2 0.69634113 0.54499385 0.3487327 0.7821202 0.7323434 3 -0.80654820 -0.56708530 -0.8417830 -0.4336508 -0.4959297 result$size # 군집별 사례의 수 [1] 38 32 30 result$totss # 전체 평균점과 사례의 거리의 제곱의 합 [1] 1881 result$withinss # 군집 내 거리: 군집 별 군집 중심과 사례의 거리의 제곱의 합 [1] 302.2123 498.8580 175.0282 result$tot.withinss # 군집 내 거리의 합 [1] 976.0985 result$betweenss # 군집 사이의 거리의 제곱의 합 [1] 904.9015 군집 내의 거리(within_SS)와 군집 사이의 거리(between_SS)의 합이 전체 평균에서의 거리(total_SS)와 같음을 확인할 수 있다. sum(result$withinss, result$betweenss) [1] 1881 그리고 군집화 결과의 출력에서 볼 수 있었던 between_SS / total_SS 의 값도 계산할 수 있다. result$betweenss / result$totss [1] 0.4810747 result$iter # 알고리즘이 수렴할 때까지 반복 횟수 [1] 3 이 사례에서는 3 반복 만에 알고리즘이 수렴한 것을 볼 수 있다. 초기 시드를 달리하며 반복하기 초기 시드를 바꾸어서 여러 번 시도하면 더 좋은 결과를 얻을 수 있는지 확인해 보자. result3 &lt;- kmeans(batters_scaled, 3, nstart=5) result3 K-means clustering with 3 clusters of sizes 35, 23, 42 Cluster means: 경기 타석 타수 안타 단타 2루타 3루타 1 -1.0314224 -1.1579459 -1.1507181 -1.0961791 -1.0238085 -0.9430983 -0.3959665 2 0.8440932 0.9867864 0.9821553 1.1192296 1.1481218 0.8825950 1.1000825 3 0.3972771 0.4245718 0.4210848 0.3005711 0.2244404 0.3025894 -0.2724540 홈런 득점 타점 볼넷 고4 HBP 삼진 1 -0.7277376 -1.0437835 -0.9774737 -0.9249198 -0.5696506 -0.60061700 -0.8479468 2 0.3489558 1.2089001 0.7152624 0.8176381 0.6388451 0.07516619 0.3297674 3 0.4153531 0.2078028 0.4228702 0.3230123 0.1248650 0.45935173 0.5260354 희플 희타 병살 도루 도실 1 -0.7190593 -0.529091688 -0.7728623 -0.3944579 -0.3463147 2 0.7674617 0.815658373 0.2178596 1.1974457 1.1433303 3 0.1789395 -0.005760322 0.5247478 -0.3270292 -0.3375138 Clustering vector: [1] 2 2 2 2 3 2 2 3 2 2 2 2 3 2 3 2 3 3 2 3 3 2 3 3 3 3 3 3 2 3 3 3 3 2 3 2 1 [38] 2 3 2 3 3 2 2 3 3 2 3 1 3 3 1 3 1 3 3 1 3 1 3 1 3 3 3 3 3 3 1 1 1 1 1 1 1 [75] 3 3 1 1 1 1 3 1 1 1 3 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 Within cluster sum of squares by cluster: [1] 230.6569 345.0618 398.5590 (between_SS / total_SS = 48.2 %) Available components: [1] &quot;cluster&quot; &quot;centers&quot; &quot;totss&quot; &quot;withinss&quot; &quot;tot.withinss&quot; [6] &quot;betweenss&quot; &quot;size&quot; &quot;iter&quot; &quot;ifault&quot; between_SS / total_SS가 증가하여 군집이 데이터의 변동의 더 많은 부분을 설명하는 것을 확인할 수 있다. 군집의 수의 조정 앞의 예에서는 \\(k=3\\)으로 군집화를 하였지만, 3 개의 군집이 타자들의 설명하는 최적의 군집인지는 사전에 알 수 없다. 그러므로 \\(k\\)를 바꾸어 가면 군집화를 수행해 보아야 한다. 다음은 \\(k=5\\)일 때의 군집화 결과를 보여준다. 초기 시드를 5 번 바꾸어 군집화를 시도하였다. result5 &lt;- kmeans(batters_scaled, 5, nstart=5) result5 K-means clustering with 5 clusters of sizes 12, 24, 18, 17, 29 Cluster means: 경기 타석 타수 안타 단타 2루타 3루타 1 0.7398361 0.7551283 0.6921748 0.6875715 1.0416848 0.1147718 1.0595434 2 -0.2353152 -0.5432903 -0.5380312 -0.5427138 -0.4400309 -0.5470315 -0.2754813 3 -1.6829442 -1.6016841 -1.5935404 -1.4892510 -1.4269824 -1.2769399 -0.4661991 4 0.9561185 1.1471550 1.1691256 1.2438566 0.8600893 1.3103549 0.4861435 5 0.3727074 0.4588313 0.4625946 0.3598355 0.3146444 0.4296683 -0.2060629 홈런 득점 타점 볼넷 고4 HBP 1 -0.5483405 0.9823698 -0.1830850 0.8373263 -0.04137540 0.5024788 2 -0.4858016 -0.5872294 -0.5415183 -0.5077042 -0.42926974 -0.2019308 3 -0.8902194 -1.3564576 -1.3138407 -1.2893163 -0.68786598 -0.6603560 4 1.5691508 1.2899511 1.5345306 0.8154366 1.38090388 0.3860638 5 0.2616452 0.1652461 0.4398473 0.3959399 -0.01016551 0.1427557 삼진 희플 희타 병살 도루 도실 1 -0.02819821 0.2160810 1.24741608 -0.3011121 2.04877873 1.90671117 2 -0.46760439 -0.3327878 -0.07163634 -0.1763419 -0.27066299 -0.13399343 3 -1.13246922 -1.0453543 -0.84733926 -1.1190501 -0.54476766 -0.66021286 4 1.16302474 0.9926538 0.21665010 0.7092819 0.08225309 0.05852587 5 0.41978997 0.2529379 -0.05795399 0.5493331 -0.33385923 -0.30261379 Clustering vector: [1] 4 4 4 4 4 4 1 4 4 4 1 4 5 1 5 1 5 5 4 2 5 4 5 5 5 5 5 5 5 4 4 1 5 1 2 1 3 [38] 1 4 1 5 5 1 1 5 5 4 5 2 2 5 2 5 2 2 5 3 2 2 2 3 5 5 5 5 5 5 2 2 2 2 3 2 3 [75] 5 5 3 2 3 2 2 2 3 2 4 2 1 3 3 3 2 3 2 3 3 3 2 3 3 3 Within cluster sum of squares by cluster: [1] 120.48508 149.10938 64.33988 197.59490 204.42453 (between_SS / total_SS = 60.9 %) Available components: [1] &quot;cluster&quot; &quot;centers&quot; &quot;totss&quot; &quot;withinss&quot; &quot;tot.withinss&quot; [6] &quot;betweenss&quot; &quot;size&quot; &quot;iter&quot; &quot;ifault&quot; 군집화는 3 번만에 수렴을 하였다. result5$iter [1] 3 between_SS / total_SS 값에서 군집의 수를 5로 하면 데이터의 변동의 더 많은 부분은 군집이 설명하는 것을 알 수 있다. 동일한 데이터에서 군집의 수 \\(k\\)를 증가시키면 between_SS / total_SS 값이 증가한다. 그러면 \\(k\\)를 계속 증가시켜야 할까? \\(k\\)를 데이터의 사례 수만큼 증가시키면 사례 하나가 군집 하나가 되므로 군집 내 거리는 0이 되고 between_SS / total_SS 값은 1이 된다. 그러나 이러한 군집화는 원래의 데이터와 동일하므로 우리에게 어떠한 새로운 정보도 주지 못한다. 반면 \\(k=1\\)로 모든 데이터를 하나의 군집으로 묶는 것도 원래의 데이터와 동일해져 새로운 정보를 주지 못한다. 우리가 원하는 것은 데이터를 하나로 뭉뚱그리거나 개별적인 사례로만 취급하는 것이 아니라 특징 공유하는 사례들을 적절한 그룹으로 나누어 봄으로써 데이터에 대한 새로운 정보와 직관을 얻는 것이다. 군집의 수 \\(k\\)를 늘리면 처음에는 데이터 안에 존재하는 안정적인 군집 패턴을 찾아낸다. 이러한 패턴은 데이터가 조금 변동되어도 안정적으로 유지된다. 그러나 \\(k\\)가 어느 수준을 넘어서면 데이터에서 우연히 모여진 패턴도 군집으로 오인하여 군집화를 수행한다. 이렇게 모형이 복잡해지면 데이터 안의 실제적인 패턴뿐 아니라 우연히 발생한 패턴마저 학습하는 현상을 과적합 또는 과대적합(overfitting)이라고 한다. 과적합된 패턴은 데이터가 조금 변동하여도 유지되지 않는다. 우리는 데이터에서 안정적으로 유지되는 군집 패턴만을 학습하고 우연적인 패턴은 학습하지 않기를 원한다. 그렇다면 군집 결과가 과적합되었는지 안 되었는지를 어떻게 판단해야 할까? 한 가지 방법은 데이터를 분할하거나 데이터에 약간의 변동을 주어 군집화를 여러 번 하여 군집결과가 유사한지 살펴보는 것이다. 좀 더 간단한 방법은 팔꿈치 차트(elbow chart)를 사용하는 것이다. 팔꿈치 차트는 \\(k\\)가 변화함에 따라 군집 내 거리(within_SS)의 합의 변화를 그래프로 그린 것이다. 다음은 \\(k=2\\)부터 \\(k=20\\)까지 군집화를 했을 때의 군집 내 거리(within_SS)의 변화를 시각화한 것이다. k_range &lt;- 2:20 within_ss &lt;- sapply(k_range, function(k) { result &lt;- kmeans(batters_scaled, k, nstart=5) result$tot.withinss }) ggplot() + geom_line(aes(k_range, within_ss)) 군집의 수가 증가함에 따라 군집 내 거리가 지속적으로 감소하는 것을 관찰할 수 있다. 아울러 감소의 정도가 처음에는 크다가 감소하여 완만해져서 그래프에서 팔의 팔꿈치처럼 꺾이는 지점이 있는 것도 볼 수 있다. 팔꿈치 방법은 이 지점 근처의 군집의 수로 최적 \\(k\\)를 결정하는 것이다. 이 예에서는 \\(k=5\\) 근처가 최적 군집 수이다. 최적 군집의 수로 군집화를 수행한다. result_best &lt;- kmeans(batters_scaled, 5, nstart=5) 군집의 해석 군집 결과를 얻었으면 군집의 의미를 해석해 보아야 한다. 이러한 해석을 통하여 데이터와 군집에 대한 직관적 이해를 높일 수 있다. 군집을 해석할 때는 프로파일 기법과 의사결정나무가 자주 사용된다. 프로파일 기법은 군집의 평균점을 잉요하여 군집의 특징을 프로파일링하는 것이고, 의사결정나무를 이용하는 방법은 군집의 결과를 의사결정나무로 예측하여 의사결정나무의 분할 방식을 이용하여 군집이 어떤 방식으로 대비되는지를 확인하는 것이다. 여기서는 프로파일 기법만 사용하도록 한다. 정규화된 데이터를 사용하였으면 전체 데이터의 평균은 원점이 된다. 따라서 군집의 평균이 양수이면 전체 집단에 비해 해당 변수의 값이 큰 경향이 군집에 있는 것이고, 음수이면 전체에 비해 해당 변수의 값이 작은 경향이 있다는 것이다. 군집의 평균을 시각화해 보자. 행렬로 되어 있는 군집의 평균을 데이터프레임으로 변환한 후, 행 이름을 군집이라는 열로 변환하였다. cluster_means &lt;- as_tibble(result_best$centers) %&gt;% rownames_to_column(var=&quot;군집&quot;) cluster_means # A tibble: 5 × 20 군집 경기 타석 타수 안타 단타 `2루타` `3루타` 홈런 득점 타점 &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 -1.63 -1.57 -1.56 -1.46 -1.39 -1.27 -0.355 -0.900 -1.32 -1.30 2 2 -0.186 -0.501 -0.499 -0.522 -0.428 -0.534 -0.381 -0.419 -0.572 -0.496 3 3 0.956 1.15 1.17 1.24 0.860 1.31 0.486 1.57 1.29 1.53 4 4 0.740 0.755 0.692 0.688 1.04 0.115 1.06 -0.548 0.982 -0.183 5 5 0.368 0.477 0.483 0.386 0.341 0.474 -0.182 0.252 0.182 0.455 # ℹ 9 more variables: 볼넷 &lt;dbl&gt;, 고4 &lt;dbl&gt;, HBP &lt;dbl&gt;, 삼진 &lt;dbl&gt;, 희플 &lt;dbl&gt;, # 희타 &lt;dbl&gt;, 병살 &lt;dbl&gt;, 도루 &lt;dbl&gt;, 도실 &lt;dbl&gt; 이 데이터를 이용하여 군집의 평균을 평행좌표계로 시각화해 보자. pivot_longer(cluster_means, -군집, names_to=&quot;변수&quot;, values_to=&quot;평균&quot;) %&gt;% ggplot() + geom_line(aes(변수, 평균, group=군집, color=군집, linetype=군집)) + coord_flip() 군집 평균을 이용하여 군집에 대한 다음과 같은 해석을 할 수 있다. 군집 3은 모든 부분에서 리그의 평균을 상회하는 것으로 보아 팀의 핵심 선수라는 것을 알 수 있다. 특히 홈런, 타점, 고의4구는 평균에 비해 매우 높으며, 도루와 도루실패는 평균 수준인 것으로 보아 중장거리 안타를 생산해 낼 수 있는 팀의 중심 타선을 이루는 선수들로 예상된다. 군집 5는 도루, 도루실패, 3루타는 리그의 평균을 크게 상회하고 홈런을 리그 평균을 하회하는 것으로 보아 발이빠른 타자들로 주로 테이블 세터로서의 역할을 하는 선수들로 에상된다. 군집 4는 리그 평균에 가까우나 많은 지표에서 평균을 약간 상회하는 것으로 보아 팀의 주전급 선수 중에서 공격이 중요한 포지션의 선수들로 예상된다. 군집 1은 리그 평균에 가까우나 많은 지표에서 평균을 하회하고 있어 주전과 비주전의 경계에 있는 선수나 수비가 중요한 포지션의 선수로 예상된다. 군집 2는 대부분의 지표에서 리그 평균을 하회하는 것으로 보아 팀의 비주전급 선수로 예상된다. 이러한 군집 해석이 맞는지 각 군집의 평균점에 어떠한 선수가 있는지 알아보자. 군집의 평균점과 각 사례의 거리를 계산하여 파악할 수도 있고, 14.2에서 소개한 주성분 분석을 사용하여 데이터를 산점도로 표현하고 산점도에 군집을 표현하여 군집의 중심에 어떠한 데이터가 있는지 살펴볼 수도 있다. library(ggbiplot) batters_pca &lt;- prcomp(batters_scaled) ggbiplot(batters_pca, var.axes = F, # 변수 벡터 생략 labels=batters$선수명, groups=paste(&quot;군집&quot;, result_best$cluster), # 군집 결과로 그룹화 ellipse=T, ellipse.alpha=0.1, ellipse.linewidth=0.5) + theme_bw() 15.3 병합 군집화 이 절에서는 계층적 군집(hierachical clustering) 방법인 병합 군집화(agglomorative clustering) 기법에 대하여 살펴본다. 앞서 살펴본 k-평균 군집화 기법은 분할 군집(partitioning clustering) 방법으로 변수 공간을 이미 정해진 수로 분할한 후 분할 공간의 경계를 데이터 변동을 더 잘 설명하도록 반복적으로 조정해 나간다. 반면 계층적 군집화에서는 단계적으로 군집의 수를 늘려가거나 줄여 나간다. 계층적 군집화는 병합 방법과 분리 방법으로 나뉜다. 병합 방법은 데이터의 개별 사래 수만큼의 군집에서 시작하여 군집을 한 단계씩 병합하여 하나의 군집으로 병합될 때까지 군집화를 수행한다. 분리 방법은 데이터의 모든 사례를 하나의 군집으로 하여 한 단계씩 군집을 분리하여 개별 사례로 분리될 때까지 군집을 늘려 나간다. 계층적 군집화는 데이터의 개별 사례 수준까지 군집화가 수행되므로 데이터의 크기가 크지 않을 때 주로 사용된다. 15.3.1 병합 군집화 알고리즘 데이터의 사례를 개별 군집으로 시작하여 가장 유사한 두 군집을 하나의 군집으로 차례로 병합하여 모든 사례가 하나의 큰 군집이 될 때까지 군집한다. 따라서 k-평균 군집화처럼 이미 정해진 군집의 수는 없다. 모든 사례를 병합한 다음 어떤 단계의 군집 결과가 가장 적합한지를 사후 평가한다. 병합 군집화는 다음의 알고리즘으로 구현된다. 1단계: 데이터에 N 개의 사례가 있으면 군집의 수 \\(k=N\\)이 되며 개별 사례들이 독자적인 군집이 되어 알고리즘이 시작된다. 2단계: \\(k\\) 개의 군집 사이의 거리를 계산하여 거러 행렬(distance matrix) 또는 유사성 행렬(similarity matrix)을 생성한다. 맨 처음에는 개별 사례를 군집으로 시작하므로 거리 행렬은 모든 사례들 사이의 거리를 계산한 행렬이 된다. 사례들이 병합되어 군집을 이루면, 여러 사례로 구성된 군집 사이의 거리를 계산하는 방법이 정의되어야 한다. 3단계: 가장 가까운 거리의 두 군집을 병합하여 군집의 수를 \\(k\\)에서 \\(k-1\\)개로 만든다. 4단계: \\(k &gt; 1\\)이면 2단계로 돌아가 하나의 군집으로 모두 병합될 때까지 반복한다. 각 반복 과정에서 병합된 군집의 순서와 거리를 기억하여 최종적으로 몇 개의 군집으로 나눌지를 결정한다. 그러므로 각 단계의 군집 결과를 평가하는 방법이 정의되어 있어야 한다. 다음과 같은 데이터를 사용하여 병합 군집화 알고리즘이 어떻게 작동하는지 확인해 보자. 다음은 병합 군집화의 각 단계의 군집 결과를 보여준다. 가장 가까운 두 사례가 8, 9이므로 이 두 사례가 하나의 군집으로 병합된다. 다음으로 가장 가까운 두 사례가 2, 3이므로 이 두 사례가 하나의 군집으로 병합된다. 그 다음에는 첫 번째 군집과 7이 가장 가까우므로 7, 8, 9이 하나로 병합된다. 이러한 단계가 계속 반복되어 모든 데이터가 하나의 군집이 될 때까지 진행된다. 이렇게 단계적으로 수행한 군집화 결과는 다음과 같은 나무 구조의 계통도(덴드로그램: dendrogram)로 표현된다. 가로축은 데이터의 사례들이며 서로 가깝게 군집이 되는 사례들이 이웃하도록 배치된다. 세로축은 군집의 병합이 이루어졌을 때의 거리를 나타낸다. 모든 사례들이 하나의 군집이 되도록 병합한 후에, 몇 개의 군집으로 데이터를 나눌지를 결정해야 한다. 다음은 3 개와 5 개의 군집으로 나누었을 때의 군집 결과를 보여준다. 15.3.2 군집 사이의 거리 계산 앞의 병합 군집화의 예에서 4 단계로 다시 돌아가 보자. 다음 그래프에 표시된 두 군집 사이의 거리는 어떻게 계산할까? 사례 사이의 거리는 앞서 설명한 유클리드나 맨해튼 거리 함수 등을 사용하여 계산할 수 있다. 그러나 병합 군집화가 진행되면 군집에는 점차 다수의 사례가 포함되므로 다수의 사례로 이루어진 군집 사이의 거리를 계산한는 방법이 정의되어야 한다. 또 다른 예를 살펴보자. 다음과 같은 나이를 가진 어린이들의 군집이 있다고 하자. 그러면 \\(\\{ 7 \\}\\)은 다음에 어느 군집과 병합되어야 할까? \\[ \\{2, 3\\}, \\quad \\{7\\}, \\quad \\{9, 11, 13\\} \\] 7 살 어린이와 나이 차이가 가장 가까운 9 살 어린이가 있는 군집과 병합되어야 할까? 군집 내 어린이들의 나이 차이가 너무 커지는 것을 방지하기 위하여 병합된 후 군집 내의 거리가 가장 작은 군집과 병합되어야 할까? 그렇다면 \\(\\{2, 3, 7\\}\\)로 병합되면 최대 나이 차이가 5 살이고, \\(\\{7, 9, 11, 13\\}\\)으로 병합되면 최대 나이 차이가 6살이므로, 최대 나이 차이가 적은 2, 3 살 어린이의 군집과 병합되어야 할 것이다. 군집 사이의 거리를 계산하는 다양한 방식을 살펴보자. 단일 연결법 (Single Linkage Method) 단일 연결법은 최단(MIN) 연결법이라고도 한다. 군집 사이의 거리를 군집 사이에서 가장 가까운 구성원 쌍의 거리로 정의한다. 그러므로 최소한도의 단일 연결만 이루어지는 거리가 군집의 거리가 된다. 단일 연결법으로 하면 자신과 가까운 이웃이 동일 군집에 포함되게 된다. 이웃과 동떨어져 있는 고립되어 있는 데이터와 군집이 가장 마지막으로 병합되므로 특이치 검출에 유용하다. 앞의 나이가 다른 어린이의 군집에서 단일 연결법으로 거리를 계산하면 다음과 같다. 그러므로 거리가 더 가까운 9 살 어린이가 있는 군집과 병합된다. \\[\\begin{align*} d(\\{2, 3\\}, \\{ 7 \\}) &amp;= d(3, 7) = 4 \\\\ d(\\{ 7 \\}, \\{9, 11, 13\\}) &amp;= d(7, 9) = 2. \\end{align*}\\] 이웃한 사례들을 계속 군집으로 병합하므로 한 군집에 있는 사례들 사이의 거리는 매우 커질 수 있다. 앞의 예는 단일 연결법으로 병합 군집화를 한 사례인데 아래 편에 위치한 사례들이 이웃한 사례들과 연결이 계속되면서 큰 군집으로 병합된 것을 볼 수 있다. 이 군집에서 3과 8 사이의 거리는 매우 크다. 그러므로 단일 연결법으로 군집화를 하면 군집의 응집력이 떨어질 수 있다. 완전 연결법 (Single Linkage Method) 최장 연결법은 최장(MAX) 연결법이라고도 한다. 군집 사이의 거리를 군집 사이에서 가장 먼 구성원 쌍의 거리로 정의한다. 그러므로 이 최장 거리로 연결하면 모든 사례 쌍이 완전하게 연결 된다. 자신과 멀리 떨어져 있는 사례일수록 마지막으로 군집화 된다. 멀리 떨어져 있는 사례와 군집은 나중에 수행되므로 군집 내의 거리가 가까워지고 군집의 응집력이 강해진다. 앞의 나이가 다른 어린이의 군집에서 완전 연결법으로 거리를 계산하면 다음과 같다. 그러므로 7 살과 나이 차이가 큰 13 살이 있는 군집이 아니라 2 살 어린이가 있는 군집과 병합된다. \\[\\begin{align*} d(\\{2, 3\\}, \\{ 7 \\}) &amp;= d(2, 7) = 5 \\\\ d(\\{ 7 \\}, \\{9, 11, 13\\}) &amp;= d(7, 13) = 6. \\end{align*}\\] 다음은 앞의 예제 데이터를 완전 연결법으로 거리를 계산하여 5 번째 단계까지 병합 군집한 결과를 보여준다. 군집들이 단일 연결법에 비해서 군집 내의 거리가 더 짧은 것을 볼 수 있다. 평균 연결법 (Average Linkage Method) 군집 사이의 거리를 군집 사이의 가능한 구성원 쌍의 거리의 평균으로 정의한다. 평균으로 군집 사이의 거리를 계산하므로 단일 연결법과 최장 연결법의 중간적 특성을 보인다. 앞의 나이가 다른 어린이의 군집에서 완전 연결법으로 거리를 계산하면 다음과 같다. 그러므로 7 살은 자신과 나이 차이가 평균적으로 더 적은 9, 11, 13 살 어린이들과 병합된다. \\[\\begin{align*} d(\\{2, 3\\}, \\{ 7 \\}) &amp;= \\frac{d(2, 7) + d(3,7)}{2} = 4.5 \\\\ d(\\{ 7 \\}, \\{9, 11, 13\\}) &amp;= \\frac{d(7,9) + d(7,11) + d(7,13)}{3} = 4. \\end{align*}\\] 중심점 연결법 (Centroid Linkage Method) 군집 사이의 거리를 군집의 중심점(평균) 사이의 거리로 정의한다. 두 군집의 경계가 붙어있어도 군집의 중심이 멀면 나중에 병합된다. Ward 법 (Ward’s Method) Ward 법은 지금까지의 군집 사이의 거리 계산 방법과는 다르다. Ward 법은 데이터를 군집으로 병합할 때 발생하는 정보의 손실을 측정한다. 데이터이 사례가 모두 개별 군집으로 되어 있으면 사례의 측정값을 직접 이용할 수 있으므로 정보의 손실이 없다. 사례들이 군집으로 병합되어 있으면, 사례들을 군집의 평균으로 뭉뚱그려서 이해하므로, 사례의 정확한 측정값에 대한 정보는 손실된다. Ward 법에서는 군집화에 따른 정보의 손실은 오차제곱합(ESS)로 계산한다. ESS는 사례와 군집 평균의 차이의 제곱의 합이다. 그러므로 ESS는 군집 내 거리의 제곱 합(within_SS)이라 할 수 있다. \\(k\\) 개의 군집이 있을 때 다음 번 병합할 군집의 선택은 두 군집이 병합되었을 때 정보의 손실 증가가 가장 작은 두 군집을 병합한다. 나이가 다른 어린이 군집의 병합 문제에서 세 군집의 ESS와 그 합은 다음과 같다. \\[\\begin{align*} ESS(\\{2, 3\\}) &amp;= (2 - 2.5)^2 + (3 - 2.5)^2 = 0.5 \\\\ ESS(\\{7\\}) &amp;= (7 - 7)^2 = 0 \\\\ ESS(\\{9, 11, 13\\}) &amp;= (9 - 11)^2 + (11 - 11)^2 + (13 - 11)^2 = 8 \\\\ ESS(\\{2, 3\\}, \\{7\\}, \\{9, 11, 13\\}) &amp;= 8.5 \\end{align*}\\] 만약 7 살 어린이가 2, 3 살 어린이들과 병합될 때의 정보 손실은 다음과 같다. \\[\\begin{align*} ESS(\\{2, 3, 7\\}) &amp;= (2 - 4)^2 + (3 - 4)^2 + (7 - 4)^2 = 14 \\\\ ESS(\\{2, 3, 7\\}, \\{9, 11, 13\\}) &amp;= 22 \\end{align*}\\] 마찬가지로 7 살 어린이가 9, 11, 13 살 어린이들과 병합될 때의 정보 손실은 다음과 같다. \\[\\begin{align*} ESS(\\{7, 9, 11, 13\\}) &amp;= (7 - 10)^2 + (9 - 10)^2 + (11 - 10)^2 + (13 - 10)^2 = 20 \\\\ ESS(\\{2, 3\\}, \\{7, 9, 11, 13\\}) &amp;= 20.5 \\end{align*}\\] 위의 결과에서 Ward 법을 사용하면 정보 손실이 더 적어지도록 7 살 어린이가 9, 11, 13 살 군집과 병합된다. Ward 법을 사용하면 정보의 손실을 줄이기 위하여 군집들의 크기 차이가 크지 않다. 15.3.3 hclust() 함수를 이용한 병합 군집화 R의 기본 stats 패키지는 병합 군집화를 위한 hclust() 함수를 제공한다. 첫 번째 인수는 사례 사이의 거리 행렬로 dist() 함수를 이용하여 계산한다. method 인수는 군집 사이의 거리 계산법을 지정한다. (dist() 함수의 method와 혼동하지 않길 바란다. dist() 함수의 method는 유클리드, 맨해튼 등의 사례 사이의 거리 계산 방법을 지정하고, hclust()의 method는 군집 사이의 거리 계산 방법을 지정한다.) \"single\": 단일 연결법 \"complete\": 완전 연결법 \"average\": 평균 연결법 \"centroid\": 중심점 연결법 \"ward.D\", \"ward.D2\": Ward 법의 두 가지 다른 알고리즘을 지정할 수 있다. 다음은 정규화된 KBO 타자들의 기본통계 데이터에 대한 유클리드 거리를 계산한 후, 단일 연결법으로 병합 군집화를 수행한는 예이다. d &lt;- dist(batters_scaled) batters_hcls &lt;- hclust(d, method=&quot;single&quot;) batters_hcls Call: hclust(d = d, method = &quot;single&quot;) Cluster method : single Distance : euclidean Number of objects: 100 병합 군집화 결과를 출력하면 군집 거리 계산법(Cluster method), 사례 사이의 거리 계산법(Distance), 사례의 수(Number of objects)를 출력한다. 병합 군집화 결과는 리스트 형식으로 상세 정보를 보유하고 있다. $merge: 사례 수가 \\(n\\)이면 \\((n-1) \\times 2\\)의 행렬로, 군집화의 각 단계별로 어떤 군집들이 병합되었는지에 대한 정보이다. 음수이면 병합된 사례를 의미하고, 양수이면 이전 단계에서 병합된 군집을 의미한다. $height: 각 단계에서 병합된 군집 사이의 거리를 의미한다. $order: 시각화에 적합하도록 사례의 순서를 정렬한 벡터이다. 이 순서로 $merge의 정보를 시각화하면 계통도에서 선의 교차가 발생하지 않는다. $labels: 사례의 레이블 $call: hclust() 호출 저보 $method: 군집 사이의 거리 계산법 $dist.method: 사례 사이의 거리 계산법 데이터 분석 초보자가 이 데이터를 직접 사용하는 경우는 많지 않으므로 이에 대한 상세한 설명은 생략한다. 15.3.4 병합 군집화에 대한 계통도 그리기 병합 군집화의 결과를 plot() 함수에 전달하면 계통도를 시각화한다. plot(batters_hcls) 계통도에서 사례들이 행 번호로 표현되었다. 선수의 이름이 나타나도록 label 인수를 지정해 보자. plot(batters_hcls, label=batters$선수명) 2024 시즌에 가장 특이했던 타자는 ’김도엉’이었음을 볼 수 있다. 나머지 군집들과 가장 마지막에 병합되었다. ’김도영’은 2024 시즌에서 홈런을 잘치는 거포형 타자이면서 도루를 잘 하는 발 빠른 타자였다. 이러한 타자는 KBO에 흔하지 않다. 타자들이 병합될 때의 군집 거리로 세로축의 위치가 결정되어 있다. 만약 모든 사례들은 아래쪽에 나타내려면 hang=-1으로 설정한다. hang은 두 군집이 병합된 거리에서 어느 정도 떨어뜨려 사례를 표시할지를 지정하는 인수이다. hang=0.1이 기본값이고 그래프의 세로축의 길이의 10% 정도 떨어뜨려 사례를 표시한다. hang=-1이면 세로축의 0 밑에 사례들을 표시한다. plot(batters_hcls, label=batters$선수명, hang=-1) 15.3.5 군집 나누기 병합 군집이 완료되면 적절한 군집의 수로 데이터를 군집화해야 한다. cutree() 함수는 병합 군집 결과에서 사례를 원하는 수만큼의 군집으로 분할한다. 첫 번째 인수로 병합 군집 결과를 지정한다. k 인수로 분할하고자 하는 군집의 수를 지정한다. h 인수로 군집을 어느 거리를 기준으로 분할할지를 지정한다. k와 h는 둘 중에 하나만 지정되어야 한다. 둘 다 지정되면 k가 우선적으로 적용된다. 다음은 \\(k=3\\)일 때의 사례들의 군집화 결과이다. cls &lt;- cutree(batters_hcls, k=3) cls [1] 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 2 2 2 2 2 [38] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 [75] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 군집에 포함된 사례 수를 확인해 보자. table(cls) # 군집별 사례 수 cls 1 2 3 1 98 1 단열 연결법의 특징때문에 98 명의 타자가 한 군집에 몰려 있고, 두 명의 예외적인 타자가 각기 하나의 군집을 이루고 있다. 데이터에서 예외적인 군집에 속하는 타자가 누구였는지 확인해 보자. filter(batters, cls == 1) # 군집 1에 속하는 사례 # A tibble: 1 × 38 선수명 팀명 포지션 경기 타석 타수 안타 단타 `2루타` `3루타` 홈런 득점 &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 김도영 KIA 내야수 141 625 544 189 112 29 10 38 143 # ℹ 26 more variables: 타점 &lt;dbl&gt;, 볼넷 &lt;dbl&gt;, 고4 &lt;dbl&gt;, HBP &lt;dbl&gt;, # 삼진 &lt;dbl&gt;, 희플 &lt;dbl&gt;, 희타 &lt;dbl&gt;, 병살 &lt;dbl&gt;, 도루 &lt;dbl&gt;, 도실 &lt;dbl&gt;, # 타율 &lt;dbl&gt;, BABIP &lt;dbl&gt;, `볼넷%` &lt;dbl&gt;, `삼진%` &lt;dbl&gt;, `볼/삼` &lt;dbl&gt;, # ISO &lt;dbl&gt;, `타수/홈런` &lt;dbl&gt;, OPS &lt;dbl&gt;, RC &lt;dbl&gt;, `RC/27` &lt;dbl&gt;, # wRC &lt;dbl&gt;, SPD &lt;dbl&gt;, wSB &lt;dbl&gt;, wOBA &lt;dbl&gt;, wRAA &lt;dbl&gt;, WAR &lt;dbl&gt; filter(batters, cls == 3) # 군집 3에 속하는 사례 # A tibble: 1 × 38 선수명 팀명 포지션 경기 타석 타수 안타 단타 `2루타` `3루타` 홈런 득점 &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 김주원 NC 내야수 134 475 385 97 68 18 2 9 61 # ℹ 26 more variables: 타점 &lt;dbl&gt;, 볼넷 &lt;dbl&gt;, 고4 &lt;dbl&gt;, HBP &lt;dbl&gt;, # 삼진 &lt;dbl&gt;, 희플 &lt;dbl&gt;, 희타 &lt;dbl&gt;, 병살 &lt;dbl&gt;, 도루 &lt;dbl&gt;, 도실 &lt;dbl&gt;, # 타율 &lt;dbl&gt;, BABIP &lt;dbl&gt;, `볼넷%` &lt;dbl&gt;, `삼진%` &lt;dbl&gt;, `볼/삼` &lt;dbl&gt;, # ISO &lt;dbl&gt;, `타수/홈런` &lt;dbl&gt;, OPS &lt;dbl&gt;, RC &lt;dbl&gt;, `RC/27` &lt;dbl&gt;, # wRC &lt;dbl&gt;, SPD &lt;dbl&gt;, wSB &lt;dbl&gt;, wOBA &lt;dbl&gt;, wRAA &lt;dbl&gt;, WAR &lt;dbl&gt; 15.3.6 최적 군집 수의 결정 계통도를 이용한 최적 군집 수 결정 병합 군집이 완료된 후 최적 군집의 수를 어떻게 결정해야 할까? 사례의 수가 많지 않은 경우에는 계통도 상에서 여러 개의 군집 수로 분할해 보아서 군집이 잘 분리되고 설명이 용이한 군집의 수를 선택하기도 한다. 다음과 같은 어떤 가족 모임의 참석자의 나이에 대한 정보가 있다고 하자. ages=c(1, 3, 5, 7, 9, 11, 13, 28, 31, 34, 35, 39, 43, 45, 70, 72, 75) ages [1] 1 3 5 7 9 11 13 28 31 34 35 39 43 45 70 72 75 이 가족 모임을 단일 연결법으로 군집화하면 다음과 같이 군집화 된다. d_ages &lt;- dist(ages) hcls_ages &lt;- hclust(d_ages, method=&quot;single&quot;) plot(hcls_ages, labels=ages) 이 데이터는 거리가 5 이상인 곳에서 자연스럽게 데이터가 분리되는 것을 확인할 수 있다. rect.hclust() 함수는 plot() 함수로 그려진 계통도 위해 군집 결과를 사각형으로 표시해 준다. 첫 번째 인수로 병합 군집 결과를 지정 k 또는 h 인수로 분할할 군집의 수나 군집의 거리를 지정한다. which 인수는 사각형으로 표시할 군집의 범위를 지정한다. 기본값은 1:k로 분할돈 군집을 모두 사각형으로 표시한다. border는 사각형의 경계 색상을 지정한다. rect.hclust() 함수를 사용하면 계통도 상에서 군집의 분할 결과를 시각적으로 탐색할 수 있다. plot(hcls_ages, labels=ages) # 계통도 시각화 rect.hclust(hcls_ages, h=5) # 군집 분할 시각화 5 살 거리로 분할하면 자연스럽게 조부모 세대, 부모 세대, 자식 세대로 분할되었다는 것을 확인할 수 있다. 다음처럼 군집의 수로도 분할을 탐개할 수 있다. 6 개로 군집을 하면 어떻게 분할되는지 살펴보자. plot(hcls_ages, labels=ages) # 계통도 시각화 rect.hclust(hcls_ages, k=6) # 군집 분할 시각화 3 살 이상 차이가 나는 그룹으로 나누어져 부모 세대는 30대 초반, 30대 후반, 40대 초반으로 분할되고 조부모 세대는 70 대 초반과 후반으로 분할되었다. 이렇듯 군집의 수나 군집을 분리하는 거리를 기준으로 군집을 분할하여 계통도에 시각화하여 가장 직관적으로 적절하다고 판단되는 군집 결과를 선택한다. 그러나 데이터의 사례 수가 많아지면 계통도에 시각화하는 것만으로 군집화를 하기 어렵다. 다음은 KBO 타자의 병합 군집 결과를 5 개의 군집으로 분할한 것을 계통도에 시각화한 것이다. 사례 수가 너무 많으면 군집 결과를 파악하기가 쉽지 않다. plot(batters_hcls, labels=batters$선수명, hang=-1) # 계통도 시각화 rect.hclust(batters_hcls, k=5) # 군집 분할 시각화 평가 지표를 이용한 최적 군집 수 결정 최적 군집의 수를 결정하는 또 다른 방법은 군집화가 얼마나 잘 되었는지를 평가하는 지표를 사용하여 것이다. 좋은 군집화란 군집 내의 구성원 사이에는 동질성이 크고 다른 군집과는 이질적이어야 한다. 즉, 군집 내 구성원 사이의 거리는 가깝고, 군집들 사이의 거리는 먼 경우이다. 그러므로 대부분의 군집화를 평가하느 지표는 응집도와 분리도를 측정하여 이를 종합하는 방법을 사용한다. 응집도: 군집 내 데이터의 유사도 분리도: 군집 사이의 데이터의 비유사도 응집도와 분리도를 측정하는 방식은 다양하다. 대표적인 군집화 평가 척도를 살펴보자. 범용 척도는 (군집 내 평균 거리)/(군집 중심 사이의 평균 거리)로 측정되며 값이 작을수록 잘 된 군집을 의미한다. \\(R^2\\)는 (1 - within_SS)/total_SS로 정의된다. within_SS는 사례와 군집 평균 사이의 거리의 제곱의 합을, total_SS는 사례와 전체 평균 사이의 거리 제곱의 합을 의미한다. 클수록 잘 된 군집을 의미한다. Dunn Index는 (군집 사이 최소 거리)/(군집 내 최대 거리)로 측정된다. 분리도가 높아지면 분자가 커지고 응집도가 높으면 분모가 작아지므로 Dunn Index는 증가한다. Silhouette은 \\(s(i) = (b(i) – a(i)) / \\max\\{a(i), b(i)\\}\\)로 측정된다. \\(a(i)\\) 사례 \\(i\\)의 군집 내 구성원과의 평균 거리이고, \\(b(i)\\)는 사례 \\(i\\)와 가장 가까운 이웃 군집의 구성원과의 평균 거리이다. 분리도 높으면 \\(b(i)\\)가 증가하고 응집도가 높으면 \\(a(i)\\)가 감소하여 \\(s(i)\\)가 1에 근접한다. 이 외에도 많은 연구자들이 군집 평가 척도를 제안하였다. 그런데 군집을 평가하는 척도는 매우 많으며, 평가 척도 별로 엇갈린 결과를 줄 때가 많다. NbClust 패키지는 다양한 평가 척도로 군집화 결과를 평가한 후, 가장 많은 척도에서 최적이라고 한 군집의 수를 선택해 준다. NbClust를 설치되어 있지 않다면 설치를 한다. install.packages(&quot;NbClust&quot;) NbClust 패키지의 NbClust() 함수는 20 여개의 평가 척도로 군집의 수에 따라 군집화를 평가해 준다. data 인수: 첫번째 인수로 군집화를 수행할 데이터가 기술된다. distance 인수: 데이터 관측치 간의 거리 계산을 위해 사용할 방법이 정의된다. dist() 함수에서 사용하는 방법 중 하나를 기술한다. min.nc 인수: 평가를 할 최소 군집의 수. 디폴트 값은 2. max.nc 인수: 평가를 할 최대 군집의 수. 디폴트 값은 15. method 인수: 군집 분석에 사용할 방법을 기술한다. “ward.D”, “ward.D2”, “single”, “complete”, “average”, “mcquitty”, “median”, “centroid”, “kmeans” 등이 지정될 수 있다. index 인수: 평가에 사용할 평가 지표를 설정한다. 기본값은 “all”로 모든 지표를 계산한다. 그런데 “all”로 설정하면 데이터에 따라서는 일부 지표에서 계산 문제가 발생할 수 있다. 이 경우에는 각각의 지표를 설정하여 평가 결과를 확인해 본다. batters_scaled 데이터에서 안타=단타+2루타+3루타+홈런의 선형 종속성이 발생한다. 데이터에서 이러한 선형 종속성이 있으면 NbClust() 함수의 지표 계산 중에 역행렬을 구하는 부분이 있어서 오류가 발생한다. 이를 방지하기 위하여 안타 열을 제외하고 최적의 군집 수를 평가해 보자. 그리고 단일 연결법은 주류의 선수에서 벗어난 특이한 선수를 찾는데 주로 사용되므로, 평균 연결법을 사용하여 최적 군집 수를 찾아보자. library(NbClust) nc_all &lt;- NbClust(data=batters_scaled[, -4], distance=&quot;euclidean&quot;, min.nc=2, max.nc=15, method=&quot;average&quot;) *** : The Hubert index is a graphical method of determining the number of clusters. In the plot of Hubert index, we seek a significant knee that corresponds to a significant increase of the value of the measure i.e the significant peak in Hubert index second differences plot. *** : The D index is a graphical method of determining the number of clusters. In the plot of D index, we seek a significant knee (the significant peak in Dindex second differences plot) that corresponds to a significant increase of the value of the measure. ******************************************************************* * Among all indices: * 9 proposed 2 as the best number of clusters * 2 proposed 3 as the best number of clusters * 10 proposed 4 as the best number of clusters * 1 proposed 7 as the best number of clusters * 1 proposed 9 as the best number of clusters * 1 proposed 13 as the best number of clusters ***** Conclusion ***** * According to the majority rule, the best number of clusters is 4 ******************************************************************* NbClust()는 20여 개의 평가지표에서 최적으로 선택된 횟수를 알려주고, 가장 많이 최적으로 선택된 군집의 수를 최적 군집 수로 선택한다. 이 예에서는 2 개의 군집과 4 개의 군집이 근소한 결과를 보였는데, 4 개의 군집이 더 많은 선택을 받아서 4 개의 군집이 최적 군집으로 선택되었다. 아울러 지표의 값보다는 그래프를 이용하여 팔꿈치 부분에서 최적 군집 수를 결정하는 D-index와 Hubert index의 경우에는, 왼편에는 군집 수에 따른 지표 값을, 오른편에는 군집 수에 따른 지표 값의 변화량을 보여준다. 오른편 그래프에서 가장 큰 피크를 이루는 곳이 최적 군집 수라 할 수 있다. NbClust()의 결과에는 다음 4 가지 상세 정보가 포함되어 있다. $All.index: 군집 수에 따른 모든 지표의 값 $All.CriticalValues: 지표 중에는 지표 값이 특정한 문턱 값을 넘어서는 것을 기준으로 최적 군집 수를 결정한다. 이러한 지표에 대하여 군집 수에 문턱 값을 제공한다. $Best.nc: 각 지표가 선택한 최적 군집 수 $Best.partition: 다수결에 의해 최종적으로 최적으로 선택된 군집 수로 군집을 분할한 결과 각 지표가 선택한 최적 군집 수의 빈도를 시각화해 보자. t(nc_all$Best.nc) %&gt;% # 행렬 전치 as_tibble() %&gt;% # 데이터프레임으로 변환 rownames_to_column(var=&quot;index&quot;) %&gt;% # 행이름 열로 변환 ggplot() + geom_bar(aes(Number_clusters)) + scale_x_continuous(breaks=0:15) 군집 결과의 해석 최적 군집 결과를 프로파일링 해 보자. 각 사례의 군집 배정 결과는 다음과 같다. nc_all$Best.partition [1] 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4 2 3 2 3 4 [38] 3 2 2 2 2 3 2 2 2 2 2 4 4 2 4 2 4 4 2 4 2 4 2 4 2 2 2 2 2 2 4 4 4 4 4 4 4 [75] 2 2 4 4 4 4 2 4 4 4 2 4 3 4 4 4 4 4 4 4 4 4 4 4 4 4 이 정보를 정규화된 데이터와 결합하여 군집의 평균을 비교해 보자. kmeans()는 군집의 평균점을 알고리즘 상에서 계산하므로 이 정보를 제공하지만, 다른 알고리즘의 경우에는 군집화가 수행된 후에 군집 평균을 직접 계산하여야 한다. cluster_means &lt;- as_tibble(batters_scaled) %&gt;% # 데이터프레임으로 변환 mutate(군집=factor(nc_all$Best.partition)) %&gt;% # 군집 결과를 열로 추가 group_by(군집) %&gt;% # 군집으로 그룹화 summarise(across(everything(), mean)) # 군집 별 평균 구하기 cluster_means # A tibble: 4 × 20 군집 경기 타석 타수 안타 단타 `2루타` `3루타` 홈런 득점 타점 &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 1.03 1.32 1.29 1.81 1.16 1.11 4.20 2.63 3.17 1.68 2 2 0.549 0.646 0.656 0.634 0.554 0.625 0.0162 0.513 0.501 0.665 3 3 0.745 0.665 0.606 0.514 0.892 -0.187 1.74 -0.707 1.13 -0.481 4 4 -0.940 -1.07 -1.08 -1.05 -0.973 -0.904 -0.408 -0.700 -0.986 -0.931 # ℹ 9 more variables: 볼넷 &lt;dbl&gt;, 고4 &lt;dbl&gt;, HBP &lt;dbl&gt;, 삼진 &lt;dbl&gt;, 희플 &lt;dbl&gt;, # 희타 &lt;dbl&gt;, 병살 &lt;dbl&gt;, 도루 &lt;dbl&gt;, 도실 &lt;dbl&gt; 군집의 평균을 평행좌표계로 시각화해 보자. pivot_longer(cluster_means, -군집, names_to=&quot;변수&quot;, values_to=&quot;평균&quot;) %&gt;% ggplot() + geom_line(aes(변수, 평균, group=군집, color=군집, linetype=군집)) + coord_flip() 마지막으로 k-평균 군집화 때와 마찬가지로 군집의 사례를 파악할 수 있도록 14.2에서 소개한 주성분 분석을 사용하여 사례를 산점도로 표현하고 산점도에 군집을 표현해 보자. 한 명으로 이루어진 군집이 있어서 타원 추정이 어렵다는 정보가 출력될 것이다. batters_pca &lt;- prcomp(batters_scaled) ggbiplot(batters_pca, var.axes = F, # 변수 벡터 생략 labels=batters$선수명, groups=paste(&quot;군집&quot;, nc_all$Best.partition), # 군집 결과로 그룹화 ellipse=T, ellipse.alpha=0.1, ellipse.linewidth=0.5) + theme_bw() Too few points to calculate an ellipse k-평균 군집화와 크게 다른 점은 두 가지이다. “김도영” 선수가 홀로 군집을 이루고 있다. 최적 군집 수가 5 개가 아니라 4 개가 되었다. k-평균 군집 결과와 유사하게 군집 2는 중장거리 타자들의 그룹이고, 군집 3은 발빠른 타자들의 그룹, 군집 4는 출전 경기가 크지 않은 타자들의 그룹이다. 군집 1은 김도영 선수의 군집으로 발도 빠르고 중장거리포를 갖춘 드문 선수였음을 보여준다. References Berry, Michael J. A., and Gordon S Linoff. 2004. Data Mining Techniques: For Marketing, Sales, and Customer Relationship Management. 2nd ed. Wiley. Linoff, Gordon S, and Michael J. A. Berry. 2011. Data Mining Techniques: For Marketing, Sales, and Customer Relationship Management. 3rd ed. Wiley. "],["ch-R-hypothesis-tests.html", "Chapter 16 R 통계적 가설검정 16.1 가설검정이란? 16.2 R을 이용한 범주형 변수의 가설검점 16.3 수치형 변수에 대한 가설검정", " Chapter 16 R 통계적 가설검정 이 장은 R을 이용해 범주형 변수에 대한 통계적 가설검정을 하는 방법을 다룬다. 이 장의 내용은 졸저 R 을 이용한 통계분석의 가설검정이란? 장과 범주형 변수의 분석 사례 절의 내용을 근간으로 한다. 16.1 가설검정이란? 통계적 가설검정은 모집단의 특성에 대한 가설을 설정한 뒤에 표본관찰을 통하여 그 가설의 채택여부를 결정하는 통계적 분석방법이다. 예를 들어, 동전 던지기 게임을 하는데 “지금 게임에 사용되는 동전은 앞면과 뒷면이 나올 확률이 동일한 공정한 동전이다”라는 가설을 세웠다고 하자. 표본관찰을 위해 10번 동전을 던져 본 뒤 앞면이나 뒷면이 나오는 횟수를 세어서 이 가설이 적합한지를 판단하였다면 이는 통계적 가설검정을 수행한 것이다. 표본을 관찰해보니, 만약 동전이 공정한 것이라고 생각되기에는 너무 많은 앞면이나 뒷면이 나오면 가설을 기각하고, 그렇지 않은 경우에는 가설을 채택한다. 그림 16.1는 가설검정의 일반적인 절차를 보여준다. Figure 16.1: 가설검정의 절차 16.1.1 가설의 설정 보통 어떤 모집단에 대한 가설검정을 할 때 먼저 모집단에 대해 서로 대립되는 두 개의 가설을 설정한다. 위의 예에서는 동전이 공정한 것이다라는 가설과 동전이 편향되어 있다는 가설이 서로 대립되고 있다. 대립되는 두 가설 중 일반적으로 받아들여지는 가설을 귀무가설(null hypothesis)이라고 하고, 통계적으로 상당한 증거가 있어야만 받아들여지는 가설을 대립가설(alternative hypthesis)이라고 한다. 앞의 예에서는 상단한 증거가 없는 한 동전은 공정한 것이라고 판단하므로 이 가설이 귀무가설이 된다. 가설검정이란 표본관찰 또는 실험을 통하여 귀무가설(\\(H_0\\))과 대립가설(\\(H_1\\)) 중에서 하나를 선택하는 과정이다. 다음은 다양한 가설검정 문제에서 가설 수립을 한 예이다. Example 16.1 게임에 사용되는 동전이 있을 때, 앞면이 나올 확률을 \\(p\\)라고 하자. 동전의 앞면이 나올 확률에 대하여 다음과 같이 가설을 수립할 수 있다. \\(H_0\\): \\(p \\, = \\, 1/2\\) (게임에 사용되는 동전은 공정한 것이다.) \\(H_1\\): \\(p \\, \\neq \\, 1/2\\) (게임에 사용되는 동전은 편향된 것이다.) Example 16.2 2010 년 초등학교 4학년 학생의 평균신장이 142cm였다. 2020 년의 초등학교 4학년 학생의 신장의 평균을 \\(\\mu\\)라고 하자. 그러면 2020 년도의 초등학교 4학년의 평균 신장에 대하여 다음과 같이 가설을 수립할 수 있다. \\(H_0\\): \\(\\mu \\, = \\, 142\\) (2020년의 초등학교 4학년 학생의 평균신장도 142cm일 것이다.) \\(H_1\\): \\(\\mu \\, &gt; \\, 142\\) (2020년의 초등학교 4학년 학생의 평균신장도 142cm보다 클 것이다.) Example 16.3 타이어 제조사에서 새로운 공정을 도입하려고 한다. \\(\\mu_1\\)을 재래식 공정으로 제조된 타이어의 평균 수명, \\(\\mu_2\\)를 신규 공정으로 제조된 타이어의 평균 수명이라고 하자. 그러면 신규 공정으로 제조된 타이어의 평균 수명에 대하여 다음과 같이 가설을 수립할 수 있다. \\(H_0\\): \\(\\mu_1 \\, = \\, \\mu_2\\) (재래식 공정이나 신규 공정이나 타이어의 평균 수명은 동일할 것이다.) \\(H_1\\): \\(\\mu \\, &lt; \\, \\mu_2\\) (신규 공정으로 제조된 타이어의 평균 수명이 더 길 것이다.) 가설검정은 대립되는 두 가설 \\(H_0\\)와 \\(H_1\\) 중에서 하나를 선택하는 것이다. 그러므로 \\(H_0\\)를 채택(accept)하면 \\(H_1\\)를 기각(reject)하게 되고, \\(H_0\\)를 기각하면 \\(H_1\\)를 채택하게 된다. 16.1.2 검정통계량과 표본 분포 검정통계량(test statistic)은 \\(H_0\\) 와 \\(H_1\\) 중 어느 하나를 채택하는 데 사용되는 표본 통계량이다. 앞의 예에서는 동전을 10번 던져 나오는 앞면의 수 또는 뒷면의 수가 검정통계량이 될 수 있다. 검정통계량이 정해지면 귀무가설 \\(H_0\\)가 맞다는 가정 하에 검정통계량의 표본 분포를 구한다. 동전이 공정한지를 보는 Example 16.1 문제에서 검정통계량 \\(T\\)를 10 번 던져서 나온 앞면의 수라고 하였다고 하자. 그러면 귀무가설 하에서 검정통계량 \\(T\\)는 크기 \\(n=10\\)이고 성공 확률 \\(p=1/2\\)인 이항분포를 따르므로 다음과 같이 검정통계량의 표본 분포를 구할 수 있다. 앞면이 나온 횟수 확률 0 0.0009766 1 0.0097656 2 0.0439453 3 0.1171875 4 0.2050781 5 0.2460938 6 0.2050781 7 0.1171875 8 0.0439453 9 0.0097656 10 0.0009766 16.1.3 기각역과 유의수준 기각역(critical region)은 귀무가설이 기각되고 대립가설이 채택되는 검정통계량의 영역을 의미한다. 기각역은 유의수준 \\(\\alpha\\)에 의해 결정된다. 유의수준이란 귀무가설이 옳은데도 불구하고 이를 기각할 확률을 의미한다. 표본의 검정통계량 값이 매우 예외적인 값이 나왔다고 하자. 예를 들어 Example 16.1 에서 10번 동전을 던져서 앞면이 10번 나왔다고 하자. 귀무가설이 맞다는 가정 하에 10번 던졌을 때 모두 앞 면이 나올 확률은 0.000977로 매우 작다. 이러한 사건은 1,000 번 이러한 실험을 반복하면 1 번 정도 발생하는 예외적인 사건이다. 그러므로 통계적 가설검정에서는 귀무 가설이 참인데 이러한 예외적인 사건이 발생했다고 판단하기보다는, 귀무가설을 기각하고 동전이 공정하지 않다는 대립가설을 채택하는게 차라리 더 합리적이라고 판단한다. 기각역이란, 귀무가설이 참이라면 매우 예외적인 확률로 발생하는 검정통계량의 영역이어서 차라리 귀무가설을 기각하고 대립가설을 채택하는 구간이다. 그러나 검정통계량의 값이 기각역에 포함되는 사건이, 귀무 가설이 참이어도 예외적으로 발생할 수 있는 사건이지 전혀 발생하지 않는 사건은 아니기 때문에 귀무가설이 참인데도 귀무가설을 기각할 확률은 존재한다. 그리고 이 확률을 유의수준이라고 한다. 그러면 얼마나 예외적인 일이 발생해야 귀무가설을 기각하고 대립가설을 채택해야 할까? 일반적으로 유의수준 \\(\\alpha\\)를 5%로 정하지만, 문제에 따라 1%나 10%로 하는 경우도 있다. 유의수준 \\(\\alpha\\)가 5%이면, 귀무가설 하에서 구한 검정통계량의 값이 발생할 가능성이 5% 이하인 영역에서 발생했으면 귀무가설을 기각하고, 그렇지 않으면 귀무가설을 채택하겠다는 의미이다. 다시 말해 검정통계량이 발생할 가능성이 예외적인 5% 영역에서 발생하면 귀무가설이 맞을 ’가능성이 작다’라고 판단하겠다는 것이다. 기각역의 크기는 유의수준 \\(\\alpha\\)에 의해서 결정되지만 기각역의 위치는 대립가설에 의해 결정된다. 기각역의 위치가 검정통계량 값의 양측에 있으면 양측검정, 기각역의 위치가 한 쪽에 있으면 단측검정이라 한다. 양측검정(two-side test)은 귀무가설이 ’모수가 특정값이다’라고 할 때, 대립가설이 ’모수가 특정값이 아니다’라고 주어지는 경우에 발생한다. 단측검정(one-side test)은 왼쪽에 기각역이 생기는 왼쪽 단측검정과 오른쪽에 생기는 오른쪽 단측검정으로 나뉘어진다. 왼쪽 단측검정은 대립가설이 ’모수가 특정 값보다 작다’로 주어지는 경우에 발생한다. 오른쪽 단측검정은 대립가설이 ’모수가 특정 값보다 크다’로 주어지는 경우에 발생한다. Example 16.1는 대립가설이 동전의 앞면이 나올 확률이 \\(1/2\\)이 아니라는 것이다. 그러므로 동전의 앞면이 나올 확률이 너무 크거나 작은 경우 모두가 관심의 대상이다. 따라서 10번 던져서 앞면이 나오는 수를 \\(x\\)라고 하면, \\(x\\)가 너무 크거나 너무 작으면 대립 가설을 채택하게 된다. 따라서 유의수준 \\(\\alpha = 0.1\\)로 가설검정을 한다면 양측검정의 기각역은 다음 그림처럼 \\(x \\le 1\\) 또는 \\(x \\ge 9\\)가 된다. (기각역에 2와 8을 포함시키면 귀무가설이 참인데도 기각될 확률이 10%보다 커진다.) 그러나 만약 대립가설이 앞면이 나올 확률이 \\(1/2\\)보다 크다였다면 앞면이 예외적으로 많이 나온 경우만 대립가설을 채택, 즉 귀무가설을 기각하게 된다. 따라서 기각역의 위치는 동전의 앞면이 예외적으로 많이 나온 영역이 된다. 따라서 이 가설검정은 오른쪽 단측검정이 되고 유의 수준 \\(\\alpha = 0.1\\)에서 기각역은 다음 그림처럼 \\(x \\ge 8\\)이 된다. (기각역에 7을 포함시키면 귀무가설이 참인데도 기각될 확률이 10%보다 커진다.) 가설검정을 할 때, 가설검정은 항상 오류 가능성을 포함하고 있다는 것에 주의해야 한다. 가설검정에서 발생할 수 있는 오류에는 제1종 오류(\\(\\alpha\\))와 제2종 오류(\\(\\beta\\))의 두 가지 종류가 있다. 제1종 오류(type I error)는 귀무가설이 옳은데도 불구하고 귀무가설을 기각하는 오류이고 제2종 오류(type II error)는 귀무가설이 사실이 아님에도 귀무가설을 채택하는 오류이다. 다음 표는 귀무가설과 대립가설이 참일 때 귀무 가설과 대립 가설을 채택하는 것에 따라 발생할 수 있는 오류의 형태를 보여 준다. 사실 \\(H_0\\) 채택 \\(H_1\\) 채택 \\(H_0\\)가 참 옳은 결정 제1종 오류 \\(H_1\\)이 참 제2종 오류 옳은 결정 1종 오류가 발생할 확률은 유의수준 \\(\\alpha\\)이다. 그러면 2종 오류가 어떤 의미를 가지고 있는지 살펴보자. Example 16.1과 같은 동전의 앞면이 나올 확률 \\(p\\)에 대해 \\(p = 1/2\\)라는 귀무가설과 \\(p &gt; 1/2\\)라는 대립가설이 서로 대립하고 있다고 하자. 그러면 앞서 본 그림처럼 기각역은 유의 수준 \\(\\alpha = 0.1\\)에서 \\(x \\ge 8\\)이 된다. 만약 \\(p = 0.7\\)이어서 대립가설이 참이라고 하자. 그러면 \\(p = 0.7\\)인데도 귀무가설 \\(p = 1/2\\)가 채택될 확률, 즉, 2종 오류는 얼마일까? 이는 크기가 10이고 성공확률이 0.7인 이항분포를 사용하면 쉽게 계산할 수 있다. 다음 그림은 \\(p = 0.7\\)이 참일 때 귀무가설 \\(p = 1/2\\)가 채택될 확률을 보여주며, 이 확률은 61.7%로 매우 크다는 것을 알 수 있다. 동일한 검정통계량을 사용할 때 2종 오류를 줄이려면 표본 크기를 증가시켜야 한다. 동전 문제에서 표본 크기가 10개가 아니라 40 개로 증가시키면 더 많은 정보를 가지고 좀 더 정밀한 가설검정을 할 수 있어서 2종 오류가 11.5%로 감소하는 것을 볼 수 있다. 그런데 만약 실제 값이 \\(p \\neq 1/2\\)이지만 \\(p \\approx 1/2\\)로 귀무가설의 값과 매우 가깝다면 어떻게 될까? 표본의 크기를 매우 크게 늘려도 2종 오류가 잘 감소하지 않을 것이다. 그러므로 가설검정에서 귀무가설이 채택되었다 하더라도 대립가설이 참일 가능성이 없다고 판단해서는 안된다. 가설검정에는 항상 오류가 포함될 수 있기 때문이다. 따라서 귀무가설이 채택되었다는 의미는 표본에서 귀무가설이 기각될 만한 충분한 통계적 증가를 발견하지 못했다라고 판단해야 한다. 16.1.4 유의확률 p-값(p-value) 지금까지 살펴본 유의수준 \\(\\alpha\\) 값에 따라 기각역을 설정하고, 표본의 검정통계량이 기각역에 있는지에 따라 가설검정을 하는 방법은 유의수준 값이 달라질 때마다 이러한 절차를 반복해야 한다. 따라서 R, SPSS, SAS 등의 대부분의 통계 소프트웨어는 기각역을 계산하기 보다는 유의확률 p-값(p-value)을 계산하여 제공한다. 유의확률 p-값은 귀무가설이 참이라고 할 때 검정통계량의 값이 귀무 가설에 반하여 얼마나 예외적인 사건이었는지를 알려주는 지표이다. p-값의 정확한 정의는 검정통계량의 값이 귀무 가설에 반하여 현재의 값 정도나 그것보다 더 예외적인 값이 나올 확률이다. Example 16.1에서 10번 던진 결과 앞면이 2회 나왔다고 하자. 대립가설이 \\(1/2\\)가 아니라는 것이므로 귀무가설에 반하는 사건은 매우 적은 앞면이 나오거나 매우 많은 앞면이 나오는 것이다. 검정통계량이 귀무 가설에 반하여 현재의 값 정도나 그것보다 더 예외적인 값이 나오는 경우는 0, 1, 2 회로 매우 앞면이 적게 나오거나, 8, 9, 10회로 매우 앞면이 많이 나오는-뒷면이 0, 1, 2회로 적게 나오는-경우이다. 따라서 양측검정인 경우 p-값은 다음과 같다. \\[ \\text{p-value} = P(N = 0, 1, 2, 8, 9, \\text{ or } 10) = 0.109375 \\] 만약 대립가설이 \\(p &lt; 1/2\\)이었다면, 현재의 검정통계량 값 정도나 그보다 더 귀무가설에 반하여 대립 가설을 지지하는 경우는 앞면이 0, 1, 2회 나오는 것이다. 따라서 왼쪽 단측검정인 경우 p-값은 다음과 같다. \\[ \\text{p-value} = P(N = 0, 1, \\text{ or } 2) = 0.0546875 \\] 만약 대립가설이 \\(p &gt; 1/2\\)이었다면, 현재의 검정통계량 값 정도나 그보다 더 귀무가설에 반하여 대립 가설을 지지하는 경우는 앞면이 2부터 10회까지가 나오는 것이다. 따라서 오른쪽 단측검정인 경우 p-값은 다음과 같다. \\[ \\text{p-value} = P(N \\ge 2) = 0.9892578 \\] 실제 가설검정에서 그러한 결과가 나오는지 binom.test() 함수를 사용하여 확인해 보자. 결과에서 p-value로 표시된 값이 앞에서 계산한 확률값에 수렴하는 것을 볼 수 있다. binom.test(2, n = 10, p = 1/2, alternative = &quot;two.sided&quot;) Exact binomial test data: 2 and 10 number of successes = 2, number of trials = 10, p-value = 0.1094 alternative hypothesis: true probability of success is not equal to 0.5 95 percent confidence interval: 0.02521073 0.55609546 sample estimates: probability of success 0.2 binom.test(2, n = 10, p = 1/2, alternative = &quot;less&quot;) Exact binomial test data: 2 and 10 number of successes = 2, number of trials = 10, p-value = 0.05469 alternative hypothesis: true probability of success is less than 0.5 95 percent confidence interval: 0.0000000 0.5069013 sample estimates: probability of success 0.2 binom.test(2, n = 10, p = 1/2, alternative = &quot;greater&quot;) Exact binomial test data: 2 and 10 number of successes = 2, number of trials = 10, p-value = 0.9893 alternative hypothesis: true probability of success is greater than 0.5 95 percent confidence interval: 0.03677144 1.00000000 sample estimates: probability of success 0.2 따라서 p-값이 유의수준 \\(\\alpha\\)보다 크면 검정통계량의 값은 기각역 바깥에 놓이게 되고, p-값이 \\(\\alpha\\)보다 작거나 같으면 검정통계량은 기각역에 놓이게 된다. 그러므로 p-값이 작을수록 대부분의 유의수준에서 기각역에 포함되게 되므로 귀무 가설을 기각해야 하는 강한 증거가 된다. 대립가설이 \\(p &gt; 1/2\\)의 가설검정 결과를 보면 유의수준 5%로 가설검정한다면 p-값이 0.05보다 크므로 귀무가설을 채택하나, 유의수준 10%로 가설검정한다면 p-값이 0.1보다 작으므로 귀무가설을 기각한다. 16.2 R을 이용한 범주형 변수의 가설검점 이 절에서는 관절염 치료법의 임상시험 데이터를 사용하여 가설검정이 R에서 어떻게 수행되는지 살펴본다. 16.2.1 관절염 치료 임상시험 데이터 분석 다음 데이터는 Koch and Edwards(1988)가 새로운 관절염 치료법의 효과를 측정한 데이터이다. 이 데이터는 vcd라는 패키지에 Arthritis라는 이름으로 포함되어 있으므로, 먼저 Arthritis 데이터를 사용하기 위하여 vcd 패키지를 설치하자. install.packages(&quot;vcd&quot;) vcd 패키지가 적재한 후 다음 명령으로 Arthritis 데이터를 살펴보자. library(bizstatp) # bizstatp 패키지를 적재한다. Arthritis ID Treatment Sex Age Improved 1 57 Treated Male 27 Some 2 46 Treated Male 29 None 3 77 Treated Male 30 None 4 17 Treated Male 32 Marked 5 36 Treated Male 46 Marked 6 23 Treated Male 58 Marked 7 75 Treated Male 59 None 8 39 Treated Male 59 Marked 9 33 Treated Male 63 None ...... Arthritis 데이터는 크게 다음 5 개의 열로 구성되어 있다. ID: 환자의 ID Treatment: 환자에게 처치된 치료법 (Treated, Placebo) Sex: 환자의 성별 (Female, Male) Age: 환자의 나이 Improved: 치료 이루의 관절염 증상의 개선 정도 (None, Some, Marked) 이 데이터를 분석하여 다음과 같은 질문에 답을 해보자. 새로운 관절염 치료법은 아무 치료도 하지 않는 것보다 효과가 있는가? 새로운 치료법의 효과는 성별로 차이가 있는가? 본격적으로 질문에 답하기에 전에 summary() 함수로 전체 데이터에 대한 통계 요약을 해보자. 아래 결과를 보면, 이 임상시험에서 새로운 치료법을 받은(Treated) 환자와 플라시보(Placebo) 치료를 받은 환자의 수가 거의 비슷하였다. 또한 여자 환자의 수가 남자 환자의 수보다 2배 이상 많았고, 환자의 연령대는 23세부터 74세까지 있었다. 치료(플라시보 치료 포함) 후에 차도가 거의 없었던(None) 환자의 수는 약간(Some) 또는 확실히(Marked) 효과가 있었던 환자를 합친 수와 같았다. summary(Arthritis) ID Treatment Sex Age Improved Min. : 1.00 Placebo:43 Female:59 Min. :23.00 None :42 1st Qu.:21.75 Treated:41 Male :25 1st Qu.:46.00 Some :14 Median :42.50 Median :57.00 Marked:28 Mean :42.50 Mean :53.36 3rd Qu.:63.25 3rd Qu.:63.00 Max. :84.00 Max. :74.00 16.2.2 기술 통계 분석 본격적인 가설검정을 하기 전에 새로운 치료법이 증상의 개선에 도움이 되었는지 기술 통계 분석을 해 보자. 기술 통계 분석은 데이터를 수치, 표, 그래프 등으로 요약하여 탐색하는 것이다. 범주형 변수에 대한 기술 통계 분석은 다음의 도구가 주로 사용된다. 범주 별 발생 빈도에 대한 빈도표와 교차표(분할표) 범주 별 발생 빈도를 막대 그래프로 시각화 치료법(Treatment)에 따른 증상 개선 여부(Improved)에 차이가 있었는지를 살펴보기 위하여 두 범주형 변수에 대한 교차표를 구해보자. R에서 교차표를 구하는 방법은 여러 가지가 있다. 여기서는 xtabs() 함수를 사용하여 절대빈도 교차표를 구하도록 한다. xtabs()의 기본 문법은 다음과 같다. xtabs(~ 범주형_변수1 + 범주형_변수2, data=데이터프레임) 그러면 범주형_변수1을 행으로, 범주형_변수2를 행으로 절대빈도 교차표를 반환한다. 절대빈도 교차표에서 두 변수의 범주가 교차하는 셀은 두 범주를 모두 만족하는 관측치의 수가 된다. 다음은 Treatment를 행으로, Improved를 열로 하여 교차표를 생성한 것이다. 뒤의 가설검정에서 교차표를 사용할 것이므로 변수에 할당하도록 하자. tti &lt;- xtabs(~ Treatment + Improved, data = Arthritis) tti Improved Treatment None Some Marked Placebo 29 7 7 Treated 13 7 21 새로운 치료법을 받은 환자(Treated) 중에는 증상의 뚜렷한 개선(Marked)은 21 명으로 개선 없음의 7 명보다 많았다. 반면 위약 치료를 받은 환자(Placebo) 중에는 뚜렷한 개선은 7 명으로 개선 없음 29 명보다 적었다. 이를 좀더 정확히 살펴보기 위해 치료법에 따른 증상 개선의 상대적 비율(%)을 구해보자. 교차표의 상대적 비율을 확인할 때는 다음 문법을 사용한다. proportions(절대빈도_교차표, margin) margin=1이면 행 별 상대 빈도를 구한다. 즉, 행의 합이 1이 되도록 상대 빈도를 구한다. margin=2이면 열 별 상대 빈도를 구한다. 즉, 열의 합이 1이 되도록 상대 빈도를 구한다. margi이 설정되지 않으면 전체 관측도수를 1로 하여 상대 빈도를 구한다. 우리의 관심은 치료법에 따른 증상 개선의 상대적 비율이므로 다음처럼 행 별 상대 빈도를 구한다. proportions(tti, margin = 1) Improved Treatment None Some Marked Placebo 0.6744186 0.1627907 0.1627907 Treated 0.3170732 0.1707317 0.5121951 결과에서 플라시보 치료를 받은 환자의 약 67%가 증상 개선 없음이었는데, 새로운 치료법을 받은 환자는 약 32%만 개선 없음이었고, 51%는 뚜렷한 개선이 있었다. 물론 이러한 차이가 통계적으로 유의미한지는 다시 가설검정을 해보아야 한다. 가설검정 방법에 대해서는 뒤에 자세히 살펴보도록 하고, 치료법과 증상 개선에 대하여 막대그래프로 시각화해 보자. 치료법을 가로축으로 하여 막대 그래프 그리는데, 증상 개선을 나란한 막대 그래프로 그려 절대 빈도도 살펴보고 막대의 크기가 1로 되게 하여 상대적 빈도로도 그렸다. 상대적 빈도로 그린 두 막대를 비교해 보면 Marked인 환자의 비율이 Treated에서 더 많았음을 쉽게 확인할 수 있다. library(tidyverse) ggplot(Arthritis, aes(x = Treatment, fill = Improved)) + geom_bar(position = &quot;dodge&quot;) ggplot(Arthritis, aes(x = Treatment, fill = Improved)) + geom_bar(position = &quot;fill&quot;) 새로운 치료법이 성별로 차이가 있었는지를 살펴보기 위하여, 새로운 치료법을 처방받은 환자들에 한정하여 성별에 따른 증상 개선의 차이가 있었는지 분석해 보자. xtabs() 함수는 subset 인수가 있어서 논리값 벡터를 설정하면 논리값 벡터가 TURE 인 행만 사용하여 빈도표나 교차표를 만든다. 다음은 Treatment가 Treated인 관측대상만으로 Sex를 행으로, Improved를 열로 교차표를 만드는 예이다. tsi_treated &lt;- xtabs(~ Sex + Improved, data = Arthritis, subset = Treatment == &quot;Treated&quot;) tsi_treated Improved Sex None Some Marked Female 6 5 16 Male 7 2 5 성별로 증상 개선의 상대적 빈도를 계산해 보자. proportions(tsi_treated, margin = 1) Improved Sex None Some Marked Female 0.2222222 0.1851852 0.5925926 Male 0.5000000 0.1428571 0.3571429 여성이 남성보다 뚜렷한 증상 개선의 비율이 높은 것을 확인할 수 있다. 이를 막대그래프로 시각화해 보자. 성별 변수로 가로축으로하여 증상 개선을 나란한 막대 그래프와 상대적 빈도를 나타내는 막대 그래프로 나타내었다. Placebo와 Treated를 나누어 살펴보기 위하여 facet_wrap() 함수를 이용하여 Treatment로 측면 그래프를 그렸다. ggplot(Arthritis, aes(x = Sex, fill = Improved)) + geom_bar(position = &quot;dodge&quot;) + facet_wrap(~ Treatment) ggplot(Arthritis, aes(x = Sex, fill = Improved)) + geom_bar(position = &quot;fill&quot;)+ facet_wrap(~ Treatment) 막대 그래프에서 새로운 치료법을 적용하든 플라시보 치료법이든 여성이 남성에 비해 관절염의 증상 개선 효과가 더 좋은 경향을 보인다는 것을 볼 수 있다. 16.2.3 독립성 검정 독립성 검정은 두 범주형 변수가 독립인지 아닌지를 가설검정한다. 여기서 독립이란 한 범주형 변수의 값이 다른 범주형 변수의 분포에 영향을 미치지 않는다는 것을 의미한다. 독립성 검정의 귀무가설은 두 변수가 독립이라는 것이고, 대립가설은 두 변수가 독립이 아니라는 것이다. 관절염 치료법 문제에서 “새로운 관절염 치료법은 아무 치료도 하지 않는 것보다 효과가 있는가?” 라는 질문에 대한 귀무가설과 대립가설은 다음처럼 수립될 수 있다. Example 16.4 \\(H_0\\): 관절염 치료법은 증상 개선에 영향을 미치지 않는다. (치료법에 따른 증상 개선의 차이는 없다.) \\(H_1\\): 관절염 치료법은 증상 개선에 영향을 미친다. (치료법에 따른 증상 개선에 차이가 있다.) 독립성 검정에는 Pearson이 카이제곱 검정이 주로 사용된다. stat 패키지의 chisq.test(절대빈도_교차표) 함수는 카이제곱 검정을 수행한다. result &lt;- chisq.test(tti) result Pearson&#39;s Chi-squared test data: tti X-squared = 13.055, df = 2, p-value = 0.001463 가설검정 결과만 살펴보면 치료법에 따른 증상 개선 차이는 없다는 귀무가설에 대한 검정에서 p-값이 매우 작게 나와서 귀무가설이 기각된다. 따라서 치료법에 따라 증상 개선의 차이가 있었다는 대립가설을 채택하게 된다. 카이제곱 검정의 의미를 이해하기 위하여 카이제곱 검정 결과를 더 상세히 살펴보자. 카이제곱 검정을 이해하기 위하여 교차표에 대하여 다음 기호를 도입하자. 교차표의 행으로 설정된 범주형 변수에 \\(R\\)개의 범주가 있고, 열로 설정된 범주형 변수에 \\(C\\)개의 범주가 있다고 하자. (관절염 치료법의 예에서는 \\(R=2\\)(Treated, Placebo), \\(C=3\\)(None, Some, Marked)이다.) 그러면 두 범주형 변수와 관련된 교차표 또는 분할표는 \\(R \\times C\\) 행렬로 표현된다. 범주 1 2 \\(\\cdots\\) C 1 \\(x_{11}\\) \\(x_{12}\\) \\(\\cdots\\) \\(x_{1C}\\) 2 \\(x_{21}\\) \\(x_{22}\\) \\(\\cdots\\) \\(x_{2C}\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\ddots\\) \\(\\vdots\\) R \\(x_{R1}\\) \\(x_{R2}\\) \\(\\cdots\\) \\(x_{RC}\\) \\(n\\)을 전체 관측도수, \\(x_{ij}\\)를 셀 \\((i, j)\\)의 관측도수라고 하자. 모든 가설검정은 귀무가설이 맞다는 가정 하에 현재의 데이터가 나올 확률을 계산한다. Example 16.4의 귀무가설이 맞다면 Treated나 Placebo에 무관하게 증상 개선의 분포는 동일해야 하고, 이는 전체 데이터에서 증상 개선 비율과 유사해야 할 것이다. 카이제곱 검정 결과의 $expected 요소는 귀무가설 하에 셀 \\((i, j)\\) 의 기대도수 \\(E[X_{ij}]\\)를 제공한다. 단, \\(i\\)는 행 인덱스, \\(j\\)는 열 인덱스를 의미한다. result$expected Improved Treatment None Some Marked Placebo 21.5 7.166667 14.33333 Treated 20.5 6.833333 13.66667 각 셀의 기대도수의 행렬 상대 빈도를 계산해 보면 Treadted와 Placebo 모두 동일한 값이라는 것을 확인할 수 있고, 이는 전체 데이터의 Improved의 상대 빈도와 동일하다. result$expected %&gt;% proportions(margin=1) Improved Treatment None Some Marked Placebo 0.5 0.1666667 0.3333333 Treated 0.5 0.1666667 0.3333333 그러나 실제 관측치는 기대도수와 다르게 발생하였다. 카이제곱 검정은 $observed 요소는 셀 \\((i,j)\\)의 관측도수 \\(x_{ij}\\)를 제공한다. result$observed Improved Treatment None Some Marked Placebo 29 7 7 Treated 13 7 21 카이제곱 검정에서는 기대도수 대비 관측도수와 기대도수가 얼만큼 차이가 있는지에 대한 Pearson 잔차를 다음과 같이 계산한다. \\[ \\frac{ x_{ij} - E[x_{ij}] }{ \\sqrt{ E[x_{ij}] } } \\] 그리고 카이제곱 검정 결과의 $residuals 요소는 이 값을 계산한 결과이다. result$residuals Improved Treatment None Some Marked Placebo 1.61749160 -0.06225728 -1.93699199 Treated -1.65647289 0.06375767 1.98367320 다음은 $residuals 결과가 앞서 소개한 수식의 결과와 같은지를 확인하기 위하여 기대도수와 관측도수를 이용하여 Pearson 잔차를 직접 계산한 결과이다. (result$observed - result$expected) / sqrt(result$expected) Improved Treatment None Some Marked Placebo 1.61749160 -0.06225728 -1.93699199 Treated -1.65647289 0.06375767 1.98367320 Pearson은 다음과 같은 검정통계량 \\(X^2\\)이 근사적으로 자유도 \\((R-1) (C-1)\\)의 카이제곱 분포를 따른다는 것을 보였다. 검정통계량 \\(X^2\\)은 관측도수가 귀무가설 하의 기대도수에서 얼만큼 벗어났는지를 측정한다. \\[ X^2 = \\sum_{i=1}^{R} \\sum_{j=1}^{C} \\frac{[x_{ij} - E(x_{ij})]^2}{E(x_{ij})} \\sim \\chi^2_{(R-1)(C-1)}. \\] 카이제곱 검정은 $statistics 요소는 검정통계량 \\(X^2\\)을 계산한 것이다. result$statistic X-squared 13.05502 이를 $residuals를 이용하여 직접 계산해도 동일한 결과를 얻는 것을 확인할 수 있다. sum(result$residuals^2) [1] 13.05502 그리고 $p.value는 카이제곱 분포를 따를 때 검정통계량이 얼만큼 예외적인 확률인지에 대한 p-값을 보여준다. p-값이 매우 작다는 것은 귀무가설 하에서 매우 예외적인 확률의 사건이 발생한 것이므로 귀무가설을 기각하게 된다. result$p.value [1] 0.001462643 이 값은 실제 카이제곱 분포를 사용하여도 계산할 수 있다. 관절염 치료법의 교차표는 \\(R=2\\), \\(C=3\\)이므로 검정통계량의 카이제곱 분포의 자유도는 \\(2\\)이다. 카이제곱 검정 결과의 $parameter는 검정통계량이 따르는 카이제곱 분포의 자유도 정보를 제공한다. result$parameter df 2 그리고 카이제곱 분포에서 검정통계량보다 같거나 큰 오른쪽 꼬리 부분의 확률은 앞의 p-값과 동일하다. pchisq(result$statistic, df=result$parameter, lower.tail=F) X-squared 0.001462643 독립성 검정에서 귀무가설이 기각된 후에는, 과연 어떤 셀이 기대도수에 비해 크게 벗어나서 귀무가설이 기각되었는지를 탐색해 볼 수 있다. 각 셀의 기대도수는 크기가 다르므로 다음처럼 표준화된 잔차를 사용하여 관측도수와 기대도수의 차이를 계산할 수 있다. \\[ \\frac{ x_{ij} - E[x_{ij}] }{ SE( x_{ij} - E[x_{ij}]) } \\] 그러면 표준화된 잔차는 표본이 커지면 근사적으로 표준정규분포를 따르므로 셀들의 관측도수가 기대도수 대비 얼만큼 벗어났는지를 동일한 스케일로 비교할 수 있다. 카이제곱 검정 결과의 $stres 요소는 각 셀의 표준화된 잔차 정보를 제공한다. result$stdres Improved Treatment None Some Marked Placebo 3.27419655 -0.09761768 -3.39563632 Treated -3.27419655 0.09761768 3.39563632 이 예에서 보듯이 Placebo는 None이 기대도수에 비해 매우 크고 Marked는 기대도수에 비해 매우 작았고, Treated는 None이 기대도수에 비해 매우 작고 Marked는 기대도수에 비해 매우 컸다. 관절염 치료법 문제에서 “새로운 치료법의 효과는 성별로 차이가 있는가?” 라는 질문에 대한 귀무가설과 대립가설은 다음처럼 수립될 수 있다. Example 16.5 \\(H_0\\): 관절염 치료법은 성별에 따라 증상 개선의 차이는 없다. \\(H_1\\): 관절염 치료법은 성별에 따라 증상 개선에 차이가 있다. 첫 번째 질문과 마찬가지로 두 범주형 변수의 독립성에 대한 검정이므로 Pearson이 카이제곱 검정을 사용해 보자. result &lt;- chisq.test(tsi_treated) Warning in chisq.test(tsi_treated): 카이제곱 approximation은 정확하지 않을수도 있습니다 result Pearson&#39;s Chi-squared test data: tsi_treated X-squared = 3.3382, df = 2, p-value = 0.1884 검정을 할 때 경고가 출력되는 것을 볼 수 있다. 카이제곱 검정은 셀의 기대도수가 5 이상이어야 검정통계량이 근사적으로 카이제곱분포를 따르는데, 이 문제에서는 셀의 기대도수가 5가 아닌 셀이 있다는 경고이다. 귀무가설 하에 각 셀의 기대도수를 출력해 보면, 5 이하인 셀이 세 개나 있는 것을 확인할 수 있다. result$expected Improved Sex None Some Marked Female 8.560976 4.609756 13.829268 Male 4.439024 2.390244 7.170732 기대도수가 5 미만인 셀이 있으면 초기하분포를 사용하는 Fisher의 Exact Test를 하여 가설검정하는 것이 좋다. Fisher의 Exact Tests는 초기하분포를 사용하여 근사가 아니라 정확한 분포를 사용하여 독립성에 대한 가설검정을 수행한다. stat의 fisher.test() 함수는 Fisher Test를 수행해 준다. fisher.test(tsi_treated) Fisher&#39;s Exact Test for Count Data data: tsi_treated p-value = 0.2204 alternative hypothesis: two.sided p-값이 10%보다도 커서 귀무가설 하에도 충분히 발생할 수 있는 데이터라는 것을 확인할 수 있다. 따라서 우리는 성별에 따른 증상 개선의 차이에 대한 충분한 통계적 증거를 찾지 못했으므로, ’새로운 치료법은 성별에 따른 증상 개선의 차이는 없다’는 귀무가설을 받아들인다. R을 이용한 범주형 변수의 가설검정에 대하여 더 상세한 내용을 알고자 하는 독자는 졸저 R 을 이용한 통계분석의 범주형 변수에 대한 가설검정 장을 더 참고하기 바란다. 16.3 수치형 변수에 대한 가설검정 R을 이용한 수치형 변수에 대한 가설검정에 대해서는 졸저 R 을 이용한 통계분석의 수치형 변수에 대한 가설검정 장과 분산 분석 장을 참고하기 바란다. "],["ch-RandPython.html", "A R과 Python 연동하기 A.1 reticulate 설치 및 사용할 파이썬 버전 설정 A.2 R과 파이썬 연동하는 방법 A.3 파이썬 모듈 연동하기 A.4 R 마크다운 문서에서 파이썬 명령 실행하기", " A R과 Python 연동하기 R의 reticlate 패키지를 사용하면 R과 Python을 쉽게 연동시킬 수 있다. reticulate 패키지는 다음 세 가지 기능을 수행한다. R에서 Python을 호출하는 기능: R 스크립트, R 마크다운 문서, R 세션 중간에 파이썬 스크립트나 파이썬 모듈을 호출할 수 있다. R과 Python 객체 간의 상호 변환: R의 데이터프레임과 파이썬의 Pandas 데이터프레임, R의 행렬/배열과 파이썬 Numpy 배열을 상호 변환해 준다. Python의 다양한 설치 환경과의 연동: 시스템 내에는 다양한 버전의 파이썬이 존재할 수 있다. reticulate는 가상 환경(virtual environments)이나 콘다 환경(Conda environments)의 파이썬 버전 등과 연동할 수 있다. 다음 설명은 이미 시스템에 파이썬이 설치되어 있고 독자가 파이썬에 대한 기본 지식을 가지고 있다고 가정한다. 파이썬은 다양한 형식으로 설치가 가능한데, 콘다 환경을 사용하면 독립적인 파이썬 환경을 구축하기 편리하다. 파이썬 설치에 대해서는 인터넷 등에서 관련 정보를 찾아보기 바란다. A.1 reticulate 설치 및 사용할 파이썬 버전 설정 다음 명령이나 RStudio 패키지 탭을 이용하여 reticulate 패키지를 설치한다. install.packages(&#39;reticulate&#39;) 설치가 잘 되었으면 reticulate 패키지를 적재해 보자. library(reticulate) 하나의 시스템에는 여러 버전의 파이썬이 설치되어 있는 경우가 자주 있다. 그렇다면 reticulate는 시스템 내의 어떤 버전의 파이썬과 연동을 하게 될까? reticulate는 다음처럼 파이썬에서 사용할 모듈을 import() 함수로 호출한다. np &lt;- import(&quot;numpy&quot;) reticulate는 맨 처음 import 되는 모듈을 시스템 내에 설치된 파이썬 버전들에서 차례로 검색하고, 해당 모듈이 맨 처음 발견된 파이썬 버전과 연동을 한다. 그리고 이후의 R에서의 파이썬 호출은 최초로 연동된 파이썬 버전에서 계속 수행하게 된다. 만약 해당 모듈이 여러 곳의 파이썬 버전에 존재한다면 어떻게 될까? reticulate는 파이썬 모듈을 찾을 때 다음 순서로 파이썬 버전을 검색한다. 사용자가 만약 시스템에 RETICULATE_PYTHON 환경 변수를 설정해 두었다면, 환경 변수에 설정된 경로에 설치된 파이썬에서 가장 먼저 모듈을 검색한다. .Rprofile에 해당 환경 변수를 설정하려면 다음 명령처럼 설정을 한다. (그러나 이는 경직된 형태로 파이썬 검색 순서를 지정한 것이므로 일반적 상황에서는 권장되지 않는다.) Sys.setenv(RETICULATE_PYTHON = &quot;경로&quot;) 사용자가 use_python(), use_vertualenv(), 또는 use_condaenv()를 사용하여 설정한 파이썬 버전을 그 다음으로 검색한다. use_python()은 파이썬이 설치된 경로를 지정할 때, use_vertualenv()나 use_condaenv()는 설치되어 있는 가상 환경이나 콘다 환경이 사용되도록 지정할 때 사용한다. use_python(&quot;경로&quot;) use_virtualenv(&quot;~/가상-환경-이름&quot;) use_condaenv(&quot;콘다-환경-이름&quot;) use_condaenv()에서 콘다 설치가 여러 개인 경우에는 특정 콘다 설치 경로를 지정하여 원하는 콘다 환경을 찾을 수 있다. use_condaenv(&quot;콘다-환경-이름&quot;, conda = &quot;콘다-설치-경로&quot;) 그런데 use 함수들은 파이썬 버전을 찾을 힌트를 제공하는 것이지 실제 파이썬 버전을 찾는 작업을 수행하지는 않는다. 그러므로 지정된 경로나 환경이 없어도 해당 명령은 오류가 발생하지 않는다. 만약 해당 파이썬 버전이 있는지 확인하려면 use 함수에 required=TRUE 인수를 추가하여 실행한다. 그러면 해당 파이썬 버전이 실제 존재하지 않으면 오류가 발생한다. 사용자가 사용할 파이썬 버전을 환경 변수나 use 함수로 설정하지 않았으면, reticulate는 다음으로 사용자의 파이썬 가상 환경이나 콘다 환경을 검색한다. 가상 환경과 콘다 환경이 발견되면, 가상 환경과 콘다 환경에서 해당 모듈을 검색한다. 다음으로 사용자 시스템 경로(PATH) 상의 파이썬 설치 위치를 검색한다. 시스템 경로에서 발견되는 파이썬이 어디에 설치되어 있는지를 확인하려면 다음 명령을 수행한다. 사용자의 시스템의 종류와 설치 방법에 따라 출력 결과는 서로 다를 수 있다. Sys.which(&quot;python&quot;) python &quot;/home/sys4ppl/miniforge3/bin/python&quot; 마지막으로 사용자들이 파이썬을 주로 설치하는 일반적인 경로를 검색하여 파이썬 버전을 찾아 해당 모듈을 검색한다. 파이썬 모듈을 import 할 때 어떤 버전의 파이썬이 먼저 검색는지를 확인하려면 다음 명령을 사용한다. py_discover_config() python: /home/sys4ppl/miniforge3/bin/python libpython: /home/sys4ppl/miniforge3/lib/libpython3.12.so pythonhome: /home/sys4ppl/miniforge3:/home/sys4ppl/miniforge3 version: 3.12.7 | packaged by conda-forge | (main, Oct 4 2024, 16:05:46) [GCC 13.3.0] numpy: [NOT FOUND] NOTE: Python version was forced by RETICULATE_PYTHON_FALLBACK 시스템에 하나 이상의 파이썬이 설치되어 있다면, 실행의 일관성을 확보하기 위하여 use 함수들을 사용하여 사용할 파이썬 버전을 지정할 것을 권장한다. 다음은 dm이라는 콘다 환경에서 파이썬 모듈을 먼저 찾도록 하는 명령이다. use_condaenv(&quot;r-programming&quot;) A.2 R과 파이썬 연동하는 방법 R에서 파이썬을 연동하는 방법은 크게 다음 4 가지 방법이 있다. R 마크다운 문서에서 파이썬 명령 실행하기: R 마크다운의 파이썬 엔진이 마크다운 문서 전 범위에서 하나의 파이썬 세션으로 R 마크다운에 기술된 파이썬 명령문을 실행시킨다. 그리고 파이썬 세션의 결과를 R로, R 세션의 결과를 파이썬으로 주고 받을 수 있다. 파이썬 모듈을 R 세션에서 연동하기: import() 함수로 파이썬 모듈을 R에 연동시켜서 R에서 직접 파이썬 모듈의 함수를 호출하여 결과를 받을 수 있다. 파이썬 스크립트 실행하기: source_python() 함수를 사용하여 R 세션에서 파이썬 스크립트를 실행할 수 있다. 그러면 파이썬 명령문을 통해 생성된 파이썬 함수와 객체를 R 세션에서 사용할 수 있다. 파이썬 REPL 실행하기: repl_python() 함수를 사용하여 R 내에서 대화형으로 파이썬 콘솔 환경을 생성할 수 있다. 이 경우에도 R 세션과 파이썬 세션은 서로 객체를 주고 받을 수 있다. A.3 파이썬 모듈 연동하기 import() 함수를 사용하면 파이썬 모듈을 호출할 수 있다. 호출된 모듈은 R 변수에 할당하여야 해당 파이썬 모듈을 사용할 수 있다. 다음은 Numpy 모듈을 R에서 연동시킨 예이다. library(reticulate) np &lt;- import(&quot;numpy&quot;) 연동된 모듈이 제공하는 함수나 객체는 $ 연산자를 사용하여 이용할 수 있다. 다음은 Numpy 모듈의 full() 함수를 이용하여 1로만 이루어진 \\(3 \\times 3\\) 배열을 만든 예이다. np$full(shape = c(3L,3L), fill_value = 1L) [,1] [,2] [,3] [1,] 1 1 1 [2,] 1 1 1 [3,] 1 1 1 이 때 주의해서 이해해야 하는 것은 위의 np$full() 함수의 실제 기능은 Numpy 모듈의 full()이라는 파이썬 함수가 제공하고, np$full() 함수는 R의 껍데기 함수라는 것이다. import() 함수로 파이썬 모듈을 연동시키면 파이썬의 함수와 객체와 연동되는 R의 껍데기 함수와 객체가 생성된다. R 세션에서는 파이썬 함수에 직접 접근하는 방법은 없으며, 이 껍데기 함수와 객체를 통해서 파이썬의 함수와 객체에 접근하게 된다. (Figure A.1 참조) Figure A.1: R에서 Python 함수의 호출 따라서 np$full() 함수를 호출할 때는 R 형식의 인수를 제공해야 하지, Python 형식의 데이터를 입력해서는 안 된다. 원래 Numpy의 full() 함수는 shape 인수에 정수나 정수의 시퀀스(sequence) 형식의 데이터를 입력하여야 한다. 다음은 파이썬에서의 원래 명령문과 실행 결과를 보여준다. import numpy as np np.full(shape = (3,3), fill_value = 1) array([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 그러나 np$full() 함수는 R 함수이므로 shape 인수에 파이썬의 정수 형식이나 정수의 시퀀스 형식에 대응하는 R 형식 데이터를 입력하여야 한다. 그러면 reticulate는 R 형식의 인수를 파이썬 형식의 데이터로 변환하여 파이썬의 np.full() 함수를 호출한다. 그리고 다시 파이썬의 np.full() 함수가 Numpy 배열 형식으로 데이터를 반환하면 reticulate는 Numpy 배열에 대응되는 R 형식인 행렬 또는 배열로 변환하여 R 세션에 결과를 전달한다. A.3.1 R과 Python의 형식 변환 R과 파이썬은 reticulate를 통하여 다음처럼 형식 변환된다. R Python R에서의 예 요소가 하나인 벡터 스칼라 1, 1L, TRUE, \"foo\" 요소가 둘 이상인 벡터 리스트 c(1, 2, 3), c(1L, 2L) 여러 형식을 포함한 리스트 튜플 list(1L, TRUE, \"foo\") 이름이 있는 리스트 딕셔너리 list(a = 1L, b = 2) 행렬/배열 Numpy 배열 matrix(1:4, nrow=2, ncol=2) 데이터프레임 Pandas 데이터프레임 data.frame(x=1:4, y=LETTERS[1:4]) 함수 함수 function(x) x+1 Raw 바이트 배열 as.raw(1:10) NULL, TRUE, FALSE None, True, False NULL, TRUE, FALSE 만약 사용자가 정의한 클래스의 파이썬 객체가 전달되어야 하면, 해당 객체의 R 참조자가 반환된다. 그러면 R에서 파이썬 모듈에 접근할 수 있는 것과 유사한 방법으로 파이썬 객체의 메쏘드와 속성을 R 참조자 객체를 이용하여 접근할 수 있다. A.3.1.1 정수 형식의 데이터 변환의 주의점 그런데 이러한 자동 형 변환에서 주의해야 할 점이 있다. R에서는 숫자 데이터는 정수나 실수나 모두 double 형식으로 자동으로 변환되어 처리하는 경우가 많다. 예를 들어 다음처럼 3이라는 정수 두 개로 이루어진 벡터는 정수로 처리되는 것이 아니라 부동소수점 형식인 double로 데이터가 처리된다. a &lt;- c(3, 3) typeof(a) [1] &quot;double&quot; 그런데 파이썬에서는 정수 형식과 실수 형식의 데이터를 엄격하게 구별하여 처리한다. 따라서 파이썬 함수에서 정수 값이 인수이여야 하는 곳에 무심코 다음 같이 R 데이터를 입력하면 파이썬에서 함수가 실행될 때 데이터 형식이 맞지 않아 오류가 발생한다. # 오류: 파이썬 함수의 integer 인수일 때 형변환에 주의 np$full(shape = c(3,3), fill_value = 1) &#39;float&#39; object cannot be interpreted as an integer 그렇기 때문에 앞에서 np$full() 함수의 shape 인수를 부여할 때, 3L로 정수형 데이터임을 명시적으로 표현하였다. 그러면 R도 형변환이 필요하기 전까지는 이 값을 double 형식이 아니라 integer 형식으로 저장하고 처리한다. b &lt;- c(3L, 3L) typeof(b) [1] &quot;integer&quot; np$full(shape = b, fill_value = 1L) [,1] [,2] [,3] [1,] 1 1 1 [2,] 1 1 1 [3,] 1 1 1 A.3.1.2 리스트, 튜플, 딕셔너리 형식으로 변환할 때 주의점 자동 형 변환에서 또 하나 주의할 점은 파이썬에서 리스트나 튜플을 인수로 원할 때이다. 파이썬에 정수 하나로 이루어진 리스트나 튜플을 전달한다고 하자. 파이썬에서는 정수 자체와, 정수 하나로 이루어진 리스트와 튜플은 서로 다른 형식의 데이터이다. type(1) &lt;class &#39;int&#39;&gt; type([1]) &lt;class &#39;list&#39;&gt; type((1,)) &lt;class &#39;tuple&#39;&gt; 그러나 R에서는 스칼라 형식은 없으므로 정수 하나도 모두 벡터로 표현된다. 그런데 파이썬에서는 스칼라 형식이 매우 자주 사용되므로 R의 요소 하나짜리 벡터는 모두 해당 형식의 스칼라로 자동 변환된다. 그러므로 반드시 파이썬의 리스트나 튜플 형식으로 데이터를 전달하려면 다음처럼 R의 리스트와 reticulate의 tuple() 함수를 사용한다. 다음에 사용된 r_to_py() 함수는 R 객체를 파이썬 객체로 변환하는 함수이다. a &lt;- r_to_py(1L); class(a) [1] &quot;python.builtin.int&quot; &quot;python.builtin.object&quot; a &lt;- r_to_py(list(1L)); class(a) [1] &quot;python.builtin.list&quot; &quot;python.builtin.object&quot; a &lt;- r_to_py(tuple(1L)); class(a) [1] &quot;python.builtin.tuple&quot; &quot;python.builtin.object&quot; R의 이름 붙은 리스트는 파이썬의 딕셔너리로 잘 변환이 된다. 그러나 R의 리스트는 요소의 이름으로 문자열만 사용할 수 있는 반면, 파이썬의 딕셔너리의 키 값은 더 복잡한 불변하는 객체가 될 수 있다. 따라서 R에서 좀 더 복잡한 파이썬 딕셔너리를 인수로 전달하고자 하면, reticulate의 dict() 함수를 사용한다. a &lt;- list(year=3, major=&quot;me&quot;, name=&quot;홍길동&quot;); class(a) [1] &quot;list&quot; a $year [1] 3 $major [1] &quot;me&quot; $name [1] &quot;홍길동&quot; b &lt;- r_to_py(a); class(b) [1] &quot;python.builtin.dict&quot; &quot;python.builtin.object&quot; b {&#39;year&#39;: 3.0, &#39;major&#39;: &#39;me&#39;, &#39;name&#39;: &#39;홍길동&#39;} a &lt;- dict(name = &quot;홍길동&quot;); class(a) [1] &quot;python.builtin.dict&quot; &quot;python.builtin.object&quot; a {&#39;name&#39;: &#39;홍길동&#39;} 아울러 R은 벡터와 리스트 등의 인덱싱이 1부터 시작하지만, 파이썬의 리스트, 튜플 등의 시퀀스 객체는 0부터 인덱싱이 시작하니 이러한 차이에 주의하여야 한다. A.3.2 형변환 직접 하기 reticulate의 기본 설정은 파이썬 객체를 R 세션으로 전달할 때 대응되는 R 객체로 자동 변환한다. 만약 파이썬 객체를 R 객체로 자동 변환하지 않고, 파이썬 객체의 R 참조자를 반환하게 하려면 import() 함수에 convert=FALSE 인수를 전달한다. 그러면 파이썬의 결과는 모두 R 참조자로 전달되므로, R에서 전달된 참조자로 다시 파이썬 객체의 메쏘드 등을 실행할 수 있다. 마지막에 R로서 결과를 확인하려면 py_to_r() 함수를 사용하여 R 참조자가 참조하는 파이썬 객체를 R 객체로 변환하여야 한다. np &lt;- import(&quot;numpy&quot;, convert=FALSE) a &lt;- np$array(1:4) a # 파이썬 객체의 R 참조자 array([1, 2, 3, 4]) class(a) [1] &quot;numpy.ndarray&quot; &quot;python.builtin.object&quot; a_max &lt;- a$max() # Numpy 배열의 max 메쏘드 호출 a_max # 파이썬 객체의 R 참조자 np.int64(4) a_max + 1 # R 객체가 아니므로 R 연산은 오류 발생 np.float64(5.0) py_to_r(a_max) + 1 [1] 5 A.3.3 파이썬 모듈의 도움말 확인하기 py_help() 함수를 사용하면 파이썬 객체에 대한 도움말을 확인할 수 있다. py_help(np$full) A.3.4 pickle 사용하기 파이썬에서는 객체들을 바이너리 형식으로 저장할 때 pickle 모듈을 자주 사용한다. 파이썬 모듈의 결과를 파이썬 객체 형식으로 파일에 저장하거나, 이미 파이썬에서 작업하여 바이너리 형식으로 저장된 데이터를 읽어오려면 py_save_object()와 py_load_object() 함수를 사용한다. 읽어들인 파이썬 객체가 자동으로 R 객체로 형변환된 것을 확인할 수 있다. a &lt;- np_array(1:4, dtype=&quot;int64&quot;) # 파이썬 Numpy 배열의 R 참조자 a array([1, 2, 3, 4]) py_save_object(a, filename = &quot;a.p&quot;) # 파이썬 객체 저장 b &lt;- py_load_object(filename = &quot;a.p&quot;) # 저장된 파이썬 객체 읽어오기 b [1] 1 2 3 4 A.4 R 마크다운 문서에서 파이썬 명령 실행하기 R 마크다운 문서는 일반적으로 마크다운으로 형식화된 문서 정보와 R 명령 모듬(chunks)으로 구성된다. R 마크다운 문서를 직조(knitting)하면 R 명령문 모듬이 실행되어 그 결과가 문서의 다른 부분과 결합하여 문서가 동적으로 완성된다. R 마크다운 문서에는 R 명령 모듬뿐 아니라 Python 명령 모듬도 포함시킬 수 있다. 그러면 reticulate의 파이썬 엔진이 파이썬 명령 모듬을 실행하여 문서에 포함되도록 한다. reticulate의 파이썬 엔진의 주요 기능은 다음과 같다. R 마크다운을 직조하는 하나의 R 세션 안에 포함된 파이썬 세션을 만들고, 이 하나의 파이썬 세션에서 파이썬 명령 모듬을 실행시킨다. 파이썬 명령 모듬의 파이썬 실행 결과를 적절한 형식으로 출력하여 문서에 포함시킨다. 특히 파이썬의 numpy, pandas, matplotlib 모듈의 그래프 결과를 적절한 형식으로 처리하여 출력한다. R 세션에서 파이썬 모듬에서 생성한 객체를 접근할 수 있도록 해 준다. R 세션에 py라는 객체가 생성되어 py$x 형식으로 파이썬 세션에 생성된 x 객체에 대한 참조자를 제공한다. 파이썬 세션에서 R 모듬에서 생성한 객체 접근할 수 있도록 해 준다. 파이썬 세션에 r이라는 객체가 생성되어 r.x 형식으로 R 세션에 생성된 x 객체에 대한 참조자를 제공한다. 아울러 파이썬 세션에 R 객체가 전달될 때, R 세션에 파이썬 객체가 전달될 때 상호 자동 변환이 이루어진다. 다음은 R의 ggplot 패키지의 mpg 데이터를 파이썬 모듬에 전달하여 그래프를 그리고 통계 요약한 후, 그 결과를 다시 R로 보내서 출력한 예이다. # R 모듬 1 library(ggplot2) mpg # A tibble: 234 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… 3 audi a4 2 2008 4 manu… f 20 31 p comp… 4 audi a4 2 2008 4 auto… f 21 30 p comp… 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… 8 audi a4 quattro 1.8 1999 4 manu… 4 18 26 p comp… 9 audi a4 quattro 1.8 1999 4 auto… 4 16 25 p comp… 10 audi a4 quattro 2 2008 4 manu… 4 20 28 p comp… # ℹ 224 more rows # 파이썬 모듬 1 import matplotlib.pyplot as plt r.mpg.plot(x = &quot;displ&quot;, y = &quot;hwy&quot;, kind = &quot;scatter&quot;) # 배기량 vs. 고속도로연비 산점도 plt.show() mean_cty_per_class = r.mpg.groupby([&#39;class&#39;])[&#39;cty&#39;].mean() # 종류별 도심연비 평균 계산 mean_cty_per_class class 2seater 15.400000 compact 20.127660 midsize 18.756098 minivan 15.818182 pickup 13.000000 subcompact 20.371429 suv 13.500000 Name: cty, dtype: float64 # R 모듬 2 barplot(py$mean_cty_per_class) 2024년 10월 현재 R 마크다운에서 파이썬의 matplotlib로 그래프를 그릴 때 다음과 같은 오류가 발생할 때가 있다. libtiff.so.6: undefined symbol: jpeg12_write_raw_data, version LIBJPEG_8.0 만약 이러한 오류가 발생하면 해결책 중 하나는 libtiff를 다음처럼 4.5.1 버전으로 낮추는 것이다. conda를 사용하고 있다면 R과 연동되는 가상환경에서 다음 명령을 수행한다. conda install -c conda-forge libtiff=4.5.1 이에 대한 좀 더 자세한 논의는 conda-forge의 libtiff 관련 이슈 논의를 참조한다. "],["ch-RTips.html", "B R 관련 여러 주제들 B.1 R의 파일 및 폴더 관련 명령어등 B.2 R에서 계산 정확도를 향상시키기", " B R 관련 여러 주제들 이 장에서는 하나의 장으로 독립적으로 다루기에는 잡다한 R 관련 주제를 다룬다. B.1 R의 파일 및 폴더 관련 명령어등 B.1.1 작업 디렉토리 6.6 절에서 설명한 바와 같이 R은 파일을 읽거나 쓸 때 상대 경로를 제공하면 작업 디렉토리(working directory)로 설정된 폴더를 기준으로 파일의 위치를 결정한다. 현재의 작업 디렉토리를 확인하려면 다음 명령을 수행한다. getwd() [1] &quot;/home/sys4ppl/Dropbox/Work/Writing/R-programming-3rd&quot; 어떤 폴더를 작업 디렉토리로 설정하려면 다음처럼 setwd(폴더_절대경로)로 설정한다. 다음은 현재의 작업 디렉토리 밑의 source라는 폴더를 작업 디렉토리로 설정한 예이다. setwd(file.path(getwd(), &quot;src&quot;)) getwd() [1] &quot;/home/sys4ppl/Dropbox/Work/Writing/R-programming-3rd/src&quot; B.1.2 폴더 내의 파일 목록 확인하기 현재의 작업 디렉토리 안에 있는 파일과 하위폴더 목록은 다음처럼 확인한다. list.files() [1] &quot;README.txt&quot; &quot;script-ex.R&quot; &quot;test&quot; 작업 디렉토리 이외의 폴더의 파일과 하위폴더 목록을 확인하려면 path=폴더_절대경로 인수를 사용한다. 다음은 현재의 작업 디렉토리에 test 하위폴더가 있는 경우에 이 하위폴더의 파일 목록을 확인하는 예이다. list.files(path=file.path(getwd(), &quot;test&quot;)) [1] &quot;script-ex-test.R&quot; &quot;test-result&quot; pattern 인수를 사용하면 정규식 표현을 사용하여 특정 형식의 파일이름을 가진 파일의 목록만 확인할 수 있다. 작업 디렉토리에서 파일의 확장자가 .R인 파일을 나열해 보자. list.files(pattern = &quot;\\\\.R$&quot;) [1] &quot;script-ex.R&quot; 현재 폴더뿐 아니라 그 아래의 하위폴더를 순환적으로 접근하여 모든 파일을 나열하려면 recursive=TRUE 인수를 사용한다. list.files(pattern = &quot;\\\\.R$&quot;, recursive = T) [1] &quot;script-ex.R&quot; &quot;test/script-ex-test.R&quot; 순환적으로 하위폴더의 파일도 나열할 때 하위폴더의 이름도 포함하여 파일명을 나열하려면 include.dir=TRUE 인수를 사용한다. list.files(pattern = &quot;\\\\.R$&quot;, recursive = T, include.dirs = T) [1] &quot;script-ex.R&quot; &quot;test/script-ex-test.R&quot; 파일을 나열할 때 절대경로로 나열하렴 full.names=TRUE 인수를 사용한다. list.files(pattern = &quot;\\\\.R$&quot;, recursive = T, full.names = T) [1] &quot;./script-ex.R&quot; &quot;./test/script-ex-test.R&quot; 파일은 제외하고 하위폴더만 나열하려면 list.dirs() 함수를 사용한다. list.dirs() [1] &quot;.&quot; &quot;./test&quot; &quot;./test/test-result&quot; list.dirs() 함수는 순환적으로 하위폴더 아래의 하위폴더들을 모두 나열한다. 만약 현재의 작업 디렉토리 아래의 하위폴더만 나열하려면 recursive=FALSE 인수를 사용한다. list.dirs(recursive=F) [1] &quot;./test&quot; B.1.3 파일과 폴더 존재 확인 파일이 있는지 확인하려면 file.exists() 함수를 사용한다. file.exists(c(&quot;script-ex.R&quot;, &quot;script.R&quot;)) [1] TRUE FALSE 폴더가 있는지를 확인하려면 dir.exists() 함수를 사용한다. B.1.4 폴더의 생성과 삭제 다음은 현재 폴더에 test2 폴더가 없으면 생성하는 예이다. if (!dir.exists(&quot;test2&quot;)) dir.create(&quot;test2&quot;) list.files() [1] &quot;README.txt&quot; &quot;script-ex.R&quot; &quot;test&quot; &quot;test2&quot; 빈 폴더의 삭제는 다음과 같이 수행한다. unlink(&quot;test2&quot;) 폴더에 파일이나 하위폴더가 있어도 삭제하려면 다음과 같이 수행한다. unlink(&quot;test2&quot;, recursive=T) list.files() [1] &quot;README.txt&quot; &quot;script-ex.R&quot; &quot;test&quot; B.1.5 파일의 생성, 복사, 이동, 삭제 다음은 빈 파일을 생성한다. file.create(&quot;new_file.csv&quot;) [1] TRUE list.files() [1] &quot;new_file.csv&quot; &quot;README.txt&quot; &quot;script-ex.R&quot; &quot;test&quot; 파일의 복사는 다음과 같이 한다. file.copy(&quot;new_file.csv&quot;, &quot;newer_file.csv&quot;) [1] TRUE list.files() [1] &quot;new_file.csv&quot; &quot;newer_file.csv&quot; &quot;README.txt&quot; &quot;script-ex.R&quot; [5] &quot;test&quot; 기존 파일을 이동하려면 다음과 같이 한다. file.rename(&quot;newer_file.csv&quot;, &quot;test/newer_file.csv&quot;) [1] TRUE list.files(recursive=T) [1] &quot;new_file.csv&quot; &quot;README.txt&quot; &quot;script-ex.R&quot; [4] &quot;test/newer_file.csv&quot; &quot;test/script-ex-test.R&quot; 파일의 삭제는 다음과 같이 한다. file.remove(c(&quot;new_file.csv&quot;, &quot;test/newer_file.csv&quot;)) [1] TRUE TRUE list.files(recursive=T) [1] &quot;README.txt&quot; &quot;script-ex.R&quot; &quot;test/script-ex-test.R&quot; B.2 R에서 계산 정확도를 향상시키기 현재 R은 IEC 60559 부동소수점 계산을 사용하고 있다. 부동소수점 숫자를 저장하기 위해 64 비트를 사용하고 있고, 이중 53 비트는 유효숫자를 저장하고 11 비트는 지수부 정보를 저장한다. 위와 관련된 정보는 base 패키지의 .Machine 변수를 출력해 보면 확인할 수 있다. .Machine[grep(&quot;^double[.](digits|exponent)&quot;, names(.Machine))] $double.digits [1] 53 $double.exponent [1] 11 컴퓨터는 이진수로 숫자를 저장하기 때문에, 숫자의 유효숫자와 지수가 표현 범위에 있는 숫자라면 이진수로 표현할 수 있는 정수와 분모가 2의 거듭제곱으로 표현된 유리수에 대해서만 정확하게 표현할 수 있다. 그 외의 숫자는 정수나 2의 거듭제곱을 분모로 가진 유리수로 근사하여 저장하므로 숫자를 저장할 수 있는 정밀도는 제한된다. 그렇기 때문에 다음처럼 수학적으로 같아야할 숫자가 다른 숫자로 간주된다. a &lt;- sqrt(2) a^2 == 2 [1] FALSE a^2 [1] 2 a^2 - 2 [1] 4.440892e-16 \\(\\sqrt{2}\\)를 제곱하면 2가 되어야 할 것이다. 그러나 \\(\\sqrt{2}\\)는 근사적인 값으로 저장되기 때문에 제곱의 결과가 정확히 2가 되지 않는다. 위의 예에서 \\(\\sqrt{2}\\)의 제곱을 출력하면 2로 표현되는 것은 R의 출력에서 유효숫자의 크기가 제한되어 있기 때문이다. 숫자 출력의 유효숫자의 자리수를 늘리면 정확히 2는 아님을 확인할 수 있다. options(&quot;digits&quot;) # 현재의 유효숫자 자리수 출력 $digits [1] 7 options(digits = 22) # 유효숫자 자리수를 22로 조정 a^2 [1] 2.000000000000000444089 일반적인 상황에서는 근사적인 이진수 표현으로 숫자를 저장하기 때문에 발생하는 오차는 큰 문제가 되지 않는다. 그러나 정밀한 계산을 하거나 매우 작은 확률 값을 곱하는 계산을 하는 경우에는 이러한 오차가 문제가 될 수 있다. R에서는 Rmpfr 패키지를 사용하면 부동소수점의 정밀도를 증가시킬 수 있다. 다음 명령으로 Rmpfr 패키지를 설치해 보자.19 install.packages(&quot;Rmpfr&quot;) Rmpfr 패키지 설치가 완료되었으면 이 패키지를 메모리로 적재한다. 그리고 정밀한 계산이 필요한 변수를 mpfr() 함수를 이용하여 높은 정밀도의 숫자를 생성할 수 있다. mpfr() 함수의 첫 번째 인수는 높은 정밀도를 필요로 하는 숫자를, 두 번째 인수는 유효숫자의 비트 수를 지정한다. library(Rmpfr) b &lt;- mpfr(2, precBits = 200) a_hp &lt;- sqrt(b) a_hp^2 == 2 [1] TRUE a_hp^2 - 2 1 &#39;mpfr&#39; number of precision 200 bits [1] 0 a_hp^2 1 &#39;mpfr&#39; number of precision 200 bits [1] 2 200 비트로 유효숫자를 표현하자 2와 \\(\\sqrt{2}\\)의 제곱이 같다고 표현된다. 다음 예처럼 mpfr() 함수로 생성된 높은 정밀도의 숫자는 더 정확한 정밀도로 계산이 수행되는 것을 확인할 수 있다. b 1 &#39;mpfr&#39; number of precision 200 bits [1] 2 log(b) 1 &#39;mpfr&#39; number of precision 200 bits [1] 0.69314718055994530941723212145817656807550013436025525412067998 log(2) [1] 0.6931471805599452862268 sin(b) 1 &#39;mpfr&#39; number of precision 200 bits [1] 0.90929742682568169539601986591174484270225497144789026837897305 sin(2) [1] 0.9092974268256817094169 다음은 1부터 24까지의 계승(factorials)을 일반적인 숫자와 mpfr 숫자로 구한 결과이다 (Mächler 2015) 일반적인 숫자로 계승을 구하면 22까지는 정확한 결과를 주지만, 23과 24의 계승은 정확한 결과가 아니다. 왜냐하면 이 계승은 1의 자리가 0이어야 하기 때문이다. 반면 mpfr 숫자로 구한 계승은 정확한 결과를 반환하는 것을 볼 수 있다. options(scipen = 10) factorial(1:24) [1] 1 2 6 [4] 24 120 720 [7] 5040 40320 362880 [10] 3628800 39916800 479001600 [13] 6227020800 87178291200 1307674368000 [16] 20922789888000 355687428096000 6402373705728000 [19] 121645100408832000 2432902008176640000 51090942171709440000 [22] 1124000727777607680000 25852016738884978212864 620448401733239409999872 factorial(mpfr(1:24, 120)) 24 &#39;mpfr&#39; numbers of precision 120 bits [1] 1 2 6 [4] 24 120 720 [7] 5040 40320 362880 [10] 3628800 39916800 479001600 [13] 6227020800 87178291200 1307674368000 [16] 20922789888000 355687428096000 6402373705728000 [19] 121645100408832000 2432902008176640000 51090942171709440000 [22] 1124000727777607680000 25852016738884976640000 620448401733239439360000 마찬가지로 Rmpfr 패키지의 chooseMpfr.all() 함수를 사용하면 더 정확한 조합의 값을 얻을 수 있다. n &lt;- 60 choose(n, 1:n) [1] 60 1770 34220 487635 [5] 5461512 50063860 386206920 2558620845 [9] 14783142660 75394027566 342700125300 1399358844975 [13] 5166863427600 17345898649800 53194089192720 149608375854525 [17] 387221678682300 925029565741050 2044802197953900 4191844505805495 [21] 7984465725343800 14154280149473100 23385332420868600 36052387482172424 [25] 51915437974328288 69886166503903472 88004802264174752 103719945525634528 [29] 114449595062769136 118264581564861152 114449595062769136 103719945525634528 [33] 88004802264174752 69886166503903472 51915437974328288 36052387482172424 [37] 23385332420868600 14154280149473100 7984465725343800 4191844505805495 [41] 2044802197953900 925029565741050 387221678682300 149608375854525 [45] 53194089192720 17345898649800 5166863427600 1399358844975 [49] 342700125300 75394027566 14783142660 2558620845 [53] 386206920 50063860 5461512 487635 [57] 34220 1770 60 1 chooseMpfr.all(n) 60 &#39;mpfr&#39; numbers of precision 57 bits [1] 60 1770 34220 487635 [5] 5461512 50063860 386206920 2558620845 [9] 14783142660 75394027566 342700125300 1399358844975 [13] 5166863427600 17345898649800 53194089192720 149608375854525 [17] 387221678682300 925029565741050 2044802197953900 4191844505805495 [21] 7984465725343800 14154280149473100 23385332420868600 36052387482172425 [25] 51915437974328292 69886166503903470 88004802264174740 103719945525634515 [29] 114449595062769120 118264581564861424 114449595062769120 103719945525634515 [33] 88004802264174740 69886166503903470 51915437974328292 36052387482172425 [37] 23385332420868600 14154280149473100 7984465725343800 4191844505805495 [41] 2044802197953900 925029565741050 387221678682300 149608375854525 [45] 53194089192720 17345898649800 5166863427600 1399358844975 [49] 342700125300 75394027566 14783142660 2558620845 [53] 386206920 50063860 5461512 487635 [57] 34220 1770 60 1 Berry, Michael J. A., and Gordon S Linoff. 2004. Data Mining Techniques: For Marketing, Sales, and Customer Relationship Management. 2nd ed. Wiley. Linoff, Gordon S, and Michael J. A. Berry. 2011. Data Mining Techniques: For Marketing, Sales, and Customer Relationship Management. 3rd ed. Wiley. Mächler, Martin. 2015. “Arbitrarily Accurate Computation with r: The Rmpfr Package.” References Mächler, Martin. 2015. “Arbitrarily Accurate Computation with r: The Rmpfr Package.” 리눅스를 사용한다면 GMP와 MPFR 라이브러리가 먼저 설치되어 있어야 한다. 우분투를 사용한다면 apt install libgmp-dev libmpfr-dev 명령으로 두 라이브러리를 설치할 수 있다.↩︎ "]]
