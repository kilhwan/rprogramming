[
["index.html", "R 프로그래밍 (개정판) Preface 1판 서문 2판 서문", " R 프로그래밍 (개정판) Kilhwan Kim 2020-11-23 Preface 1판 서문 이 책을 쓰게 된 동기를 설명하기에 앞서 개인적인 경력을 밝히는 것이 좋겠다. 저자는 경영과학과 산업공학을 전공하였기 때문에 대학과 대학원 시절 통계학에 대한 다양한 강의를 수강하였고, Minitab, SPSS, SAS 등의 통계 패키지도 접할 기회를 가졌다. 그러나 정작 졸업 후 경력의 대부분을 IT 업계에서 보내며 통계 분석과는 동떨어진 정보시스템 개발과 컨설팅 업무를 주로 수행하였다. 그러는 과정에서 저자는 C, Java, JavaScript 등의 다양한 프로그래밍 언어를 다루게 되었고 시스템 개발에 대한 폭넓은 이해를 하게 되었다. 세월이 흘러 저자는 박사과정에 진학하여 대학교에 교편을 잡게 되었고, 세상은 바야흐로 빅데이터의 시대로 접어들어 R이 데이터 분석의 강력한 수단으로 각광받게 되었다. 물론 R은 이전부터 통계 전문가들 사이에선 잘 알려져 있었지만, 지금처럼 많은 분야에서 주목받지는 못했다. 이러한 흐름에 맞추어 저자는 여러 해 동안 R을 이용한 통계 분석 및 데이터 마이닝을 공부해 왔고 관련된 강의와 연구 프로젝트도 수행하게 되었다. 이 책은 저자가 R을 공부할 때 느낀 불만족스러운 부분에서 시작되었다. 현재 국내에는 R을 이용하고자 하는 두 부류의 집단이 있는 것 같다. 한 부류는 통계학과 유사 학문을 전공한 사람들로 R에 대해서는 프로그래밍 언어적 측면보다는 데이터 분석 패키지로서 관심이 많다. 이 부류의 사람들은 즉각적인 데이터 분석을 위해 임의적인 방식으로 R의 명령어를 사용하는 것을 선호한다. 다른 부류는 IT 전문가로서 빅데이터 분석에 대한 시대적 요구가 커짐에 따라 R에 관심을 갖게 된 사람들이다. 이들은 통계나 수학적 배경 지식은 약하나 프로그래밍 언어에 대한 이해가 높은 사람들로서, R을 체계적인 방식으로 사용하여 시스템을 구축하는데 관심이 많다. 그런데 국내의 R 관련 서적들은 대부분 R을 통계 분석과 데이터 마이닝 알고리즘을 수행할 수 있는 단편적인 명령어 중심으로 소개하고 있다. R의 프로그래밍 언어로서의 측면을 체계적인 방식으로 다루는 책은 오히려 드문 편이다. 저자가 판단하기에 국내 서적 중 R의 프로그래밍 언어적 측면을 본격적으로 다룬 유일한 책이 Norman Matloff의 The Art of R Programming의 번역본이 아닐까 한다. 다행히 저자는 부족하나마 통계학과 데이터 마이닝에 대한 지식과 경험, 그리고 프로그래밍 언어에 대한 지식과 시스템 개발 경험을 두루 갖출 수 있었다. 물론 두 분야의 전문가가 보면 부족한 수준일 것이다. 그러나 이러한 양 분야의 지식과 경험이 저자에게 R을 매우 종합적으로 조망하게 해 주었다. 그 결과 R을 단순하게 통계 분석의 툴로서만 이용하는 사람들에게 R의 프로그래밍 언어적 특성을 체계적으로 알려주는 게 필요하다고 판단하게 되었다. 왜냐하면, 빅데이터 분석을 위해서는 선진 데이터 분석 알고리즘을 깊이 이해하고 적용하는 것만큼이나, 대규모 데이터를 시스템적으로 처리하는 프로그래밍 기술이 중요해지기 때문이다. 따라서 앞으로 데이터 분석가가 시스템 개발에 직접 참여하게 될 일들이 점차 많아질 것이고, 자신이 가장 익숙한 언어로 프로그램을 개발할 수 있는 능력은 중요한 핵심역량이 될 것이다. 이 책은 통계 및 데이터 마이닝을 공부하는 학생이나 전문가가 R의 프로그래밍 언어적 특성을 이해하는 것을 돕기 위해 집필되었다. 그러나 역으로 프로그래밍 언어에 익숙한 독자가 R의 특성을 파악하는 데에도 도움을 주리라 생각된다. 다른 프로그램 언어에 이미 익숙한 저자로서는 R을 공부할 때 답답했던 측면 중 하나가 R의 프로그램 언어적 특성을 명확하게 설명해 주는 자료가 흔치 않다는 점이었다. R이 기존의 프로그래밍 언어와 다르게 작동되는 부분을 만날 때마다 어리둥절함에 빠질 때가 많았기 때문이다. 이 책은 저자가 몸담고 있는 대학의 강의를 위해 준비했던 자료를 기반으로 원고가 작성되었다. 부족한 지식이나마 책으로 펼칠 수 있도록 격려해 주신 학과 교수님들과, 부족한 강의를 들으며 다양한 피드백을 해준 상명대학교 경영공학과 학생들에게 감사의 말씀을 전한다. 아울러 이 책을 준비할 때 물심양면 지원해준 가족에게도 감사의 말을 전한다. 2017년 2월 상명대학교 천안캠퍼스에서 김길환 2판 서문 1판이 출간된지 3년 반이 지났습니다. 1판을 작성하였을 때는 R의 버전이 3이었지만 현재 버전 4가 출시되어 사용되고 있습니다. R의 기본 기능은 크게 바뀌지 않았지만 데이터 프레임의 처리 방식 등에 근본적인 변화가 있었습니다. 아울러 Hadley Wickham의 tidyverse 패키지가 R 작업의 표준으로 자리잡아 가고 있습니다. 2판은 이러한 변화를 반영하였습니다. 기존의 데이터 변환과 관련된 내용을 모두 R의 기본 기능을 사용하는 방식에서 tidyverse 패키지를 사용하는 방식으로 바꾸었습니다. 그래픽과 시각화와 관련된 내용도 R의 기본 graphics 패키지 대신 ggplot2 패키지를 사용하도록 변경하였습니다. 현재까지 2판은 완성되지 않았습니다. 강의와 더불어 2판은 조금씩 수정돼 나갈 것입니다. 온라인 상에서 수정된 내용을 계속 확인하실 수 있습니다. 그러므로 2판의 서문도 계속 바뀌어져 나갈 것입니다. 2020년 8월 상명대학교 천안캠퍼스에서 2판 초안을 마무리하며 김길환 "],
["ch-intro.html", "Chapter 1 R 설치 및 시작 1.1 R 소개 1.2 R 설치하기 1.3 RStudio 1.4 RStudio로 R 시작하기", " Chapter 1 R 설치 및 시작 1.1 R 소개 R은 통계 계산과 그래픽을 위한 프로그래밍 언어이자 소프트웨어 환경이다. R은 1960년대와 1970년대 Bell 연구소에서 개발된 S라는 데이터 처리 언어에 기반을 두고 있다. 1990년대 중반 뉴질랜드 오클랜드 대학의 로스 이하카와 로버트 젠틀맨에 의해 시작되어 현재는 R의 핵심 기능은 R 코어 팀이, 다양한 추가 기능은 자발적 기여자들에 의해 개발되고 있다. R은 GPL 하에 배포되는 공개 소프트웨어로 누구나 자유롭게 이용할 수 있다. R은 빅데이터 분석에 널리 사용되고 있으며, 패키지 개발이 용이하여 통계 분석가들 사이에서 통계 소프트웨어 개발에 많이 쓰이고 있다. R은 데이터 조작, 계산, 그래픽 표현을 위한 소프트웨어이다. R의 주요 기능은 다음과 같다. 효율적이고 편련한 데이터 조작 및 처리 기능 데이트를 다양한 그래프로 표현해주는 데이터 시각화 기능 통계 분석 및 데이터 마이닝 알고리즘 수행 기능 분석 결과를 문서 및 발표 자료로 생성하는 기능 간단하며 효과적인 프로그래밍 언어로서의 기능 이 장에서는 R을 설치하고 실행하는 방법과 R의 개괄적인 기능을 소개한다. 1.2 R 설치하기 1.2.1 R 배포판 내려받기 R을 설치하기 위해서는 R 배포판을 먼저 구해야 한다. R은 공개 소프트웨어이므로 무료로 R 공식 웹 사이트 (http://www.r-project.org/)에서 내려받을 수 있다. R 공식 사이트의 첫 화면의 내용 중 download R 을 클릭하면 R 배포판을 내려받기할 CRAN 미러를 선택하는 화면으로 이동하게 된다. 지리적으로 가까운 CRAN 미러 서버를 선택하거나, 맨 위의 “0-Cloud”를 선택한다. 그러면 설치할 R 배포판을 선택하는 화면으로 이동한다. R 배포판을 선택하는 화면에서 Download R for Windows를 클릭하여 윈도우용 배포판을 선택한다.1 윈도우용 배포판 중 어떤 항목을 내려받을 것인지를 물어보는데 처음 설치하는 것이므로 Base를 선택한다. 그러면 32/64bits 겸용 윈도우용 R 바이너리 파일을 내려받을 수 있는 화면으로 이동한다. Download R x.x.x for windows를 클릭하여 배포판을 내려받는다. 여기서 x.x.x는 내려받기를 하는 R 배포판의 버전을 의미한다. 1.2.2 설치에 앞서 주의할 사항 한글 윈도우에서 R과 RStudio를 설치하여 사용할 때 이유를 알 수 없는 여러 문제가 발생할 수 있다. 이러한 문제의 대부분은 파일과 디렉토리(폴더)의 경로명에 한글이 들어간 경우에 발생한다. 특히 윈도우 사용자 이름이 한글인 경우 이러한 문제가 빈번히 발생하는데, R이나 RStudio가 사용자 폴더의 하위 폴더에 필요한 파일과 디렉토리를 만들기 때문이다. 이러한 문제를 미연에 방지하려면 설치 전에 윈도우 사용자 이름이 한글인지 확인하고, 한글이면 영문 사용자 이름으로 관리자 계정을 하나 더 만들어 그 계정으로 R과 RStudio의 설치를 진행하는 것이 좋다. 물론 한글 사용자 이름을 사용하더라도 환경변수의 임시 디렉토리 설정을 변경하여 발생할 수 있는 대부분의 문제를 해결할 수 있지만, 새로운 패키지나 함수를 사용할 때마다 이러한 문제가 잠복되어 있다가 다른 방식으로 다시 발생할 수 있다. R에 대한 이해가 높지 않은 초심자의 경우 이러한 문제가 발생하면 문제의 원인을 파악하기 어렵다. 그렇기 때문에 영문 이름으로 된 관리자 권한의 사용자로서 R과 RStudio를 설치하기를 강력히 권장한다. 1.2.3 R 설치하기 내려받은 R 설치 파일을 실행시켜 R을 설치한다. 설치 과정 중 사용할 언어 선택 화면이 나타나면 한국어를 선택한 후 [확인]을 클릭한다. GNU 라이선스 정보 화면이 나타나면 [다음]을 클릭한다. 설치할 위치를 선택하는 화면이 나타나면 [찾아보기]를 클릭하여 적절한 설치 폴더를 직접 지정하거나 기본 값으로 설치한다. [다음]을 클릭한다. 구성 요소 설치를 묻는 화면이 나타나면 위쪽에 있는 선택 리스트를 이용하여 32-bit 사용자 편의를 위한 쉬운 설치 또는 64-bit 사용자 편의를 위한 쉬운 설치 중 자신의 윈도우즈 시스템이 32-bit 윈도우인지 64-bit 윈도우인지에 따라 선택한다. 그리고 [다음]을 클릭한다.(자신의 윈도우 종류를 모르겠으면 사용자 편의를 위한 쉬운 설치를 선택하여 전체를 다 설치하여도 된다. Windows 10을 기준으로 몇 bits 운영체제인지를 확인하려면, 시작 메뉴에서 [제어판]을 선택한 후 [시스템]-[정보]를 선택하면 시스템 종류에 해당 정보가 나온다.) R을 시작할 때의 사용하는 스타트업 옵션을 조정할 것인지를 묻는 화면이 나온다. 지금은 그냥 No (기본값 사용)을 선택하도록 한다. 그리고 [다음]을 클릭한다. 시작 메뉴 폴더를 선택하도록 하는데, 기본 값인 `R’을 이용하도록 한다. [다음]을 클릭한다. 추가 사항 적용은 특별한 요구가 없는 한 기본 설정을 이용하도록 한다. [다음]을 클릭하면 설치가 실행된다. 설치가 완료되면 [완료]를 클릭한다. 윈도우즈 시작 메뉴에 가면 R 폴더가 생성되어 있고 그 안의 메뉴를 클릭하면 R이 실행된다. 1.3 RStudio R 배포판이 제공하는 기능만으로도 기본적인 프로그래밍이나 데이터 분석이 가능하다. 그러나 프로그래밍이나 데이터 분석 작업이 복잡해지면 R을 좀 더 편리하게 사용할 수 있는 통합된 개발 환경(IDE: Integrated Development Environment)이 큰 도움이 된다. RStudio는 R을 위한 강력한 통합 개발 환경을 제공해 준다. R과 마찬가지로 공개 소프트웨어로 누구나 자유롭게 이용할 수 있다. 따라서 많은 R 사용자가 RStudio를 사용하고 있다. 1.3.1 RStudio 설치 RStudio 웹페이지(http://www.rstudio.com/product/rstudio/download/)에 접속하면 RStudio를 내려 받을 수 있다. RStudio는 데스크탑용과 서버용이 있다. 데스크탑 버전은 개별 사용자를 위한 버전이고, 서버용 버전은 여러 사람이 동시에 데이터를 분석하거나 원격에서 데이터를 분석하기에 좋은 환경이다. 서버용 버전과 관련된 정보는 RStudio 홈페이지를 참조하기 바란다. RStudio Desktop은 무료용 Open Source License (Free) 버전과 상업용 Commercial License 버전이 있다. 데스크탑용 RStudio는 무료용이나 상업용이나 기능상 차이는 없다. 상업용에는 별도의 기술 지원이 추가된다. Open Source License (Free)에서 [DOWNLOAD]을 클릭하여 다운로드 페이지로 이동한다. 그러면 자동으로 접속자의 환경을 파악하여 사용자가 사용하는 운영체제에 적절한 RStudio 데스크탑 버전을 선택해 준다. 윈도우즈 사용자들은 [DOWNLOAD RSTUDIO FOR WINDOWS]가 나타날 것이다. 이를 클릭하면 RStudio가 다운로드 될 것이다. 만약 다른 운영체제의 RStudio가 필요하면 하단의 목록에서 적절한 배포한을 선택한다. (RStudio는 공개 소프트웨어로 프로그램 소스 파일도 함께 공개되어 있어, 같은 페이지 하단에서 볼 수 있는 바와 같이 RStudio 소스를 내려받을 수도 있다.) 내려받은 파일을 실행하면 RStudio 설치를 완료할 수 있다. 1.4 RStudio로 R 시작하기 RStudio를 설치하면 윈도우 시작메뉴에 RStudio를 실행할 수 있는 메뉴가 나타난다. 이를 실행하면 다음 그림처럼 RStudio가 실행된다. 기본 설정은 왼편에 R 콘솔이나 코드 편집기 창들이 위치하고, 오른편에 작업 환경, 명령어 히스토리, 파일, 그림, 패키지, 도움말 관련 창들이 위치하도록 되어 있다. 1.4.1 R 콘솔과 프롬프트 R은 기본적으로 텍스트 기반의 명령문을 입력받아 명령문에 대한 응답하는 방식으로 작동한다. R 콘솔은 사용자의 명령문을 받고 텍스트 기반 결과물을 출력하는 곳이다. R 콘솔은 사용자의 명령을 받을 준비가 되어 있다는 것을 나타내기 위해 명령 프롬프트인 `&gt;’ 기호를 표시한다. 프롬프트가 보이면 R 명령문을 입력하고 Enter 키를 누르면 입력된 R 명령문이 R에 전달되어 실행된다. 명령문의 실행 결과가 텍스트이면 R 콘솔에 결과가 나타나고 그래프이면 오른편의 Plots 창에 그래프가 나타난다. 이 책에서는 아래에 나오는 형태로 R 콘솔의 입출력을 표시한다. &gt;가 있는 행은 사용자가 입력한 행이고 &gt;가 없는 행은 R의 출력 결과로 표시한다. R을 맛보기 위해 R이 제공하는 cars 데이터에 대해 기초적인 분석을 수행해보자. 이 절에서 이용되는 R 명령어에 대해서는 현재 시점에선 이해할 필요가 없다. 이 책이 진행되면서 차근차근 설명될 것이다. 먼저 다음과 같이 cars 데이터를 화면에 출력해 보자. 콘솔에 cars라고 입력 후 Enter를 입력한다. &gt; cars speed dist 1 4 2 2 4 10 3 7 4 4 7 22 5 8 16 6 9 10 ... cars 데이터는 자동차의 속력(speed)과 제동 거리(dist)에 대한 50 개의 관찰값으로 구성되어 있다. cars 데이터에 대하여 자세한 정보를 얻어보자. ?를 명령어에 붙이면 명령어에 대한 설명을 오른편의 Help 창에 도움말이 나타난다. &gt; ?cars summary() 함수를 이용하여 자동차의 속력과 제동 거리에 대한 최소값, 최대값, 평균, 사분위수 등 기본 통계치를 구해 보자. &gt; summary(cars) speed dist Min. : 4.0 Min. : 2.00 1st Qu.:12.0 1st Qu.: 26.00 Median :15.0 Median : 36.00 Mean :15.4 Mean : 42.98 3rd Qu.:19.0 3rd Qu.: 56.00 Max. :25.0 Max. :120.00 자동차의 속력과 제동 거리의 상관 관계를 보기 위해 plot() 함수를 이용하여 산점도(scatter plot)를 그려 본다. &gt; plot(cars) 자동차의 속력과 제동 거리의 관계를 선형 모형으로 나타내기 위해 다음 명령어를 이용하여 cars 데이터에 대한 선형회귀분석을 수행한다. &gt; lm.cars &lt;- lm(dist ~ speed, data=cars) &gt; lm.cars Call: lm(formula = dist ~ speed, data = cars) Coefficients: (Intercept) speed -17.579 3.932 제동 거리를 속도로 회귀분석해 보면 절편이 -17.579이고 기울기가 3.932가 됨을 알 수 있다. 앞에 그린 산점도에 abline() 함수를 이용하여 회귀 적합선을 그려 넣어 본다. &gt; plot(cars) &gt; abline(lm.cars, col=&quot;blue&quot;) 본 절에서 수행한 명령어가 궁금한 독자는 help(명령어)나 ?명령어를 R 콘솔에 입력해 보라. 관련 도움말을 얻을 수 있을 것이다. 1.4.2 R 콘솔 사용과 관련된 몇 가지 팁 입력 시 주의 사항 R 명령문은 대문자와 소문자를 다른 문자로 간주한다. 그러니 함수명이나 변수명을 입력할 때 대소문자가 틀리지 않도록 해야 한다. R 명령문 입력시 가장 많이 틀리는 부분이 ' ', \" \", ( ), { } 등이 서로 짝이 맞지 않는 경우다. R 명령문을 입력하고 Enter를 입력하였는데, 결과가 출력되지 않고 프롬프트가 +로 바뀌는 경우에는, 입력한 명령문이 완전하지 않기 때문에 나머지 입력을 받기 위해 기다리고 있다는 것을 나타낸다. 주로 앞서 설명한 ' ', \" \", ( ), { } 등이 서로 맞지 않아 발생하는 경우가 많다. 이를 해결하는 두 가지 방법이 있다. 명령문의 나머지를 + 프롬프트 뒤에 입력한 후 Enter를 입력하여 명령문을 마무리하거나, Esc를 눌러 지금까지 입력된 내용을 취소하는 것이다. RStudio의 콘솔은 몇 가지 편의 기능을 제공한다. 이 기능들을 이용하면 작업의 생산성을 향상시킬 수 있다. 코드 완성 RStudio 콘솔에서 Tab 키를 사용하여 코드를 자동 완성시킬 수 있다. 예를 들어 앞 절에 나온 lm.cars 변수를 사용하는 예제를 수행한 뒤라면, lm.c 까지만 입력한 후 Tab 키를 눌러보자. 그러면 자동으로 변수의 전체 이름을 완성해 줄 것이다. 코드 완성 기능을 이용하여 변수 이름을 입력하는 것을 습관화 하면 좋다. 변수의 이름을 잘못 입력하여 발생하는 오류를 줄일 수 있다. 코드 완성 기능은 함수에도 이용할 수 있다. sum까지만 입력한 후 Tab을 눌러보자. 그러면 다음 그림 처럼 sum으로 시작하는 함수의 목록이 나타난다. 목록 중 원하는 함수를 선택하면 해당 함수 이름을 콘솔에 자동 완성해 준다. 필요한 함수의 정확한 이름이 생각나지 않을 때 매우 유용하다. 코드 완성 기능은 함수의 인수 입력에도 이용할 수 있다. summary(라고 입력한 후에* Tab 키를 누르면 함수 인수의 목록과 설명이 나온다. R 함수들의 인수 이름을 정확히 기억하는 것은 쉽지 않다. 코드 완성 기능을 오류 없이 정확한 명령어를 빠르게 입력할 수 있도록 도와준다. 이전 명령문 불러오기 R 콘솔에서는 이전에 입력한 명령을 불러와 다시 실행하거나 수정하여 실행시킬 수 있다. 이전 명령은 위와 아래 화살표 키를 이용하여 불러온다. [위 화살표 키] 이전에 입력한 명령을 차례대로 불러온다. [아래 화살표 키] 위 화살표 키와 반대로 불러온다. [Ctrl + 위 화살표 키] 이전 명령의 목록을 보여준다. 1.4.3 R 스크립트 파일 만들기 R 콘솔에서 대화 형식으로 명령문을 입력하고 결과를 받는 것은 단순한 작업의 경우에는 편리하지만, 복잡한 분석을 위해 입력해야 할 명령문이 많거나 추후에 동일한 또는 유사한 작업을 할 예정이라면 R 스크립트 파일을 작성하여 명령문을 저장해 두는 것이 좋다. R 스크립트는 한번에 실행할 명령문을 단순한 텍스트 형식으로 기술한 파일이다. R 스크립트에는 실행할 명령문을 한 줄씩 입력한다. R은 스크립트를 읽어들여서 줄바꿈이 되는 곳을 기준으로 한 줄씩 처리한다. summary(cars) lm.cars &lt;- lm(dist~speed, data=cars) lm.cars plot(dist~speed, cars) abline(lm.cars) RStudio 코드 편집기 RStudio의 코드 편집기는 R 스크립트 등 다양한 파일을 작성하는 것을 도와준다. 문법 강조 표현, 코드 완성 등 다양한 기능들을 가지고 있다. 또한 코드 편집기에 입력한 R 명령을 콘솔에서 즉시 실행해 볼 수도 있다. 많은 R 사용자가 R 명령을 콘솔에서 직접 실행하는 것보다 코드 편집기에서 스크립트로 작성한 후 실행하는 것을 선호한다. 왜냐하면 코드 편집기를 이용하면 실행한 R 명령을 파일에 저장해 둘 수 있으므로, 나중에 동일한 코드를 재실행할 수 있을 뿐 아니라 함수 등으로 쉽게 변환할 수 있기 때문이다. RStudio에서 지원하는 주요 파일 형식 RStudio는 다음 형식의 파일에 대하여 문법 강조 표현 및 특화된 코드 편집 기능을 제공한다. R 스크립트: R 명령어 코드와 주석만을 포함하는 파일이다. R 노트북: R 명령어와 함께 실행 결과를 Mathematica 노트북 형태로 저장해주는 파일이다. R Markdown 문서: 마크다운이라는 매우 단순한 형식으로 문서 모양을 지정할 수 있다. R 명령어와 마크다운이 같이 한 문서에 사용되어 동적인 문서를 생성한다. R 마크다운 문서는 HTML, 워드 문서, PDF 문서로 변환이 가능하다. Shiny Web App: RStudio에서 개발한 R을 이용해 웹 응용을 쉽게 개발하도록 지원하는 웹 응용 개발 체계이다. R Sweave 문서: LaTex 문서 내에 R 명령어를 포함하여 동적인 LaTex 파일을 만들어 주는 형식이다. R HTML 문서: HTML 문서 내에 R 명령어를 포함하여 동적으로 HTML 파일을 만들어 주는 형식이다. R Presentation 문서: HTML5 기능을 이용하여 HTML 기반의 동적인 프리젠테이션 파일을 만들어 주는 파일 형식이다. R Documentation 문서: R 프로그램에 대한 문서화를 지원해 주는 파일 형식이다. 스크립트 파일 만들기 일반적인 사용자는 보통 R 스크립트 파일, R 마크다운 파일, R 프리젠테이션 파일을 많이 사용한다. RStudio에서 새로운 파일을 생성하려면 File-&gt;New File 메뉴를 이용하거나 그림처럼 새 파일을 만드는 명령 단추를 클릭한다. 기존 파일을 열기 위해서는 File-&gt;Open File… 또는 File-&gt;Recent Files 메뉴를 이용하거나, 파일 열기 명령 단추를 클릭한다. RStudio에서 여러 파일을 열게 되면 탭으로 각 파일을 표시해 준다. 매우 많은 파일이 열려서 탭을 모두 표시할 수 없으면 우측 상단에 &gt;&gt; 또는 좌측 상단에 &lt;&lt; 아이콘이 표시되어 보이지 않는 파일 탭 사이를 전환할 수 있도록 해 준다. 편집기의 코드 완성 기능 코드 편집기는 Tab 키를 이용하여 자동 코드 완성을 지원한다. 코드 완성 기능은 콘솔과 마찬가지니 콘솔의 설명을 참조하기 바란다. 문자 찾기와 바꾸기 코드 편집기는 문서의 문자를 찾거나 바꾸는 기능을 지원한다. Ctrl +F 단축키를 이용하거나 Edit-&gt;Find 또는 Edit-&gt;Replace and Find 메뉴를 이용한다. 코드 실행 RStudio는 코드 편집기의 코드를 직접 실행시킬 수 있다. 실행할 코드는 콘솔에 자동 입력되어 실행되고 그 결과도 콘솔에 표시된다. 코드의 한 줄 또는 일부 여러 줄을 실행하려면 그 줄을 선택한 후 코드 편집기의 도구 모음에서 Run를 실행하거나 Ctrl+Enter 키를 이용한다. 코드 전체를 실행하기 위해서는 코드 편집기의 도구 모음에서 Source -&gt; Source with Echo를 실행하거나 Ctrl+Shift+Enter 키를 이용한다. 코드 편집기의 도구 모음에서 그냥 Source를 실행하면 파일의 명령문이 실행은 되나 결과가 콘솔에 출력되지 않는다. 주석 처리 R 스트립트에 명령문이 아닌 내용을 입력하고 싶으면 #을 앞에 사용하여 주석 처리를 한다. # 뒤에 입력된 내용은 명령문으로 간주하지 않고 무시한다. 주석문은 명령문의 의미를 나중에 이해하기 쉽도록 기술하거나, R 스크립트 개발 과정에서 디버깅이나 다른 이유로 명령문을 실행에서 제외할 때 사용한다. 직접 #를 입력하는 방법뿐 아니라, Edit-&gt;Comment/Uncomment Lines 메뉴나 코드 편집기 상단의 코드 명령 단추에서 해당 메뉴를 이용하면 선택한 코드 부분 전체를 주석 처리하거나 주석 처리를 취소할 수 있다. 들여쓰기 코드를 작성할 때 동일한 논리적 단위들을 동일하게 들여쓰기하면 코드를 읽기가 쉬워진다. RStudio는 코드 작성시 현재의 들여쓰기 옵션에 따라 자동으로 들여쓰기를 해 준다. 코드를 작성한 후 들여쓰기를 직접 조정하고 싶으면, 코드를 선택한 후 Tab 키를 누른다. 그러면 Tab 키를 누른 횟수만큼 들여쓰기가 된다. 반대로 Shift+Tab 키를 누르면, 누른 횟수만큼 내어쓰기가 된다. 참고로 RStudio는 Tab 한 회에 공백 2문자만큼 들여쓰기를 한다. 이를 조절하고 싶으면 [Toos]-[Global Options]-[Code] 메뉴에 가서 Tab 한 회당 들여쓰기할 공백 문자 수를 조절하면 된다. 이 책에서는 윈도우에 R을 설치한다고 가정한다. R 배포판은 설치 방법이나 그래픽 인터페이스의 몇 가지 기능을 제외하고 운영 체제에 따른 차이는 없다. ↩︎ "],
["ch-R-Data-Basic.html", "Chapter 2 R 데이터 기초 2.1 단순한 데이터 형태 2.2 단순 연산 2.3 변수와 할당 2.4 함수를 이용한 연산", " Chapter 2 R 데이터 기초 R은 통계 데이터 분석 툴이기도 하지만 그 자체로 프로그래밍 언어이다. 한국어, 영어와 같은 모든 언어가 그러하듯이 R에도 자기만의 어휘와 표현법, 표현 형태들이 있다. 외국어에 익숙해지기 위해 기본적인 문법 요소와 다양한 문형들을 익혀야 하는 것처럼 R도 R의 기본 표현법과 표현 형태를 익혀야만 사용할 수 있다. 고급 문법과 문형에 익숙할수록 더 유창한 언어 실력을 보일 수 있듯이 R도 고급 표현을 익히면 더 다양한 분석을 수행할 수 있다. 이 장에서는 R의 가장 기초적인 데이터 요소를 배운다. 3에서 6 장들은 이 장에서 배운 내용을 기초로 R의 기초 데이터를 확장해 나간다. 이 장의 내용은 프로그래밍 언어에 익숙한 독자들에게는 이미 익숙한 내용일 것이다. 그런 독자들은 다음 장부터 시작하여도 무방하다. 2.1 단순한 데이터 형태 R의 기본적 데이터 형태: 숫자, 문자, 논리값 R은 데이터를 다룬다. R에서 다루는 기본적인 데이터 형태는 숫자, 문자, 논리값이다. 어떤 학생의 키가 172.2이면 이 데이터의 형태는 숫자이다. 그 학생의 이름이 ’홍길동’이면 이 데이터는 문자 데이터이다. 그리고 이 학생이 남자인지 여부를 TRUE 또는 FALSE로 표현하였다면 이 데이터의 형태는 논리값이다. R의 모든 복잡한 데이터 형태는 이러한 숫자, 문자, 논리값을 기반으로 구성된다. 아래는 R의 콘솔에서 숫자, 문자, 논리값을 차례대로 입력해 본 결과이다. ‘&gt;’ 다음 부분을 R 콘솔에 입력한 후 Enter 키를 누른다. 그러면 입력한 내용이 R에 전달되어 출력 결과가 그 다음 줄에 나타난다(’&gt;’가 없는 줄). &gt; 10 [1] 10 &gt; TRUE [1] TRUE &gt; &quot;홍길동&quot; [1] &quot;홍길동&quot; 10 vs ‘10’ 여기서 주의할 점은 숫자와 논리값과는 달리 문자 데이터는 큰 따옴표나 작은 따옴표로 시작과 끝을 표현해 주어야 한다는 것이다. 따라서 사칙연산이 가능한 숫자 10과 문자 \"10\"은 서로 다르다. 마찬가지로 논리값 TRUE와 문자열 \"TRUE\"도 다른 의미를 가진다. 2.2 단순 연산 사칙 연산 R은 더하기, 빼기, 곱하기, 나누기 등의 사칙연산에 대한 기본적 기능을 제공한다. 아래의 ‘&gt;’ 이후의 부분을 입력 후 Enter 키를 누르면 그 아래에 출력 결과가 나온다. &gt; 2 + 2 [1] 4 &gt; 2 - 2 [1] 0 &gt; 2 * 2 [1] 4 &gt; 2 / 2 [1] 1 2.2.0.1 몫과 나머지 R에서 나눗셈은 부동 소수점 형식의 실수(real numbers)로 계산된다. 만약 정수의 나눗셈에서 몫과 너머지를 구하려면 %/%과 %% 연산자를 사용한다. &gt; 11 / 3 [1] 3.666667 &gt; 11 %/% 3 # 몫 [1] 3 &gt; 11 %% 3 # 나머지 [1] 2 거듭 제곱 연산 또한 ‘^’ 연산자를 이용해 거듭제곱도 가능하다. 아래의 예는 2의 1제곱부터 4제곱까지의 결과이다. 여기서 4개의 거듭제곱 연산 명령문 (Enter 키를 쳐서 R로 보내는 내용)을 한 줄로 보내기 위해 ’;’로 각각의 명령문을 나누어 한번의 Enter 키로 명령을 실행하였다. 각 명령문의 결과는 다른 줄로 출력되었음을 볼 수 있다. &gt; 2^1; 2^2; 2^3; 2^4 [1] 2 [1] 4 [1] 8 [1] 16 비교 연산 ‘==’ vs. ‘=’ R은 사칙연산뿐 아니라 부등호와 등호를 이용한 비교연산도 가능하다. 아래는 비교 연산을 수행한 경우이다. ‘&gt;=’와’&lt;=’ 연산자는 같거나 크다 또는 같거나 작다를 의미한다. ‘==’ 연산자는 같다를 의미하고 ‘!=’ 연산자는 같지 않다를 의미한다. 여기서 주의할 점은 등호가 ‘=’가 아니라’==‘라는 점이다.’=’ 연산자는 뒤에서 살펴볼 변수에 값을 할당하는데 이용된다. &gt; 2 &gt; 2; 2 &gt;= 2; 2 &lt; 2 ; 2 &lt;= 2 [1] FALSE [1] TRUE [1] FALSE [1] TRUE &gt; 2 == 2; 2 != 2 [1] TRUE [1] FALSE 논리값 연산 논리값은 ‘&amp;’, ‘\\verb1|1’, ‘!’, xor(x, y) 연산자를 이용하여 논리적 AND, OR, NOT, XOR 연산의 수행도 가능하다. &gt; TRUE &amp; FALSE [1] FALSE &gt; TRUE | FALSE [1] TRUE &gt; !TRUE [1] FALSE &gt; xor(TRUE, TRUE) [1] FALSE 문자열 결합 연산 paste() 문자열에 대한 연산으로는 paste() 함수를 이용하여 문자를 연결하는 연산이 있다. paste() 함수는 문자열을 공백 하나를 사이에 두고 하나의 문자열로 합쳐준다. 숫자처럼 문자가 아닌 것은 문자로 변환한 후 합쳐준다. sep인자를 이용하면 두 문자열의 사이에 다양한 문자를 넣을 수 있다. &gt; paste(2014, 3) [1] &quot;2014 3&quot; &gt; paste(&quot;March&quot;, 11, 2014) [1] &quot;March 11 2014&quot; &gt; paste(2014, 3, 11, sep=&quot;-&quot;) [1] &quot;2014-3-11&quot; &gt; paste(2014, 3, 11, sep=&quot;/&quot;) [1] &quot;2014/3/11&quot; &gt; paste(2014, 3, 11, sep=&quot;&quot;) [1] &quot;2014311&quot; 문자열 분리 연산 strsplit() paste와 반대로 하나의 문자열을 여러 문자열로 분리해 내는 strsplit 함수도 있다. split인자에 문자열을 분리하는 기준이 되는 문자 또는 문자열을 지정해 준다. &gt; strsplit(&quot;2016-3-11 11:16:22&quot;, split=&quot; &quot;) [[1]] [1] &quot;2016-3-11&quot; &quot;11:16:22&quot; &gt; strsplit(&quot;2016-3-11 11:16:22&quot;, split=&quot;-&quot;) [[1]] [1] &quot;2016&quot; &quot;3&quot; &quot;11 11:16:22&quot; &gt; strsplit(&quot;2016-3-11 11:16:22&quot;, split=&quot;:&quot;) [[1]] [1] &quot;2016-3-11 11&quot; &quot;16&quot; &quot;22&quot; &gt; strsplit(&quot;2016-3-11 11:16:22&quot;, split=c(&quot;16&quot;)) [[1]] [1] &quot;20&quot; &quot;-3-11 11:&quot; &quot;:22&quot; strsplit의 split 인자는 사실 정규식 표현도 가능하다. (정규식에 대해서는 regular expression에 대한 다른 자료를 참조하길 바란다.) 다음은 정규식을 이용하여 ‘-’나,’ ‘(공백)나,’:’ 문자가 있는 곳 모두를 분리한 예이다. &gt; strsplit(&quot;2016-3-11 11:16:22&quot;, split=&quot;[- :]&quot;) [[1]] [1] &quot;2016&quot; &quot;3&quot; &quot;11&quot; &quot;11&quot; &quot;16&quot; &quot;22&quot; 2.3 변수와 할당 변수는 메모리 공간에 붙이는 레이블 R에서 연산을 수행하다 보면 연산의 중간 결과를 저장해둘 필요가 있다. 이 때 이용할 수 있는 것이 변수이다. 변수는 데이터를 저장해 두는 공간이라고 생각하면 쉽다. 변수는 사실 데이터를 저장해 두는 공간에 라벨을 붙여두는 것이다. 다시 그 데이터가 필요할 때 라벨을 이용하여 데이터가 저장된 공간에 가서 그 데이터 값을 가져와 이용하면 된다. 변수에 값 할당하기 할당(assignments)이란 어떤 변수에 데이터를 저장하는 것을 말한다. 예를 들어 x에 5라는 숫자 데이터를 할당하였다면 5라는 숫자가 x라는 라벨이 붙은 저장 공간에 들어간 것과 마찬가지이다. 우리는 x라는 라벨을 이용하여 필요할 때 x라는 라벨이 붙은 저장공간에 저장된 데이터 값을 가져올 것이다. 할당 연산자 변수에 데이터를 할당하는 것은 ‘&lt;-’ 또는 ‘=’ 연산자를 이용하여 이루어진다. 이 책에는 할당 연산자로 ‘&lt;-’을 이용할 것이다. 할당 연산자의 모양에서도 알 수 있듯이’&lt;-’ 연산자 오른쪽의 데이터를 왼쪽의 변수에 집어넣는다. x라는 변수에 저장된 데이터 값을 알고 싶으면 x를 입력한 후 Enter 키를 누르면 x의 값이 출력된다. &gt; x &lt;- 5 &gt; x [1] 5 연산에 변수 사용하기 x를 이용하여 다양한 명령을 수행할 수 있다. 뿐만 아니라 괄호 등을 이용하여 복잡한 연산을 수행할 수 있다. &gt; x + 2 [1] 7 &gt; x * 2 [1] 10 &gt; x^2 [1] 25 &gt; (x+3)^2 + 5 [1] 69 &gt; x [1] 5 위의 마지막 결과에서 볼 수 있듯이 변수의 값은 ‘&lt;-’ 연산자에 의해 다시 다른 값으로 할당되지 않으면 연산에서 사용되어도 원래의 값이 변하지 않는다. 변수에 값 재할당하기 변수는 데이터의 저장공간일 뿐이므로 현재 들어간 데이터 값 대신 다른 값을 재할당할 수도 있다. 다음의 예는 x에 7을 재할당한 후 앞서 수행한 연산을 다시 수행해 본 것이다. &gt; x &lt;- 7 &gt; x + 2 [1] 9 &gt; x*2 [1] 14 &gt; x^2 [1] 49 &gt; 2^x [1] 128 이제 x라는 라벨이 붙은 저장공간에 7이라는 숫자 데이터가 들어가 있으므로 x를 이용한 연산 결과가 앞의 예와는 다르게 나옴을 볼 수 있다. 할당문은 우변이 수행된 후 좌변으로 할당이 이루어진다. 한 명령문 안에서 x의 값을 가져와 연산에 이용한 후 그 결과를 다시 x에 재할당할 수 있다. 이 경우 ‘&lt;-’ 연산자 오른편의 연산이 먼저 수행된 후 ‘&lt;-’ 연산자에 의해 왼편의 변수로 할당이 이루어진다. &gt; x &lt;- x + 1; x [1] 8 &gt; x &lt;- 2 + x; x [1] 10 &gt; x &lt;- x*2; x [1] 20 &gt; x &lt;- x^2; x [1] 400 마찬가지로 한 변수의 값을 이용하여 연산을 수행한 후 다른 변수에 값을 할당할 수도 있다. 아래 예에서도 볼 수 있듯이 x가 연산에 이용되더라도 재할당이 이루어지지 않으면 x라고 라벨이 붙은 저장공간에 들어가 있는 데이터 값은 동일하다. &gt; x [1] 400 &gt; y &lt;- 2 * x &gt; y [1] 800 &gt; x [1] 400 여기서도 변수의 값은 할당문에 의해 할당 또는 재할당이 이루어지지 않으면 변화가 없음을 다시 확인할 수 있다. 변수 제거하기 rm() 여러 가지 이유로 변수를 제거할 필요가 있을 수 있다. 변수를 제거하려면 rm() 함수를 이용하면 된다. 제거할 변수를 rm() 함수 내에 기술하면 이 변수가 사라지게 된다. &gt; x; y [1] 400 [1] 800 &gt; rm(x, y) &gt; x Error in eval(expr, envir, enclos): object &#39;x&#39; not found &gt; y Error in eval(expr, envir, enclos): object &#39;y&#39; not found rm() 함수로 변수를 제거하면 변수가 사용하는 메모리는 자유롭게 되며, R이 다른 용도로 이용할 수 있다. 여기서 주의할 점은 rm()에 의해서 메모리가 자유롭게 되더라도 R이 사용하던 메모리가 운영체제로 바로 반환되지는 않는다는 것이다. 이를 처리하려면 gc() 함수를 이용하여 garbage collection을 하도록 해야 한다. 그러나 사실 R은 주기적으로 garbage collection을 하므로 특별한 이유가 없으면 이를 별도로 수행할 필요는 없다. 변수 목록 확인하기 ls() ls() 함수를 이용하면 현재 환경에서 정의되어진 모든 변수의 이름을 출력해 준다. 반면 rm() 함수는 list 인자에 변수의 이름을 주면 해당 변수를 메모리에서 제거한다. 따라서 아래와 같은 방식을 이용하면 현재 환경에 정의되어 있는 모든 변수를 제거할 수 있다. &gt; a &lt;- 5 &gt; b &lt;- 7 &gt; ls() [1] &quot;a&quot; &quot;b&quot; &gt; rm(list=ls()) &gt; ls() character(0) assign() 참고로 assign() 함수로도 변수의 할당은 할 수 있다. 대부분의 경우는 assign() 함수를 이용하는 것보다는 앞서 설명한 할당 연산자를 이용하여 변수에 값을 할당하는 것이 편리하고 이해하기도 쉽다. 그러나 가끔 많은 변수를 자동적으로 생성해야 하는 경우나 데이터베이스에서 변수의 이름을 읽어들여와 값을 할당하는 등의 경우에는 assign() 함수를 이용하는 것이 필요하다. assign() 함수는 첫번째 인수로 변수의 이름을 문자열로 갖고, 두번째 인수로 변수에 할당한 값을 갖는다. &gt; x1 Error in eval(expr, envir, enclos): object &#39;x1&#39; not found &gt; assign(&quot;x1&quot;, 5) &gt; x1 [1] 5 &gt; assign(&quot;x1&quot;, x1 + 3) &gt; x1 [1] 8 위의 예에서 x1이라는 변수가 없었는데, assign() 함수에 의해 x1 변수가 할당되었음을 볼 수 있다. 주의할 점은 보통의 할당문에서는 변수가 문자열과 구분되도록 따옴표 없이 사용되나, assign() 함수에서는 변수의 이름이 문자열로 따옴표와 함께 표시된다는 것이다. 2.4 함수를 이용한 연산 R의 기본 기능에는 다양한 함수가 포함되어 있다. 사용자도 자신만의 함수를 만들 수 있다. 함수는 입력으로 어떤 값을 받은 후 출력으로 어떤 값을 반환한다. 함수가 어떤 값을 입력받고 반환하는지는 함수마다 다르다. 함수 호출 하기 R에서 함수를 이용하려면 다음의 형태로 함수를 호출하여야 한다. &gt; 함수이름(함수 입력 인수) 함수 출력 값 아래는 제곱근을 구하는 sqrt() 함수의 예이다. 함수의 입력 인수(arguments)로는 4가 주어져 있고 제곱근을 구하는 함수는 입력된 4를 가지고 결과인 2를 반환하고 있다. 함수는 연산자와 함께 사용될 수 있고 함수의 결과가 다시 다른 함수의 입력 인수가 될 수 있다. &gt; sqrt(4) [1] 2 &gt; (sqrt(9) + 2) / 4 [1] 1.25 &gt; sin( (sqrt(9) + 2)/ 4 ) [1] 0.9489846 Table 2.1: 수학 관련 주요 함수 수학 함수 설명 ceiling(x) x의 값을 정수로 올림 floor(x) x의 값을 정수로 내림 trunc(x) x의 값의 소수점 자리를 버림 round(x) x의 값을 반올림 round(x, digits=n) x의 값을 소수점 n자리에서 반올림 sqrt(x) x의 제곱근 exp(x) x의 지수함수 값 log(x) 자연대수를 밑으로 하는 로그 값 log(x, base=a) a를 밑으로 하는 로그 값 sin(x), cos(x), tan(x) x의 삼각함수의 값 factorial(n) \\(n! = 1 \\times 2 \\times \\cdots \\times n\\) choose(n,k) n 개 중 k를 뽑는 조합의 수 실수를 정수로 변환하는 함수 표 2.1은 R에 내장되어 있는 수학 관련 주요 함수를 보여준다. 다음 예는 함수를 이용하여 숫자에 대한 올림, 내림, 버림, 반올림 등을 수행한 결과이다. &gt; a &lt;- 3.141593 &gt; ceiling(a) [1] 4 &gt; floor(a) [1] 3 &gt; trunc(a) [1] 3 &gt; round(a) [1] 3 &gt; round(a, digits=2) [1] 3.14 순열과 조합 함수 다음은 순열(factorial)과 조합(combination)의 값을 구한 결과이다. 30에 대한 순열 값은 매우 커서 공학 형식으로 숫자가 표시된다. 이를 일반적인 형식으로 표시하기 위해서 format 함수를 이용하였다. &gt; factorial(5) [1] 120 &gt; factorial(30) [1] 2.652529e+32 &gt; format(factorial(30), scientific = FALSE, ) [1] &quot;265252859812191032188804700045312&quot; &gt; choose(5, 2) [1] 10 &gt; choose(45, 6) [1] 8145060 함수에 대한 자세한 내용은 10 장의 함수(function)와 관련된 내용을 참조한다. "],
["ch-R-Vectors.html", "Chapter 3 R 벡터 3.1 숫자 벡터 3.2 논리 벡터 3.3 문자 벡터 3.4 결측치 (Missing Values) 3.5 인덱스 벡터와 필터링", " Chapter 3 R 벡터 벡터는 R의 통계 분석에서 가장 중요한 데이터 형식이다. 다른 범용의 프로그래밍 언어와는 다르게 R은 벡터 단위의 연산 및 조작을 지원함으로써 통계 데이터 분석에 매우 편리한 이점을 제공한다. 벡터는 동일 형식 데이터의 나열 벡터는 50명 학생들의 키 데이터 (162.1, 175.8, 183.2, …), 50명 학생들의 성별 데이터 (\"여\", \"남\", \"남\", ...)처럼 한가지 타입의 데이터를 나열한 것이다. 여기서 타입이란 1, 2 등의 숫자 타입, \"yes\", \"no\" 등의 문자열 타입, TRUE/FALSE의 논리적 타입을 의미한다. 숫자 벡터에는 숫자 데이터만 나열되고, 문자 벡터나 논리 벡터에는 각각 문자열과 논리값만이 나열된다. 벡터의 길이/크기 벡터가 포함하고 있는 데이터의 개수를 벡터의 길이 또는 크기라고 한다. 따라서 50 명 학생의 키 데이터는 길이가 50인 벡터가 된다. 사실 R은 벡터가 아닌 숫자, 문자, 논리값은 없다. 10이라는 숫자 하나도 사실은 길이가 1인 숫자 벡터이고, 문자열도 논리값도 길이가 1인 문자 벡터와 논리 벡터일 뿐이다. 3.1 숫자 벡터 3.1.1 c() 함수를 이용한 숫자 벡터 만들기 숫자 연결하여 벡터 만들기 c() 함수는 여러 가지 기능을 하지만 가장 중요한 기능은 두개 이상의 벡터를 인수로 받아 이를 연결(concatenating)하여 새로운 벡터를 만드는 것이다. 다음은 c() 함수로 숫자 2, 4, 6, 9, 10으로 이루어진 숫자 벡터를 만들어 y라는 변수에 할당하는 예이다. &gt; y &lt;- c(2, 4, 6, 8, 10) &gt; y [1] 2 4 6 8 10 R 콘솔 상에 변수 y를 입력한 후 Enter를 치면 변수 y의 내용을 출력한다. 변수가 벡터인 경우에는 벡터의 요소들을 나열한다. 앞의 예에서는 정수만으로 이루어진 벡터를 만들었는데 이번에는 실수가 들어간 숫자 벡터를 만들어 보자. 실수 하나가 벡터의 요소로 들어가자 나머지 숫자도 소수점을 가지는 실수로 표현됨을 볼 수 있다. &gt; x &lt;- c(1,3,5,7,9.2) &gt; x [1] 1.0 3.0 5.0 7.0 9.2 길이가 2 이상인 벡터 연결하여 새 벡터 만들기 지금까지는 숫자(길이가 1인 숫자 벡터)만을 연결하여 숫자 벡터를 만들었다. 이제 길이가 2 이상인 숫자 벡터 x와 y를 연결하여 새로운 숫자 벡터 z를 만들어 보도록 하자. &gt; z &lt;- c(x, y) &gt; z [1] 1.0 3.0 5.0 7.0 9.2 2.0 4.0 6.0 8.0 10.0 위의 예에서 x와 y의 위치가 바뀌면 어떻게 될까? 아래 결과에서 볼 수 있듯이 새롭게 생긴 z 벡터의 요소의 순서가 바뀐다. y의 요소 다음에 x의 요소들이 차례대로 나열된다. &gt; z &lt;- c(y, x) &gt; z [1] 2.0 4.0 6.0 8.0 10.0 1.0 3.0 5.0 7.0 9.2 여러 줄에 걸친 벡터 출력 c() 함수는 세 개 이상의 벡터를 연결시킬 수도 있다. 아래 결과에서 벡터 w는 x, y, z의 요소들이 차례로 나열되어 새 벡터가 되었음을 볼 수 있다. 이 때 벡터가 길어 여러 줄로 출력이 되었다. 출력 결과 중 [1]과 [11]은 첫째 줄은 벡터의 1번째 요소부터, 둘째 줄은 11번째 요소부터 출력되고 있음을 나타낸다. 이렇듯 벡터가 길어 여러 줄로 콘솔에 출력되면 각 줄의 맨 앞에 표시되는 요소가 벡터의 몇 번째 요소인지를 알려준다. &gt; w &lt;- c(x, y, z) &gt; w [1] 1.0 3.0 5.0 7.0 9.2 2.0 4.0 6.0 8.0 10.0 [11] 2.0 4.0 6.0 8.0 10.0 1.0 3.0 5.0 7.0 9.2 3.1.2 패턴을 이용한 숫자 벡터 만들기 R의 데이터를 다루다 보면 어떤 패턴을 따르는 숫자 벡터가 필요한 경우가 있다. 예를 들어 50명의 학생에게 1부터 50까지 차례로 일련번호를 부여하려고 한다고 하자. c() 함수를 이용하여 1부터 50까지 숫자를 일일이 연결하여 이를 만드는 것은 매우 번거로운 일이다. 이러한 경우에는 n:m 명령을 사용하여, 숫자 n부터 시작하여 숫자 m까지 1씩 증가하거나 감소하는 수열로 된 벡터를 쉽게 만들 수 있다. n:m &gt; 1:10 [1] 1 2 3 4 5 6 7 8 9 10 &gt; 10:1 [1] 10 9 8 7 6 5 4 3 2 1 위 결과에서 보듯이 m이 n보다 크면 1씩 증가하는 수열을, n이 m보다 크면 1씩 감소하는 수열이 생성된다. 위의 예는 자연수만을 사용하였는데, 사실 수열의 시작과 끝을 나타내는 숫자는 음의 정수나 실수 등 어떠한 숫자도 가능하다. n이 정수가 아닌 경우도 n부터 시작하여 1씩 증가 또는 감소하여 m을 넘지 않는 수열을 만든다는 사실은 변함이 없다. &gt; -4:8 [1] -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 &gt; 0.7:8 [1] 0.7 1.7 2.7 3.7 4.7 5.7 6.7 7.7 &gt; 2.3:-5 [1] 2.3 1.3 0.3 -0.7 -1.7 -2.7 -3.7 -4.7 seq() seq() 함수를 이용하면 1씩 증가하거나 감소하는 수열 벡터뿐 아니라 좀 더 복잡한 수열 벡터도 생성할 수 있다. &gt; seq(n, m) &gt; seq(n, m, by=k) &gt; seq(length=j, from=n, by=k) seq() 함수는 입력 인수의 형태에 따라 생성하는 수열이 다르다. seq(n, m)으로 함수를 호출하면 n:m과 마찬가지로 1씩 증가하거나 감소하는 수열을 생성한다. seq(n, m, by=k)로 호출하면 n부터 시작하여 k씩 증가하여 m을 넘지 않는 수열을 생성한다. seq(length=j, from=n, by=k)로 호출하면 n부터 시작하여 k씩 증가하는 길이가 j인 수열을 만든다. &gt; seq(5, 15) [1] 5 6 7 8 9 10 11 12 13 14 15 &gt; seq(5, 15, by = 2) [1] 5 7 9 11 13 15 &gt; seq(length=10, from = -3, by = 0.5) [1] -3.0 -2.5 -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 1부터 어떤 벡터의 길이까지 일련번호를 생성할 때 seq() 함수를 이용하면 편리하다. seq()의 along 인수에 벡터를 부여하면 1부터 그 벡터의 길이만큼의 일련번호가 생성된다. &gt; y [1] 2 4 6 8 10 &gt; seq(along=y) [1] 1 2 3 4 5 rep() 어떤 벡터를 반복시켜서 새로운 벡터를 만들고 싶을 때는 rep() 함수를 이용한다. 첫번째 인수에 반복할 벡터를, times 인수에 반복할 횟수를 부여한다. rep() 함수를 빈번하게 이용하는 경우가 숫자 하나를 여러번 반복하여 벡터를 만들 때이다. &gt; y &lt;- c(1:5, 0:-5) &gt; rep(y, times = 2) [1] 1 2 3 4 5 0 -1 -2 -3 -4 -5 1 2 3 4 5 0 -1 -2 -3 -4 -5 &gt; rep(1, times = 10) [1] 1 1 1 1 1 1 1 1 1 1 rep() 함수를 이용하면 벡터 전체를 차례로 반복시키는 것뿐 아니라, 요소별로 횟수만큼 반복시킨 후 이를 결합하여 새로운 벡터를 만들 수도 있다. 이 경우에는 times 인수 대신 each 인수에 반복할 회수를 부여한다. &gt; rep(y, each = 2) [1] 1 1 2 2 3 3 4 4 5 5 0 0 -1 -1 -2 -2 -3 -3 -4 -4 -5 -5 3.1.3 숫자 벡터의 연산 요소 단위 연산 (elementwise operation) R의 강점 중 하나가 벡터의 요소끼리 연산을 지원한다는 것이다. 이는 여타의 범용 프로그래밍 언어에서는 볼 수 없는 점이다. 길이가 동일한 두 벡터에 더하기나 곱하기 연산 등을 수행하면, 같은 위치에 있는 요소끼리 해당 연산이 이루어진다(그림 3.1 참조). &gt; x &lt;- seq(length=5, from=0, by=10) &gt; x [1] 0 10 20 30 40 &gt; y &lt;- 1:5 &gt; y [1] 1 2 3 4 5 &gt; x + y [1] 1 12 23 34 45 &gt; x - y [1] -1 8 17 26 35 &gt; x * y [1] 0 20 60 120 200 &gt; x / y [1] 0.000000 5.000000 6.666667 7.500000 8.000000 다른 범용 프로그래밍 언어에 대한 지식이 있는 독자라면, 이를 해당 언어로 구현하려면 어떻게 해야 할지 잠시 생각해 보자. 반복문을 이용하여 이를 수행해야 할 것이다. 이러한 점을 고려하면 R이 벡터 연산을 얼마나 편리하게 수행하게 해 주는지 이해할 수 있을 것이다. Figure 3.1: 길이가 같은 벡터의 연산 벡터 재사용 (recycling) 연산에 사용되는 두 벡터의 길이가 다르면 어떻게 될까? 이 경우 길이가 짧은 벡터의 요소들이 순환 반복되어 사용된다(그림 3.2 참조). 이러한 현상을 벡터의 재사용(recycling)이라고 부른다. 다음 예는 길이가 10인 z 벡터와 길이가 5인 y 벡터를 더한 결과를 보여준다. 결과에서 보듯이 z의 10개 요소와의 더하기 위해, y의 요소가 차례대로 한번 사용된 후 다시 한번 더 반복되어 사용되었다. (더한 결과의 일의 자리를 살펴보면 이를 확인할 수 있다). &gt; z &lt;- rep(x, times=2) &gt; z [1] 0 10 20 30 40 0 10 20 30 40 &gt; z + y [1] 1 12 23 34 45 1 12 23 34 45 다음은 길이가 11인 w 벡터와 길이가 5인 y 벡터를 더한 예이다. 이 경우에도 w의 11개 요소와 대응되기 위해서 y의 전 요소가 두 번 반복되어 이용되고 마지막으로 y의 첫째 요소가 다시 재사용되었음을 볼 수 있다(그림 3.2 참조). 이처럼 두 벡터의 길이가 서로 배수가 아닌 경우에는 혹시 사용자의 착각일 수도 있기 때문에 경고 메시지가 출력된다. 경고 메시지는 오류가 아니므로 계산 수행은 정상적으로 수행된다. &gt; w &lt;- c(z, 50) &gt; w [1] 0 10 20 30 40 0 10 20 30 40 50 &gt; w + y Warning in w + y: longer object length is not a multiple of shorter object length [1] 1 12 23 34 45 1 12 23 34 45 51 Figure 3.2: 길이가 다른 벡터의 연산 사실 길이가 다른 벡터 간의 연산이 가장 빈번히 사용되는 경우는 숫자 하나와 숫자 벡터간의 연산이다. 이 경우 숫자 하나가 벡터의 길이만큼 재사용되어 연산이 이루어진다. &gt; x &lt;- 1:5 &gt; 10 * x [1] 10 20 30 40 50 &gt; x + 10 [1] 11 12 13 14 15 &gt; 10/x [1] 10.000000 5.000000 3.333333 2.500000 2.000000 &gt; x^2 [1] 1 4 9 16 25 Table 3.1: 숫자 벡터를 인수로 하는 함수 예 함수명 함수 설명 length(x) 벡터 x의 길이를 반환한다. sum(x) 벡터 x에 있는 모든 요소들을 더한 결과를 반환한다. mean(x) 벡터 x에 있는 요소들의 평균을 반환한다. var(x) 벡터 x에 있는 요소들의 분산을 반환한다. sd(x) 벡터 x에 있는 요소들의 표준편차를 반환한다. range(x) 벡터 x에 있는 요소들의 최소값과 최대값을 반환한다. min(x)/max(x) 벡터 x에 있는 요소들의 최소값/최대값을 반환한다. median(x) 벡터 x에 있는 요소들의 중위수를 반환한다. rank(x) 벡터 x의 각 요소를 작은 것에서 큰 것까지 순위를 반환한다. sort(x) 벡터 x의 각 요소를 순서대로 배열한다. order(x) 벡터 x의 요소의 값이 가장 작은 것부터 NA 가장 큰 것까지 순서대로 요소의 위치를 반환한다. which.max(x) 벡터 x의 최대값/최소값의 위치를 반환한다. which.min(x) NA which(x) 벡터 x에서 조건을 만족하는 요소의 위치를 반환한다. 숫자 벡터를 인수로 하는 함수 숫자 벡터에 사칙연산 등의 수학 연산뿐 아니라, R에서 제공하는 다양한 함수도 적용할 수 있다. 숫자 벡터를 인수로 하는 함수들은 많이 있는데, 그 중 대표적인 함수들을 표 3.1에 제시하였다. 다음은 숫자 벡터에 함수를 적용한 예이다. &gt; x &lt;- c(11, 3, 4, 20, 5) &gt; x [1] 11 3 4 20 5 &gt; length(x) [1] 5 &gt; sum(x) [1] 43 &gt; mean(x) [1] 8.6 &gt; var(x) [1] 50.3 &gt; sd(x) [1] 7.092249 &gt; sum( (x - mean(x))^2 ) / ( length(x) - 1 ) [1] 50.3 &gt; range(x) [1] 3 20 &gt; min(x) [1] 3 &gt; max(x) [1] 20 &gt; median(x) [1] 5 &gt; which.max(x) [1] 4 &gt; which.min(x) [1] 2 &gt; which(x &gt; 10 ) [1] 1 4 &gt; which(x &gt; 10 &amp; x &lt; 15) [1] 1 벡터의 순서 및 정렬 관련 함수 R은 벡터 요소들의 크기 순서, 정렬을 해주는 rank(), order(), sort() 함수가 있다. rank() 함수는 벡터 요소의 크기 등수를 작은 것에서 큰 것 순으로 1에서부터 등수를 매겨준다. 즉, rank() 함수 결과의 첫번째 요소는 원래 벡터의 첫번째 요소의 크기 등수이다. 반면 order() 함수는 작은 것부터 큰 것 순으로 요소의 원래 벡터에서의 위치를 알려준다. 즉, order() 함수 결과의 첫번재 요소는 원래 벡터에서 가장 작은 요소가 어느 위치에 있는지를 알려준다. 그림 3.3는 앞의 설명을 도식화하여 보여준다. &gt; rank(x) [1] 4 1 2 5 3 &gt; sort(x) [1] 3 4 5 11 20 &gt; order(x) [1] 2 3 5 1 4 &gt; knitr::include_graphics(&quot;img/rank-vs-order.png&quot;) Figure 3.3: rank() 함수와 order() 함수의 비교 3.2 논리 벡터 R은 숫자뿐 아니라 논리값으로 구성된 벡터를 만들 수 있다. 논리 벡터의 요소들은 TRUE, FALSE, NA (not available) 값을 가질 수 있다. c()로 논리 벡터 만들기 논리 벡터도 숫자 벡터와 마찬가지로 논리값을 c() 함수로 연결하여 만들 수 있다. 아래 예에서 보듯이 TRUE와 FALSE 대신 혼동의 여지가 없는 경우에는 T와 F 만 입력하여도 TRUE와 FALSE로 인식함을 볼 수 있다. &gt; a &lt;- c(T, F, T); a [1] TRUE FALSE TRUE 비교 연산으로 논리 벡터 만들기 논리 벡터는 위의 예처럼 c() 함수로도 만들 수 있지만 많은 경우 벡터의 비교 연산의 결과로서 만들어진다. 다음은 비교 연산을 통해 논리 벡터를 생성한 예이다. ‘&lt;’, ‘&lt;=’, ‘&gt;’, ‘&gt;=’, ‘==’, ‘!=’ 등의 비교 연산이 벡터 요소별로 수행되어 논리 벡터가 생성되었다. &gt; y &lt;- 1:5 &gt; y &gt; 3 [1] FALSE FALSE FALSE TRUE TRUE &gt; y &gt;= 3 [1] FALSE FALSE TRUE TRUE TRUE &gt; y &lt; 5 [1] TRUE TRUE TRUE TRUE FALSE &gt; y &lt;= 5 [1] TRUE TRUE TRUE TRUE TRUE &gt; y == 2 [1] FALSE TRUE FALSE FALSE FALSE &gt; y != 2 [1] TRUE FALSE TRUE TRUE TRUE 논리 연산으로 논리 벡터 만들기 기존 논리 벡터들에 대해 논리 연산을 수행하여 새로운 논리 벡터를 만들 수도 있다. 다음은 ‘&amp;’, ‘’, ‘!’ 등의 논리 연산자를 이용하여 논리 벡터에 대해 AND, OR, NOT 연산을 수행한 예이다. &gt; b &lt;- !a; b [1] FALSE TRUE FALSE &gt; a &amp; b [1] FALSE FALSE FALSE &gt; a | b [1] TRUE TRUE TRUE any() all() 논리 연산은 아니지만 논리 벡터에 자주 사용되는 함수가 any()와 all() 함수이다. 이 함수를 이용하면 논리 벡터의 논리값 중 하나라도 TRUE가 있는지 또는 모든 논리값이 TRUE인지를 확인할 수 있다. &gt; any( c(F, F, F) ) [1] FALSE &gt; any( c(F, F, T) ) [1] TRUE &gt; all( c(T, F, T) ) [1] FALSE &gt; all( c(T, T, T) ) [1] TRUE any()와 all()을 비교 연산자와 함께 이용하면 어떤 조건을 만족하는 요소가 벡터에 하나라도 있는지 또는 모든 요소가 조건을 만족하는지를 쉽게 확인할 수 있다. &gt; cars$dist [1] 2 10 4 22 16 10 18 26 34 17 28 14 20 24 28 26 34 34 46 [20] 26 36 60 80 20 26 54 32 40 32 40 50 42 56 76 84 36 46 68 [39] 32 48 52 56 64 66 54 70 92 93 120 85 &gt; any(cars$dist &gt; 100) [1] TRUE &gt; any(cars$dist &gt; 200) [1] FALSE &gt; all(cars$dis &gt; 5) [1] FALSE &gt; all(cars$dist &gt; 0) # for checking data errors [1] TRUE Figure 3.4: ifelse() 함수 연산 ifelse() ifelse() 함수는 논리 벡터를 이용하는 또 다른 벡터 연산 함수이다. ifelse(x, a, b)로 호출되는데, x에는 논리 벡터, a와 b에는 (원칙적으로는) x의 길이와 동일한 벡터가 부여된다. ifelse() 함수는 x의 요소가 TRUE인 경우에는 벡터 a의 요소를, FALSE인 경우에는 벡터 b의 요소를 선택하여 x와 길이가 동일한 새로운 벡터를 만들어 낸다. 그림 3.4은 다음 예처럼 a 벡터가 1:5, b 벡터가 -1:-5일 때, x 벡터의 논리값에 따라 a와 b의 요소 중 어떤 요소가 선택되어 새로운 벡터가 만들어지는지를 보여준다. &gt; x &lt;- c(T, F, F, T, F) &gt; a &lt;- 1:5 &gt; b &lt;- -1:-5 &gt; y &lt;- ifelse(x, a, b); y [1] 1 -2 -3 4 -5 ifelse()의 첫번째 인수로 논리 벡터가 직접 부여되기보다는 비교 연산의 결과가 부여되는 경우가 많다. 다음은 벡터 y에서 양수인 요소는 그대로 두고, 0이하인 요소는 0이 되도록 하여 새로운 벡터를 만든 예이다. &gt; ifelse(y &gt; 0, y, 0) [1] 1 0 0 4 0 위의 결과가 나온 이유는 다음과 같다. 첫번째 x 인수에 y와 0을 비교하는 연산이 들어갔다. 이 비교 연산은 다음과 같이 y보다 큰 요소에만 TRUE를 주는 논리값 벡터를 반환한다. &gt; y &gt; 0 [1] TRUE FALSE FALSE TRUE FALSE 두번째 a 인수에는 y가 부여되었으므로로 위의 비교 연산에서 TRUE가 된 위치에는 y 요소가 선택된다. 그리고 세번째 b 인수에는 0이 들어갔다. x 위치에 들어간 벡터의 요소가 5개인데, b 위치에 들어간 벡터는 요소가 1개이므로 숫자 벡터의 연산에서와 마찬가지로 0이 5번 재사용된다. 그러므로 x의 값이 FALSE인 위치에 0이 들어가게 된다 (그림 3.5 참조). Figure 3.5: ifelse() 함수 연산에서의 벡터 재사용 3.3 문자 벡터 문자 벡터는 문자를 요소로 하는 벡터이다. 범주형 데이터를 다루거나 데이터에 이름을 부여할 때 자주 이용된다. 문자 벡터 만들기 문자 벡터의 생성은 숫자나 논리 벡터처럼 c() 함수를 이용하여 생성할 수 있다. &gt; students &lt;- c(&quot;길동&quot;, &quot;철수&quot;, &quot;Tom&quot;) &gt; students [1] &quot;길동&quot; &quot;철수&quot; &quot;Tom&quot; 숫자나 논리 벡터를 as.character() 함수를 이용하여 문자 벡터로 변환할 수도 있다. 다음 예에서 n은 숫자 벡터로 따옴표 없이 값이 표시되고, num은 문자 벡터로 모든 요소가 따옴표로 둘러싸여 표시됨을 확인한다. &gt; n &lt;- 1:3 &gt; n [1] 1 2 3 &gt; num &lt;- as.character(n) &gt; num [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; paste()로 문자 벡터 연결하기 문자 벡터에 많이 사용되는 연산 중 하나가 문자 벡터를 요소끼리 서로 연결시키는 연산이다. paste() 함수로 이러한 문자 벡터 연결을 수행할 수 있는데, 호출 시 sep 인수를 사용하지 않으면 연결되는 벡터의 요소는 공백으로 연결되고, sep 인수가 사용되면 sep 인수에 부여된 문자열이 연결되는 요소 사이에 구분자로 들어간다. &gt; paste(students, num) [1] &quot;길동 1&quot; &quot;철수 2&quot; &quot;Tom 3&quot; &gt; paste(students, num, sep=&quot;&quot;) [1] &quot;길동1&quot; &quot;철수2&quot; &quot;Tom3&quot; &gt; paste(students, num, sep=&quot;-&quot;) [1] &quot;길동-1&quot; &quot;철수-2&quot; &quot;Tom-3&quot; &gt; paste(students, 1:2) [1] &quot;길동 1&quot; &quot;철수 2&quot; &quot;Tom 1&quot; 마지막 예에서 문자 벡터의 길이가 다르면 숫자 벡터의 연산처럼 길이가 짧은 벡터의 요소가 재사용됨을 볼 수 있다. 또 paste() 적용시 숫자 벡터가 자동으로 문자 벡터로 변환되어 연결되었음을 볼 수 있다. paste() 함수는 세 개 이상의 문자 벡터를 연결하는 데에도 사용될 수 있다. &gt; paste(students, num, c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), &quot;!&quot;) [1] &quot;길동 1 A !&quot; &quot;철수 2 B !&quot; &quot;Tom 3 C !&quot; strsplit()로 문자 벡터 분리하기 paste()와 반대의 역할을 하는 함수가 strsplit()이다. strsplit()는 paste()와는 달리 문자열을 나눌 때 구분자로 사용할 문자열을 split 인수로 반드시 제공해야 한다. 마지막 예에서 x와 split의 요소가 같은 위치끼리 적용되어 문자열 분리가 수행되었음을 확인할 수 있다. &gt; x &lt;- c(&quot;2015-3-15 10:12:12&quot;, &quot;2016-10-11 11:12:13&quot;, + &quot;2014-7-8 02:03:04&quot;) &gt; strsplit(x, split=&quot; &quot;) [[1]] [1] &quot;2015-3-15&quot; &quot;10:12:12&quot; [[2]] [1] &quot;2016-10-11&quot; &quot;11:12:13&quot; [[3]] [1] &quot;2014-7-8&quot; &quot;02:03:04&quot; &gt; strsplit(x, split=&quot;-&quot;) [[1]] [1] &quot;2015&quot; &quot;3&quot; &quot;15 10:12:12&quot; [[2]] [1] &quot;2016&quot; &quot;10&quot; &quot;11 11:12:13&quot; [[3]] [1] &quot;2014&quot; &quot;7&quot; &quot;8 02:03:04&quot; &gt; strsplit(x, split=&quot;:&quot;) [[1]] [1] &quot;2015-3-15 10&quot; &quot;12&quot; &quot;12&quot; [[2]] [1] &quot;2016-10-11 11&quot; &quot;12&quot; &quot;13&quot; [[3]] [1] &quot;2014-7-8 02&quot; &quot;03&quot; &quot;04&quot; &gt; strsplit(x, split=c(&quot;-&quot;, &quot;:&quot;, &quot; &quot;)) [[1]] [1] &quot;2015&quot; &quot;3&quot; &quot;15 10:12:12&quot; [[2]] [1] &quot;2016-10-11 11&quot; &quot;12&quot; &quot;13&quot; [[3]] [1] &quot;2014-7-8&quot; &quot;02:03:04&quot; nchar()로 문자수 세기 nchar() 함수는 문자 벡터의 각 요소의 문자 개수를 알려 준다. 공백도 문자이므로 문자 개수를 셀 때 포함이 된다는데 주의한다. &gt; nchar(&quot;날짜&quot;) [1] 2 &gt; a &lt;- c(&quot;날짜&quot;, &quot;day&quot;, &quot;date&quot;, &quot;날짜와 시간&quot;) &gt; nchar(a) [1] 2 3 4 6 Table 3.2: 문자 벡터를 인수로 하는 함수 예 함수명 함수 설명 nchar(x) 벡터 x의 문자열 요소의 문자 수를 반환한다. substr(x, start, stop) 벡터 x의 문자열 요소의 start번째 문자부터 stop번째 문자까지의 부분 문자열을 출력한다. grep(pattern, x, ignore.case=F, fixed=F) 벡터 x의 문자열 요소에 pattern 문자열 요소가 있는지 검색한다. pattern은 정규식일 수 있다. sub(pattern, replacement, x, ignore.case=F, fixed=F) 벡터 x의 문자열 요소에서 pattern을 찾아 replacement로 대체한다. strsplit(x, split, fixed=F) 벡터 x의 문자열 요소를 split에서 분리한 결과를 반환한다. paste(…, sep=’ ’) 문자 벡터를 sep를 이용하여 결합시킨 결과를 반환한다. toupper(x) 벡터 x의 문자열 요소를 대문자로 변환한다. tolower(x) 벡터 x의 문자열 요소를 소문자로 변환한다. 이외에도 다양한 문자 벡터 함수가 존재한다. 그 중 대표적인 함수를 표 3.2에 제시하였다. 3.4 결측치 (Missing Values) NA R에서는 데이터에 결측치가 있을 때 이를 NA 값으로 표시한다. 예를 들어 5명의 학생의 키 데이터가 있는데 마지막 학생의 데이터를 얻지 못하였다면, 그 학생의 데이터는 NA로 값을 입력한다. is.na() na.omit() is.na() 함수를 이용하면 결측치의 포함 여부나 위치를 확인할 수 있다. is.na()는 벡터에서 결측치가 있는 위치는 TRUE, 결측치가 아닌 위치는 FALSE로 하는 논리 벡터를 결과로 반환한다. na.omit() 함수를 이용하면 결측치를 제외한 벡터를 만들 수 있다. na.omit()에 대한 자세한 설명은 도움말을 참조하기 바란다. &gt; z &lt;- c(11:13, NA) &gt; z [1] 11 12 13 NA &gt; is.na(z) [1] FALSE FALSE FALSE TRUE &gt; na.omit(z) [1] 11 12 13 attr(,&quot;na.action&quot;) [1] 4 attr(,&quot;class&quot;) [1] &quot;omit&quot; na.rm 인수 숫자 벡터에 결측치가 있으면 sum()이나 mean() 함수 등의 결과는 NA로 출력된다. 숫자 벡터에 결측치가 있기 때문에 합이나 평균을 알 수 없다는 의미이다. 만약 결측치를 제외하고 합이나 평균을 구하고 싶으면, 이들 함수를 호출할 때 na.rm=TRUE 인수를 추가하여야 한다. 그러면 결측치를 제외하고 해당 결과를 계산하게 할 수 있다. &gt; sum(z) [1] NA &gt; sum(z, na.rm=TRUE) [1] 36 NaN 결측치는 아니지만 데이터의 값을 결정할 수 없는 경우가 있다. 대표적인 경우가 0에서 0을 나누는 경우이다. 이 경우 숫자 연산의 결과를 결정할 수 없으므로 NaN(Not a Number)로 결과를 표현된다. 주의할 점은 R은 무한대도 숫자로 간주하므로, 무한대의 결과가 나올 때는 Inf로 결과를 표현한다. 다음 예에서 앞의 두 계산은 무한대로, 뒤의 두 계산은 값을 결정할 수 없어 NaN로 결과를 반환함을 볼 수 있다. &gt; 1/0 [1] Inf &gt; Inf * 5 [1] Inf &gt; 0/0 [1] NaN &gt; Inf - Inf [1] NaN is.nan() 벡터에 NaN가 포함되어 있는지를 확인하려면 is.nan() 함수를 사용하면 된다. is.na()와 마찬가지로 NaN 요소가 있는 위치를 TRUE 값으로 하는 논리 벡터를 반환한다. 다음 예에서 보듯이 NaN가 포함되었는지를 정확히 알기 위해서는 is.na()가 아니라 is.nan() 함수를 실행하여야 한다. &gt; z &lt;- -1:1 / 0 &gt; z [1] -Inf NaN Inf &gt; is.na(z) [1] FALSE TRUE FALSE &gt; r &lt;- c(z, NA) &gt; is.na(r) [1] FALSE TRUE FALSE TRUE &gt; is.nan(r) [1] FALSE TRUE FALSE FALSE 통계 데이터에는 결측치가 자주 발생한다. 그리고 결측치 처리는 통계 분석에서 매우 중요한 문제 중 하나이다. R에서 결측치를 처리하는 다양한 기법에 대해서는 R in Action2의 18장을 참조하기 바란다. 3.5 인덱스 벡터와 필터링 데이터를 분석하다 보면, 데이터의 특정 요소만 추출하여 분석해 보고 싶을 때가 있다. 40세 이상의 고객만 추출하여 분석한다든지, 남자 학생에 대해서만 별도의 분석을 하는 경우가 그러한 예라고 할 수 있다. 이렇게 데이터에서 특정 부분만 추출하여 새로운 데이터를 만드는 작업을 필터링(filtering)이라고 한다. 벡터 필터링은 특정 벡터에서 특정 요소만을 추출하는 것을 의미한다. R에서 벡터 필터링은 인덱스 벡터를 이용하여 수행된다. 여기서 인덱스란 벡터에서 특정 요소의 위치를 의미한다. 예를 들어 5개의 요소로 구성된 벡터에서 두번째 요소를 추출하려면 두번째라는 위치가 그 요소의 인덱스가 된다. 그런데 어떤 벡터에서 추출하고자 하는 요소가 여러 개일 수도 있다. 이 경우 추출해야할 위치를 여러 개 나열해야 하고, 이렇게 나열한 요소의 위치 정보를 인덱스 벡터라고 한다. 물론 하나의 요소만 추출하고자 한다면 인덱스 벡터는 길이가 1이 될 것이다. 벡터 필터링을 하려면 다음처럼 벡터의 이름 다음에 인덱스 벡터를 대괄호 안에 기술하면 된다. &gt; vector[index_vector] 인덱스 벡터는 자연수 벡터, 음의 정수 벡터, 논리 벡터, 이름 벡터의 네 가지 형태를 가질 수 있다. 이를 각각 살펴보도록 하자. 3.5.1 자연수 인덱스 벡터 자연수 인덱스는 추출할 요소의 위치를 자연수로 표현한다. 벡터의 첫번째 요소의 위치는 1로, 두번째 요소의 위치는 2로 하여, 요소의 위치를 차례대로 1부터 벡터 길이까지의 자연수로 표현한다. 아래 예는 10개의 요소로 이루어진 벡터 x에서 자연수 인덱스 벡터로 새로운 벡터를 추출한 예이다(그림 3.6 참조). 마지막 예처럼 인덱스 벡터에서 자연수가 반복되면 해당 위치에 있는 요소가 반복되어 추출됨을 볼 수 있다. &gt; x &lt;- 11:20 &gt; x[6] [1] 16 &gt; x[c(6, 10)] [1] 16 20 &gt; x[seq(3, 9, by=2)] [1] 13 15 17 19 &gt; x[rep(c(2,4), times=3)] [1] 12 14 12 14 12 14 Figure 3.6: 자연수 인덱스 벡터를 이용한 벡터 필터링 인덱스 벡터를 사용하여 여러 요소를 뽑을 때 주의할 점이 있다. 벡터의 필터링에서 대괄호 안에는 오직 하나의 인덱스 벡터만 기술될 수 있다는 것이다. 만약 2개 이상의 요소를 뽑아야 한다면, c() 등으로 연결하여 하나의 인덱스 벡터로 만든 후 대괄호에 넣어야 한다. 만약 이를 실수하여 다음처럼 뽑을 요소를 각각 기술하게 되면 오류가 발생한다. &gt; x[6, 10] Error in x[6, 10]: incorrect number of dimensions 앞의 예에서는 6이라는 요소를 하나만 가지는 벡터 하나와, 10이라는 요소 하나만 가지는 또 다른 벡터를 대괄호 안에 기술한 것이다. 벡터는 일차원 구조로 오직 한 개의 인덱스 벡터를 입력 받으므로, 위의 경우는 c(6, 10)으로 하나의 벡터로 결합하여 인덱스 벡터를 전달해야 한다. 행렬에서는 두 개의 인덱스 벡터를 입력받게 되는데, 이 형식과 벡터의 인덱스 벡터를 혼동하지 않아야 한다. 추출해야 할 요소를 사용자가 직접 지정할 수도 있지만, 어떤 경우에는 함수를 이용하여 원하는 요소를 특정할 수도 있다. 예를 들어 which.min() 함수는 숫자 벡터의 최소값의 위치를 자연수 인덱스 형식으로 반환한다. 따라서 which.min() 결과를 인덱스 벡터로 이용하면 해당 벡터의 최소값을 추출할 수 있다. 자연수 인덱스 벡터로 많이 사용되는 함수 중 하나가 order() 함수이다. order() 함수는 크기 순으로 벡터 요소의 위치를 반환해 주는 함수이다. 이 함수의 결과를 인덱스 벡터로 사용하면 벡터의 요소를 크기로 정렬하는 효과가 발생한다. &gt; x &lt;- c(7, 9, 4, 6, 13, 4, 1, 11) &gt; x[which.min(x)] # You can use min() instead. [1] 1 &gt; x[which.max(x)] # You can use max() instead. [1] 13 &gt; x[which(x &gt; 10)] # You can use a logical index vector instead. [1] 13 11 &gt; x[order(x)] # You can use sort() instead. [1] 1 4 4 6 7 9 11 13 3.5.2 음의 정수 인덱스 벡터 자연수 인덱스가 추출한 요소의 위치를 표현한다면, 음의 정수 인덱스는 추출하지 않은 요소의 위치를 표현한다. 따라서 벡터 필터링에 음의 정수 인덱스 벡터가 사용되면, 데이터 벡터에서 해당 위치의 요소가 제외된 나머지 요소로 새로운 벡터를 만들어 반환한다. 예를 들어 인덱스 벡터가 -2라면 원래 벡터의 2번째 요소만 제외한 나머지 요소로 이루어진 벡터가 반환된다(그림 3.7 참조). &gt; x &lt;- 11:20; x [1] 11 12 13 14 15 16 17 18 19 20 &gt; x[-2] [1] 11 13 14 15 16 17 18 19 20 &gt; x[c(-2, -4)] [1] 11 13 15 16 17 18 19 20 &gt; x[-(3:6)] [1] 11 12 17 18 19 20 Figure 3.7: 음의 정수 인덱스 벡터를 이용한 벡터 필터링 3.5.3 논리 인덱스 벡터 논리 인덱스는 추출할 요소는 TRUE, 추출하지 않을 요소는 FALSE로 표시한다. 인덱스 벡터가 논리 벡터로 주어지면 데이터 벡터에서 TRUE 위치의 요소만 선택되어 새로운 벡터가 만들어진다. 다음 예와 그림 3.8은 논리 인덱스 벡터가 벡터 필터링에 어떻게 사용되는지를 보여준다. &gt; x &lt;- 1:5 &gt; y &lt;- c(T, F, T, T, F) &gt; x[y] [1] 1 3 4 Figure 3.8: 논리값 인덱스 벡터를 이용한 벡터 필터링 위의 예처럼 사용자가 직접 추출할 요소를 TRUE로 직접 기술하여 논리 인덱스 벡터를 제공할 수도 있지만, 더 많은 경우는 추출할 조건을 비교 연산 표현식으로 제공하는 경우가 더 많다(그림 3.8 참조). &gt; x &gt; 3 [1] FALSE FALSE FALSE TRUE TRUE &gt; x[x&gt;3] [1] 4 5 &gt; x &gt;3 &amp; x &lt;5 [1] FALSE FALSE FALSE TRUE FALSE &gt; x[x &gt;3 &amp; x &lt;5] [1] 4 다음처럼 논리 인덱스 벡터가 데이터 벡터의 길이보다 작으면 인덱스 벡터가 재사용되어 벡터 필터링이 이루어진다. &gt; y &lt;- c(TRUE, FALSE) &gt; x[y] [1] 1 3 5 3.5.4 이름 인덱스 벡터 R에선 벡터의 각 요소에 이름을 부여할 수 있다. 이름 인덱스 벡터는 추출할 요소의 위치를 벡터 요소의 이름으로 지정하는 방식이다. 벡터 요소의 이름은 names() 함수로 확인하거나 할당할 수 있다. 벡터의 요소에 이름을 부여하면, 벡터가 출력될 때 데이터의 값뿐 아니라 요소의 이름도 함께 출력이 된다. 다음은 names() 함수를 이용하여 animals라는 숫자 벡터의 각 요소에 이름을 부여한 후, 이름 인덱스 벡터로 요소들을 추출한 예이다. &gt; animals &lt;- c(5, 7, 3, 2) &gt; names(animals) &lt;- c(&quot;cats&quot;, &quot;dogs&quot;, &quot;camels&quot;, &quot;donkeys&quot;) &gt; animals cats dogs camels donkeys 5 7 3 2 &gt; animals[&quot;camels&quot;] camels 3 &gt; animals[c(&quot;dogs&quot;,&quot;donkeys&quot;)] dogs donkeys 7 2 3.5.5 인덱스 벡터를 이용해 벡터 요소에 값 할당하기 지금까지는 인덱스 벡터를 이용하여 필요한 요소를 추출하는 방법에 대하여 살펴보았다. 그런데 인덱스 벡터를 이용하여 데이터 벡터의 특정 요소에만 값을 할당할 수도 있다. 다음은 숫자 인덱스 벡터를 이용하여 벡터의 특정 요소에 값을 할당한 예이다. &gt; a &lt;- 1:5; a [1] 1 2 3 4 5 &gt; a[2] &lt;- 20; a [1] 1 20 3 4 5 &gt; a[c(3, 5)] &lt;- c(100, 300); a [1] 1 20 100 4 300 &gt; a[c(1, 3, 5)] &lt;- -5; a [1] -5 20 -5 4 -5 &gt; a[-1] &lt;- 0; a [1] -5 0 0 0 0 다음은 논리 인덱스 벡터를 이용하여 결측치가 있는 데이터에 결측치 대신 0을 넣는 예이다. is.na() 함수는 결측치가 있는 위치를 TRUE로 하는 논리값 벡터를 반환하므로, 이 결과를 인덱스 벡터로 하면 결측치가 있는 위치만 지정됨을 알 수 있다. &gt; x &lt;- c(NA, 2:4, NA) &gt; x [1] NA 2 3 4 NA &gt; x[is.na(x)] &lt;- 0 &gt; x [1] 0 2 3 4 0 다음은 논리 인덱스 벡터를 이용하여 숫자 벡터의 요소를 모두 양수로 바꾸는 예이다. &gt; y &lt;- c(-2, 0, 4, -7, 8) &gt; y[y&lt;0] &lt;- -y[y&lt;0] &gt; y [1] 2 0 4 7 8 Kabacoff, Robert. R in action. Manning Publications Co., 2015.↩︎ "],
["ch-R-Matrix.html", "Chapter 4 R 행렬 4.1 행렬 만들기 4.2 벡터를 결합하여 행렬 만들기 4.3 행렬의 필터링 4.4 행렬의 연산 4.5 행렬과 함수 4.6 배열 4.7 행렬과 배열의 고급 연산", " Chapter 4 R 행렬 벡터보다 조금 더 복잡한 데이터 구조가 행렬과 배열이다. 행렬과 배열은 벡터처럼 모든 요소가 동일한 데이터의 타입을 가져야 한다. 행렬과 배열은 다차원적 데이터 구조이다. 지금까지 배운 벡터는 일차원적인 데이터 구조였다. 벡터의 길이가 50이라면 벡터의 각 요소의 위치는 \\(1, 2, \\ldots, 50\\)까지 하나의 숫자로 특정할 수 있다. 반면 행렬과 배열은 다차원적인 데이터 구조이다. 행렬은 2차원적 데이터 구조로 행과 열로 구성된다. 행렬의 각 요소의 위치는 어떤 행과 어떤 열에 포함되는지를 나타내는 두 개의 숫자로 특정할 수 있다. 배열은 행렬을 일반화한 것으로 다차원적인 데이터 구조이다. 예로 3차원 배열은 세 개의 숫자에 의해 데이터의 위치를 특정할 수 있다. 4.1 행렬 만들기 행렬의 필요성 행렬의 예로 다음을 고려해 보자. 어떤 강의의 수강생을 성별, 학년의 두 가지 기준으로 분류한다고 해 보자. 그러면 표 4.1 같은 형식으로 데이터를 정리할 수 있을 것이다. 이와 같이 두 범주형 변수에 대해 관측도수를 요약한 표를 교차표(cross table) 또는 분할표라고 한다. Table 4.1: 어떤 과목의 수강생 분할표 X1 1 학년 2 학년 3 학년 4 학년 남 0 5 7 5 여 2 4 8 2 표 4.1 같은 데이터는 일차원적인 벡터 형태로 데이터를 저장하면 각 데이터 요소가 어떤 의미를 갖는지 파악하기가 쉽지 않다. 이러한 경우에는 2차원으로 구성된 행렬을 이용하는 것이 좋다. 행렬을 만드는 방법은 (1) 벡터를 행렬로 변환시키는 방법과 (2) 벡터를 결합하여 행렬을 만드는 방법이 있다. 이 절에서는 벡터를 행렬로 변환시키는 방법부터 살펴보자. matrix() matrix() 함수를 이용하면 데이터 벡터를 데이터 행렬로 변환시킬 수 있다. 다음의 예를 보면서 설명해 보자. &gt; n &lt;- 1:10 &gt; n [1] 1 2 3 4 5 6 7 8 9 10 &gt; m &lt;- matrix(n, nrow=2, ncol=5) &gt; m [,1] [,2] [,3] [,4] [,5] [1,] 1 3 5 7 9 [2,] 2 4 6 8 10 &gt; m &lt;- matrix(n, nrow=2) 위 예에서 n은 1부터 10까지 숫자를 가진 벡터이다. matrix() 함수의 첫 인수로 행렬로 바꿀 벡터를 주고, nrow 인수에 새로 만들 행렬의 행 수를 주면 행렬이 만들어짐을 볼 수 있다. 이렇게 만들어진 행렬 m은 크기가 \\(2 \\times 5\\) 인 행렬이 된다. 왜냐하면 전체 데이터의 수는 10개인데 2 개의 행이 지정되었으므로 모두 5개의 열이 있어야 모든 데이터를 수용할 수 있기 때문이다. matrix()는 열을 순서대로 채워나간다. 벡터의 요소는 차례대로 1열의 1행을 채우고 2행을 채운다. 그리고 난 후 2열의 모든 행을 순서대로 채운다. 이러한 방식으로 차례차례 모든 열의 데이터를 채워 나감을 볼 수 있다. 만약 열이 아니라 행을 차례대로 채워나가면서 행렬을 만드고 싶으면 byrow=TRUE 인수를 사용하면 된다. &gt; matrix(n, nrow=2, ncol=5, byrow=T) [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 행렬과 dim 속성 원래의 벡터 n과 벡터로 만들어진 행렬 m의 속성을 보기 위해 attributes() 함수를 이용하자. 벡터 n에는 아무 속성도 부여되지 않았지만 행렬 m은 차원을 의미하는 dim 속성이 부여되었음을 볼 수 있다. dim 속성에는 길이가 2인 숫자 벡터가 부여되어 있는데, 첫번째 요소는 행의 개수, 두번째 요소는 열의 개수를 나타낸다. &gt; attributes(n) NULL &gt; attributes(m) $dim [1] 2 5 matrix()로 벡터를 행렬로 변환시킬 때 행의 개수 대신 열의 개수를 지정할 수도 있다. 이 경우 nrow 대신 ncol 인수를 사용하면 된다. 아래 예에서는 열의 개수를 2로 지정하였으므로 행렬 m은 크기가 \\(5 \\times 2\\)인 행렬이 되었음을 볼 수 있다. 이는 dim 속성에서도 확인할 수 있다. &gt; m &lt;- matrix(n, nrow=5, ncol=2) &gt; m [,1] [,2] [1,] 1 6 [2,] 2 7 [3,] 3 8 [4,] 4 9 [5,] 5 10 &gt; attributes(m) $dim [1] 5 2 벡터 출력 vs. 행렬 출력 행렬 m을 출력한 내용을 보면 벡터와는 다름을 볼 수 있다. 먼저 벡터는 데이터를 R 콘솔의 모든 줄을 차례대로 채우면서 출력하고, 줄이 바뀔 때마다 각 줄의 첫 요소가 벡터의 몇 번째 데이터인지를 [i] 형태로 보여준다. 반면 행렬은 행과 열의 개수에 맞추어 출력시킬 뿐 아니라 [i,j] 형태로 데이터의 위치를 보여준다. matrix()에서 벡터 재사용 matrix() 함수를 이용하여 행렬을 만들 때 행과 열의 크기를 모두 지정할 수 있다. 만약 벡터의 크기가 행렬의 요소 개수보다 적으면 벡터가 재사용된다. 반대로 벡터의 크기가 행렬의 요소 개수보다 크거나 배수가 되지 않으면 경고 메시지가 출력되고 행렬을 만드는 데는 앞에 있는 벡터 요소들만 사용된다. &gt; m &lt;- matrix(1:9, nrow=3, ncol=3) &gt; m [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 &gt; m &lt;- matrix(1, nrow=3, ncol=3) &gt; m [,1] [,2] [,3] [1,] 1 1 1 [2,] 1 1 1 [3,] 1 1 1 &gt; m &lt;- matrix(1:3, nrow=3, ncol=3) &gt; m [,1] [,2] [,3] [1,] 1 1 1 [2,] 2 2 2 [3,] 3 3 3 &gt; m &lt;- matrix(11:30, nrow=3, ncol=3) Warning in matrix(11:30, nrow = 3, ncol = 3): data length [20] is not a sub- multiple or multiple of the number of rows [3] &gt; m [,1] [,2] [,3] [1,] 11 14 17 [2,] 12 15 18 [3,] 13 16 19 4.2 벡터를 결합하여 행렬 만들기 cbind()와 rbind() 기존의 벡터나 행렬을 열이나 행으로 묶어서 새로운 행렬을 만들 수 있다. 아래 예는 벡터를 cbind()와 rbind() 함수를 이용하여 열 또는 행으로 묶은 경우이다. &gt; cbind(1:5, 10:6) [,1] [,2] [1,] 1 10 [2,] 2 9 [3,] 3 8 [4,] 4 7 [5,] 5 6 &gt; rbind(1:5, 10:6, 11:15) [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 10 9 8 7 6 [3,] 11 12 13 14 15 벡터+벡터, 벡터+행렬, 행렬+행렬 결합 벡터들만 연결하여 행렬을 만드는 것이 아니라, 행렬과 벡터 또는 행렬과 행렬을 행 또는 열로 묶어 새로운 행렬을 만들 수 있다. &gt; A &lt;- matrix(1:9, nrow=3, ncol=3) &gt; cbind(A, 10:12) [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 &gt; rbind(10:12, A) [,1] [,2] [,3] [1,] 10 11 12 [2,] 1 4 7 [3,] 2 5 8 [4,] 3 6 9 &gt; cbind(A, A) [,1] [,2] [,3] [,4] [,5] [,6] [1,] 1 4 7 1 4 7 [2,] 2 5 8 2 5 8 [3,] 3 6 9 3 6 9 &gt; t &lt;- rbind(A, 10:12) &gt; t [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 [4,] 10 11 12 &gt; rbind(A, t) [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 [4,] 1 4 7 [5,] 2 5 8 [6,] 3 6 9 [7,] 10 11 12 &gt; cbind(A, t) Error in cbind(A, t): number of rows of matrices must match (see arg 2) 행렬+행렬 연결은 행 또는 열의 수가 같아야 한다. 마지막 예에서 볼 수 있듯이 행렬을 cbind 할 때는 행의 수가 같아야 하며, rbind를 할 때에는 열의 수가 일치하여야 한다. 하지만 벡터의 경우에는 가장 긴 길이에 맞추어 요소가 재사용된다. &gt; A &lt;- cbind(1:6, 7:9) &gt; A [,1] [,2] [1,] 1 7 [2,] 2 8 [3,] 3 9 [4,] 4 7 [5,] 5 8 [6,] 6 9 &gt; cbind(A, 10:11) [,1] [,2] [,3] [1,] 1 7 10 [2,] 2 8 11 [3,] 3 9 10 [4,] 4 7 11 [5,] 5 8 10 [6,] 6 9 11 &gt; rbind(1, 1:5) [,1] [,2] [,3] [,4] [,5] [1,] 1 1 1 1 1 [2,] 1 2 3 4 5 4.3 행렬의 필터링 행과 열 인덱스 벡터 벡터와 마찬가지로 행렬도 인덱스 벡터에 의해 필터링을 할 수 있다. 벡터는 오직 한 개의 인덱스 벡터를 가지는데, 행렬은 2차원인 만큼 각 차원을 지정할 수 있도록 2개의 인덱스 벡터를 가진다. 첫번째 인덱스 벡터는 추출할 행의 위치를, 두번째 인덱스 벡터는 추출할 열의 위치를 지정하게 된다. 벡터와 마찬가지로 행렬도 자연수, 음의 정수, 논리, 이름 인덱스 벡터를 가질 수 있다. 자연수 인덱스 벡터 아래는 1부터 25까지의 숫자를 크기 \\(5 \\times 5\\)인 행렬로 만든 후 인덱스 벡터로 각 데이터 요소를 특정하는 예를 보여주고 있다. &gt; z &lt;- matrix(1:25, nrow=5, ncol=5) &gt; z [,1] [,2] [,3] [,4] [,5] [1,] 1 6 11 16 21 [2,] 2 7 12 17 22 [3,] 3 8 13 18 23 [4,] 4 9 14 19 24 [5,] 5 10 15 20 25 &gt; z[1,1] [1] 1 &gt; z[5,5] [1] 25 &gt; z[1:3,1] [1] 1 2 3 &gt; z[2, 1:3] [1] 2 7 12 &gt; z[c(3, 5), c(2, 4)] [,1] [,2] [1,] 8 18 [2,] 10 20 다음 예처럼 인덱스 벡터 위치가 비어 있으면 그 인덱스는 전체 범위를 취한다. 인덱스 벡터가 모두 비어 있으면 행렬 그 자체가 된다. 즉 z[ , ]은 z와 같다. &gt; z[,2] [1] 6 7 8 9 10 &gt; z[3,] [1] 3 8 13 18 23 &gt; z[,c(3,5)] [,1] [,2] [1,] 11 21 [2,] 12 22 [3,] 13 23 [4,] 14 24 [5,] 15 25 &gt; z[ , ] [,1] [,2] [,3] [,4] [,5] [1,] 1 6 11 16 21 [2,] 2 7 12 17 22 [3,] 3 8 13 18 23 [4,] 4 9 14 19 24 [5,] 5 10 15 20 25 음의 정수 인덱스 벡터 벡터와 마찬가지로 음의 정수를 이용하면 해당 행과 열을 제외한 행렬을 구할 수 있다. &gt; z[,-2] [,1] [,2] [,3] [,4] [1,] 1 11 16 21 [2,] 2 12 17 22 [3,] 3 13 18 23 [4,] 4 14 19 24 [5,] 5 15 20 25 &gt; z[-3,] [,1] [,2] [,3] [,4] [,5] [1,] 1 6 11 16 21 [2,] 2 7 12 17 22 [3,] 4 9 14 19 24 [4,] 5 10 15 20 25 &gt; z[,-c(2,4)] [,1] [,2] [,3] [1,] 1 11 21 [2,] 2 12 22 [3,] 3 13 23 [4,] 4 14 24 [5,] 5 15 25 &gt; z[-3,-2] [,1] [,2] [,3] [,4] [1,] 1 11 16 21 [2,] 2 12 17 22 [3,] 4 14 19 24 [4,] 5 15 20 25 인덱스 벡터로 행과 열 재배치 하기 행렬의 인덱스 벡터를 이용하여 행 단위 재배치나 열 단위 재배치가 가능하다. &gt; z[5:1, ] [,1] [,2] [,3] [,4] [,5] [1,] 5 10 15 20 25 [2,] 4 9 14 19 24 [3,] 3 8 13 18 23 [4,] 2 7 12 17 22 [5,] 1 6 11 16 21 &gt; z[ , c(3:5, 1:2)] [,1] [,2] [,3] [,4] [,5] [1,] 11 16 21 1 6 [2,] 12 17 22 2 7 [3,] 13 18 23 3 8 [4,] 14 19 24 4 9 [5,] 15 20 25 5 10 아울러 인덱스 벡터를 사용하여 행과 열에 대한 정렬도 가능하다. 다음은 행렬의 첫번째 열을 기준으로 행을 큰 순에서 작은 순으로 정렬한 예이다. &gt; a &lt;- matrix(sample(1:16), nrow=4, ncol=4) &gt; a [,1] [,2] [,3] [,4] [1,] 5 8 2 12 [2,] 15 1 3 4 [3,] 6 11 10 13 [4,] 14 9 7 16 &gt; a[,1] [1] 5 15 6 14 &gt; order(a[,1]) [1] 1 3 4 2 &gt; a[order(a[,1]), ] [,1] [,2] [,3] [,4] [1,] 5 8 2 12 [2,] 6 11 10 13 [3,] 14 9 7 16 [4,] 15 1 3 4 논리 인덱스 벡터 벡터와 마찬가지로 논리 인덱스 벡터를 사용할 수 있다. 다음의 예에서 보듯이 행과 열의 인덱스 벡터에서 TRUE가 되는 행과 열만 선택된다. &gt; height &lt;- c(180, 172, 167, 175, 182) &gt; weight &lt;- c(72, 78, 58, 64, 68) &gt; year &lt;- c(1, 3, 2, 4, 2) &gt; A &lt;- cbind(height, weight, year) &gt; A[ , c(F, T, T)] weight year [1,] 72 1 [2,] 78 3 [3,] 58 2 [4,] 64 4 [5,] 68 2 &gt; A[ , c(T, F, T)] height year [1,] 180 1 [2,] 172 3 [3,] 167 2 [4,] 175 4 [5,] 182 2 &gt; A[ A[,1] &gt; 180, ] height weight year 182 68 2 &gt; A[ A[,2] &lt; 70, ] height weight year [1,] 167 58 2 [2,] 175 64 4 [3,] 182 68 2 행과 열 이름 부여하기: rownames()와 colnames() 벡터와 마찬가지로 행과 열의 이름을 인덱스로 하여 행렬의 부분을 참조할 수 있다. 행렬의 행과 열 이름의 확인과 할당은 rownames()와 colnames() 함수를 이용하여 이루어진다. rbind()나 cbind()에 의해 벡터 변수가 결합되면 변수의 이름이 자동적으로 행이나 열의 이름으로 부여된다. &gt; colnames(A) [1] &quot;height&quot; &quot;weight&quot; &quot;year&quot; &gt; rownames(A) NULL &gt; rownames(A) &lt;- paste(&quot;student&quot;, 1:5, sep=&quot;&quot;) &gt; A height weight year student1 180 72 1 student2 172 78 3 student3 167 58 2 student4 175 64 4 student5 182 68 2 &gt; A[, &quot;year&quot;] student1 student2 student3 student4 student5 1 3 2 4 2 &gt; A[&quot;student1&quot;,] height weight year 180 72 1 &gt; A[&quot;student2&quot;, &quot;weight&quot;] [1] 78 &gt; A[&quot;student2&quot;, 2] # 행과 열의 인덱스 벡터의 종류가 달라도 된다. [1] 78 벡터로서 필터링 하기 만약 행렬 이름 뒤에 인덱스 벡터가 하나밖에 주어지지 않으면, 행렬은 벡터로서 처리되어 필터링되고 행렬의 차원 정보는 무시된다 &gt; z [,1] [,2] [,3] [,4] [,5] [1,] 1 6 11 16 21 [2,] 2 7 12 17 22 [3,] 3 8 13 18 23 [4,] 4 9 14 19 24 [5,] 5 10 15 20 25 &gt; z[10] [1] 10 &gt; z[z&gt;15] [1] 16 17 18 19 20 21 22 23 24 25 4.4 행렬의 연산 행렬의 요소 단위 연산 행과 열의 수가 같은 행렬은 산술 연산을 할 수 있다. 이 경우 벡터와 마찬가지로 산술 연산은 같은 위치의 요소 단위(element-by-element)로 이루어진다. &gt; A &lt;- matrix(1:9, nrow=3, ncol=3) &gt; A [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 &gt; B &lt;- matrix(seq(from=10, length=9, by=10), nrow=3, ncol=3) &gt; B [,1] [,2] [,3] [1,] 10 40 70 [2,] 20 50 80 [3,] 30 60 90 &gt; A + B [,1] [,2] [,3] [1,] 11 44 77 [2,] 22 55 88 [3,] 33 66 99 &gt; B - A [,1] [,2] [,3] [1,] 9 36 63 [2,] 18 45 72 [3,] 27 54 81 &gt; A * B [,1] [,2] [,3] [1,] 10 160 490 [2,] 40 250 640 [3,] 90 360 810 &gt; B / A [,1] [,2] [,3] [1,] 10 10 10 [2,] 10 10 10 [3,] 10 10 10 행렬은 재사용되지 않는다 행과 열의 개수가 다른 행렬의 산술연산은 오류를 발생시킨다. 그 이유는 행렬은 벡터와 달리 요소의 재사용(recycling)이 일어나지 않기 때문이다. 그렇기 때문에 행렬과 행렬의 연산에서는 행과 열이 같은 크기이어야 한다. &gt; C &lt;- cbind(A, 10:12) &gt; C [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 &gt; B + C Error in B + C: non-conformable arrays &gt; C &lt;- rbind(A, 1:3) &gt; C [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 [4,] 1 2 3 &gt; B * C Error in B * C: non-conformable arrays 벡터와 행렬의 연산: 벡터는 재사용된다 벡터와 행렬의 산술연산도 같은 위치의 요소 단위로 이루어진다. 벡터 a와 행렬 A의 연산시 벡터 a는 먼저 행렬 A와 같은 차원의 행렬로 변환되어 연산이 수행된다. 만약 벡터의 길이가 행렬의 길이보다 작으면 벡터의 데이터는 행렬의 길이만큼 순환 재사용된다. 연산을 위해 벡터가 행렬로 변환될 때도 matrix()로 행렬이 만들어질 때와 마찬가지로 열 별로 데이터를 채워나간다. &gt; a &lt;- 9:1 &gt; a + A [,1] [,2] [,3] [1,] 10 10 10 [2,] 10 10 10 [3,] 10 10 10 &gt; a &lt;- c(0, 10, 100) &gt; a + A [,1] [,2] [,3] [1,] 1 4 7 [2,] 12 15 18 [3,] 103 106 109 &gt; A * a [,1] [,2] [,3] [1,] 0 0 0 [2,] 20 50 80 [3,] 300 600 900 숫자와 행렬이 연산은 길이가 1인 벡터와 행렬이 연산되는 것이므로 모든 행렬의 요소와 숫자간에 연산이 이루어진다. 다음 예에서 숫자 10이 A의 모든 요소에 대응하여 계산되었음을 볼 수 있다. &gt; 10 * A [,1] [,2] [,3] [1,] 10 40 70 [2,] 20 50 80 [3,] 30 60 90 그러나 벡터의 길이가 배열의 길이보다 길면 오류가 발생한다. &gt; b &lt;- 1:10 &gt; b * A Warning in b * A: longer object length is not a multiple of shorter object length Error in eval(expr, envir, enclos): dims [product 9] do not match the length of object [10] 현재까지는 행렬의 연산 중 요소 단위의 연산만을 설명하였다. R은 이 외에도 행렬의 외적, 행렬의 곱, 역행렬 구하기 등 다양한 행렬 연산을 지원한다. 관심 있는 독자는 4.7 절을 참조한다. 4.5 행렬과 함수 4.5.1 행렬을 인수로 하는 함수들 이 절에서는 행렬을 인수로 하는 R 함수를 살펴본다. t() 어떤 행렬에서 행과 열이 바뀐 행렬을 전치행렬(transposed matrix)이라 한다. t() 함수를 이용하면 전치행렬을 구할 수 있다. &gt; A &lt;- matrix(1:4, nrow=2, ncol=2) &gt; A [,1] [,2] [1,] 1 3 [2,] 2 4 &gt; t(A) [,1] [,2] [1,] 1 2 [2,] 3 4 행렬의 차원 정보를 주는 함수: nrow(), ncol(), dim() 행렬의 행 수와 열 수를 구할 때는 nrow(), ncol() 함수를 이용한다. 행과 열의 차원 전체를 얻고자 하면 dim() 함수를 이용한다. &gt; nrow(A) [1] 2 &gt; ncol(A) [1] 2 &gt; dim(A) [1] 2 2 &gt; attributes(A) $dim [1] 2 2 행과 열에 이름 함수: rownames(), colnames() 행과 열 이름을 확인하거나, 새로 할당할 때는 rownames()와 colnames() 함수를 이용한다. &gt; rownames(A) NULL &gt; colnames(A) NULL &gt; rownames(A) &lt;- c(&quot;upper&quot;, &quot;lower&quot;) &gt; colnames(A) &lt;- c(&quot;left&quot;, &quot;right&quot;) &gt; A left right upper 1 3 lower 2 4 &gt; attributes(A) $dim [1] 2 2 $dimnames $dimnames[[1]] [1] &quot;upper&quot; &quot;lower&quot; $dimnames[[2]] [1] &quot;left&quot; &quot;right&quot; 벡터로 변환: as.vector(), c() as.vector()나 c() 함수를 이용하면 행렬을 벡터로 변경할 수 있다. 배열을 벡터로 바꾸는 공식적인 방법은 as.vector() 함수를 이용하는 것이다. 다음 예를 살펴보자. (R이 대소문자를 구분하는 것에 주의.) &gt; X &lt;- rbind(1:5, 5:1) &gt; X [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 5 4 3 2 1 &gt; x &lt;- as.vector(X) &gt; x [1] 1 5 2 4 3 3 4 2 5 1 &gt; attributes(x) NULL 하지만 c() 함수도 이와 유사한 효과를 나타낸다. cbind()와 rbind()는 행렬과 벡터의 차원 속성을 유지하며 데이터를 연결한다. 그러나 c() 함수는 dim과 dimnames 속성을 지운다. &gt; y &lt;- c(X) &gt; y [1] 1 5 2 4 3 3 4 2 5 1 &gt; attributes(y) NULL 행렬에 벡터 함수 적용하기 사실 행렬은 벡터에 dim 속성이 부여된 것뿐이므로, 벡터에 적용되는 함수를 행렬에 적용하면 행렬을 벡터로 간주하여 잘 동작한다. &gt; sum(X) [1] 30 &gt; mean(X) [1] 3 &gt; sd(X) [1] 1.490712 &gt; range(X) [1] 1 5 4.5.2 행렬의 행별 또는 열별로 함수를 적용하는 방법 apply() 함수를 이용하면 행렬의 행별 또는 열별로 함수를 적용할 수 있다. apply() &gt; apply(X, MARGIN, FUN, ...) apply() 함수의 X 인수에는 행별 또는 열별로 함수를 적용할 행렬을, MARGIN 인수에는 함수를 적용할 방향을 지정한다. MARGIN 인수가 1이면 행별로, 2이면 열별로 함수가 적용된다. apply() 함수의 FUN 인수에는 행이나 열별로 적용할 함수를 전달한다. 다음은 행렬 A에 대해 행별 합과 열별 합을 구한 예이다. 행렬 전체를 sum()한 결과와의 차이를 비교해 보라. &gt; set.seed(123) &gt; a &lt;- sample(1:25) &gt; a [1] 15 19 14 3 10 18 11 5 23 6 9 21 24 20 22 25 17 1 12 13 2 16 7 8 4 &gt; A &lt;- matrix(a, nrow=5, ncol=5) &gt; A [,1] [,2] [,3] [,4] [,5] [1,] 15 18 9 25 2 [2,] 19 11 21 17 16 [3,] 14 5 24 1 7 [4,] 3 23 20 12 8 [5,] 10 6 22 13 4 &gt; apply(A, 1, sum) [1] 69 84 51 66 55 &gt; apply(A, 2, sum) [1] 61 63 96 68 37 &gt; sum(A) [1] 325 apply() 함수가 적용되는 행렬의 행과 열에 이름이 있으면 apply()의 결과 벡터에도 해당 이름이 적용되어 출력된다. &gt; colnames(A) &lt;- LETTERS[1:5] &gt; rownames(A) &lt;- paste(&quot;X&quot;, 1:5, sep=&quot;&quot;) &gt; A A B C D E X1 15 18 9 25 2 X2 19 11 21 17 16 X3 14 5 24 1 7 X4 3 23 20 12 8 X5 10 6 22 13 4 &gt; apply(A, 1, min) X1 X2 X3 X4 X5 2 11 1 3 4 &gt; apply(A, 2, max) A B C D E 19 23 24 25 16 함수의 결과가 벡터이면 열로서 결합하여 출력한다. 지금까지 apply()의 FUN 인수에 부여된 함수는 sum()처럼 오직 하나의 값만을 반환하는 함수였다. 그렇기 때문에 apply() 함수로 행 또는 열별 합을 구하면 행 또는 열의 수만큼의 길이를 가지는 벡터로서 결과값이 반환되었다. 그러면 range()나 summary()처럼 길이가 2 이상인 벡터로서 결과를 주는 함수를 FUN 인수에 적용하면 어떻게 될까? 이 경우에는 함수가 적용되어 나온 결과 벡터를 cbind()처럼 열로서 결합하여 최종 결과를 출력한다. &gt; apply(A, 2, range) A B C D E [1,] 3 5 9 1 2 [2,] 19 23 24 25 16 &gt; apply(A, 1, range) X1 X2 X3 X4 X5 [1,] 2 11 1 3 4 [2,] 25 21 24 23 22 &gt; apply(A, 1, summary) X1 X2 X3 X4 X5 Min. 2.0 11.0 1.0 3.0 4 1st Qu. 9.0 16.0 5.0 8.0 6 Median 15.0 17.0 7.0 12.0 10 Mean 13.8 16.8 10.2 13.2 11 3rd Qu. 18.0 19.0 14.0 20.0 13 Max. 25.0 21.0 24.0 23.0 22 range() 함수는 최소값과 최대값이라는 두 요소로 이루어진 벡터를 결과로서 반환하는 함수이다. 따라서 첫번째 예는 A의 열별 최소값과 최대값을 열로 하는 행렬을, 두번째 예는 A의 행별 최대값과 최소값을 열로 하는 행렬을 반환하였다. 마지막 예에서는, summary() 함수가 최소값, 사분위수, 최대값, 평균 등의 통계치를 벡터로 반환하기 때문에, apply() 결과는 A의 행별 통계치를 열로 하는 행렬로서 반환되었다. 4.6 배열 4.6.1 배열의 생성 벡터는 일차원 데이터 구조로 하나의 인덱스 벡터로 요소의 위치를 지정한다. &gt; x &lt;- 11:20; x [1] 11 12 13 14 15 16 17 18 19 20 &gt; x[1] [1] 11 &gt; x[6:7] [1] 16 17 행렬은 2차원의 데이터 구조로 두 개의 인덱스 벡터로 요소의 위치를 지정한다. 첫번째 인덱스 벡터가 행의 위치를 지정하고, 두번째 인덱스 벡터가 열 위치를 지정한다. &gt; x &lt;- matrix(11:19, nrow=3, ncol=3); x [,1] [,2] [,3] [1,] 11 14 17 [2,] 12 15 18 [3,] 13 16 19 &gt; x[1, 2] [1] 14 &gt; x[2:3, 1] [1] 12 13 배열은 행렬을 일반화한 것으로 2차원 이상의 차원을 가지는 데이터 구조이다. 사실 행렬은 2차인 구조를 가지는 배열의 특수한 예이다. 배열은 벡터, 행렬과 마찬가지로 동일한 형식의 데이터만 그 요소로 가질 수 있으므로, 따라서 숫자 배열, 문자 배열, 논리값 배열 등이 만들어질 수 있다. array() 배열은 array() 함수를 이용하여 행렬과 비슷한 방법으로 만들수 있다. &gt; matrix(data, nrow, ncol) &gt; array(data, dim) dim 인수 matrix() 함수와 마찬가지로 데이터 요소를 가지고 있는 벡터가 array()의 첫번째 인수로 제공된다. matrix() 함수와 다른 점은 차원의 크기가 dim 인수에 벡터 형식으로 제공된다는 것이다. 행렬은 2차원으로 차원이 정해져 있으므로 첫번째 차원인 행의 크기는 nrow 인수에 두번째 차원인 열의 크기는 ncol 인수에 숫자 하나로 제공된다. 그러나 배열은 2차원 이상의 다양한 차원을 가질 수 있으므로, 원하는 차원의 수만큼 각 차원의 크기를 결정해야 한다. 따라서 차원의 개수만큼의 요소를 가지는 벡터가 dim 인수에 제공된다. 따라서 어떤 배열의 차원 벡터의 길이가 k이면 그 배열은 k차원 배열이라고 한다. 다음은 3차원 배열을 생성한 예이다. &gt; x &lt;- array(11:28, dim=c(3, 3, 2)) &gt; x , , 1 [,1] [,2] [,3] [1,] 11 14 17 [2,] 12 15 18 [3,] 13 16 19 , , 2 [,1] [,2] [,3] [1,] 20 23 26 [2,] 21 24 27 [3,] 22 25 28 3차원 배열의 출력 방식 행렬과 마찬가지로 3차원 배열의 첫번째 차원은 행(rows)을, 두번째 차원은 열(columns)을, 세번째 차원은 층(layers)을 나타낸다. 3차원 큐브를 생각하면 이해하기 쉽다. 앞의 예에서는 행은 3개, 열도 3개, 층은 2개로 데이터 요소가 배열되었다. 3차원 배열의 경우 컴퓨터 화면은 2차원이기 때문이 각 층을 차례로 보여주는 방식으로 배열의 요소를 출력한다. 따라서 각 층의 데이터는 2차원의 행렬의 형태로 출력된다. 출력된 행렬이 어떤 층의 데이터인지 보여주기 위해서 ’ , , (층 번호)’가 각 행렬의 위에 같이 출력되었다. 3차원 배열에서 데이터가 채워지는 순서 예에서 보듯이 행렬과 마찬가지로 앞 차원의 인덱스들이 먼저 변하며 데이터가 채워진다. 1층의 데이터가 다 채워진 후 2 층의 데이터가 채워지고, 동일 층에서는 앞의 열이 먼저 채워지고 뒤의 열이 다음에 채워진다. 동일 층의 동일 열에서는 앞의 행이 먼저 채워지고 뒤의 행이 다음에 채워진다. 즉, [행, 열, 층]의 인덱스가 [1, 1, 1]에서 시작하여 [2, 1, 1]로 진행하며 1층-1열의 모든 행을 다 채우고 나서, 다시 [1, 2, 1]부터 1층-2열의 데이터를 채운다. 그리고 1층의 데이터가 모두 채워지면 다시 2층의 1열의 1행, 즉 [1, 1, 2]부터 차례대로 1층과 같은 방식으로 데이터를 채워나간다. 비유적으로 설명하자면 숫자의 자리수가 일의 자리가 채워지면 십의 자리, 그리고 그 다음 백의 자리가 채워지듯이, 첫번째 차원의 인덱스가 모두 채워지면 두번째 차원의 인덱스가 하나 증가하고, 두번째 차원의 인덱스가 모두 채워지면 세번째 차원이 인덱스가 하나 증가하며 데이터가 채워진다고 할 수 있다. 다만 십진법에서는 숫자의 자리수는 모두 10으로 크기가 같고, 0부터 시작하며, 숫자 표기상 뒷쪽 자릿수가 먼저 채워지는데, R의 배열에서는 차원의 크기가 서로 다를 수 있고, 1부터 시작하고, 앞 쪽의 차원이 먼저 채워지는 것에 차이가 있다. k차원 배열은 k개의 인덱스 벡터로 요소의 위치를 지정한다. 3차원 배열에서 요소의 위치를 지정하기 위해서는 3개의 인덱스 벡터가 필요하다. 마찬가지로 k-차원의 배열에서 요소의 위치를 지정하기 위해서는 k개의 인덱스 벡터가 필요하다. &gt; x[2, 1, 1] [1] 12 &gt; x[2, 1, 2] [1] 21 &gt; x[1, 2:3, 2] [1] 23 26 행렬은 2차원 배열이므로 array() 함수를 이용해서도 행렬을 만들 수 있다. &gt; x &lt;- array(11:19, c(3,3)) &gt; x [,1] [,2] [,3] [1,] 11 14 17 [2,] 12 15 18 [3,] 13 16 19 벡터를 재사용하여 배열 만들기 행렬을 만들 때와 마찬가지로 데이터로 제공된 벡터가 배열의 모든 공간을 채울 수 없으면 벡터가 재사용된다. &gt; x &lt;- array(1, dim=c(2, 3, 2)) &gt; x , , 1 [,1] [,2] [,3] [1,] 1 1 1 [2,] 1 1 1 , , 2 [,1] [,2] [,3] [1,] 1 1 1 [2,] 1 1 1 &gt; x &lt;- array(1:6, dim=c(3, 3, 2)) &gt; x , , 1 [,1] [,2] [,3] [1,] 1 4 1 [2,] 2 5 2 [3,] 3 6 3 , , 2 [,1] [,2] [,3] [1,] 4 1 4 [2,] 5 2 5 [3,] 6 3 6 참고로 벡터를 재사용하여 배열을 채울 때, 벡터의 길이가 배열의 길이의 배수가 아니어도 경고 메시지가 나오지 않는다. 이는 행렬의 경우와 다른데 차원이 커지면 벡터의 길이와 배열의 길이를 배수로 맞추는 것이 쉽지 않기 때문에 생략한 것으로 보인다. &gt; x &lt;- array(1:5, dim=c(3, 3, 2)) &gt; x , , 1 [,1] [,2] [,3] [1,] 1 4 2 [2,] 2 5 3 [3,] 3 1 4 , , 2 [,1] [,2] [,3] [1,] 5 3 1 [2,] 1 4 2 [3,] 2 5 3 마찬가지로 벡터의 길이가 배열의 길이보다 길어도 아무 경고 메시지 없이 배열을 잘 생성한다. &gt; x &lt;- array(1:30, dim=c(3, 3, 2)) &gt; x , , 1 [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 , , 2 [,1] [,2] [,3] [1,] 10 13 16 [2,] 11 14 17 [3,] 12 15 18 4차원 배열 예 마지막으로 4차원 배열을 만들어 보자. 컴퓨터 화면은 2차원이므로 4차원 배열을 표현하기 위해, 세번째와 네번째 차원의 인덱스가 정해져 있을 때의 데이터를 2차원 행렬로 출력해 주는 것을 볼 수 있다. 3차원 배열 때와 마찬가지로 앞의 차원의 인덱스가 먼저 변하면서 데이터가 차례로 배정됨을 볼 수 있다. &gt; y &lt;- array(1:30, dim=c(2, 3, 2, 2)) &gt; y , , 1, 1 [,1] [,2] [,3] [1,] 1 3 5 [2,] 2 4 6 , , 2, 1 [,1] [,2] [,3] [1,] 7 9 11 [2,] 8 10 12 , , 1, 2 [,1] [,2] [,3] [1,] 13 15 17 [2,] 14 16 18 , , 2, 2 [,1] [,2] [,3] [1,] 19 21 23 [2,] 20 22 24 4.6.2 배열도 결국 벡터 배열은 dim 속성을 가진 벡터이다. 행렬과 마찬가지로 배열도 사실 벡터이다. 그러므로 typeof() 함수를 이용하여 생성된 배열의 타입을 확인해 보면 숫자 벡터임을 보여준다. 그러나 class() 함수로 배열의 클래스를 확인하면 array 클래스로 처리됨을 볼 수 있다. 앞의 예에서도 벡터가 array 클래스로 처리되기 때문에 행, 열, 층 등으로 잘 구분되어 출력될 수 있었던 것이다. Array 클래스의 데이터는 본질적으로 벡터가 dim 속성을 가지고 있는 것 뿐이다. Dim 속성은 해당 배열의 각 차원의 크기를 나타내 준다. R은 dim 속성에 저장된 차원 정보를 이용하여 데이터 요소를 각 차원에 맞게 출력해 준다. &gt; typeof(x) [1] &quot;integer&quot; &gt; class(x) [1] &quot;array&quot; &gt; attributes(x) $dim [1] 3 3 2 벡터에 dim 속성을 부여하여 배열 만들기 배열은 결국 벡터가 dim 속성을 가지고 있는 것이므로 벡터에 dim 속성을 부여하여 배열을 만들 수도 있다. 다음 예에서도 보듯이 데이터는 변함이 없고 dim 속성에 따라 데이터가 보여지는 형식이 달라짐을 볼 수 있다. &gt; x &lt;- 1:12 &gt; dim(x) NULL &gt; x [1] 1 2 3 4 5 6 7 8 9 10 11 12 &gt; dim(x) &lt;- c(3, 4) &gt; x [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 &gt; dim(x) &lt;- c(2, 3, 2) &gt; x , , 1 [,1] [,2] [,3] [1,] 1 3 5 [2,] 2 4 6 , , 2 [,1] [,2] [,3] [1,] 7 9 11 [2,] 8 10 12 &gt; dim(x) &lt;- NULL &gt; x [1] 1 2 3 4 5 6 7 8 9 10 11 12 dimnames 속성과 dimnames() 함수 배열도 행렬과 마찬가지로 각 차원에 이름을 부여할 수 있다. 배열의 dimnames 속성에 차원의 이름 벡터를 리스트 객체로 만들어 부여하면 된다. (리스트 객체에 대한 설명은 5장을 살펴보기 바란다.) 배열에 dimnames 속성을 부여하려면 array() 함수의 dimnames 인수를 이용하거나, 다음처럼 dimnames() 함수를 사용한다. &gt; dim(x) &lt;- c(2, 3, 2) &gt; dimnames(x) &lt;- list(c(&quot;A&quot;, &quot;B&quot;), + paste(&quot;group&quot;,1:3,sep=&quot;-&quot;), + c(&quot;Male&quot;, &quot;Female&quot;)) &gt; x , , Male group-1 group-2 group-3 A 1 3 5 B 2 4 6 , , Female group-1 group-2 group-3 A 7 9 11 B 8 10 12 &gt; attributes(x) $dim [1] 2 3 2 $dimnames $dimnames[[1]] [1] &quot;A&quot; &quot;B&quot; $dimnames[[2]] [1] &quot;group-1&quot; &quot;group-2&quot; &quot;group-3&quot; $dimnames[[3]] [1] &quot;Male&quot; &quot;Female&quot; 4.6.3 배열의 연산과 필터링 배열의 요소 단위 연산 배열 연산과 필터링은 행렬 연산과 필터링의 경우와 동일한 원리로 작동한다. 다른 점은 행렬보다 더 많은 차원의 데이터를 다룬다는 것이다. 행렬 연산과 마찬가지로 배열 연산도 동일한 차원 벡터를 갖는 배열들이 요소 단위로 연산이 이루어진다. &gt; a &lt;- array(1:8, c(2, 2, 2)); a , , 1 [,1] [,2] [1,] 1 3 [2,] 2 4 , , 2 [,1] [,2] [1,] 5 7 [2,] 6 8 &gt; b &lt;- array(10^(0:7), c(2, 2, 2)); b , , 1 [,1] [,2] [1,] 1 100 [2,] 10 1000 , , 2 [,1] [,2] [1,] 1e+04 1e+06 [2,] 1e+05 1e+07 &gt; a + b , , 1 [,1] [,2] [1,] 2 103 [2,] 12 1004 , , 2 [,1] [,2] [1,] 10005 1000007 [2,] 100006 10000008 &gt; a * b , , 1 [,1] [,2] [1,] 1 300 [2,] 20 4000 , , 2 [,1] [,2] [1,] 5e+04 7e+06 [2,] 6e+05 8e+07 행렬 연산과 마찬가지로 차원 벡터가 다른 배열과 연산을 시도하면 오류가 발생한다. &gt; d &lt;- array(11:30, c(2, 3, 2)); d , , 1 [,1] [,2] [,3] [1,] 11 13 15 [2,] 12 14 16 , , 2 [,1] [,2] [,3] [1,] 17 19 21 [2,] 18 20 22 &gt; a + d Error in a + d: non-conformable arrays 벡터와 배열이 연산되면 벡터는 배열의 길이만큼 재사용되어 연산이 수행된다. &gt; 2 * a , , 1 [,1] [,2] [1,] 2 6 [2,] 4 8 , , 2 [,1] [,2] [1,] 10 14 [2,] 12 16 &gt; 1:2 * a , , 1 [,1] [,2] [1,] 1 3 [2,] 4 8 , , 2 [,1] [,2] [1,] 5 7 [2,] 12 16 차원 축소와 drop 인수 배열도 행렬과 마찬가지로 차원의 수만큼의 자연수, 음의 정수, 논리, 이름 인덱스 벡터로 필터링을 수행할 수 있다. 필터링의 결과로 어떤 차원의 크기가 1로 줄어들게 되면, 더 낮은 차원의 데이터 구조로 차원이 축소된다. 예를 들어 3차원 배열을 필터링한 결과가 1차원 벡터나 2차원 행렬이 될 수 있다. 이러한 차원 축소를 원하지 않으면 drop=FALSE 인수를 사용하여 필터링을 하면 된다.3 &gt; x , , Male group-1 group-2 group-3 A 1 3 5 B 2 4 6 , , Female group-1 group-2 group-3 A 7 9 11 B 8 10 12 &gt; x[ , , 2] group-1 group-2 group-3 A 7 9 11 B 8 10 12 &gt; x[ ,2, 2] A B 9 10 &gt; x[1, 2:3, 2] group-2 group-3 9 11 &gt; x[1, 2:3, 1:2] Male Female group-2 3 9 group-3 5 11 &gt; x[1, 2:3, 1:2, drop=F] , , Male group-2 group-3 A 3 5 , , Female group-2 group-3 A 9 11 &gt; x[,-2,c(T, F)] group-1 group-3 A 1 5 B 2 6 &gt; x[&quot;A&quot;, &quot;group-2&quot;, &quot;Female&quot;] [1] 9 4.7 행렬과 배열의 고급 연산 행렬은 배열의 매우 중요하고 특수한 경우이다. 따라서 R에서는 행렬에만 가능한 여러 연산과 기능들이 있다. 4.7.1 행렬의 곱 지금까지 행렬의 연산은 요소 단위로 이루어졌다. 따라서 행렬에 곱하기 연산자 *를 사용하면 같은 위치의 요소끼리 곱해졌다. 그러나 수학에서 일반적으로 정의하는 행렬의 곱은 다음과 같은 형식으로 수행된다. \\[\\begin{equation*} \\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix} \\times \\begin{pmatrix} e &amp; f \\\\ g &amp; h \\end{pmatrix} = \\begin{pmatrix}b\\,g+a\\,e &amp; b\\,h+a\\,f \\\\ d\\,g+c\\,e &amp; d\\,h+c\\,f \\end{pmatrix} \\end{equation*}\\] 연산자 %*%는 행렬의 곱 연산을 수행한다. 다음의 예는 요소별로 곱이 이루어지는 * 연산자와 행렬의 곱 연산자 %*%이 어떻게 다른지 보여준다. 결과에서 알 수 있듯이 행렬 곱은 교환법칙이 성립하지 않는다. 반면 요소 단위의 곱은 교환법칙이 성립한다. &gt; A &lt;- array(1:4, c(2,2)); A [,1] [,2] [1,] 1 3 [2,] 2 4 &gt; B &lt;- array(10^(0:3), c(2,2)); B [,1] [,2] [1,] 1 100 [2,] 10 1000 &gt; A * B [,1] [,2] [1,] 1 300 [2,] 20 4000 &gt; B * A [,1] [,2] [1,] 1 300 [2,] 20 4000 &gt; A %*% B [,1] [,2] [1,] 31 3100 [2,] 42 4200 &gt; B %*% A [,1] [,2] [1,] 201 403 [2,] 2010 4030 벡터가 행렬의 곱 수식에 나타나면 자동적으로 열 벡터나 행 벡터로 변환이 이루어진다. 그리고 행렬의 곱의 결과과 행이나 열 벡터로 표현되더라도 차원 축소는 일어나지 않는다. &gt; x &lt;- c(1,1) &gt; x %*% A [,1] [,2] [1,] 3 7 &gt; A %*% x [,1] [1,] 4 [2,] 6 &gt; x %*% A %*% x [,1] [1,] 10 4.7.2 행렬의 주대각선 요소와 대각행렬 행렬을 이용한 수학적 연산에서 행렬의 주대각선 요소나 대각행렬은 매우 중요한 역할을 수행한다. R은 diag() 함수를 이용하여 행렬에서 주대각선 요소를 추출하거나, 대각행렬을 만든다. diag() 함수는 첫번째 인수 x에 어떤 형식의 데이타가 오는지에 따라 다른 연산을 수행한다. 인수 x가 행렬이면, 그 행렬의 주대각선 요소를 벡터로 반환한다. 인수 x가 벡터이고 벡터의 길이가 1보다 크면, 그 벡터를 주대각선 요소로 하는 대각행렬(diagonal matrix)를 반환한다. 이 경우 nrow나 ncol이 주어지면 벡터가 재사용되어 대각행렬을 만들 수 있다. 인수 x가 숫자 하나이고 그 값이 k이면, \\(k \\times k\\) 단위 행렬(identity matrix)을 반환한다. 만약 nrow나 ncol 등이 주어지면 k가 주대각선 요소인 대각행렬이 생성된다. &gt; diag(A) [1] 1 4 &gt; diag(1:4) [,1] [,2] [,3] [,4] [1,] 1 0 0 0 [2,] 0 2 0 0 [3,] 0 0 3 0 [4,] 0 0 0 4 &gt; diag(3) [,1] [,2] [,3] [1,] 1 0 0 [2,] 0 1 0 [3,] 0 0 1 &gt; diag(3, nrow=2) [,1] [,2] [1,] 3 0 [2,] 0 3 4.7.3 연립 일차 방정식과 역행렬 다음과 같은 연립 일차 방정식이 있다고 하자. \\[\\begin{align*} 2 x - 3 y &amp;= 5 \\\\ -2 x + 4 y &amp;= -4 \\end{align*}\\] 위의 연립 일차 방정식은 행렬과 벡터를 이용하여 나타내면 다음처럼 표현된다. \\[\\begin{equation*} \\mathbf{A} \\mathbf{x} = \\mathbf{b} \\end{equation*}\\] 단, \\[\\begin{equation*} \\mathbf{A} = \\begin{pmatrix} 2 &amp; -3 \\\\ -2 &amp; 4 \\end{pmatrix}, \\, \\mathbf{x} = \\begin{pmatrix} x \\\\ y \\end{pmatrix}, \\, \\mathbf{b} = \\begin{pmatrix} 5 \\\\ -4 \\end{pmatrix}. \\end{equation*}\\] 위의 식의 해를 구하기 위해서는 앙변에 \\(\\mathbf{A}\\)의 역행렬 \\(\\mathbf{A}^{-1}\\)을 곱하면 된다. \\[\\begin{equation*} \\mathbf{x} = \\mathbf{A}^{-1} \\mathbf{b} \\end{equation*}\\] R에서는 solve() 함수를 이용하여 해를 구한다. solve(a, b) 함수의 첫번째 인수 a에는 연립 일차 방정식의 좌변의 계수를 나타내는 정방행렬이, 두번째 인수 b에는 우변의 상수항을 나타내는 벡터가 제공된다. &gt; A &lt;- matrix(c(2, -2, -3, 4), nrow=2, ncol=2); A [,1] [,2] [1,] 2 -3 [2,] -2 4 &gt; b &lt;- c(5, -4); b [1] 5 -4 &gt; x &lt;- solve(A, b); x [1] 4 1 &gt; A %*% x [,1] [1,] 5 [2,] -4 위의 문제의 답은 \\(x = 4\\)이고 \\(y = 1\\)임을 알 수 있다. 행렬 A와 해 x를 곱하면 우변항의 b와 같아짐을 확인할 수 있다. solve() 함수의 두번째 인수 b가 주어지지 않으면 b를 단위 행렬로 하여 해를 구한다. 그러면 해는 좌변 행렬의 역행렬이 된다. \\[\\begin{align*} &amp; \\mathbf{A} \\mathbf{x} = \\mathbf{I} \\\\ &amp; \\mathbf{x} = \\mathbf{A}^{-1} \\end{align*}\\] 단, \\(\\mathbf{I}\\)는 \\(\\mathbf{A}\\)와 차원이 같은 단위 행렬이다. 따라서 다음은 행렬 \\(\\mathbf{A}\\)의 역행렬 \\(\\mathbf{A}^{-1}\\)을 구해준다. 결과에서 solve()의 해를 원래의 행렬로 곱하면 단위 행렬이 됨을 확인할 수 있다. &gt; A.inverse &lt;- solve(A); A.inverse [,1] [,2] [1,] 2 1.5 [2,] 1 1.0 &gt; A %*% A.inverse [,1] [,2] [1,] 1 0 [2,] 0 1 \\(\\mathbf{A}^{-1}\\)을 구하였으므로 \\(\\mathbf{x} = \\mathbf{A}^{-1} \\mathbf{b}\\) 관계를 이용하여 앞의 방정식의 해를 구할 수도 있다. &gt; A.inverse %*% b [,1] [1,] 4 [2,] 1 하지만 이러한 방법은 수치 계산적인 측면에서 비효율적이고 불안정한 결과를 만들 수 있다. 따라서 \\(\\mathbf{A}\\)의 역행렬을 직접 구하기보다는 solve(A, b)를 이용하여 해를 구하는 것이 좋다. \\(\\mathbf{x}^{t} \\mathbf{A}^{-1} \\mathbf{x}\\) 처럼 이차형식(quadratic form)을 구할 때도 역행렬을 직접 구하기보다는 x %*% solve(A, x)로 계산하는 것이 더 좋다. 4.7.4 고유치(eigenvalues)와 고유벡터(eigenvectors) 행렬의 고유치와 고유벡터를 구하기 위해서는 eigen() 함수를 이용한다. eigen() 함수의 결과는 values와 vectors라는 이름을 가진 두 요소를 가지는 리스트이다. (리스트에 대해서는 5 장을 참조하라.) 고유치 또는 고유벡터를 확인하려면 values 또는 vectors로 리스트 요소를 지정하면 된다. &gt; A [,1] [,2] [1,] 2 -3 [2,] -2 4 &gt; ev &lt;- eigen(A) &gt; ev$values [1] 5.6457513 0.3542487 &gt; ev$vectors [,1] [,2] [1,] 0.6354064 -0.8767397 [2,] -0.7721779 -0.4809652 매우 큰 행렬의 경우 고유벡터가 필요하지 않다면 계산하지 않는 것이 효율적이다. eigen() 함수의 only.values 옵션을 TRUE로 설정하면 고유벡터는 계산하지 않고 고유치만 계산한다. &gt; eigen(A, only.values = TRUE) $values [1] 5.6457513 0.3542487 $vectors NULL C나 Java 등의 언어에 익숙한 독자들은 배열의 인덱스에 drop이라는 인수를 사용할 수 있다는 것이 의아할 수 있을 것이다. R은 함수적 프로그래밍 언어(functional programming language)로 배열의 필터링마저도 사실 함수의 형태로 구현된다. 필터링을 지원하는 함수는 [인데 이 함수는 drop 인수를 지원한다.↩︎ "],
["ch-R-List.html", "Chapter 5 R 리스트 5.1 객체, 객체의 타입, 객체의 속성 5.2 리스트의 생성 및 필터링 5.3 리스트의 변경 및 연결 5.4 리스트에 함수 적용하기 5.5 리스트 활용 분야", " Chapter 5 R 리스트 지금까지는 객체에 포함되는 요소가 모두 같은 타입인 벡터나 행렬을 살펴보았다. 이 장에서는 숫자와 문자 등 다른 타입의 데이터를 결합시킬 수 있는 리스트라는 데이터 구조를 살펴본다. 실제 데이터 분석을 수행할 때 사용자가 리스트를 직접적으로 생성하는 경우는 그리 많지 않다. 그러나 리스트를 이해하는 것은 매우 중요한데 그 이유는 다음과 같다. 리스트 이해의 중요성 첫째, 6 장에서 보겠지만 데이터 분석에서 가장 중요한 데이터 구조는 데이터 프레임이다. 그리고 데이터 프레임은 리스트를 기반으로 하고 있다. 따라서 데이터 프레임의 근간이 되는 리스트에 대해 명확하게 이해하는 것이 데이터를 효율적으로 조작하는 데 도움이 된다. 둘째, 통계 및 데이터 마이닝을 위해 사용하는 다양한 R의 함수는 복잡한 분석의 결과를 리스트 타입으로 제공하는 경우가 많다. 따라서 데이터 분석의 결과를 효과적으로 이용하기 위해서는 리스트 구조를 이해할 필요가 있다. 앞서 리스트란 타입이 다른 데이터를 결합시킬 수 있는 데이터 구조라고 했으므로, 본격적으로 리스트를 논하기 전에 R에서 사용하는 다양한 데이터 타입을 먼저 살펴보자. 5.1 객체, 객체의 타입, 객체의 속성 객체 R에서는 메모리에 저장하거나 메모리에서 읽어 올 수 있는 모든 데이터 단위를 객체(objects)라고 부른다. 앞에서 살펴본 숫자 벡터, 논리 벡터, 문자 벡터들은 모두 객체이다. 또한 행렬, 배열, 그리고 앞으로 살펴볼 리스트, 데이터 프레임뿐 아니라, 함수, 그래프 등도 모두 객체여서 변수에 할당하여 메모리에 저장하거나 필요시 메모리에서 읽어들일 수 있다. 객체의 타입 객체는 하나의 데이터 타입(type)을 갖는다. (모드(mode)라고도 한다.) 데이터 타입이 다른 객체는 다른 방식으로 메모리에 저장되고 읽어들여진다. 예를 들어 논리 벡터의 경우 논리값 타입을 가지며, 논리값 타입을 갖는 데이터는 논리값이 효율적으로 저장되고 연산될 수 있는 형식으로 메모리에 저장되어진다. R에서는 함수를 나타내는 closure 타입, R의 표현식을 의미하는 expression 타입 등 다양한 타입이 존재한다. 그러나 데이터의 관점에서 보면 크게 두 가지 종류의 근본적인 데이터 타입이 존재한다. 하나는 원자적 벡터(atomic vectors)이고, 다른 하나는 일반적 벡터(generic vectors) 또는 리스트라고 불리는 데이터 타입이다. 원자적 벡터 atomic vector 원자적 벡터는 숫자 벡터, 논리 벡터, 문자 벡터처럼 하나의 데이터 형식으로 저장되는 데이터 타입을 의미한다. 반면 리스트는 숫자와 문자 등 서로 다른 데이터 형식으로 저장되는 요소를 가지는 데이터 타입이다. 원자적 벡터의 대표적인 타입은 논리값(logical), 정수(integer), 실수(double), 복소수(complex), 문자(chracter), 바이트(raw) 등이 있다. typeof() 객체가 어떤 데이터 타입으로 저장되어 있는지를 확인하기 위해서 typeof() 함수를 이용할 수 있다. &gt; a &lt;- c(T, F, F, T); typeof(a) [1] &quot;logical&quot; &gt; b &lt;- 1:4; typeof(b) [1] &quot;integer&quot; &gt; d &lt;- c(1.5, 2.7, 3.3, 4.7); typeof(d) [1] &quot;double&quot; &gt; e &lt;- c(&quot;car&quot;, &quot;bus&quot;, &quot;train&quot;, &quot;plane&quot;); typeof(e) [1] &quot;character&quot; 데이터 자동 형변환 논리값, 정수, 실수, 문자 데이터 형식은 제시된 순서대로 데이터가 자동 형변환 된다. 논리값과 정수가 하나의 벡터에 같이 사용되면, 벡터는 하나의 데이터 형식으로 저장되어야 하므로 논리값보다 더 표현 범위가 넓은 정수 형식으로 데이터가 변환된다. 논리값의 FALSE는 0으로, TRUE는 1로 변환된다. 정수와 실수가 같이 사용되면 모두 실수 형식으로 변환된다. 실수와 문자 데이터가 같이 사용되면 모두 문자 형식으로 자동 변환된다. &gt; f &lt;- c(a, b); f; typeof(f) [1] 1 0 0 1 1 2 3 4 [1] &quot;integer&quot; &gt; g &lt;- c(b, d); g; typeof(g) [1] 1.0 2.0 3.0 4.0 1.5 2.7 3.3 4.7 [1] &quot;double&quot; &gt; h &lt;- c(d, e); h; typeof(h) [1] &quot;1.5&quot; &quot;2.7&quot; &quot;3.3&quot; &quot;4.7&quot; &quot;car&quot; &quot;bus&quot; &quot;train&quot; &quot;plane&quot; [1] &quot;character&quot; 물론 숫자 형식의 데이터가 문자로 변환되면 더이상 숫자로서의 연산을 지원되지 않는다. &gt; g * 2 [1] 2.0 4.0 6.0 8.0 3.0 5.4 6.6 9.4 &gt; h * 2 Error in h * 2: non-numeric argument to binary operator 내재적 속성 객체의 데이터 타입은 모든 객체의 내재적 속성 중 하나이다. 모든 객체가 가지는 또 다른 내재적 속성은 길이이다. 길이 속성은 해당 객체의 데이터 요소가 몇 개인지를 알려준다. typeof(objects)와 length(objects) 함수를 이용하면 객체의 데이터 타입과 길이를 알아낼 수 있다. &gt; length(a) [1] 4 &gt; length(b) [1] 4 행렬의 타입 행렬도 결국은 모두 같은 데이터 형식을 가지는 데이터 요소로 구성되어 있으므로, 원자적 벡터 형식의 데이터라고 할 수 있다. 따라서 행렬의 데이터 타입도 결국 벡터가 가지는 데이터 타입과 동일함을 확인할 수 있다. &gt; aa &lt;- matrix(a, nrow=2); typeof(aa); length(aa) [1] &quot;logical&quot; [1] 4 &gt; bb &lt;- matrix(b, nrow=2); typeof(bb); length(bb) [1] &quot;integer&quot; [1] 4 &gt; dd &lt;- matrix(d, nrow=2); typeof(dd); length(dd) [1] &quot;double&quot; [1] 4 &gt; ee &lt;- matrix(e, nrow=2); typeof(ee); length(ee) [1] &quot;character&quot; [1] 4 즉 벡터 b와 행렬 bb는 동일한 형식으로 정수가 4개 메모리에 저장되어 있는 데이터이다. 그러므로 데이터 타입도 integer로 동일하고 요소의 길이도 동일하다. 그러나 b와 bb를 출력해 보면 서로 다른 방식으로 처리되어 출력됨을 볼 수 있다. b는 일련의 숫자로 출력되고, bb는 행과 열이 2인 행렬의 형식으로 출력된다. R은 똑같이 저장되어 있는 데이터에서 이를 어떻게 구분하여 처리하는 것일까? &gt; b [1] 1 2 3 4 &gt; bb [,1] [,2] [1,] 1 3 [2,] 2 4 &gt; class(b) [1] &quot;integer&quot; &gt; class(bb) [1] &quot;matrix&quot; &quot;array&quot; 클래스 class() R은 객체에 데이터 타입 말고 클래스라는 속성을 부여할 수 있다. 데이터 타입은 내재적 속성으로 모든 객체에게 부여된다. 반면 클래스는 객체에 따라 부여되지 않을 수도 있고 여러 개가 부여될 수 있는 속성으로, 객체가 R 함수에 의해 처리될 때 어떤 방식으로 처리되어야 하는지를 알려준다. 위의 예에서 숫자 벡터 b는 아무 클래스도 부여되지 않았으므로 데이터 타입인 integer가 클래스로 지정되어 있고, 행렬 bb의 데이터 타입은 integer이지만 클래스로 matrix가 부여되어 있음을 확인할 수 있다. 따라서 R은 b와 bb의 클래스가 다르므로 print() 출력 함수로 데이터를 출력할 때 다른 방식으로 처리를 수행하였다. attributes() 그러면 R은 4개의 정수가 차례로 저장되어 있는 bb에 대해 2개의 행과 2개의 열을 가진 행렬로 표현해야 한다는 것을 어떻게 알았을까? R은 객체의 데이터를 데이터 타입에 맞추어 저장하고 있을 뿐만 아니라, 그 객체의 부가 정보(메타 정보)를 속성이라는 형태로 저장하고 있다. 각 객체가 가진 내재적 속성인 데이터 타입과 길이를 제외한 모든 속성은 attributes(objects) 함수에 의해 확인할 수 있다. &gt; attributes(b) NULL &gt; attributes(bb) $dim [1] 2 2 위의 예에서 벡터 b는 다른 속성 정보가 없지만, bb는 dim 속성에 행과 열의 길이 정보가 부여되어 있음을 알 수 있다. 사실 R은 벡터에 부여된 dim 속성을 보고 이 벡터가 행렬로 또는 배열로 처리되어야 하는지를 인식하고, 행과 열의 길에에 맞게 출력과 연산 등을 수행한다. attr() attributes(objects) 함수는 객체에 내재된 속성을 제외한 모든 속성을 보여주거나 모든 속성에 데이터를 할당할 때 이용되는 반면, attr(object, name) 함수는 객체에서 특정 이름을 가진 속성을 보여주거나 해당 속성에 데이터를 할당하기 위해 이용된다. 이러한 함수가 자주 사용되지는 않지만 속성에 대한 개념을 이해하는 것은 매우 중요하다. R의 객체 시스템과 각 속성들은 통합되어 있으므로 객체의 속성을 할당하거나 삭제할 때 주의할 필요가 있기 때문이다. 객체의 속성은 할당문의 좌변에 사용되어서 객체에 새로운 속성을 부여하거나 기존의 속성 값을 변경할 수 있다. 예를 들어 다음과 같이 z 객체에 dim 속성을 부여하여 R이 z를 3ⅹ3의 행렬인 것처럼 다루도록 할 수 있다. &gt; z &lt;- 1:9 &gt; z [1] 1 2 3 4 5 6 7 8 9 &gt; class(z) [1] &quot;integer&quot; &gt; attr(z, &quot;dim&quot;) NULL &gt; attr(z, &quot;dim&quot;) &lt;- c(3,3) &gt; attributes(z) $dim [1] 3 3 &gt; z [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 아래 예는 dimnames 속성에 행과 열의 이름을 할당하여 행렬이 출력될 때 행과 열의 이름이 같이 출력되도록 한 경우이다. 이 경우도 R은 저장되어 있는 9개의 정수뿐 아니라 객체의 부가적인 속성 정보를 이용하여 어떤 식으로 처리할 것인지를 결정하게 된다. &gt; attr(z, &quot;dimnames&quot;) &lt;- list(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 1:3) &gt; attributes(z) $dim [1] 3 3 $dimnames $dimnames[[1]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; $dimnames[[2]] [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &gt; z 1 2 3 A 1 4 7 B 2 5 8 C 3 6 9 객체 속성 함수 attr() 함수를 이용하여 다양한 속성을 객체에 부가할 수 있다. 그러나 보통 속성 이름을 잘못 부여하여 오작동하는 것을 방지하고, 사용자의 편의를 도모하기 위해 자주 사용되는 속성을 확인하거나 할당하는 dim(), dimnames(), names(), row.names(), class() 등의 각 속성 전용의 함수들이 정의되어 있다. 각 함수의 사용법은 이 책의 관련 부분이나 R의 도움말을 참고하기 바란다. 객체 속성을 변경할 때는 이러한 attr()보다는 객체 속성 함수를 이용하는 것이 좋다. 왜냐하면 attr() 함수는 속성 이름이 잘 못되더라도 새로운 속성을 설정하는 것으로 생각하여 오류가 발생하지 않는다. 객체 속성 함수를 사용하면 해당 속성을 위한 함수를 잘 못 지정하면 오류가 발생하기 때문에 입력 오류를 바로 확인할 수 있다. 모드와 타입의 차이 마지막으로 모드와 타입의 차이를 설명하고자 한다. 많은 R 문서나 책을 보면 앞에서 이야기한 데이터 타입을 모드라는 이름으로 설명하는 경우가 많다. 사실 모드와 타입은 비슷한 개념으로 생각하면 된다. 타입이 R에서 이용되는 개념이라고 한다면, 모드는 R의 전신인 S 언어에서 데이터의 기본 형식을 지정하기 위해서 사용한 개념이다. R은 S 언어에 대한 호환성을 보장하기 위해 모드라는 개념을 같이 혼용하여 사용하고 있다. 객체의 모드를 확인하기 위해서는 mode() 함수를 이용한다. &gt; typeof(a); mode(a) [1] &quot;logical&quot; [1] &quot;logical&quot; &gt; typeof(b); mode(b) [1] &quot;integer&quot; [1] &quot;numeric&quot; &gt; typeof(d); mode(d) [1] &quot;double&quot; [1] &quot;numeric&quot; &gt; typeof(e); mode(e) [1] &quot;character&quot; [1] &quot;character&quot; 대부분의 경우 타입과 모드는 비슷한 결과를 주지만, 숫자 벡터의 경우 R의 타입은 integer와 double로 저장 형식이 정수인지 실수인지 구분하고, S 언어의 모드는 모두 numeric으로 표시한다. 그러나 S도 storage.mode()라는 함수를 이용하면 내부적으로 저장하는 형식을 확인할 수 있다. &gt; storage.mode(b) [1] &quot;integer&quot; &gt; storage.mode(d) [1] &quot;double&quot; 그러나 R에서는 mode()나 storage.mode() 함수 모두 typeof() 함수의 결과에 기반을 하고 있으므로, S 언어와의 하위 호환성 때문이 아니라면 타입이라는 개념과 typeof() 함수를 사용하는 것이 좋다. 5.2 리스트의 생성 및 필터링 R의 리스트는 요소(component)라고 불리는 객체들을 순서대로 모은 데이터 구조이다. 리스트의 요소들은 서로 다른 데이터 형식일 수 있다. 이론적으로 말하자면 리스트는 서로 다른 타입을 가지는 요소에 대한 주소 정보를 가지고 있는 데이터 형식이다. list() 리스트 객체는 list() 함수를 이용하여 만드는데, 아래처럼 리스트 요소에 이름 없이 만드는 방법과 리스트 요소에 이름을 붙여서 만드는 방법이 있다. &gt; list(요소1, 요소2, ...) &gt; list(이름1=요소1, 이름2=요소2, ...) 다음은 list() 함수를 이용하여 리스트를 만드는 예를 보여주고 있다. &gt; a &lt;- list(name=&quot;Fred&quot;, age=43, wife=&quot;Mary&quot;, + no.children= 3, child.ages=c(4, 7, 9), + is.house.owner=T) &gt; a $name [1] &quot;Fred&quot; $age [1] 43 $wife [1] &quot;Mary&quot; $no.children [1] 3 $child.ages [1] 4 7 9 $is.house.owner [1] TRUE a의 요소로 문자, 숫자, 논리값을 모두 포함할 수 있음을 볼 수 있다. 뒤에서 살펴보겠지만 리스트는 요소로 다른 리스트를 포함할 수도 있고, 함수 등의 다른 타입의 객체도 포함할 수 있다. 위의 예에서 list() 함수의 인수로 리스트에 포함될 요소를 ’이름=요소’의 형식으로 기술하였다. a 객체를 출력해 보면 각 요소의 이름이 $를 앞에 붙여 출력되고 그 다음에 요소의 내용이 출력된다. 리스트 객체의 타입, 길이, 속성 및 names() typeof()와 length() 함수를 이용하면 객체의 내재적 속성인 타입과 요소의 길이를 확인할 수 있다. attributes() 함수를 이용하면 그 밖의 속성을 확인할 수 있는데, names 속성이 부여되어 있음을 볼 수 있다. 사실 attributes()에 의해 반환되는 결과는 속성을 요소로 갖는 리스트 객체이다. &gt; typeof(a) [1] &quot;list&quot; &gt; length(a) [1] 6 &gt; attributes(a) $names [1] &quot;name&quot; &quot;age&quot; &quot;wife&quot; &quot;no.children&quot; [5] &quot;child.ages&quot; &quot;is.house.owner&quot; &gt; names(a) [1] &quot;name&quot; &quot;age&quot; &quot;wife&quot; &quot;no.children&quot; [5] &quot;child.ages&quot; &quot;is.house.owner&quot; list() 함수를 이용하여 객체를 정의할 때 요소에 이름을 부여하지 않으면, 특별한 이름 없이 각 요소가 순서대로 1부터 숫자가 매겨진다. 앞서와 달리 요소의 이름 대신 요소의 번호가 [[ ]] 안에 표시된 후 요소의 내용이 출력됨을 볼 수 있다. &gt; a2 &lt;- list(1:5, letters[1:8], LETTERS[1:3]) &gt; a2 [[1]] [1] 1 2 3 4 5 [[2]] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; [[3]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; 리스트 요소 지정 리스트에서 요소 하나를 지정할 때는 주로 다음의 세가지 방법을 사용한다. 첫번째 방법은, [[ ]] 연산자와 요소의 번호로 지정하는 것이다. 두번째 방법은 list_name$component_name의 형태로 $ 뒤에 리스트 요소의 이름을 이용하여 지정하는 것이다. 세번째 방법은, [[ ]] 연산자 안에 숫자 대신 요소의 이름을 나타내는 문자열을 제시하여 지정하는 것이다. 이 때 두번째와 세번째 방법은 요소의 이름을 사용하는 것은 모두 동일하나, 두번째 방법에서는 $ 뒤에 사용되는 요소의 이름이 변수처럼 따옴표 없이 그대로 이용되는 반면, 세번째 방법에서는 요소의 이름이 문자열로 따옴표로 표현되는 차이가 있다. 숫자 대신 이름을 이용하는 것은 숫자를 기억하지 않아도 되므로 편리하다. &gt; a[[3]] [1] &quot;Mary&quot; &gt; a$wife [1] &quot;Mary&quot; &gt; a[[&quot;wife&quot;]] [1] &quot;Mary&quot; 단계적으로 요소 지정 리스트 요소가 벡터나 행렬인 경우에는 지정된 요소에 다시 인덱스 벡터를 이용하여 부분을 선택할 수 있다. &gt; a[[5]] [1] 4 7 9 &gt; a[[5]][2:3] [1] 7 9 &gt; a$child.ages[2:3] [1] 7 9 요소 이름의 단축 요소의 이름이 다른 요소들의 이름과 충분히 구별 가능하면 축약된 형태로 적을 수도 있다. 그러나 되도록 이름의 단축 기능은 사용하지 말 것을 권장한다. 최근의 R 관련 프로그램은 대부분 코드 자동 완성 기능이 있으므로 긴 이름도 쉽게 작성할 수 있으므로, 이름의 단축으로 얻는 입력 타수 절약이라는 장점보다는 명령문의 가독성이 줄어드는 단점이 더 크기 때문이다. &gt; a$no [1] 3 &gt; a$child [1] 4 7 9 부분 리스트로 필터링 지금까지는 리스트의 한 요소를 지정하는 방법에 대하여 설명하였다. 어떤 경우에는 리스트의 여러 요소를 지정할 필요가 있다. 이러한 경우에는 [[ ]] 연산자가 아니라 벡터의 필터링에 사용한 [ ]를 동일하게 이용한다. &gt; a[1:3] $name [1] &quot;Fred&quot; $age [1] 43 $wife [1] &quot;Mary&quot; &gt; a[c(2, 5)] $age [1] 43 $child.ages [1] 4 7 9 &gt; a[-(4:5)] $name [1] &quot;Fred&quot; $age [1] 43 $wife [1] &quot;Mary&quot; $is.house.owner [1] TRUE &gt; a[c(&quot;wife&quot;, &quot;child.ages&quot;)] $wife [1] &quot;Mary&quot; $child.ages [1] 4 7 9 &gt; a[c(T, F, F)] $name [1] &quot;Fred&quot; $no.children [1] 3 벡터의 필터링과 마찬가지로 자연수를 이용하여 해당 위치의 요소를 뽑을 수도 있고, 음의 정수를 이용하여 해당 위치의 요소를 빼고 필터링을 수행할 수도 있다. 문자열 벡터를 이용하여 요소의 이름으로 필터링이 가능하다. 리스트 요소 지정 vs. 부분 리스트 필터링 여기서 주목해야 할 것은 벡터의 필터링의 결과는 원래 벡터의 부분으로 구성된 벡터인 것과 마찬가지로, 리스트의 [ ] 필터링의 결과는 리스트의 부분으로 구성된 또 다른 리스트가 된다. 반면 [[ ]]나 $ 연산자를 이용하여 요소를 지정하는 것은 리스트의 요소 그 자체가 된다. 즉, 또 다른 리스트가 되는 것이 아니라 리스트의 요소가 벡터이면 벡터 그 자체가 된다. 다음의 예는 [ ]와 [[ ]] 연산자를 이용하여 a의 5번째 요소를 뽑아낸 예이다. &gt; a[[5]] [1] 4 7 9 &gt; a[5] $child.ages [1] 4 7 9 전자는 벡터로 출력되고 후자는 다시 요소가 하나짜리 리스트로 표현됨을 볼 수 있다. 내용적으로 두 결과의 차이가 크지 않지만 형식적으로는 두 결과는 큰 차이를 가진다. 전자의 경우는 요소 그 자체인 벡터가 되므로 벡터 필터링이나 벡터와 관련된 연산이 가능하지만, 후자는 불가능하다. 대신 리스트와 관련된 연산이나 필터링을 수행해야 한다. &gt; a[[5]][2:3] [1] 7 9 &gt; a[[5]] * 7 [1] 28 49 63 &gt; a[5][2:3] $&lt;NA&gt; NULL $&lt;NA&gt; NULL &gt; a[5] * 7 Error in a[5] * 7: non-numeric argument to binary operator 위의 예에서 [[ ]]로 지정된 결과는 요소 그 자체가 되므로, 결과가 숫자 벡터가 된다. 따라서 벡터와 관련된 모든 연산이 가능하다. 반면 [ ]로 필터링된 결과는 리스트라는 형식이 유지되어 요소가 하나인 리스트가 된다. 따라서 2번째와 3번째 요소를 필터링하자, 해당 요소가 없으므로 모두 NULL로 표시된다. 리스트이므로 수식 벡터의 연산도 수행되지 않음을 알 수 있다. 5.3 리스트의 변경 및 연결 리스트 요소의 추가 이미 생성된 리스트는 새로운 요소를 추가함으로써 확장될 수 있다. 새로운 요소를 추가하거나 변경하는 방법은 여러 가지가 있을 수 있는데, 첫번째로 생각할 수 있는 방법은 [[ ]] 연산자나 $ 연산자를 이용하여 요소를 추가하거나 변경하는 방법이다. 다음은 새로운 요소를 리스트에 추가한 예이다. &gt; length(a) [1] 6 &gt; a[[7]] &lt;- 1:5 &gt; a[[&quot;address&quot;]] &lt;- &quot;Cheonan&quot; &gt; a$years.since.marrage &lt;- 15 &gt; a $name [1] &quot;Fred&quot; $age [1] 43 $wife [1] &quot;Mary&quot; $no.children [1] 3 $child.ages [1] 4 7 9 $is.house.owner [1] TRUE [[7]] [1] 1 2 3 4 5 $address [1] &quot;Cheonan&quot; $years.since.marrage [1] 15 리스트 요소의 변경 벡터와 마찬가지로 기존 요소를 지정한 후 할당을 하면 기존 요소가 변경된다. &gt; a[[7]] &lt;- 10:18 &gt; a$address &lt;- &quot;Daejeon&quot; &gt; a[[9]] &lt;- 16 &gt; a $name [1] &quot;Fred&quot; $age [1] 43 $wife [1] &quot;Mary&quot; $no.children [1] 3 $child.ages [1] 4 7 9 $is.house.owner [1] TRUE [[7]] [1] 10 11 12 13 14 15 16 17 18 $address [1] &quot;Daejeon&quot; $years.since.marrage [1] 16 자연수 인덱스를 이용한 리스트 요소의 추가와 빈 요소의 생성 위의 예에서 새로운 요소를 추가할 때 요소의 이름을 이용하면 현재까지 있는 요소의 다음 위치에 차례로 해당 이름을 갖는 요소가 추가된다. 그러나 숫자를 이용하여 위치를 지정하여 새로운 요소를 추가하면 해당 위치에 요소가 생성된다. 위의 예처럼 이미 해당 위치에 다른 요소가 있다면 새로운 값으로 변경이 될 것이며, 아무 것도 없었다면 해당 위치에 새로운 데이터가 추가된다. 그러면 기존 리스트의 마지막 요소의 다음 위치가 아니라 더 먼 위치에 새로운 요소를 추가하면 어떻게 될까? &gt; a2 [[1]] [1] 1 2 3 4 5 [[2]] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; [[3]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &gt; a2[[5]] &lt;- &quot;New items&quot; &gt; a2 [[1]] [1] 1 2 3 4 5 [[2]] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; [[3]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; [[4]] NULL [[5]] [1] &quot;New items&quot; 위의 예에서 보듯이 비어 있는 요소는 아무 것도 없다는 뜻의 NULL로 표현되어 출력되고 마지막 위치에 있는 요소까지 모두 출력된다. 리스트 요소의 삭제 리스트의 요소를 삭제하기 위해서는 해당 요소를 [[ ]]나 $ 연산자를 이용하여 지정한 후 해당 요소에 NULL을 할당하면 된다. &gt; a2[[5]] &lt;- NULL &gt; a2 [[1]] [1] 1 2 3 4 5 [[2]] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; [[3]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; [[4]] NULL &gt; a2[[4]] &lt;- NULL &gt; a2 [[1]] [1] 1 2 3 4 5 [[2]] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; [[3]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &gt; names(a2) &lt;- c(&quot;num&quot;, &quot;lower.case&quot;, &quot;upper.case&quot;) &gt; a2 $num [1] 1 2 3 4 5 $lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; $upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &gt; a2$num &lt;- NULL &gt; a2 $lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; $upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; 부분 리스트를 이용한 리스트 변경 지금까지는 [[ ]]나 $ 연산자를 이용하여 요소 하나를 추가, 변경, 삭제하는 것을 보여주었다. [ ] 연산자를 이용하면 리스트의 여러 요소를 추가 또는 변경할 수 있다. 이 때 할당문의 오른쪽에 있는 객체는 리스트 객체여야 한다. 왜냐하면 [ ] 연산자를 이용한 필터링의 결과는 원래 리스트의 부분 리스트이기 때문이다. &gt; a2[3:4] &lt;- list(1:5, month.name) &gt; a2 $lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; $upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; [[3]] [1] 1 2 3 4 5 [[4]] [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; 리스트의 recycling 만약 오른쪽 항의 리스트가 할당될 부분 리스트보다 요소 수가 적으면 오른쪽 항의 리스트가 재사용된다. &gt; a2[3:6] &lt;- list(11:15, month.abb) &gt; a2 $lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; $upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; [[3]] [1] 11 12 13 14 15 [[4]] [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; &quot;Dec&quot; [[5]] [1] 11 12 13 14 15 [[6]] [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; &quot;Dec&quot; 벡터의 리스트로의 형변환 또한 부분 리스트를 지정한 후 할당하는 예에서, 오른쪽에 리스트가 아니라 벡터가 주어지면 벡터의 각 요소가 리스트의 요소로 변환된 후 할당이 이루어진다. 이는 R 등의 고급 언어들의 특징인데 할당해야 할 내용이 할당받을 객체의 타입과 다른 경우, 가능하면 할당문의 왼쪽에 있는 객체의 타입으로 변환하려고 노력한다. as.list() 함수를 이용하여 벡터를 리스트로 사용자가 명시적으로 변환할 수도 있다. &gt; a2[3:6] &lt;- c(&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;W&quot;) &gt; a2 $lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; $upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; [[3]] [1] &quot;X&quot; [[4]] [1] &quot;Y&quot; [[5]] [1] &quot;Z&quot; [[6]] [1] &quot;W&quot; &gt; c(&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;W&quot;) [1] &quot;X&quot; &quot;Y&quot; &quot;Z&quot; &quot;W&quot; &gt; as.list(c(&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;W&quot;)) [[1]] [1] &quot;X&quot; [[2]] [1] &quot;Y&quot; [[3]] [1] &quot;Z&quot; [[4]] [1] &quot;W&quot; &gt; a2[3:6] &lt;- NULL &gt; a2 $lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; $upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; 위의 예에서 부분리스트에 NULL을 할당하면 부분 리스트에 해당되는 모든 요소가 삭제됨을 볼 수 있다. 이 때도 역시 NULL이 재사용되어 4개의 요소에 모두 NULL이 할당되었다. c() 일계층 리스트의 생성 리스트는 벡터와 같이 c() 함수를 이용하여 리스트들을 연결하여 하나의 리스트로 만들 수 있다. &gt; a3 &lt;- list(first=1:3, second=4:6) &gt; a3 $first [1] 1 2 3 $second [1] 4 5 6 &gt; a4 &lt;- c(a2, a3) &gt; a4 $lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; $upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; $first [1] 1 2 3 $second [1] 4 5 6 &gt; length(a4) [1] 4 계층적인 구조의 리스트 생성 위의 예에서 c()로 연결된 리스트들은 모든 요소가 평평하게 하나의 계층으로 연결되었음을 볼 수 있다. 그런데 리스트는 모든 타입의 요소를 포함할 수 있기 때문에 리스트의 요소에 리스트가 할당될 수 있다. 이 경우 리스트는 계층적인 구조를 갖게 된다. &gt; a5 &lt;- list(a2, a3) &gt; a5 [[1]] [[1]]$lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; [[1]]$upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; [[2]] [[2]]$first [1] 1 2 3 [[2]]$second [1] 4 5 6 &gt; length(a5) [1] 2 c()로 같은 계층으로 연결한 앞의 a4의 결과와 a5의 출력 결과를 비교해 보라. a4에서 upper.case 요소를 뽑기 위해서는 2번째 요소를 뽑으면 된다. 그러나 a5에서는 2번째 요소를 뽑으면 2번째 리스트 전체가 뽑혀져서 나오는 것을 볼 수 있다. a5에서 upper.case를 뽑으려면 첫번째 요소를 뽑은 후, 거기서 다시 2번째 요소를 뽑아야 한다. &gt; a4[[2]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &gt; a5[[2]] $first [1] 1 2 3 $second [1] 4 5 6 &gt; a5[[1]][[2]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &gt; a5[[2]]$second [1] 4 5 6 &gt; a4$second [1] 4 5 6 계층적인 구조의 리스트를 c()로 연결하면 첫 층위에서만 하나의 리스트로 합쳐진다. 모든 층위의 요소를 재귀적으로 하나로 합치려면 recursive=TRUE 인수를 설정한다. 그러면 모든 요소들이 하나로 합쳐져 벡터로 변환된다. 다음 예에서는 문자 요소가 있으므로 모두 문자로 자동 형변환되어 합쳐졌다. &gt; c(a4, a5) $lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; $upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; $first [1] 1 2 3 $second [1] 4 5 6 [[5]] [[5]]$lower.case [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; [[5]]$upper.case [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; [[6]] [[6]]$first [1] 1 2 3 [[6]]$second [1] 4 5 6 &gt; c(a4, a5, recursive = TRUE) lower.case1 lower.case2 lower.case3 lower.case4 lower.case5 lower.case6 &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; lower.case7 lower.case8 upper.case1 upper.case2 upper.case3 first1 &quot;g&quot; &quot;h&quot; &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;1&quot; first2 first3 second1 second2 second3 lower.case1 &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;a&quot; lower.case2 lower.case3 lower.case4 lower.case5 lower.case6 lower.case7 &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; lower.case8 upper.case1 upper.case2 upper.case3 first1 first2 &quot;h&quot; &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;1&quot; &quot;2&quot; first3 second1 second2 second3 &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; unlist() 리스트의 벡터로 형 변환 앞서 as.list()를 이용하여 벡터를 리스트로 변환한 예를 보았다. 어떤 경우에는 리스트의 모든 요소를 벡터로 변환할 필요가 있다. 앞의 예처럼 c( , recursive = TRUE)를 사용할 수도 있지만, 이 때 사용하는 전용 함수인 unlist()를 사용하는 것이 더 일반적이다. &gt; unlist(a3) first1 first2 first3 second1 second2 second3 1 2 3 4 5 6 &gt; unlist(a4) lower.case1 lower.case2 lower.case3 lower.case4 lower.case5 lower.case6 &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; lower.case7 lower.case8 upper.case1 upper.case2 upper.case3 first1 &quot;g&quot; &quot;h&quot; &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;1&quot; first2 first3 second1 second2 second3 &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; 예에서 보듯이 리스트의 요소가 모두 숫자로 표시가 가능하면 숫자 벡터로 변환하지만, 하나라도 문자 등이 있으면 모두 문자 벡터로 변환한다. 그리고 벡터의 각 요소에 리스트 요소의 이름과 벡터의 위치에 따라 자동으로 이름이 부여되었음을 확인할 수 있다. unlist() 함수는 strsplit() 결과를 하나의 문자 벡터로 만들 때 자주 사용된다. &gt; a &lt;- c(&quot;R은 통계분석을 위해 특화된 프로그램 언어입니다.&quot;, &quot;다양한 데이터 분석 함수가 내장되어 있습니다.&quot;) &gt; b &lt;- strsplit(a, split = &quot; &quot;) &gt; b [[1]] [1] &quot;R은&quot; &quot;통계분석을&quot; &quot;위해&quot; &quot;특화된&quot; &quot;프로그램&quot; [6] &quot;언어입니다.&quot; [[2]] [1] &quot;다양한&quot; &quot;데이터&quot; &quot;분석&quot; &quot;함수가&quot; &quot;내장되어&quot; &quot;있습니다.&quot; &gt; unlist(b) [1] &quot;R은&quot; &quot;통계분석을&quot; &quot;위해&quot; &quot;특화된&quot; &quot;프로그램&quot; [6] &quot;언어입니다.&quot; &quot;다양한&quot; &quot;데이터&quot; &quot;분석&quot; &quot;함수가&quot; [11] &quot;내장되어&quot; &quot;있습니다.&quot; 5.4 리스트에 함수 적용하기 행렬을 공부할 때 apply() 함수를 이용하여 행렬의 각 행 또는 각 열에 함수를 적용하는 방법을 공부하였다. 리스트에도 리스트의 각 요소에 함수를 적용하는 lapply()와 sapply() 함수가 있다. 5.4.1 lapply() 함수 lapply() lapply() 함수는 다음의 문법 구조를 가진다. &gt; lapply(리스트, 함수) 다음 예는 lapply()를 이용하여 숫자 벡터로 이루어진 리스트의 각 요소에 mean() 함수를 적용한 예이다. 어떤 객체에 함수를 적용할 때는 function(object) 형식으로 함수의 인수로 객체를 제공한다. 그러나 lapply()에서는 첫번째 인수로 리스트를 제공하고, 두번째 인수로 함수 객체를 제공한다. &gt; b &lt;- list(1:5, 21:29, seq(2, 20, by=2)) &gt; b [[1]] [1] 1 2 3 4 5 [[2]] [1] 21 22 23 24 25 26 27 28 29 [[3]] [1] 2 4 6 8 10 12 14 16 18 20 &gt; mean(b[[1]]) [1] 3 &gt; mean(b[[2]]) [1] 25 &gt; mean(b[[3]]) [1] 11 &gt; lapply(b, mean) [[1]] [1] 3 [[2]] [1] 25 [[3]] [1] 11 위의 예에서 보듯이 lapply()는 리스트의 각 요소에 함수를 적용한 후 그 결과를 동일한 형식의 리스트 객체로 제공한다. lapply() 결과 리스트의 요소 이름 아래 예는 리스트에 여러 함수들을 적용한 예이다. 리스트에 이름을 제공하면 결과에도 동일한 이름이 요소에 붙여짐을 확인할 수 있다. &gt; lapply(b, max) [[1]] [1] 5 [[2]] [1] 29 [[3]] [1] 20 &gt; names(b) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) &gt; lapply(b, range) $A [1] 1 5 $B [1] 21 29 $C [1] 2 20 5.4.2 sapply() 함수 sapply() 많은 경우에 최종 결과가 리스트보다는 벡터나 행렬 등의 간단한 형태로 제공되는 것이 편리하다. 이런 경우에는 sapply()를 사용한다. (simplified lapply로 기억하면 편리하다.) sapply()도 lapply()와 문법적 구조가 동일하다. 다른 점은 최종 결과를 리스트가 아니라 가능하면 벡터나 행렬처럼 간단한 형식으로 반환한다는 점이다. sapply()도 apply() 함수처럼 벡터로 결과를 반환하거나, 요소 하나에 함수를 적용한 결과가 길이가 2 이상인 벡터이면 열로 결과를 붙여서 행렬 형식으로 결과를 반환한다. &gt; sapply(b, length) A B C 5 9 10 &gt; sapply(b, range) A B C [1,] 1 21 2 [2,] 5 29 20 &gt; lb &lt;- lapply(b, length) &gt; typeof(lb) [1] &quot;list&quot; &gt; sb &lt;- sapply(b, length) &gt; typeof(sb) [1] &quot;integer&quot; 사용자 정의 함수의 적용 lapply()와 sapply(), 또는 apply() 등을 이용하여 객체의 각 요소나 부분에 함수를 적용할 때 기존의 함수뿐 아니라 사용자가 정의한 함수를 적용할 수도 있다. (함수를 정의하는 법은 10 장의 함수와 관련된 내용을 참조하기 바란다.) 다음은 리스트의 각 요소에서 10보다 큰 수의 개수를 세는 예이다. &gt; sapply(b, function(x){ + sum(x &gt; 10) + }) A B C 0 9 5 5.4.3 mapply() 함수 lapply()와 sapply()가 하나의 리스트에 대해 각 요소에 함수를 적용한다면, mapply()는 다수의 리스트에 대해 같은 위치의 요소들에 함수를 적용하기 위한 함수이다. mapply()는 sapply()처럼 결과를 벡터나 행렬 등의 단순한 형태로 제공할 수 있으면 리스트가 아니라 단순한 형태로 결과를 제공한다. mapply()는 다음과 같은 문법 구조를 가진다. 먼저 리스트의 요소에 적용할 함수를 첫번째 FUN 인수로 제공한다. 그리고는 함수를 동시에 같이 적용할 리스트의 목록을 기술한다. 그러면 이 리스트의 같은 위치의 요소들이 함수의 인수로 제공된다. 리스트 외에도 별도의 인수를 함수에 제공할 필요가 있으면 MoreArgs 인수에 리스트 형태로 제공한다. &gt; mapply(FUN, list_1(vector_1), ..., list_n(vector_n), + MoreArgs=NULL) 다음과 같은 2 개의 리스트가 존재한다고 하자. &gt; a &lt;- list(1:5, 10:5, letters[1:4]) &gt; b &lt;- list(6:4, 4:7, LETTERS[5:1]) 다음은 리스트의 같은 위치에 있는 요소를 c() 함수를 이용하여 각각 연결한 예이다. &gt; mapply(c, a, b) [[1]] [1] 1 2 3 4 5 6 5 4 [[2]] [1] 10 9 8 7 6 5 4 5 6 7 [[3]] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;E&quot; &quot;D&quot; &quot;C&quot; &quot;B&quot; &quot;A&quot; 또한 mapply()에 리스트를 인수로 제공할 때 이름=리스트 형태로 인수를 제공하면 FUN 인수에 부여된 함수에 해당 이름으로 인수가 제공된다. 다음은 rep() 함수에 반복할 벡터 x와 반복 횟수를 times을 리스트로 제공한 예이다. &gt; mapply(rep, times=2:4, x=list(1:2, 11:12, 21:22)) [[1]] [1] 1 2 1 2 [[2]] [1] 11 12 11 12 11 12 [[3]] [1] 21 22 21 22 21 22 21 22 위의 결과에서 x 리스트의 각 요소와 times 벡터의 각 요소가 차례로 결합되어 rep() 함수가 적용되었음을 볼 수 있다. 5.5 리스트 활용 분야 리스트로 결과를 반환하는 함수의 예 이 장의 시작부분에서 리스트가 중요한 이유를 설명할 때, 많은 데이터 분석 함수들이 결과를 리스트 형태로 제공한다고 하였다. 실제 그러한지 예를 통해 살펴보도록 하자. 다음은 선형회귀분석을 수행하는 lm() 함수의 결과가 리스트 객체라는 것을 보여준다. 리스트 객체의 각 요소는 수행된 선형회귀분석에 대한 자세한 결과를 저장하고 있다. &gt; x &lt;- lm(dist~speed, data=cars) &gt; x Call: lm(formula = dist ~ speed, data = cars) Coefficients: (Intercept) speed -17.579 3.932 &gt; typeof(x) [1] &quot;list&quot; &gt; class(x) [1] &quot;lm&quot; &gt; names(x) [1] &quot;coefficients&quot; &quot;residuals&quot; &quot;effects&quot; &quot;rank&quot; [5] &quot;fitted.values&quot; &quot;assign&quot; &quot;qr&quot; &quot;df.residual&quot; [9] &quot;xlevels&quot; &quot;call&quot; &quot;terms&quot; &quot;model&quot; &gt; x$residuals 1 2 3 4 5 6 7 3.849460 11.849460 -5.947766 12.052234 2.119825 -7.812584 -3.744993 8 9 10 11 12 13 14 4.255007 12.255007 -8.677401 2.322599 -15.609810 -9.609810 -5.609810 15 16 17 18 19 20 21 -1.609810 -7.542219 0.457781 0.457781 12.457781 -11.474628 -1.474628 22 23 24 25 26 27 28 22.525372 42.525372 -21.407036 -15.407036 12.592964 -13.339445 -5.339445 29 30 31 32 33 34 35 -17.271854 -9.271854 0.728146 -11.204263 2.795737 22.795737 30.795737 36 37 38 39 40 41 42 -21.136672 -11.136672 10.863328 -29.069080 -13.069080 -9.069080 -5.069080 43 44 45 46 47 48 49 2.930920 -2.933898 -18.866307 -6.798715 15.201285 16.201285 43.201285 50 4.268876 &gt; x$terms dist ~ speed attr(,&quot;variables&quot;) list(dist, speed) attr(,&quot;factors&quot;) speed dist 0 speed 1 attr(,&quot;term.labels&quot;) [1] &quot;speed&quot; attr(,&quot;order&quot;) [1] 1 attr(,&quot;intercept&quot;) [1] 1 attr(,&quot;response&quot;) [1] 1 attr(,&quot;.Environment&quot;) &lt;environment: R_GlobalEnv&gt; attr(,&quot;predvars&quot;) list(dist, speed) attr(,&quot;dataClasses&quot;) dist speed &quot;numeric&quot; &quot;numeric&quot; lm() 함수의 결과의 타입은 list이고, 클래스는 함수의 이름과 동일한 lm임을 볼 수 있다. (R에서는 사용자의 기억을 돕기 위해서 일반적으로 함수의 결과가 복잡한 경우 함수의 이름과 동일한 클래스 이름으로 결과를 반환한다. 클래스에 대해서는 11 장을 참조한다.) lm 클래스의 객체이긴 하지만 타입이 리스트이므로 names() 함수를 이용하여 요소의 이름을 확인하고, $ 연산자를 이용하여 요소에 접근하여 요소의 내용을 확인할 수 있다. unclass() 주의할 점은 리스트이긴 하지만 lm 클래스이므로 출력을 해 보면 리스트의 모든 요소가 출력되는 것이 아니라 lm 클래스에 맞추어 회귀분석의 주요 결과만 간략하게 출력됨을 볼 수 있다. 만약 리스트로서 모든 요소를 확인하고 싶으면 unclass() 함수를 이용하여 객체에 부여된 클래스 속성을 제거하면 단순한 리스트 객체가 되어서 모든 요소가 출력된다. 출력이 매우 길므로 출력 결과는 생략하였다. &gt; unclass(x) 데이터 프레임 리스트가 중요한 또 다른 이유는 R에서 데이터를 저장할 때 빈번하게 이용하는 데이터 프레임이라는 형식이 리스트를 기반으로 하고 있기 때문이다. 정확히 이야기하면, 데이터 프레임은 data.frame이라는 클래스 속성을 갖는 리스트이다. &gt; head(cars) speed dist 1 4 2 2 4 10 3 7 4 4 7 22 5 8 16 6 9 10 &gt; typeof(cars) [1] &quot;list&quot; &gt; class(cars) [1] &quot;data.frame&quot; 이번에도 cars 객체는 리스트로 데이터를 저장하지만, 클래스가 data.frame이므로 출력해 보면 일반적인 리스트의 형식으로 출력되지 않고 행렬 형태로 출력된다. unclass()를 이용하면 클래스가 없어져서 이 데이터가 리스트 형식으로 저장되어 있음을 확인할 수 있다. &gt; unclass(cars) $speed [1] 4 4 7 7 8 9 10 10 10 11 11 12 12 12 12 13 13 13 13 14 14 14 14 15 15 [26] 15 16 16 17 17 17 18 18 18 18 19 19 19 20 20 20 20 20 22 23 24 24 24 24 25 $dist [1] 2 10 4 22 16 10 18 26 34 17 28 14 20 24 28 26 34 34 46 [20] 26 36 60 80 20 26 54 32 40 32 40 50 42 56 76 84 36 46 68 [39] 32 48 52 56 64 66 54 70 92 93 120 85 attr(,&quot;row.names&quot;) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 결과에서 speed와 dist로 이름이 붙여진 숫자 벡터로 구성된 리스트임을 확인할 수 있다. 그리고 row.names라는 속성이 부여되어 있음을 확인할 수 있다. 데이터 프레임은 보통 다른 통계 소프트웨어에서 데이터 집합 또는 데이터 행렬이라고 불리는 것이다. R에서는 본질적으로 데이터 프레임은 data.frame 클래스인 리스트인데, 요소의 길이가 모두 같은 리스트이다. 그러므로 데이터를 행렬 형태로 표현할 수 있다. 리스트의 각 요소가 각 열로 표현된다. 리스트를 데이터 프레임으로 변환시키기 위해서는 as.data.frame()을 이용하면 된다. &gt; y &lt;- list(a=11:15, b=letters[11:15]) &gt; y $a [1] 11 12 13 14 15 $b [1] &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &gt; typeof(y); class(y) [1] &quot;list&quot; [1] &quot;list&quot; &gt; z &lt;- as.data.frame(y) &gt; z a b 1 11 k 2 12 l 3 13 m 4 14 n 5 15 o &gt; typeof(z); class(z) [1] &quot;list&quot; [1] &quot;data.frame&quot; "],
["ch-R-Data-Frame.html", "Chapter 6 R 데이터 프레임 6.1 범주형 데이터와 요인 (Factors) 6.2 데이터 프레임 만들기 6.3 데이터 프레임 각 열의 지정 6.4 데이터 프레임의 필터링 6.5 데이터 프레임에 함수 적용하기 6.6 파일에서 데이터 읽어오기 6.7 파일에 데이터 프레임 쓰기 6.8 데이터 프레임의 열을 변수처럼 이용하는 방법", " Chapter 6 R 데이터 프레임 이 장에서는 여러 타입의 데이터가 혼재된 데이터 프레임이란 데이터 구조를 다룬다. 보통 다른 통계 소프트웨어에서 데이터 분석의 기본 단위인 데이터 집합 또는 데이터 행렬이라고 불리는 것이다. 데이터 프레임의 두 측면: 리스트적 측면 행렬적 측면 데이터 프레임은 행렬을 일반화한 것으로 생각하면 이해하기 쉽다. 행렬에 속한 데이터는 모두 같은 타입인데 반해, 데이터 프레임은 각 열마다 각기 다른 타입의 데이터를 가질 수 있다. 데이터 프레임에는 한 열은 숫자 타입의 데이터가, 다른 한 열은 문자 타입의 데이터가 각각 들어갈 수 있다. 한 강의를 듣는 학생에 대한 표 6.1 같은 데이터가 있다고 하자. 이 데이터에는 중간고사, 기말고사 같이 숫자 데이터도 있지만, 학생 이름과 성별처럼 문자 데이터도 있다. 그리고 재수강 여부처럼 논리 값 데이터도 있다. 데이터의 형태는 다르지만 한 학생에 대한 정보를 얻기 위해서는 숫자, 문자, 논리 값을 포함한 데이터를 다룰 수 있어야 한다. 이 경우에 사용할 수 있는 데이터 구조가 데이터 프레임이다. 본질적으로 데이터 프레임은 ‘data.frame’ 클래스인 리스트이다. 리스트가 특정 조건을 만족하면 데이터 프레임이 될 수 있다. 리스트와 데이터 프레임의 관계에 대한 자세한 내용은 5 장을 참조하라. Table 6.1: 한 과목의 수강생 데이터 번호 이름 학년 성별 중간고사 기말고사 재수강 1 김철수 1 남 74 91 T 2 김영희 4 여 82 77 F 3 이철수 3 남 67 88 F 4 이영희 2 여 89 78 T 5 홍길동 1 남 92 86 F 6.1 범주형 데이터와 요인 (Factors) R 데이터 프레임의 각 열은 숫자, 문자, 논리 값 벡터 또는 요인으로 구성된다. 숫자, 문자, 논리 값 벡터에 대해서는 3 장에서 다루었다. 본 절에서는 R 데이터 프레임에 대하여 설명하기에 앞서 요인에 대하여 살펴보도록 한다. 6.1.1 명목형 변수와 요인 전국 유권자 대상으로 지지하는 정당에 대해 다음 설문조사를 하였다고 하자. 다음 중 지지하는 정당은? ( ) A 정당 B 정당 C 정당 지지하는 정당 없음 범주 데이터의 숫자 코딩 10 명의 유권자에게 응답을 얻었다면 아마도 1부터 4까지의 숫자를 이용하여 다음과 같이 설문 결과를 입력하게 될 것이다. &gt; results &lt;- c(1, 3, 2, 4, 3, 2, 1, 3, 2, 2) &gt; results [1] 1 3 2 4 3 2 1 3 2 2 여기서 숫자로 코딩된 설문 결과는 1부터 4까지의 수량적 의미를 가지기보다는 4가지 범주(A 정당, B 정당, C 정당, 없음)의 차이를 숫자로 표현한 것 뿐이다. 그런데 이렇게 범주형 데이터를 숫자 벡터로 표현하는 것은 범주형 데이터를 편리하게 코딩할 수 있는 장점이 있는 반면 다음과 같은 단점을 가진다. 숫자 코딩의 문제점 결과가 숫자 벡터로 입력되었으므로 다음처럼 어떤 범주에도 대응되지 않는 잘못된 숫자가 입력될 수도 있다. &gt; results[1] &lt;- 5 &gt; results [1] 5 3 2 4 3 2 1 3 2 2 결과를 숫자형 데이터로 오인하여 잘못된 처리를 수행할 수 있다. 입력하는 시점에는 오인을 할 가능성이 적지만 데이터를 분석하는 과정에서 주의를 기울이지 않으면 범주형 데이터를 숫자 데이터로 오인하여 잘못된 분석을 수행할 수 있다. 다음은 범주형 데이터를 나타내는 벡터를 수량 데이터로 오인하여 평균을 분석한 예이다. &gt; mean(results) [1] 2.7 데이터 입력 후 제대로 기록해 두지 않으면 각 숫자의 의미가 무엇인지 파악하기 어렵게 된다. factor() 이러한 문제를 해결하기 위해 R은 범주형 데이터를 처리할 때 이용할 수 있는 요인(factor)이라는 데이터 형태를 제공한다. 요인을 생성하기 위해서 factor() 함수를 이용한다. 수준 levels 다음은 숫자로 코딩된 결과(results)를 이용하여 1, 2, 3, 4 수준(level)을 가진 요인을 생성한 예이다. 요인에서 수준은 요인 데이터가 가질 수 있는 차별적 값을 나타낸다. &gt; results [1] 5 3 2 4 3 2 1 3 2 2 &gt; attributes(results) NULL &gt; fResults &lt;- factor(results, levels=1:4) &gt; fResults [1] &lt;NA&gt; 3 2 4 3 2 1 3 2 2 Levels: 1 2 3 4 &gt; attributes(fResults) $levels [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; $class [1] &quot;factor&quot; 결과에서 보듯이 수준에 포함되지 않은 5의 값은 NA로 변환된다. 요인으로 변경된 데이터의 클래스는 factor가 되고, levels 속성이 지정되어 있음을 볼 수 있다. results의 첫 번째 데이터를 제대로 된 값인 1로 변경한 후 다시 한번 요인으로 변경해 보자. &gt; results[1] &lt;- 1 &gt; fResults &lt;- factor(results, levels=1:4) &gt; fResults [1] 1 3 2 4 3 2 1 3 2 2 Levels: 1 2 3 4 만약 요인 데이터에 이미 정의된 수준을 제외한 다른 값을 입력하면 다음과 같이 경고가 출력되고 입력된 데이터는 NA로 입력됨을 볼 수 있다. &gt; fResults[11] &lt;- 4 &gt; fResults [1] 1 3 2 4 3 2 1 3 2 2 4 Levels: 1 2 3 4 &gt; fResults[12] &lt;- 5 Warning in `[&lt;-.factor`(`*tmp*`, 12, value = 5): invalid factor level, NA generated &gt; fResults [1] 1 3 2 4 3 2 1 3 2 2 4 &lt;NA&gt; Levels: 1 2 3 4 만약 요인 데이터를 숫자 벡터로 착각하여 평균을 구하려고 해 보자. 먼저 fResults의 데이터를 원래대로 돌려놓은 후 mean() 함수로 평균을 구해보자. 그러면 숫자 데이터가 아니므로 평균을 구할 수 없음을 알 수 있다. &gt; fResults[12] &lt;- 2 &gt; fResults [1] 1 3 2 4 3 2 1 3 2 2 4 2 Levels: 1 2 3 4 &gt; mean(fResults) Warning in mean.default(fResults): argument is not numeric or logical: returning NA [1] NA levels() 요인의 수준을 좀 더 의미있는 형태로 바꾸어 보자. 그러면 요인에 입력된 숫자가 각각 어떤 범주에 대응하는지를 쉽게 파악할 수 있다. &gt; levels(fResults) [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &gt; levels(fResults) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;None&quot;) &gt; fResults [1] A C B None C B A C B B None B Levels: A B C None 이제 fResults 요인을 출력해 보면 각 데이터가 수준에 정의된 문자로 표현됨을 볼 수 있다. 그러면 fResults는 문자 데이터로 변환된 것일까? 그렇지 않다. 요인은 내부적으로 데이터를 각각의 범주를 1부터 시작하는 자연수로 관리한다. 이 예에서는 4가지 서로 다른 범주(수준)이 있으므로 1부터 4까지의 자연수로 데이터를 표현한다. 단지 입출력될 때 요인에 부여된 수준으로 처리를 할 뿐이다. 이를 확인하기 위해서 typeof() 함수로 요인의 근원적 타입을 확인하고, unclass() 함수를 이용하여 요인이 내부적으로 어떤 정보를 가지고 있는지 확인해 보자. &gt; typeof(fResults) [1] &quot;integer&quot; &gt; class(fResults) [1] &quot;factor&quot; &gt; unclass(fResults) [1] 1 3 2 4 3 2 1 3 2 2 4 2 attr(,&quot;levels&quot;) [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;None&quot; 요인이 내부적으로 숫자로 데이터를 표현하고 있다고 하더라도, 수준에 정의되지 않은 숫자로 데이터를 입력할 수는 없다. 요인은 항상 수준에 정의되어 있는 데이터 값만으로 입력되거나 출력될 수 있다. &gt; levels(fResults) [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;None&quot; &gt; fResults[11] &lt;- 4 Warning in `[&lt;-.factor`(`*tmp*`, 11, value = 4): invalid factor level, NA generated &gt; fResults[12] &lt;- &quot;None&quot; &gt; fResults [1] A C B None C B A C B B &lt;NA&gt; None Levels: A B C None 6.1.2 순서형 변수와 요인 범주형 데이터는 앞의 예처럼 범주 간에 순서가 없는 명목형 데이터도 있지만, 범주 간에 순서가 있는 순서형 데이터도 있다. 전국 유권자 대상으로 현 정권에 대한 만족도에 대해 다음 설문조사를 하였다고 하자. 현 정권의 국정 수행에 대해 만족하고 계십니까? ( ) 매우 불만 불만 보통 만족 매우 만족 설문 결과를 다음과 같이 요인을 가지고 결과를 코딩할 수 있을 것이다. 그러나 요인은 디폴트로 수준 간에 순서가 없는 명목형 변수로 데이터를 처리한다. 그러므로 순서를 비교하는 비교 연산을 적용할 수 없다. &gt; satisfaction &lt;- c(&quot;매우 불만&quot;, &quot;매우 만족&quot;, &quot;불만&quot;, &quot;만족&quot;, &quot;보통&quot;, + &quot;불만&quot;, &quot;매우 불만&quot;, &quot;보통&quot;, &quot;매우 만족&quot;, &quot;불만&quot;) &gt; fSatisfaction &lt;- factor(satisfaction, + levels=c(&quot;매우 불만&quot;, &quot;불만&quot;, &quot;보통&quot;, &quot;만족&quot;, &quot;매우 만족&quot;)) &gt; fSatisfaction [1] 매우 불만 매우 만족 불만 만족 보통 불만 매우 불만 [8] 보통 매우 만족 불만 Levels: 매우 불만 불만 보통 만족 매우 만족 &gt; fSatisfaction &gt;= &quot;만족&quot; Warning in Ops.factor(fSatisfaction, &quot;만족&quot;): &#39;&gt;=&#39; not meaningful for factors [1] NA NA NA NA NA NA NA NA NA NA ordered 인수로 순서형 변수 만들기 명목형 데이터를 나타내는 요인의 숫자는 각 범주를 표현하는 의미를 가지므로 앞의 맨 마지막 예처럼 순서를 비교하는 연산을 수행할 수 없다. 그런데 이 경우에는 범주 간에 순서적 의미가 있으므로 factor() 함수의 ordered 인수를 설정하여 범주 간의 순서 관계를 명확히 할 수 있다. 다음 예에서 볼 수 있듯이 범주 간의 순서가 수준이 출력될 때 명시됨을 볼 수 있고, 순서 비교가 가능함을 볼 수 있다. 심지어는 order() 함수로 순서를 파악할 수 있다. &gt; oSatisfaction &lt;- factor(satisfaction, ordered = TRUE, + levels=c(&quot;매우 불만&quot;, &quot;불만&quot;, &quot;보통&quot;, &quot;만족&quot;, &quot;매우 만족&quot;)) &gt; oSatisfaction [1] 매우 불만 매우 만족 불만 만족 보통 불만 매우 불만 [8] 보통 매우 만족 불만 Levels: 매우 불만 &lt; 불만 &lt; 보통 &lt; 만족 &lt; 매우 만족 &gt; oSatisfaction &gt;= &quot;만족&quot; [1] FALSE TRUE FALSE TRUE FALSE FALSE FALSE FALSE TRUE FALSE &gt; sum(oSatisfaction &gt;= &quot;만족&quot;) [1] 3 &gt; mean(oSatisfaction &gt;= &quot;만족&quot;) [1] 0.3 &gt; order(oSatisfaction) [1] 1 7 3 6 10 5 8 4 2 9 R은 범주형 변수인 ’불만’과 ’만족’의 순서를 알 수 없다. ordered() 함수로 순서형 범주를 만들 때 levels에 나열된 순서로 크기가 주어진다고 가정한다. 만약 위의 예에서 levels의 순서가 다르면 다른 결과가 나올 것이다. &gt; oSatisfaction &lt;- factor(satisfaction, ordered = TRUE, + levels=c(&quot;매우 만족&quot;, &quot;만족&quot;, &quot;보통&quot;, &quot;불만&quot;, &quot;매우 불만&quot;)) &gt; oSatisfaction [1] 매우 불만 매우 만족 불만 만족 보통 불만 매우 불만 [8] 보통 매우 만족 불만 Levels: 매우 만족 &lt; 만족 &lt; 보통 &lt; 불만 &lt; 매우 불만 &gt; oSatisfaction &gt;= &quot;만족&quot; [1] TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE FALSE TRUE &gt; sum(oSatisfaction &gt;= &quot;만족&quot;) [1] 8 &gt; mean(oSatisfaction &gt;= &quot;만족&quot;) [1] 0.8 &gt; order(oSatisfaction) [1] 2 9 4 5 8 3 6 10 1 7 수준의 순서 순서형이 아닌 명목형 범주 데이터는 factor()로 만들어지고 이 때도 levels에 주어진 순서로, 범주(수준)가 내부적으로 저장되는 숫자가 결정된다. levels에 언급된 수준의 순서대로 1번부터 차례로 숫자가 부여된다. 순서형 범주 데이터처럼 순서가 데이터 분석에 핵심적인 역할을 하지는 않지만, 그래프나 표가 표현될 때 이 범주(수준)의 순서대로 출력되므로, 범주를 원하는 순서대로 출력하고자 하면 levels 인수에 수준의 순서를 명시하는 것이 좋다. 그렇지 않으면 단어의 사전적 순서 등에 의해 순서가 부여된다. &gt; a &lt;- c(&quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;) &gt; fa1 &lt;- factor(a) &gt; fa1 [1] F M F M F Levels: F M &gt; unclass(fa1) [1] 1 2 1 2 1 attr(,&quot;levels&quot;) [1] &quot;F&quot; &quot;M&quot; &gt; table(fa1) fa1 F M 3 2 &gt; fa2 &lt;- factor(a, levels=c(&quot;M&quot;, &quot;F&quot;)) &gt; fa2 [1] F M F M F Levels: M F &gt; unclass(fa2) [1] 2 1 2 1 2 attr(,&quot;levels&quot;) [1] &quot;M&quot; &quot;F&quot; &gt; table(fa2) fa2 M F 2 3 labels 인수 요인을 만든 후 기존의 수준을 변경하고 싶으면 levels() 함수를 이용하여 새로운 수준을 할당한다고 설명하였다. 그러나 요인을 만들 때 기존에 코딩된 수준을 바로 변경하고 싶을 수가 있다. 이 경우에는 factor() 함수에 labels 인수를 이용하면 기존의 수준이 labels 인수에 주어진 형태로 변경된다. 이 때 주의할 점은 levels 인수는 원래 데이터가 코딩된 형태로 정의되어야 하고, labels 인수는 바꿀 코딩 형태로 정의되어야 한다. &gt; fa3 &lt;- factor(a, levels=c(&quot;M&quot;, &quot;F&quot;), labels=c(&quot;Male&quot;, &quot;Female&quot;)) &gt; fa3 [1] Female Male Female Male Female Levels: Male Female &gt; unclass(fa3) [1] 2 1 2 1 2 attr(,&quot;levels&quot;) [1] &quot;Male&quot; &quot;Female&quot; &gt; table(fa3) fa3 Male Female 2 3 &gt; fa3[6] &lt;- &quot;M&quot; Warning in `[&lt;-.factor`(`*tmp*`, 6, value = &quot;M&quot;): invalid factor level, NA generated &gt; fa3[6] &lt;- &quot;Male&quot; 6.2 데이터 프레임 만들기 data.frame() data.frame() 함수를 이용하면 벡터, 행렬, 요인, 심지어 다른 데이터 프레임을 묶어서 새로운 데이터 프레임을 만들 수 있다. 이 때 다음과 같은 제한 조건이 있다. 첫째, 벡터는 모두 같은 길이를 가져야 하며 행렬과 데이터 프레임은 모두 같은 행 수를 가져야 한다. 벡터의 같은 위치의 데이터와 행렬 및 데이터 프레임의 같은 행에 있는 데이터가 연결되어 하나의 데이터 단위가 된다. 둘째, 벡터는 하나의 벡터가 데이터 프레임의 하나의 열이 되지만, 행렬, 데이터 프레임은 각 열이 데이터 프레임의 하나의 열이 된다. 이러한 사실을 염두하면서 표 6.1의 데이터를 데이터 프레임으로 만들어 본다. 먼저 학생이름, 학년, 성별로만 이루어진 데이터 프레임을 만들어 보자. &gt; name &lt;- c(&quot;김철수&quot;, &quot;김영희&quot;, &quot;이철수&quot;, &quot;이영희&quot;, &quot;홍길동&quot;) &gt; grade &lt;- c(1, 4, 3, 2, 1) &gt; gender &lt;- c(&quot; M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;) &gt; student &lt;- data.frame(name, grade, gender) &gt; student name grade gender 1 김철수 1 M 2 김영희 4 F 3 이철수 3 M 4 이영희 2 F 5 홍길동 1 M 위의 예에서는 길이가 같은 벡터와 요인을 인수로 해서 데이터 프레임을 만들었다. 데이터 프레임을 출력해 보면 자동으로 행 번호가 부여되어 있음을 볼 수 있다. 열의 이름으로 각각 벡터와 요인을 저장한 변수명이 부여되었음을 볼 수 있다. 이번에는 만들어진 데이터 프레임에 중간, 기말 고사 점수와 재수강 여부를 포함시켜 새로운 데이터 프레임을 만들어 보자. 아래 예에서는 중간, 기말 고사 점수를 행렬로 먼저 만든 후 데이터 프레임에 포함시켜 보았다. &gt; midterm = c(74, 82, 67, 89, 92) &gt; final = c(91, 77, 88, 78, 86) &gt; scores = cbind(midterm, final) &gt; scores midterm final [1,] 74 91 [2,] 82 77 [3,] 67 88 [4,] 89 78 [5,] 92 86 &gt; rt &lt;- c(TRUE, FALSE, FALSE, TRUE, FALSE) &gt; students &lt;- data.frame(student, scores, retake = rt) &gt; students name grade gender midterm final retake 1 김철수 1 M 74 91 TRUE 2 김영희 4 F 82 77 FALSE 3 이철수 3 M 67 88 FALSE 4 이영희 2 F 89 78 TRUE 5 홍길동 1 M 92 86 FALSE 위에서 새로운 데이터 프레임의 각 열의 이름은 기존 데이터 프레임의 각 열의 이름, 행렬의 열 이름이 자동으로 부여되고 있음을 볼 수 있다. 재수강 여부 데이터벡터 rt는 data.frame()이 호출될 때, retake = rt 형태로 인수를 전달하여 새로운 데이터 프레임에서는 이름이 retake로 변경되었다. 데이터 프레임을 생성할 때 각 열에 이름을 부여하고 싶으면 이와 같은 방식으로 이름을 부여하면 된다. cbind() 앞서 설명하였듯이 데이터 프레임은 행렬적인 외양을 가지고 있으므로 행렬처럼 cbind()나 rbind()를 이용하여 행과 열을 추가할 수 있다. 다음 예는 cbind를 이용하여 중간과 기말의 총점 열을 추가한 예이다. &gt; total.scores &lt;- midterm + final &gt; cbind(students, total.scores) name grade gender midterm final retake total.scores 1 김철수 1 M 74 91 TRUE 165 2 김영희 4 F 82 77 FALSE 159 3 이철수 3 M 67 88 FALSE 155 4 이영희 2 F 89 78 TRUE 167 5 홍길동 1 M 92 86 FALSE 178 rbind() 다음 예는 rbind()로 새로운 데이터 행을 추가한 예이다. 이 때 주의할 점은 추가할 데이터의 각 항목의 이름과 형식이 일치해야 한다는 것이다. &gt; a &lt;- data.frame(name=&quot;Jane Eyre&quot;, grade=4, gender=&quot;F&quot;, + midterm=90, final=85, retake=F) &gt; a name grade gender midterm final retake 1 Jane Eyre 4 F 90 85 FALSE &gt; rbind(students, a) name grade gender midterm final retake 1 김철수 1 M 74 91 TRUE 2 김영희 4 F 82 77 FALSE 3 이철수 3 M 67 88 FALSE 4 이영희 2 F 89 78 TRUE 5 홍길동 1 M 92 86 FALSE 6 Jane Eyre 4 F 90 85 FALSE 6.3 데이터 프레임 각 열의 지정 데이터 프레임은 리스트 타입 생성된 데이터 프레임에 대해 typeof() 함수와 attributes() 함수를 이용하여 타입과 속성을 알아보자. 다음 결과에서 데이터 프레임은 리스트 타입이며, names 속성에 데이터 프레임의 각 열의 이름이 나열되어 있음을 볼 수 있다. &gt; typeof(students) [1] &quot;list&quot; &gt; attributes(students) $names [1] &quot;name&quot; &quot;grade&quot; &quot;gender&quot; &quot;midterm&quot; &quot;final&quot; &quot;retake&quot; $class [1] &quot;data.frame&quot; $row.names [1] 1 2 3 4 5 리스트 형식으로 데이터 프레임의 열 지정 데이터 프레임은 본질적으로 리스트 타입이므로 데이터 프레임의 각 열은 리스트의 요소가 된다. 따라서 데이터 프레임의 각 열을 지정할 때는 리스트의 각 요소를 지정할 때와 마찬가지로, $ 기호 또는 [[ ]]를 이용하여 다음과 같은 형태로 지정하면 된다. 이는 데이터 프레임이 리스트 타입이기 때문에 리스트와 같은 방식으로 요소들에 접근할 수 있기 때문이다. 리스트에 대한 자세한 설명은 5 장을 확인하기 바란다. &gt; data_frame_name$column_name &gt; data_frame_name[[column_number]] &gt; data_frame_name[[column_name]] 다음은 위에서 생성한 students의 각 열을 이름으로 지정하여, 학생의 성별 데이터, 중간, 기말고사를 출력한 예이다. &gt; students$gender [1] &quot; M&quot; &quot;F&quot; &quot;M&quot; &quot;F&quot; &quot;M&quot; &gt; students[[&quot;midterm&quot;]] [1] 74 82 67 89 92 &gt; students[[5]] [1] 91 77 88 78 86 &gt; students$name [1] &quot;김철수&quot; &quot;김영희&quot; &quot;이철수&quot; &quot;이영희&quot; &quot;홍길동&quot; &gt; typeof(students$name) [1] &quot;character&quot; 데이터 프레임의 각 열은 벡터 데이터 프레임의 각 열은 벡터이므로 데이터 프레임의 특정 열을 리스트 필터링과 같은 방식으로 지정한 후, 벡터 연산이나 벡터 인덱스를 이용하여 각 요소의 값을 출력하거나 변경할 수 있다. &gt; students$midterm * 2 [1] 148 164 134 178 184 &gt; sum(students$midterm) [1] 404 &gt; students$midterm[5] [1] 92 &gt; students$midterm[5] &lt;- 50 &gt; students[[4]][3:5] [1] 67 89 50 또한 리스트에 새로운 요소를 추가할 때와 마찬가지 방법으로 열을 추가할 수도 있다. 다음 예는 hw이라는 이름으로 숙제 점수 열을 추가하는 예이다. &gt; students$hw &lt;- c(8, 9, 7, 8, 10) &gt; students name grade gender midterm final retake hw 1 김철수 1 M 74 91 TRUE 8 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M 67 88 FALSE 7 4 이영희 2 F 89 78 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 6.4 데이터 프레임의 필터링 데이터를 분석하다 보면 작업 중인 데이터 프레임의 일부만을 선택하여 작업을 할필요가 있다. 어떤 경우에는 데이터의 일부분만 변경할 필요가 있다. 필요 없는 열을 제거하거나 새로운 열을 추가하기 위해서는 여러 열을 한번에 지정할 수도 있어야 한다. 이러한 작업을 수행하기 위해서는 데이터 프레임의 일부분을 지정하는 필터링을 수행하여야 한다. 데이터 프레임은 리스트를 기본적인 속성으로 하기 때문에 리스트로서 부분을 필터링하는 방법이 있고, 행렬적 외양을 가지고 있기 때문에 행렬처럼 필터링을 하는 방법이 있다. 6.4.1 리스트 형식으로 필터링 데이터 프레임은 리스트 구조를 가지고 있으며, 데이터 프레임의 열은 리스트의 각 요소가 된다. 따라서 5 장에서 이용한 리스트의 부분 필터링을 수행하는 방법으로 데이터 프레임의 일부 열만 필터링을 수행할 수 있다. 리스트로서 필터링은 1차원 인덱스 구조를 갖는다. 리스트로서 데이터 프레임을 필터링하는 방법은 아래와 같이 인덱스 벡터를 이용하는 것이다. 여기서 인덱스 벡터는 벡터나 리스트의 인덱스 벡터와 마찬가지로 숫자, 이름, 논리값 벡터가 될 수 있다. &gt; data_frame_name[index_vector] 다음 예는 students 데이터 프레임에서 열의 인덱스를 숫자, 이름, 논리값으로 각각 지정하여 새로운 데이터 프레임을 만든 경우이다. &gt; students.new &lt;- students[1:2] &gt; students.new name grade 1 김철수 1 2 김영희 4 3 이철수 3 4 이영희 2 5 홍길동 1 &gt; students.new &lt;- students[-(1:2)] &gt; students.new gender midterm final retake hw 1 M 74 91 TRUE 8 2 F 82 77 FALSE 9 3 M 67 88 FALSE 7 4 F 89 78 TRUE 8 5 M 50 86 FALSE 10 &gt; student.new &lt;- students[c(&quot;gender&quot;, &quot;grade&quot;)] &gt; student.new gender grade 1 M 1 2 F 4 3 M 3 4 F 2 5 M 1 &gt; student.new &lt;- students[c(T, F, F, T, T, F)] &gt; student.new name midterm final hw 1 김철수 74 91 8 2 김영희 82 77 9 3 이철수 67 88 7 4 이영희 89 78 8 5 홍길동 50 86 10 data.frame() 함수를 이용하면 기존의 데이터 프레임에 새로운 열을 추가하여 새로운 데이터 프레임도 만들 수 있다. 다음 예는 기존의 students 데이터 프레임에 키 데이터를 추가한 경우이다. &gt; height &lt;- c(172, 167, 181, 162, 178) &gt; students.new &lt;- data.frame(students[2:3], height=height) &gt; students.new grade gender height 1 1 M 172 2 4 F 167 3 3 M 181 4 2 F 162 5 1 M 178 열 지정하기 vs. 한 열만 데이터 프레임으로 필터링 앞서 설명하였듯이 데이터 프레임은 리스트이므로 데이터 프레임의 한 열만을 지정할 때 []뿐 아니라 [[]]나 와 $를 이용해 한 열을 지정할 수 있다. 두 방식의 차이는 전자가 데이터 프레임에서 지정된 열만으로 이루어진 새로운 데이터 프레임을 반환하는 반면, 후자는 데이터 프레임에 있는 열 자체, 즉 벡터를 반환한다. 아래는 students 데이터 프레임에서 []와 [[]]를 이용하여 두번째 열을 지정한 결과이다. &gt; a &lt;- students[2] &gt; a grade 1 1 2 4 3 3 4 2 5 1 &gt; typeof(a) [1] &quot;list&quot; &gt; attributes(a) $names [1] &quot;grade&quot; $row.names [1] 1 2 3 4 5 $class [1] &quot;data.frame&quot; &gt; a &lt;- students[[2]] &gt; a [1] 1 4 3 2 1 &gt; typeof(a) [1] &quot;double&quot; &gt; attributes(a) NULL 지금까지 설명한 내용은 데이터 프레임이 리스트 타입이기 때문에 성립하는 내용이다. 따라서 지금까지 설명한 내용은 리스트에도 모두 적용된다. 6.4.2 행렬 형식으로 필터링 행렬로서 필터링은 2차원 인덱스 구조를 갖는다. 데이터 프레임은 열의 길이가 모두 같기 때문에, 보통의 리스트에는 없는 행렬과 같은 필터링 방법이 존재한다. 특히 기존의 데이터 프레임에 행을 삭제 또는 추가할 필요가 있는 경우 이러한 행렬 방식의 필터링 방법은 매우 유용한다. 데이터 프레임의 인덱스 벡터의 사용은 다음과 같이 행렬의 방식과 동일하게 행과 열을 독립적으로 지정하는 2차원 인덱스 구조를 가진다. &gt; data_frame_name[row_index_vector, column_index_vector] 다음은 students 데이터 프레임에서 행렬 인덱스 벡터를 이용하여 데이터의 일부를 지정한 예이다. &gt; students[1,] name grade gender midterm final retake hw 1 김철수 1 M 74 91 TRUE 8 &gt; students[2:3,] name grade gender midterm final retake hw 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M 67 88 FALSE 7 &gt; students[-(2:3),] name grade gender midterm final retake hw 1 김철수 1 M 74 91 TRUE 8 4 이영희 2 F 89 78 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 &gt; students[,4] [1] 74 82 67 89 50 &gt; students[,-4] name grade gender final retake hw 1 김철수 1 M 91 TRUE 8 2 김영희 4 F 77 FALSE 9 3 이철수 3 M 88 FALSE 7 4 이영희 2 F 78 TRUE 8 5 홍길동 1 M 86 FALSE 10 &gt; students[, c(2, 4)] grade midterm 1 1 74 2 4 82 3 3 67 4 2 89 5 1 50 &gt; students[2:4, 3:5] gender midterm final 2 F 82 77 3 M 67 88 4 F 89 78 &gt; students$midterm &gt;= 80 [1] FALSE TRUE FALSE TRUE FALSE &gt; students[students$midterm &gt;= 80, ] name grade gender midterm final retake hw 2 김영희 4 F 82 77 FALSE 9 4 이영희 2 F 89 78 TRUE 8 &gt; students[students$midterm &gt;= 80, c(&quot;name&quot;, &quot;grade&quot;, &quot;gender&quot;)] name grade gender 2 김영희 4 F 4 이영희 2 F &gt; students[students$grade != 1, c(&quot;name&quot;, &quot;grade&quot;, &quot;gender&quot;)] name grade gender 2 김영희 4 F 3 이철수 3 M 4 이영희 2 F 행렬 필터링 방법을 이용한 데이터 프레임 정렬 행렬과 마찬가지로 데이터 프레임을 특정 열을 기준으로 정렬할 수 있다. 다음은 학년을 기준으로 데이터 프레임을 정렬한 예와, 기말고사 점수가 높은 학생부터 낮은 학생 순으로 정렬한 예이다. &gt; order(students$grade) [1] 1 5 4 3 2 &gt; students[order(students$grade), ] name grade gender midterm final retake hw 1 김철수 1 M 74 91 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 4 이영희 2 F 89 78 TRUE 8 3 이철수 3 M 67 88 FALSE 7 2 김영희 4 F 82 77 FALSE 9 &gt; order(students$final, decreasing = TRUE) [1] 1 3 5 4 2 &gt; students[order(students$final, decreasing = TRUE), ] name grade gender midterm final retake hw 1 김철수 1 M 74 91 TRUE 8 3 이철수 3 M 67 88 FALSE 7 5 홍길동 1 M 50 86 FALSE 10 4 이영희 2 F 89 78 TRUE 8 2 김영희 4 F 82 77 FALSE 9 만약 학생을 학년으로 정렬을 한 후, 동일 학년이면 기말고사가 높은 사람이 먼저 나오게 정렬하고자 하면 어떻게 할까? 사실 order() 함수는 길이가 같은 여러 개의 벡터를 차례대로 비교하여 순위를 결정할 수 있다. order()의 인수 중 맨처음 나열된 벡터를 기준으로 순서를 결정하지만, 동률이 있으면 두번째로 나열된 벡터를 기준으로 동률 간의 순서를 결정한다. 두번째 벡터에서도 동률이면 다음에 나열된 벡터를 기준으로 이용한다. 예를 들어 학생을 학년 순서로 정렬하는데, 학년이 동률인 경우 기말고사 점수로 순서를 정한다고 하자. 그러면 다음과 같이 order() 함수를 기술하면 된다. &gt; order(students$grade, students$final) [1] 5 1 4 3 2 &gt; students[order(students$grade, students$final), ] name grade gender midterm final retake hw 5 홍길동 1 M 50 86 FALSE 10 1 김철수 1 M 74 91 TRUE 8 4 이영희 2 F 89 78 TRUE 8 3 이철수 3 M 67 88 FALSE 7 2 김영희 4 F 82 77 FALSE 9 그런데 우리는 학년은 낮은 학년부터 높은 학년으로 정렬하지만 기말고사는 높은 점수에서 낮은 점수로 정렬하고자 한다. order() 함수의 decreasing 인수를 TRUE로 하면 학년마저 높은 순에서 낮은 순으로 되니 원하는 결과를 얻을 수 없다. 이런 경우에는 첫번째 벡터는 그대로 두고, 두번째 벡터에 -1을 곱한 후 순서를 정렬하면 원하는 결과를 얻을 수 있다. &gt; students[order(students$grade, students$final, decreasing=T), ] name grade gender midterm final retake hw 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M 67 88 FALSE 7 4 이영희 2 F 89 78 TRUE 8 1 김철수 1 M 74 91 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 &gt; students[order(students$grade, -students$final), ] name grade gender midterm final retake hw 1 김철수 1 M 74 91 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 4 이영희 2 F 89 78 TRUE 8 3 이철수 3 M 67 88 FALSE 7 2 김영희 4 F 82 77 FALSE 9 6.4.3 subset()을 이용한 필터링 subset()4 함수는 벡터, 행렬, 데이터 프레임에서 조건에 맞는 부분을 반환하는 함수이다. 지금까지 우리는 벡터, 행렬, 데이터 프레임을 필터링할 때, 인덱스 벡터를 이용하여 이를 수행하였다. 사실 데이터 처리에 필요한 거의 모든 작업은 subset()을 이용할 필요가 없이, 지금까지 설명한 인덱스 벡터를 이용하여 필터링을 수행하면 된다. 그러나 subset() 함수를 이용하면 지금까지의 필터링 방법을 좀 더 쉽게 할 수 있는 경우가 있다. subset() 함수는 다음과 같은 형식을 가진다. subset() &gt; subset(x, subset, select, drop=FALSE, ...) subset() 함수로 필터링하는 방법과 인덱스 벡터를 이용하는 필터링과의 차이점은 다음 3가지이다. 조건에 부합하는 행을 필터링 할 때, subset() 함수는 subset 인수에 조건을 기술한다. 인덱스 벡터는 자연수, 음의 정수, 논리값, 문자열이 모두 가능하지만, subset에서는 논리값만 가능하다. subset에서는 열을 변수처럼 기술할 수 있기 때문에 행 필터링 조건을 인덱스 벡터를 이용하는 방법보다 좀 더 간편하게 기술할 수 있다. subset() 함수를 이용한 필터링에서는 subset의 조건식의 결과가 NA인 경우는 FALSE로 평가하여 NA 행을 자동으로 제거한다. 인덱스 벡터를 이용하는 경우는 조건식의 결과가 NA이어도 그 행은 제거되지 않는다. 열을 필터링할 때, 인덱스 벡터를 이용한 필터링에서는 열의 번호나 이름으로 필터링할 열을 지정한다. 열의 이름으로 필터링 할 때는 반드시 문자열로 열의 이름이 표시된다. subset()의 경우 선택할 열은 select 인수로 표현하는데, 열의 이름을 따옴표 없이 변수처럼 그대로 기술한다. 그러면 열의 이름이 열의 번호로 대체되어 최종적으로 필터링이 수행된다. 위에서 설명한 내용이 어떤 의미인지를 벡터, 행렬, 데이터 프레임의 경우에서 각각 살펴보도록 한다. subset()을 이용한 벡터 필터링 &gt; x &lt;- c(7, 9, NA, 5, 2) &gt; x[x&gt;6] [1] 7 9 NA &gt; subset(x, x&gt; 6) [1] 7 9 위의 예에서 보듯이 벡터를 필터링할 때, 인덱스 벡터를 이용하는 방법은 NA가 있는 경우 그 결과를 알 수 없으므로 필터링한 결과에도 NA로 표시한다. 그러나 subset() 함수는 NA를 자동으로 제거함을 알 수 있다. subset()을 이용한 데이터 프레임 필터링 &gt; y &lt;- 1:5 &gt; z &lt;- -1:-5 &gt; long.name &lt;- data.frame(x, y, z) &gt; long.name x y z 1 7 1 -1 2 9 2 -2 3 NA 3 -3 4 5 4 -4 5 2 5 -5 &gt; rm(x, y, z) &gt; long.name[long.name$x &gt;6, ] x y z 1 7 1 -1 2 9 2 -2 NA NA NA NA &gt; subset(long.name, x&gt;6) x y z 1 7 1 -1 2 9 2 -2 위의 예에서 보듯이 인덱스 벡터를 이용하는 경우에는 데이터 프레임의 열을 지정하기 위해서 $ 앞에 데이터 프레임 이름을 일일이 지정해야 했다. 그러나 subset()의 경우 두번째 인수에 열을 그냥 변수처럼 기술한다. 인덱스 벡터를 이용하는 방법은 NA가 있는 경우 그 결과를 알 수 없으므로 필터링한 결과에도 NA로 표시한다. 그러나 subset() 함수는 NA를 자동으로 제거한다. &gt; long.name[long.name$x &gt;6, 2:3] y z 1 1 -1 2 2 -2 NA NA NA &gt; subset(long.name, x&gt;6, y:z) y z 1 1 -1 2 2 -2 &gt; long.name[long.name$x &gt;6, c(&quot;x&quot;, &quot;z&quot;)] x z 1 7 -1 2 9 -2 NA NA NA &gt; subset(long.name, x&gt;6, c(x, z)) x z 1 7 -1 2 9 -2 &gt; subset(long.name, x&gt;6, -z) x y 1 7 1 2 9 2 인덱스 벡터의 경우 열을 지정할 때 번호나 문자열 이름을 이용하였는데, subset()은 열의 이름을 변수처럼 사용하여 지정하고 있음을 알 수 있다. 앞서 설명하였듯이 변수처럼 사용된 열의 이름은 열의 위치를 나타내는 숫자로 변환되어 처리된다. 그렇기 때문에 y:z나 -z 등의 기술이 가능하다. 6.5 데이터 프레임에 함수 적용하기 리스트로서 각 열에 함수 적용하기 데이터 프레임은 리스트로서의 속성이 있기 때문에 lapply()나 sapply() 함수를 이용하여 열별로 함수를 적용할 수 있다. &gt; lapply(students[4:5], mean) $midterm [1] 72.4 $final [1] 84 &gt; sapply(students[4:5], mean) midterm final 72.4 84.0 &gt; sapply(students[4:5], summary) midterm final Min. 50.0 77 1st Qu. 67.0 78 Median 74.0 86 Mean 72.4 84 3rd Qu. 82.0 88 Max. 89.0 91 행렬 함수 적용하기 데이터 프레임은 행렬과 동일한 형식을 가지고 있기 때문에 행렬에서 사용했던 다양한 함수가 데이터 프레임에도 작동하는 경우가 많다. 다음은 행과 열의 길이를 알아내는 nrow()과 ncol() 함수, 그리고 행과 열을 전치시키는 t() 함수를 데이터 프레임에 적용한 예이다. &gt; nrow(students) [1] 5 &gt; ncol(students) [1] 7 &gt; t(students) [,1] [,2] [,3] [,4] [,5] name &quot;김철수&quot; &quot;김영희&quot; &quot;이철수&quot; &quot;이영희&quot; &quot;홍길동&quot; grade &quot;1&quot; &quot;4&quot; &quot;3&quot; &quot;2&quot; &quot;1&quot; gender &quot; M&quot; &quot;F&quot; &quot;M&quot; &quot;F&quot; &quot;M&quot; midterm &quot;74&quot; &quot;82&quot; &quot;67&quot; &quot;89&quot; &quot;50&quot; final &quot;91&quot; &quot;77&quot; &quot;88&quot; &quot;78&quot; &quot;86&quot; retake &quot;TRUE&quot; &quot;FALSE&quot; &quot;FALSE&quot; &quot;TRUE&quot; &quot;FALSE&quot; hw &quot; 8&quot; &quot; 9&quot; &quot; 7&quot; &quot; 8&quot; &quot;10&quot; 행과 열이 전치된 데이터 프레임을 살펴보면 모든 열이 문자열 벡터로 변경되었음을 볼 수 있다. 데이터 프레임의 각 열은 모두 동일한 타입이어야 한다. 전치된 열은 논리값, 숫자, 문자가 모두 포함되어 있다. 따라서 이를 모두 수용할 수 있는 문자 행렬로 변환되었음을 볼 수 있다. apply()로 행이나 열에 함수 적용하기 데이터 프레임에도 apply() 함수를 적용할 수 있다. 그러나 여기서 주의할 점은 R은 apply() 함수를 적용하기 앞서 데이터 프레임을 행렬로 변환시킨다. 따라서 앞의 t() 함수의 적용 결과처럼 요소 중에 하나라도 문자가 있으면 모든 요소를 수용할 수 있는 문자 행렬로 변환하게 된다. &gt; apply(students, 2, mean) name grade gender midterm final retake hw NA NA NA NA NA NA NA &gt; apply(students[4:5], 2, mean) midterm final 72.4 84.0 &gt; apply(students[4:5], 1, sum) [1] 165 159 155 167 136 첫번째 예에서는 students에 문자 열이 있어 모두 문자 행렬로 변환된다. 그러므로 mean이 적용될 수 없어서 경고와 함께 모두 NA의 값이 출력되었다. 그러나 중간과 기말고사 점수가 있는 부분만으로 부분 데이터 프레임을 만들어 apply()을 적용하면 모두 숫자이므로 숫자 행렬로 변환되어 결과가 잘 수행되었음을 알 수 있다. 따라서 열별로 함수를 적용할 때에는 행렬로 변환이 필요한 apply()보다는 lapply()나 sapply()를 바로 적용하는 것이 더 좋다. 긴 데이터 프레임의 앞 또는 뒷 부분 출력하기 데이터 프레임에만 적용되는 것은 아니지만 head()와 tail() 함수를 이용하면 긴 데이터 프레임의 앞 부분과 뒤 부분만을 쉽게 참조할 수 있다. &gt; nrow(iris) [1] 150 &gt; head(iris) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5.0 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa &gt; tail(iris) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 145 6.7 3.3 5.7 2.5 virginica 146 6.7 3.0 5.2 2.3 virginica 147 6.3 2.5 5.0 1.9 virginica 148 6.5 3.0 5.2 2.0 virginica 149 6.2 3.4 5.4 2.3 virginica 150 5.9 3.0 5.1 1.8 virginica iris 데이터는 R에서 제공하는 데이터인데 150 개의 관측치로 되어 있으므로 이를 화면에 다 출력하면 화면이 많이 스크롤되어서 데이터를 파악하기 힘들다. 이런 경우 head()나 tail()을 사용하여 데이터의 앞 또는 뒷 부분을 파악한다. 이 두 함수는 데이터 프레임의 앞과 뒤의 6줄을 반환한다. 다음처럼 n 인수를 사용하여 출력할 행의 수를 직접 지정할 수도 있다. &gt; head(iris, n = 3) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa &gt; tail(iris, n = 2) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 149 6.2 3.4 5.4 2.3 virginica 150 5.9 3.0 5.1 1.8 virginica 6.6 파일에서 데이터 읽어오기 규모가 큰 데이터는 R 콘솔에서 직접 입력하기보다는 파일에서 불러오는 경우가 많다. R에서는 주로 텍스트 파일이나 Excel의 데이터를 읽어오는 경우가 많다. 6.6.1 텍스트 파일에서 데이터 읽어오기 텍스트에 있는 모든 데이터를 데이터 프레임에 저장하려는 경우 read.table() 함수를 이용하면 편리하다. 파일을 불러오기 전에 주의할 점은 파일의 이름만으로 파일을 읽어오고 싶으면 현재의 작업 디렉토리(폴더)에 파일이 있어야 한다는 것이다. 그렇지 않은 경우에는 파일의 절대 경로를 모두 써 주어야만 읽어올 수 있다. 작업 디렉토리 설정 R 윈도우 버전에서 작업 디렉터리의 변경은 [파일]-[작업디렉토리변경] 메뉴를 이용하면 된다. RStudio에서는 [Session]-[Set Working Directory]-[Choose Directory] 메뉴를 이용하면 된다. 현재의 작업 디렉터리가 어디인지를 알기 위해서는 getwd() 명령을 이용하면 된다. 현재 작업 디렉터리의 파일을 보고 싶으면 list.files() 명령을 이용한다. R 명령으로 작업 디렉터리를 변경하려면 setwd()를 이용한다. 다음은 getwd()로 현재 작업 디렉토리를 얻은 후 setwd()로 data라는 하위 디렉토리(폴더)로 작업 디렉토리를 변경하고, 그 안에 있는 파일 목록을 확인한 예이다. R에서는 UNIX나 LINUX의 디렉토리 계층 체계를 따라 하위 디렉토리 계층을 나타날 때 \\가 아니라 /을 이용한다. &gt; WD &lt;- getwd() &gt; setwd(paste0(WD, &quot;/data&quot;)) &gt; list.files(pattern = &quot;.txt&quot;) [1] &quot;courses2.txt&quot; &quot;scores_no_header.txt&quot; &quot;scores_rn.txt&quot; [4] &quot;scores.txt&quot; &quot;students.txt&quot; 머리 행이 있는 텍스트 데이터 파일 읽기 다음처럼 파일에 있는 데이터가 첫 행은 각 항목의 이름이고 둘째 행부터 데이터가 있는 경우를 먼저 살펴보자. prov scores 서울 25 대전 35 천안 42 데이터 파일이 작업 디렉토리(폴더) 밑의 data 디렉토리(폴더)에 scores.txt로 저장되어 있다면 read.table() 함수를 이용하여 다음과 같이 header=TRUE 인수로 데이터 프레임으로 읽어올 수 있다. 읽어들일 파일이 작업 디렉토리에 있다면 \"data/scores.txt\"가 아니라 \"scores.txt\" 형태로 읽어들이면 된다. &gt; prov.scores &lt;- read.table(&quot;data/scores.txt&quot;, header=TRUE, fileEncoding=&quot;UTF-8&quot;) &gt; prov.scores prov scores 1 서울 25 2 대전 35 3 천안 42 &gt; attributes(prov.scores) $names [1] &quot;prov&quot; &quot;scores&quot; $class [1] &quot;data.frame&quot; $row.names [1] 1 2 3 위 결과에서 보면 파일에서 데이터를 읽어와 데이터 프레임을 생성했고, 첫 행에 나와 있는 항목 이름을 데이터 프레임 각 열의 이름으로 하고 있다. 행의 이름으로는 1, 2, 3의 순서로 행 번호를 자동 부여했다. 각 행의 데이터는 공백 문자를 기준으로 구분을 하였다. 앞의 명령어에서 fileEncoding 인수는 텍스트 파일이 어떤 문자 인코딩으로 저장되어 있는지를 지정한 것이다. 윈도우즈를 제외한 대부분의 시스템에서는 UTF-8 형식으로 텍스트 파일을 저장하지만, 한글 윈도우는 CP949 (EUC-KR)로 텍스트를 인코딩 한다. 여러 시스템 간의 호환성을 위하여 이 책에서는 텍스트 데이터를 UTF-8으로 저장하고 읽어들이기로 한다. read.table() 함수 등은 시스템의 디폴트 인코딩을 사용하여 데이터를 읽어 온다. 한글 윈도우즈의 디폴트 인코딩은 CP949이므로 UTF-8으로 텍스트 데이터를 처리하기 위하여 fileEncoding 인수를 지정하였다. 행 이름이 있는 텍스트 데이터 파일 읽기 다음 예는 파일에 데이터의 행 번호 또는 이름이 부여되어 있는 경우이다. 이 같은 경우에는 첫 행에 행 번호를 나타내는 이름은 표시하지 않는다. 따라서 첫 행과 다른 행은 한 항목의 수에서 차이가 난다. prov scores 10 서울 25 20 대전 35 30 천안 42 이와 같은 형식의 파일이 작업 디렉토리 밑의 data 디렉토리의 scores_rn.txt에 저장되어 있는 경우에도 같은 방식으로 데이터를 데이터 프레임으로 읽어온다. 다음에서 볼 수 있듯이 행 번호로 파일의 첫 번째 열의 값이 사용되었다. 그리고 read.table() 함수에서 header 인수를 사용하지 않았다. 항목이 하나 적은 것으로 첫 번째 행이 머리행인 것을 자동 인식하기 때문이다. &gt; prov.scores &lt;- read.table(&quot;data/scores_rn.txt&quot;, fileEncoding=&quot;UTF-8&quot;) &gt; prov.scores prov scores 10 서울 25 20 대전 35 30 천안 42 머리 행이 없는 텍스트 데이터 파일 읽기 위의 결과에서 파일에 있는 행 번호가 데이터 프레임에 이용되었음을 볼 수 있다. read.table() 함수는 머리 행이 없는 텍스트 파일에서도 데이터를 읽어들일 수 있다. 다음과 같은 scores_no_header.txt 파일이 작업 디렉토리 밑의 data 디렉토리에 저장되어 있다고 하자. 서울 25 대전 35 천안 42 다음 명령문은 scores_no_header.txt 데이터 파일을 데이터 프레임으로 읽어들인 예이다. 열의 이름이 임의로 붙여졌음을 볼 수 있다. &gt; prov.scores &lt;- read.table(&quot;data/scores_no_header.txt&quot;, header=FALSE, fileEncoding=&quot;UTF-8&quot;) &gt; prov.scores V1 V2 1 서울 25 2 대전 35 3 천안 42 edit() 데이터 프레임에서 데이터를 편집하고 싶으면 edit() 함수를 이용한다. 다음 명령을 수행하면 데이터 프레임이 스프레드시트 형태로 나타나 수정이 가능하다. 편집창에서 수정 후 편집창을 닫으면 변경한 내용이 반영되어 새로운 데이터 프레임 prov.scores.new가 생성된다. &gt; prov.scores.new &lt;- edit(prov.scores) 6.6.2 Excel 파일에서 데이터 읽어오기 CSV 파일 많은 경우 데이터가 Excel로 저장되어 있다. Excel에서 데이터를 읽어오기 위해서는 먼저 Excel 파일을 CSV 형태의 파일로 작업 디렉토리에 저장하여야 한다.5 CSV 파일은 데이터의 각 필드가 쉼표로 분리되어 있는 파일이다. 대부분의 통계 패키지뿐 아니라 다수의 SW에서 지원하는 파일 형식이다. Excel의 버전에 따라 저장방식이 조금 차이가 있을 수 있으나, 대부분 ’다른 이름으로 저장’에서 파일 형식을 CSV 형식으로 지정해 주면 된다. read.csv() R에서 CSV 파일을 읽어오는 함수는 read.csv()이다. 다음은 각 국의 자살률에 대한 성별, 조사년도 데이터를 읽어온 예이다. 총 105개의 데이터인데 처음 몇 개의 데이터만 출력하여 보이고 있다. &gt; sr &lt;- read.csv(file=&quot;data/suicide_rates.csv&quot;, fileEncoding=&quot;UTF-8&quot;) &gt; nrow(sr) [1] 105 &gt; head(sr) Country Year Males Females 1 ALBANIA 3 4.7 3.3 2 ANTIGUA AND BARBUDA 95 0.0 0.0 3 ARGENTINA 8 12.6 3.0 4 ARMENIA 8 2.8 1.1 5 AUSTRALIA 6 12.8 3.6 6 AUSTRIA 9 23.8 7.1 사실 read.csv() 함수는 read.table()의 wrapper 함수로서 header=TRUE, sep=‘,’ 인수로 read.table() 함수를 호출하기만 한다. 따라서 다음처럼 read.table() 함수를 이용해서도 CSV 파일을 읽어들일 수 있다. 이 때 주의할 점은 함수 호출 시 header=TRUE, sep=‘,’ 인수를 지정해야 한다는 것이다. &gt; sr2 &lt;- read.table(file=&quot;data/suicide_rates.csv&quot;, header=TRUE, sep=&quot;,&quot;, fileEncoding=&quot;UTF-8&quot;) &gt; nrow(sr2) [1] 105 &gt; head(sr2) Country Year Males Females 1 ALBANIA 3 4.7 3.3 2 ANTIGUA AND BARBUDA 95 0.0 0.0 3 ARGENTINA 8 12.6 3.0 4 ARMENIA 8 2.8 1.1 5 AUSTRALIA 6 12.8 3.6 6 AUSTRIA 9 23.8 7.1 read.csv()와 관련된 흔한 실수 read.csv() 함수를 이용할 때 초보자가 가장 자주 하는 실수가 일반 텍스트 파일인데 read.csv() 함수로 데이터를 읽어들이는 것이다. 다음은 공백으로 필드가 구분된 scores.txt 파일을 read.table()과 read.csv() 함수로 각각 읽어들인 결과이다. &gt; prov.scores &lt;- read.table(&quot;data/scores.txt&quot;, header=TRUE, fileEncoding=&quot;UTF-8&quot;) &gt; prov.scores prov scores 1 서울 25 2 대전 35 3 천안 42 &gt; prov.scores.csv &lt;- read.csv(&quot;data/scores.txt&quot;, fileEncoding=&quot;UTF-8&quot;) &gt; prov.scores.csv prov..scores 1 서울 25 2 대전 35 3 천안 42 출력해 보면 두 결과가 유사해 보인다. 그러나 읽어들여진 데이터로 작업을 해보면 read.csv() 파일로 읽어들인 데이터로는 제대로 된 작업이 수행되지 않음을 알 수 있다. 먼저 두 데이터에서 scores 열에 대한 평균을 내 보자. &gt; mean(prov.scores$scores) [1] 34 &gt; mean(prov.scores.csv$scores) Warning in mean.default(prov.scores.csv$scores): argument is not numeric or logical: returning NA [1] NA 결과에서 보듯이 read.table()로 읽어들인 데이터 프레임에서는 원하는 결과를 얻을 수 있지만 read.csv()로 읽어들인 데이터 프레임에서는 그렇지 않았다. 그 이유는 read.csv()는 데이터 열이 쉼표로 분리된 것으로 가정하므로 한 줄의 데이터를 읽어들인 후 쉼표를 발견할 수 없어서 모두 하나의 열로 처리를 했기 때문이다. 하나가 된 데이터에는 문자와 숫자가 모두 포함되어 있으므로 이를 모두 처리할 수 있는 문자 벡터로 데이터를 저장하게 된다. 따라서 숫자 데이터 처리 함수인 mean()을 적용할 때 오류가 난 것이다. 이는 두 데이터 프레임의 열의 개수와 이름 등을 확인해 보면 쉽게 확인할 수 있다. &gt; ncol(prov.scores) [1] 2 &gt; names(prov.scores) [1] &quot;prov&quot; &quot;scores&quot; &gt; ncol(prov.scores.csv) [1] 1 &gt; names(prov.scores.csv) [1] &quot;prov..scores&quot; 6.7 파일에 데이터 프레임 쓰기 write.table()과 write.csv() 데이터 프레임의 작업 결과를 추후에 다시 이용하기 위해서, 또는 다른 통계 패키지에서 작업 결과를 이용하기 위해서는 데이터 프레임을 파일로 저장할 수 있어야 한다. 이 경우 write.table()과 write.csv() 함수를 이용하면 데이터 프레임을 파일에 저장할 수 있다. 다음 예에서는 이 장에서 만든 students 데이터 프레임을 세 가지 형식으로 작업 디렉토리 밑의 data 디렉토리의 파일에 저장하고 있다. &gt; write.table(students, &quot;data/students.txt&quot;, row.names=FALSE, fileEncoding=&quot;UTF-8&quot;) &gt; write.csv(students, &quot;data/students.csv&quot;, row.names=FALSE, fileEncoding=&quot;UTF-8&quot;) &gt; write.csv(students, &quot;data/students_rn.csv&quot;, row.names=TRUE, fileEncoding=&quot;UTF-8&quot;) 첫 번째 write.table()은 공백문자로 데이터 표레임의 열을 분리하여 일반 텍스트 파일로 저장한 예이다. 다음은 저장된 students.txt 파일의 모습이다. 결과에서 볼 수 있듯이 데이터 프레임의 열 이름이 머리 행으로 저장되고 데이터들이 공백문자로 구분되어 저장되었다. 숫자 데이터는 그대로, 문자 데이터는 따옴표로 둘러싸여서 저장되어 있다. &quot;name&quot; &quot;grade&quot; &quot;gender&quot; &quot;midterm&quot; &quot;final&quot; &quot;retake&quot; &quot;hw&quot; &quot;김철수&quot; 1 &quot; M&quot; 74 91 TRUE 8 &quot;김영희&quot; 4 &quot;F&quot; 82 77 FALSE 9 &quot;이철수&quot; 3 &quot;M&quot; 67 88 FALSE 7 &quot;이영희&quot; 2 &quot;F&quot; 89 78 TRUE 8 &quot;홍길동&quot; 1 &quot;M&quot; 50 86 FALSE 10 두 번째 명령문은 write.csv() 함수를 사용하여 데이터 프레임을 CSV 파일 형식으로 저장한 예이다. 다음은 저장된 students.csv 파일의 모습이다. 결과에서 볼 수 있듯이 쉼표로 각 데이터가 분리되어 있다.다음 결과에서 볼 수 있듯이 쉼표로 각 데이터가 분리되어 있다. Excel에서 파일을 읽으면 데이터를 Excel의 각 셀로 잘 읽어 들일 수 있다. &quot;name&quot;,&quot;grade&quot;,&quot;gender&quot;,&quot;midterm&quot;,&quot;final&quot;,&quot;retake&quot;,&quot;hw&quot; &quot;김철수&quot;,1,&quot; M&quot;,74,91,TRUE,8 &quot;김영희&quot;,4,&quot;F&quot;,82,77,FALSE,9 &quot;이철수&quot;,3,&quot;M&quot;,67,88,FALSE,7 &quot;이영희&quot;,2,&quot;F&quot;,89,78,TRUE,8 &quot;홍길동&quot;,1,&quot;M&quot;,50,86,FALSE,10 세 번째 명령문은 write.csv()을 사용하여 CSV 파일로 데이터를 저장한 것은 두 번째 명령문과 같은데 다만 행 번호를 같이 저장한 예이다. 다음은 저장된 students_rn.csv 파일의 모습니다. 결과에서 첫 번째 열에 행 번호가 저장되어 있음을 볼 수 있다. &quot;&quot;,&quot;name&quot;,&quot;grade&quot;,&quot;gender&quot;,&quot;midterm&quot;,&quot;final&quot;,&quot;retake&quot;,&quot;hw&quot; &quot;1&quot;,&quot;김철수&quot;,1,&quot; M&quot;,74,91,TRUE,8 &quot;2&quot;,&quot;김영희&quot;,4,&quot;F&quot;,82,77,FALSE,9 &quot;3&quot;,&quot;이철수&quot;,3,&quot;M&quot;,67,88,FALSE,7 &quot;4&quot;,&quot;이영희&quot;,2,&quot;F&quot;,89,78,TRUE,8 &quot;5&quot;,&quot;홍길동&quot;,1,&quot;M&quot;,50,86,FALSE,10 다음 예에서 write.table() 또는 write.csv() 파일로 저장한 데이터를 다시 데이터 프레임으로 잘 복원할 수 있음을 확인할 수 있다. 이 때로 파일의 형식이 공백으로 분리된 파일인지 CSV 파일인지에 따라 read.table()과 read.csv()를 적절히 선택하여야 한다. &gt; read.table(&quot;data/students.txt&quot;, header=TRUE, fileEncoding=&quot;UTF-8&quot;) name grade gender midterm final retake hw 1 김철수 1 M 74 91 TRUE 8 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M 67 88 FALSE 7 4 이영희 2 F 89 78 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 &gt; read.csv(&quot;data/students.csv&quot;, header=TRUE, fileEncoding=&quot;UTF-8&quot;) name grade gender midterm final retake hw 1 김철수 1 M 74 91 TRUE 8 2 김영희 4 F 82 77 FALSE 9 3 이철수 3 M 67 88 FALSE 7 4 이영희 2 F 89 78 TRUE 8 5 홍길동 1 M 50 86 FALSE 10 사실 write.csv() 함수는 write.table()에서 sep 인수에 ','를 부여한 결과와 같다. 따라서 두 번째와 세 번째 명령문은 다음처럼 하여도 같은 결과를 얻을 수 있다. &gt; write.table(students, &quot;data/students.csv&quot;, sep=&quot;,&quot;, row.names=FALSE, fileEncoding=&quot;UTF-8&quot;) &gt; write.table(students, &quot;data/students_rn.csv&quot;, sep=&quot;,&quot;, row.names=TRUE, fileEncoding=&quot;UTF-8&quot;) 바이너리 형식으로 데이터 객체 저장 및 복원 데이터 프레임뿐 아니라 R의 모든 객체들을 saveRDS()와 readRDS(), 또는 save()와 load() 함수를 이용하여 바이너리 형식으로 저장하고 복원할 수 있다. 이 경우 메모리에 적재되는 형태대로 파일에 저장되었다가 복원되므로 별도의 처리 과정이 불필요해진다. 그러므로 대용량의 데이터를 R 플랫폼 내에서 저장하거나 복원할 때 매우 유용하다. 관련된 내용은 saveRDS()/readRDS()와 save()/load() 함수의 도움말을 참조하기 바란다. 6.8 데이터 프레임의 열을 변수처럼 이용하는 방법 변수 검색 경로 $ 기호를 이용하는 방법보다 좀 더 간편하게 데이터 프레임의 열에 접근할 수 있는 방법이 있다. attach() 함수를 이용하면 데이터 프레임의 각 열을 변수로 등록할 수 있다. attach() 함수가 실행되면 해당 데이터 프레임의 각 열을 변수로 검색 경로(search path)에 등록한다. 검색 경로란 R이 어떤 변수를 참조할 때 변수에 대한 정보를 검색하는 경로를 의미한다. 현재의 검색 경로를 파악하기 위해서는 search() 함수를 이용하면 된다. &gt; search() [1] &quot;.GlobalEnv&quot; &quot;package:stats&quot; &quot;package:graphics&quot; [4] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; [7] &quot;package:methods&quot; &quot;Autoloads&quot; &quot;package:base&quot; 위의 결과에서 알 수 있듯이 R이 기동되면 현재의 작업공간을 .GlobalEnv라는 이름으로 첫 번째 검색 경로로 등록한다. 현재의 작업 공간에서 만든 변수들은 여기서 찾을 수 있다. 그리고 package:를 접두사로 하여 패키지별 변수의 데이터베이스가 검색 경로에 등록된다. R은 검색 경로에 나와 있는 순서대로 변수들의 정보를 찾는다. attach()로 데이터 프레임을 검색 경로에 등록하기 본격적으로 attach() 함수의 작동을 보기 전에 students 데이터 프레임을 제외하고 다른 데이터 객체를 .GlobalEnv에서 삭제하도록 하겠다. .GlobalEnv 작업공간에 있는 변수를 보기 위해서는 ls() 또는 objects() 함수를 사용한다. rm() 함수를 이용하면 작업공간의 변수를 삭제할 수 있다. 이들 함수의 자세한 사용방법은 도움말을 참조한다. &gt; obj &lt;- ls() &gt; rm(list=obj[which(obj != &quot;students&quot;)]) &gt; ls() [1] &quot;obj&quot; &quot;students&quot; &gt; rm(obj) &gt; objects() [1] &quot;students&quot; 아래는 attach() 함수를 이용하여 students 데이터 프레임을 검색 경로에 등록한 예이다. 아래 예에서 보듯이 students를 검색 경로에 등록하기 전에는 retake 변수가 검색 경로에 없으므로 찾을 수 없다고 나온다. 그러나 students 데이터 프레임을 검색 경로에 등록하면 데이터 프레임의 열인 retake를 변수처럼 이용할 수 있음을 알 수 있다. &gt; retake Error in eval(expr, envir, enclos): object &#39;retake&#39; not found &gt; attach(students) &gt; retake [1] TRUE FALSE FALSE TRUE FALSE &gt; search() [1] &quot;.GlobalEnv&quot; &quot;students&quot; &quot;package:stats&quot; [4] &quot;package:graphics&quot; &quot;package:grDevices&quot; &quot;package:utils&quot; [7] &quot;package:datasets&quot; &quot;package:methods&quot; &quot;Autoloads&quot; [10] &quot;package:base&quot; attach()로 등록된 변수는 데이터 프레임과 독립적인 복사본이다. 여기서 주의할 점은 attach 된 변수가 변경되더라도 원래 데이터 프레임의 데이터가 변경되지는 않는다는 것이다. attach를 통해 등록된 변수는 데이터 프레임의 데이터가 복사되어 생성되지만 데이터 프레임과는 무관한 별도의 변수처럼 작동한다. &gt; retake[1] &lt;- NA &gt; retake [1] NA FALSE FALSE TRUE FALSE &gt; students$retake [1] TRUE FALSE FALSE TRUE FALSE 데이터 프레임의 데이터를 변경하려면 $ 기호를 써서 직접 변경하여야 한다. 마찬가지로 원래 데이터 프레임의 데이터가 변경되어도 검색 경로에 추가된 retake 변수의 데이터는 변경되지 않음을 알 수 있다. &gt; students$retake[5] &lt;- NA &gt; students$retake [1] TRUE FALSE FALSE TRUE NA &gt; retake [1] NA FALSE FALSE TRUE FALSE detach() 데이터 프레임을 검색 경로에서 제거하려면 detach() 함수를 이용한다. &gt; detach(students) &gt; search() [1] &quot;.GlobalEnv&quot; &quot;package:stats&quot; &quot;package:graphics&quot; [4] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; [7] &quot;package:methods&quot; &quot;Autoloads&quot; &quot;package:base&quot; attach()로 등록된 변수의 검색 경로 상의 위치 R에서 검색 경로의 첫 번째 위치는 항상 현재의 작업공간이 차지한다. attach()에 의해 추가되는 변수들은 항상 검색 경로 상에서 두번째나 그 뒤의 위치에 놓인다. 디폴트로 attach()에 의해 추가되는 변수는 검색 경로 상에서 두번째 위치에 놓이게 되므로 현재의 작업공간을 제외하고는 검색 우선순위가 가장 높게 설정된다. 이를 바꾸고 싶으면 attach() 함수의 position 인수를 이용하면 된다. (자세한 내용은 attach()의 도움말을 참조한다.) 일반적으로 데이터 프레임을 이용할 때 다음이 좋은 절차라 알려져 있다. 첫째, 어떤 문제와 관련된 모든 변수를 데이터 프레임에 포함시키고 적절한 이름을 부여한다. 둘째, 분석하는 문제와 관련된 데이터 프레임을 attach()하여 검색 경로 위치 두 번째에 추가한다. 검색경로의 첫 번째 위치에 작업공간이 있어서 분석 운영을 위한 수치와 임시적인 변수들이 놓인다. 셋째, 분석하는 문제를 떠나기 전에 다음에 사용하고자 하는 변수는 $를 이용하여 데이터 프레임에 저장한다. 그리고 detach() 한다. 넷째, 작업공간의 모든 필요 없는 변수를 삭제한다. 그러나 저자의 경우 attach()와 detach()를 잘 이용하지 않는다. 왜냐하면 이러한 방식은 프로그램이 복잡하거나 동시에 다루어야 할 데이터 프레임이 여러 개인 경우 변수 이름의 충돌이 일어나기 쉽다. 그래서 자신이 원하는 곳의 변수가 아니라 다른 위치의 동일한 이름의 변수를 참조하거나 변경하는 오류가 발생하기 쉽다. 또한 RStudio 같은 IDE를 사용하면 편집기 상에서 데이터 프레임의 이름 등을 자동 완성시킬 수 있으므로 긴 이름을 입력하는 것이 그리 수고스럽지 않기 때문이다. 이 두 가지 방법 중 어떠한 스타일을 택할 것인지는 개인의 선호에 달려 있다. 이 책에서는 특별한 경우가 아니면 attach() 등을 사용하지 않을 것이다. 참고로 이름이 비슷한 함수로 car 패키지의 subsets()라는 함수가 있다. 이 함수는 변수의 부분집합으로 회귀분석한 후, 그 결과를 그래프로 그리는 함수이다.↩︎ Excel 파일 형식으로 바로 데이터를 읽어들이기 위해서는 readxl 패키지의 read_excel() 함수를 이용하면 된다. 관심있는 독자는 웹 검색을 해 보면 관련 자료를 쉽게 찾을 수 있을 것이다.↩︎ "],
["ch-dataTransformation.html", "Chapter 7 dplyr을 이용한 데이터 변환 7.1 정돈 데이터 (tidy data) 7.2 tidyverse 패키지 7.3 dplyr 패키지와 정돈 데이터의 변환 7.4 filter()로 행 선택하기 7.5 arrange()로 행 정렬하기 7.6 select()를 이용하여 변수 이름으로 열 선택하기 7.7 mutate()로 새로운 변수 만들기 7.8 summarize()로 변수 요약하기 7.9 group_by()로 그룹 별로 요약하기 7.10 %&gt;% 파이프 연산자", " Chapter 7 dplyr을 이용한 데이터 변환 데이터를 분석하려면 데이터를 분석에 적절한 형식으로 변환하는 전처리가 필요하다. 또한 기본적인 분석을 위해서도 데이터를 요약하는 작업이 필요하다. 이 장에서는 정돈 형식의 데이터 프레임을 변환하는 방법을 배운다. 7.1 정돈 데이터 (tidy data) 7.1.1 정돈 데이터 형식의 조건 정돈 데이터란 그림 7.1처럼 다음의 조건을 만족하는 데이터 행렬(R에서는 데이터 프레임)의 형식을 의미한다. 데이터 행렬의 각 행과 관측(대상)(observations)은 일대일의 관계이다. 데이터 행렬의 각 열과 변수(variables)는 일대일의 관계이다. 측정값(values)은 각 셀과 일대일의 관계이다. Figure 7.1: 정돈 데이터 7.1.2 비정돈 데이터 형식 현실에서 만나는 많은 데이터가 정돈 데이터 형식이지만, 그렇지 않은 데이터도 자주 볼 수 있다. 그림 7.2의 왼쪽 데이터는 어떤 가상의 감염병에 대해 세 나라의 발생 사례를 월별로 정리한 데이터이다. 이 데이터는 감염 사례라는 변수와 관련된 데이터가 3개의 열에 흩어져 있으므로 비정돈 형식이다. 월별, 년도별 매출처럼 시계열 데이터는 종종 이런 형식으로 데이터가 표현된다. 이러한 방식의 표현은 데이터를 매우 압축적인 방식으로 표현할 수 있고 같은 시간대의 데이터를 비교하기 쉬운 장점이 있다. 그림 7.2의 오른쪽 데이터는 왼쪽 데이터를 정돈 형식으로 변환한 결과이다. 이러한 변환을 하는 방법에 대해서는 9 장에서 다룰 것이다. Figure 7.2: 비정돈 데이터 7.1.3 정돈 데이터를 사용하는 이유 그림 7.2를 보면 정돈 형식 데이터가 오히려 비효율적인 방식으로 보이며, 데이터를 한 눈에 비교하기도 어려워 보인다. 그럼에도 정돈 형식의 데이터를 사용하는 이유는 표준화된 데이터 변환 작업을 하기 위해서이다. 한 행이 하나의 관측 대상을, 한 열이 하나의 변수를, 한 셀이 한 값을 나타낸다는 가정이 성립하면, 데이터 변환이나 데이터를 이용한 그래픽 작업을 데이터의 내용에 무관하게 항상 일정한 형식으로 수행할 수 있다. 7.2 tidyverse 패키지 tidyverse 패키지는 정돈 데이터 패러다임을 따른 R 패키지들을 한번에 설치하고 적재할 수 있도록 돕는 패키지이다. 7.2.1 tidyverse 패키지 설치 tidyverse 패키지를 설치하려면 다음 명령을 실행하면 된다. 패키지의 이름은 문자열이므로 따옴표 안에 기술해야 한다. &gt; install.packages(&quot;tidyverse&quot;) 또는 RStudio의 Packages 탭에서 [Install]을 클릭한 후 tidyverse라고 입력을 하면 된다. 패키지 설치는 한 번만 수행하면 된다. 7.2.2 tidyverse 패키지 적재 tidyverse 패키지가 설치되었으면 패키지를 사용할 때마다 네임스페이스를 적재하고 검색 리스트에 패키지를 포함하는 작업이 필요하다.6 다음은 tidyverse 패키지를 적재하는 명령어이다. 이번에는 패키지 이름에 따옴표가 없음에 주의한다. &gt; library(tidyverse) ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ── ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 ✓ tibble 3.0.3 ✓ dplyr 1.0.2 ✓ tidyr 1.1.1 ✓ stringr 1.4.0 ✓ readr 1.3.1 ✓ forcats 0.5.0 ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── x dplyr::filter() masks stats::filter() x dplyr::lag() masks stats::lag() 앞의 명령을 실행하면 정돈 데이터 패러다임을 따르는 여러 개의 패키지가 동시에 적재된다. 그리고 R 기본 패키지와 정돈 데이터 패키지 중에서 이름이 충돌이 나는 것에 대해 보고를 한다. 만약 R 기본 패키지에서 이 함수를 사용하는 경우에는 패키지이름::함수() 형식으로만 사용할 수 있다. 자세한 내용은 R 관련 책을 참조하기 바란다. 7.3 dplyr 패키지와 정돈 데이터의 변환 7.3.1 dplyr 패키지 정돈 데이터의 변환에는 tidyverse 패키지가 포함하고 있는 dplyr 패키지가 이용된다. 앞에서 tidyverse를 적재하였으면 이미 dplyr이 적재되어 있으므로 다시 적재할 필요가 없다. 7.3.2 정돈 데이터 변환의 종류 정돈 데이터의 변환은 크게 5가지 변환 작업이 있다. filter(): 데이터에서 관측(대상)을 측정값을 기준으로 선택한다. arrange(): 관측(대상)을 기준으로 데이터를 정렬한다. select(): 변수이름으로 일부 변수만 데이터에서 선택한다. mutate(): 기존 변수를 사용하여 새로운 변수를 데이터에 추가한다. summarize(): 여러 측정치를 하나의 통계량으로 요약한다. 그리고 위의 작업은 group_by() 함수와 같이 사용되어 전체 데이터에서 작업이 수행되는 것이 아니라 관측(대상)의 그룹별로 수행되도록 조정할 수 있다. 일반적으로 데이터의 변환 작업은 위의 6가지 작업이 여러 차례 순서대로 결합하여 진행된다. 7.3.3 dplyr 패키지 vs. R의 기본 기능 앞으로 볼 dplyr 패키지의 함수들이 수행하는 작업은 R에서 제공하는 기본 함수로도 수행될 수 있다. 특히 filter(), arrange(), select(), mutate() 함수의 작업은 R 데이터프레임의 필터링 기능을 사용하면 대체할 수 있으며, summarize()와 group_by() 함수의 작업은 tapply(), aggregate() 등을 사용하면 대체할 수 있다. 그럼에도 불구하고 복잡한 데이터 변환을 수행할 때 R의 기본 기능보다는 dplyr 패키지의 함수들이 선호되는 이유는 다음과 같다. dplyr 함수에서는 데이터프레임의 열을 변수처럼 사용할 수 있어서 R의 기본 기능보다 더 짧은 명령문으로 데이터의 조작과 변환이 가능하다. R의 기본 함수들은 한 함수가 여러 가지 변환을 수행하고 서로의 기능이 중복되는데 반해, dplyr 패키지의 함수는 오직 하나의 기능만을 수행하고 서로 기능이 중복되지 않아서 명령문을 이해하기 쉽다. R의 기본 함수들이 입력과 출력 형식이 제각각인데 반해, dplyr 패키지의 함수는 공통된 입력과 출력 형식을 사용하므로 여러 단계를 거치는 복잡한 데이터 변환 작업도 dplyr 함수를 파이프 연산자로 연결하여 쉽게 구현할 수 있다. 7.3.4 mpg 데이터 이 장에서는 ggplot2() 패키지에서 제공하는 mpg 데이터를 이용하여 정돈 데이터를 변환하는 함수를 설명한다. 다음 명령을 이용하여 mpg 데이터를 출력해 보자. 화면의 크기에 따라 출력되는 내용이 책과는 조금 다를 수 있다. &gt; mpg # A tibble: 234 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto(l… f 18 29 p comp… 2 audi a4 1.8 1999 4 manual… f 21 29 p comp… 3 audi a4 2 2008 4 manual… f 20 31 p comp… 4 audi a4 2 2008 4 auto(a… f 21 30 p comp… 5 audi a4 2.8 1999 6 auto(l… f 16 26 p comp… 6 audi a4 2.8 1999 6 manual… f 18 26 p comp… 7 audi a4 3.1 2008 6 auto(a… f 18 27 p comp… 8 audi a4 quat… 1.8 1999 4 manual… 4 18 26 p comp… 9 audi a4 quat… 1.8 1999 4 auto(l… 4 16 25 p comp… 10 audi a4 quat… 2 2008 4 manual… 4 20 28 p comp… # … with 224 more rows mpg는 1999년과 2008년에 미국 EPA에서 조사하여 발표한 자동차 주요 모델별 연비 데이터이다. 데이터는 234 개의 행이 있으며, 각 행은 다음과 같은 변수로 구성되어 있다. manufacturer: 자동차 제조사 model: 자동차 모델명 displ: 자동차 배기량 year: 제조년도 cyl: 엔진 실린더 수 trans: 자동차 트랜스미션 종류 drv: 자동차 구동 방식. f=전륜구동, r=후륜구동, 4=사륜구동 cty: 도심 연비 (마일/갤론) hwy: 고속도로 연비 (마일/갤론) fl: 연료 종류 class: 자동차 분류 7.4 filter()로 행 선택하기 7.4.1 선택 조건이 하나인 경우 선택 조건이 하나인 경우 다음 형식으로 filter()를 사용한다. filter(데이터프레임, 조건) ’데이터프레임’에는 filter()를 적용할 데이터 프레임을 ’조건’에는 행 선택 조건을 기술한다. ’조건’은 논리값 벡터이어야 한다. 많은 경우 ’조건’은 다음처럼 변수와 어떤 값을 비교연산자로 비교한다. 다음 예에서 보는 것처럼 dplyr 패키지의 함수들은 첫번째 인수로 데이터프레임을 지정한 후, 나머지 부분에서 그 데이터프레임의 열을 변수처럼 사용할 수 있다. &gt; filter(mpg, manufacturer==&quot;hyundai&quot;) # A tibble: 14 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 1999 4 auto(l… f 18 26 r midsize 2 hyundai sonata 2.4 1999 4 manual… f 18 27 r midsize 3 hyundai sonata 2.4 2008 4 auto(l… f 21 30 r midsize 4 hyundai sonata 2.4 2008 4 manual… f 21 31 r midsize 5 hyundai sonata 2.5 1999 6 auto(l… f 18 26 r midsize 6 hyundai sonata 2.5 1999 6 manual… f 18 26 r midsize 7 hyundai sonata 3.3 2008 6 auto(l… f 19 28 r midsize 8 hyundai tibur… 2 1999 4 auto(l… f 19 26 r subcom… 9 hyundai tibur… 2 1999 4 manual… f 19 29 r subcom… 10 hyundai tibur… 2 2008 4 manual… f 20 28 r subcom… 11 hyundai tibur… 2 2008 4 auto(l… f 20 27 r subcom… 12 hyundai tibur… 2.7 2008 6 auto(l… f 17 24 r subcom… 13 hyundai tibur… 2.7 2008 6 manual… f 16 24 r subcom… 14 hyundai tibur… 2.7 2008 6 manual… f 17 24 r subcom… &gt; filter(mpg, cty &gt; 28) # A tibble: 3 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 volkswagen jetta 1.9 1999 4 manual… f 33 44 d compact 2 volkswagen new be… 1.9 1999 4 manual… f 35 44 d subcom… 3 volkswagen new be… 1.9 1999 4 auto(l… f 29 41 d subcom… &gt; filter(mpg, cty &gt;= 28) # A tibble: 5 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 honda civic 1.6 1999 4 manual… f 28 33 r subcom… 2 toyota corolla 1.8 2008 4 manual… f 28 37 r compact 3 volkswagen jetta 1.9 1999 4 manual… f 33 44 d compact 4 volkswagen new be… 1.9 1999 4 manual… f 35 44 d subcom… 5 volkswagen new be… 1.9 1999 4 auto(l… f 29 41 d subcom… 조건을 서술할 때 자주 틀리는 부분이 등호 기호로 =를 사용하는 것이다. R에서 두 값이 같은지를 비교할 때는 ==를 사용한다. 다음처럼 조건에 사용되는 변수에 대해 연산을 수행한 후에 그 결과를 비교할 수도 있다. &gt; filter(mpg, cty * 2 &gt; 60) # A tibble: 2 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 volkswagen jetta 1.9 1999 4 manual… f 33 44 d compact 2 volkswagen new be… 1.9 1999 4 manual… f 35 44 d subcom… &gt; filter(mpg, sqrt(cty) &lt; 3.2) # A tibble: 5 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 dodge dakota pi… 4.7 2008 8 auto(… 4 9 12 e pick… 2 dodge durango 4… 4.7 2008 8 auto(… 4 9 12 e suv 3 dodge ram 1500 … 4.7 2008 8 auto(… 4 9 12 e pick… 4 dodge ram 1500 … 4.7 2008 8 manua… 4 9 12 e pick… 5 jeep grand che… 4.7 2008 8 auto(… 4 9 12 e suv 7.4.2 여러 조건을 만족하는 행 추출하기 두 개 이상의 조건을 모두 만족하는 행만 뽑아내려면 다음의 문법을 사용한다. filter(데이터프레임, 조건1, 조건2, ..., 조건n) 다음은 현대에서 생산한 차 중 도심 연비가 20 마일 이상인 차만 추출한 결과이다. &gt; filter(mpg, manufacturer==&quot;hyundai&quot;, cty &gt;= 20) # A tibble: 4 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsize 2 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsize 3 hyundai tibur… 2 2008 4 manual(… f 20 28 r subcom… 4 hyundai tibur… 2 2008 4 auto(l4) f 20 27 r subcom… 앞의 조건에서 배기량이 2.4 이상인 차만 추출해 보자. &gt; filter(mpg, manufacturer==&quot;hyundai&quot;, cty &gt;= 20, displ &gt;= 2.4) # A tibble: 2 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsi… 2 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r midsi… 7.4.3 논리 연산자로 복합 조건 만들기 지금까지는 하나의 조건이나 여러 조건을 동시에 만족하는 행을 추출하는 방법을 보았다. 어떤 경우에는 여러 조건 중 하나라도 만족하면 그 행을 추출해야 할 경우가 있다. 이러한 경우에는 2 장에서 배운 논리 연산자를 이용하여 복합 조건을 만들어야 한다. 다음은 OR 연자자인 |를 이용하여 두 조건 중 하나만 만족하여도 행이 추출되도록 하였다. &gt; filter(mpg, model==&quot;sonata&quot; | cty &gt;= 28) # A tibble: 12 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 honda civic 1.6 1999 4 manual… f 28 33 r subco… 2 hyundai sonata 2.4 1999 4 auto(l… f 18 26 r midsi… 3 hyundai sonata 2.4 1999 4 manual… f 18 27 r midsi… 4 hyundai sonata 2.4 2008 4 auto(l… f 21 30 r midsi… 5 hyundai sonata 2.4 2008 4 manual… f 21 31 r midsi… 6 hyundai sonata 2.5 1999 6 auto(l… f 18 26 r midsi… 7 hyundai sonata 2.5 1999 6 manual… f 18 26 r midsi… 8 hyundai sonata 3.3 2008 6 auto(l… f 19 28 r midsi… 9 toyota corolla 1.8 2008 4 manual… f 28 37 r compa… 10 volkswagen jetta 1.9 1999 4 manual… f 33 44 d compa… 11 volkswagen new be… 1.9 1999 4 manual… f 35 44 d subco… 12 volkswagen new be… 1.9 1999 4 auto(l… f 29 41 d subco… 만약 위의 결과에서 2008년도 데이터만 추출하고 싶다면 어떻게 해야 할까? 다음처럼 두 조건식을 사용하여 첫 번째 조건과 두 번째 조건을 모두 만족하는 결과만 추출할 수도 있고, 하나의 조건식에 AND 연산자인 &amp;를 사용하여 복합 조건식을 사용하여 추출할 수도 있다. &gt; filter(mpg, model==&quot;sonata&quot; | cty &gt;= 28, year==2008) # A tibble: 4 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsi… 2 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsi… 3 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsi… 4 toyota corolla 1.8 2008 4 manual(… f 28 37 r compa… &gt; filter(mpg, (model==&quot;sonata&quot; | cty &gt;= 28) &amp; year==2008) # A tibble: 4 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsi… 2 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsi… 3 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsi… 4 toyota corolla 1.8 2008 4 manual(… f 28 37 r compa… 단, 복합 조건식에서 AND 연산이 OR 연산보다 우선순위가 있으므로 괄호를 사용하여 연산의 순서가 제대로 되도록 하여야 한다. 괄호가 없으면 AND가 수행된 후 OR가 수행되어 모든 소타나 자동차의 결과가 추출되었음을 볼 수 있다. &gt; filter(mpg, model==&quot;sonata&quot; | cty &gt;= 28 &amp; year==2008) # A tibble: 8 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 1999 4 auto(l4) f 18 26 r midsi… 2 hyundai sonata 2.4 1999 4 manual(… f 18 27 r midsi… 3 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsi… 4 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsi… 5 hyundai sonata 2.5 1999 6 auto(l4) f 18 26 r midsi… 6 hyundai sonata 2.5 1999 6 manual(… f 18 26 r midsi… 7 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsi… 8 toyota corolla 1.8 2008 4 manual(… f 28 37 r compa… 7.5 arrange()로 행 정렬하기 arrange()는 다음 문법을 사용하여 행을 정렬한다. arrange(데이터프레임, 첫번째 정렬 기준 변수, 두번째 정렬 기준 변수, ....) filter()와 마찬가지로 첫 번재 인수로 정렬할 데이터 프레임을 전달 받는다. 그리고 두번재 인수부터 정렬의 기준이 되는 변수를 차례로 기술한다. 첫 번째 기준 변수의 값이 같으면, 두 번째 기준 변수를, 두 번째 기준 변수의 값까지 같으면 그 다음 변수를 기준으로 차례로 순서를 결정하여 정렬을 수행한다. 다음은 2008년도 현대의 자동차 모델만 filter()론 선택하여 a라는 변수에 저장한 후, 이 데이터에 대하여 여러 조건으로 정렬을 수행해본 예이다. &gt; a &lt;- filter(mpg, manufacturer == &quot;hyundai&quot;, year == 2008) &gt; a # A tibble: 8 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsize 2 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsize 3 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsize 4 hyundai tibur… 2 2008 4 manual(… f 20 28 r subcom… 5 hyundai tibur… 2 2008 4 auto(l4) f 20 27 r subcom… 6 hyundai tibur… 2.7 2008 6 auto(l4) f 17 24 r subcom… 7 hyundai tibur… 2.7 2008 6 manual(… f 16 24 r subcom… 8 hyundai tibur… 2.7 2008 6 manual(… f 17 24 r subcom… &gt; arrange(a, cyl) # A tibble: 8 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsize 2 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsize 3 hyundai tibur… 2 2008 4 manual(… f 20 28 r subcom… 4 hyundai tibur… 2 2008 4 auto(l4) f 20 27 r subcom… 5 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsize 6 hyundai tibur… 2.7 2008 6 auto(l4) f 17 24 r subcom… 7 hyundai tibur… 2.7 2008 6 manual(… f 16 24 r subcom… 8 hyundai tibur… 2.7 2008 6 manual(… f 17 24 r subcom… &gt; arrange(a, cyl, cty) # A tibble: 8 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai tibur… 2 2008 4 manual(… f 20 28 r subcom… 2 hyundai tibur… 2 2008 4 auto(l4) f 20 27 r subcom… 3 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsize 4 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsize 5 hyundai tibur… 2.7 2008 6 manual(… f 16 24 r subcom… 6 hyundai tibur… 2.7 2008 6 auto(l4) f 17 24 r subcom… 7 hyundai tibur… 2.7 2008 6 manual(… f 17 24 r subcom… 8 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsize &gt; arrange(a, model, trans) # A tibble: 8 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsize 2 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsize 3 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsize 4 hyundai tibur… 2 2008 4 auto(l4) f 20 27 r subcom… 5 hyundai tibur… 2.7 2008 6 auto(l4) f 17 24 r subcom… 6 hyundai tibur… 2 2008 4 manual(… f 20 28 r subcom… 7 hyundai tibur… 2.7 2008 6 manual(… f 17 24 r subcom… 8 hyundai tibur… 2.7 2008 6 manual(… f 16 24 r subcom… 7.5.1 desc()를 이용하여 내림차순으로 정렬하기 앞의 예에서 arrange()는 수치 변수는 올림차순으로 문자 변수는 알파벳 순으로 정렬하는 것을 볼 수 있다. 만약 위의 예에서 내림차순으로, 또는 알파벳 역순으로 정렬을 하고 싶으면 어떻게 하여야 할까? dplyr 패키지는 desc()를 이용하면 된다. &gt; arrange(a, desc(cyl)) # A tibble: 8 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsize 2 hyundai tibur… 2.7 2008 6 auto(l4) f 17 24 r subcom… 3 hyundai tibur… 2.7 2008 6 manual(… f 16 24 r subcom… 4 hyundai tibur… 2.7 2008 6 manual(… f 17 24 r subcom… 5 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsize 6 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsize 7 hyundai tibur… 2 2008 4 manual(… f 20 28 r subcom… 8 hyundai tibur… 2 2008 4 auto(l4) f 20 27 r subcom… &gt; arrange(a, desc(cyl), cty) # A tibble: 8 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai tibur… 2.7 2008 6 manual(… f 16 24 r subcom… 2 hyundai tibur… 2.7 2008 6 auto(l4) f 17 24 r subcom… 3 hyundai tibur… 2.7 2008 6 manual(… f 17 24 r subcom… 4 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsize 5 hyundai tibur… 2 2008 4 manual(… f 20 28 r subcom… 6 hyundai tibur… 2 2008 4 auto(l4) f 20 27 r subcom… 7 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsize 8 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsize &gt; arrange(a, model, desc(trans)) # A tibble: 8 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsize 2 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsize 3 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsize 4 hyundai tibur… 2.7 2008 6 manual(… f 16 24 r subcom… 5 hyundai tibur… 2 2008 4 manual(… f 20 28 r subcom… 6 hyundai tibur… 2.7 2008 6 manual(… f 17 24 r subcom… 7 hyundai tibur… 2 2008 4 auto(l4) f 20 27 r subcom… 8 hyundai tibur… 2.7 2008 6 auto(l4) f 17 24 r subcom… desc()가 적용된 변수만 내림차순을 기준으로 정렬을 하는 것을 볼 수 있다. 7.6 select()를 이용하여 변수 이름으로 열 선택하기 7.6.1 변수 이름을 나열하여 선택하기 select() 함수는 다음처럼 변수 이름을 일일이 나열하여 원하는 열을 선택할 수 있다. R의 기본 문법을 알고 있는 사람들은 데이터 프레임의 인덱싱에서처럼 문자열로 이름을 나열하는 것이 아니라 변수를 사용하듯 따옴표 없이 이름을 나열하는 것에 주의한다. select(데이터프레임, 변수이름1, 변수이름 2, ....) &gt; select(a, model, year, cty, hwy) # A tibble: 8 x 4 model year cty hwy &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 sonata 2008 21 30 2 sonata 2008 21 31 3 sonata 2008 19 28 4 tiburon 2008 20 28 5 tiburon 2008 20 27 6 tiburon 2008 17 24 7 tiburon 2008 16 24 8 tiburon 2008 17 24 7.6.2 변수 이름으로 변수 범위를 선택하기 select() 함수는 다음처럼 변수 이름으로 선택할 변수의 범위를 지정할 수 있다. select(데이터프레임, 범위시작_변수이름:범위종료_변수이름, ...) &gt; select(a, model:trans) # A tibble: 8 x 5 model displ year cyl trans &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; 1 sonata 2.4 2008 4 auto(l4) 2 sonata 2.4 2008 4 manual(m5) 3 sonata 3.3 2008 6 auto(l5) 4 tiburon 2 2008 4 manual(m5) 5 tiburon 2 2008 4 auto(l4) 6 tiburon 2.7 2008 6 auto(l4) 7 tiburon 2.7 2008 6 manual(m6) 8 tiburon 2.7 2008 6 manual(m5) &gt; select(a, model:trans, cty:hwy) # A tibble: 8 x 7 model displ year cyl trans cty hwy &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; 1 sonata 2.4 2008 4 auto(l4) 21 30 2 sonata 2.4 2008 4 manual(m5) 21 31 3 sonata 3.3 2008 6 auto(l5) 19 28 4 tiburon 2 2008 4 manual(m5) 20 28 5 tiburon 2 2008 4 auto(l4) 20 27 6 tiburon 2.7 2008 6 auto(l4) 17 24 7 tiburon 2.7 2008 6 manual(m6) 16 24 8 tiburon 2.7 2008 6 manual(m5) 17 24 반대로 다음처럼 변수 이름으로 선택하지 않을 변수의 범위를 지정할 수 있다. select(데이터프레임, -(범위시작_변수이름:범위종료_변수이름), ...) &gt; select(a, -(model:trans)) # A tibble: 8 x 6 manufacturer drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai f 21 30 r midsize 2 hyundai f 21 31 r midsize 3 hyundai f 19 28 r midsize 4 hyundai f 20 28 r subcompact 5 hyundai f 20 27 r subcompact 6 hyundai f 17 24 r subcompact 7 hyundai f 16 24 r subcompact 8 hyundai f 17 24 r subcompact &gt; select(a, -(model:trans), -manufacturer) # A tibble: 8 x 5 drv cty hwy fl class &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 f 21 30 r midsize 2 f 21 31 r midsize 3 f 19 28 r midsize 4 f 20 28 r subcompact 5 f 20 27 r subcompact 6 f 17 24 r subcompact 7 f 16 24 r subcompact 8 f 17 24 r subcompact 7.6.3 변수 이름을 매칭하여 선택하기 dplyr 패키지는 다양한 형태로 변수를 선택할 수 있도록 다음의 변수 이름 매칭 함수를 제공한다. starts_with(\"abs\"): abc로 이름이 시작하는 모든 변수 ends_with(\"abs\"): abc로 이름이 끝나는 모든 변수 contains(\"abs\"): abc를 이름에 포함하고 있는 모든 변수 matches(\"(.)\\\\1\"): 정규 표현식을 만족하는 이름을 가진 모든 변수 num_range(\"x\", 1:3): “x1”, “x2”, “x3”이라는 이름의 변수 &gt; select(a, starts_with(&quot;c&quot;)) # A tibble: 8 x 3 cyl cty class &lt;int&gt; &lt;int&gt; &lt;chr&gt; 1 4 21 midsize 2 4 21 midsize 3 6 19 midsize 4 4 20 subcompact 5 4 20 subcompact 6 6 17 subcompact 7 6 16 subcompact 8 6 17 subcompact 7.6.4 변수 이름 바꾸기 select() 함수에서 변수 이름을 지정할 때, (새로운 변수 이름)=(기존 변수 이름) 형식으로 지정하면 변수의 이름을 바꿀 수 있다. &gt; select(a, model, city=cty, highway=hwy) # A tibble: 8 x 3 model city highway &lt;chr&gt; &lt;int&gt; &lt;int&gt; 1 sonata 21 30 2 sonata 21 31 3 sonata 19 28 4 tiburon 20 28 5 tiburon 20 27 6 tiburon 17 24 7 tiburon 16 24 8 tiburon 17 24 만약 전체 데이터를 유지한 상태에서 변수 이름만 변경하려면, rename() 함수를 이용한다. 문법은 select()와 같다. &gt; rename(a, city=cty, highway=hwy) # A tibble: 8 x 11 manufacturer model displ year cyl trans drv city highway fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l… f 21 30 r midsi… 2 hyundai sonata 2.4 2008 4 manual… f 21 31 r midsi… 3 hyundai sonata 3.3 2008 6 auto(l… f 19 28 r midsi… 4 hyundai tibur… 2 2008 4 manual… f 20 28 r subco… 5 hyundai tibur… 2 2008 4 auto(l… f 20 27 r subco… 6 hyundai tibur… 2.7 2008 6 auto(l… f 17 24 r subco… 7 hyundai tibur… 2.7 2008 6 manual… f 16 24 r subco… 8 hyundai tibur… 2.7 2008 6 manual… f 17 24 r subco… 7.6.5 변수 순서 바꾸기 select() 함수는 나열된 변수의 순서에 따라 새롭게 만들어진 데이터 프레임의 변수의 순서를 조정한다. &gt; select(a, cty, hwy) # A tibble: 8 x 2 cty hwy &lt;int&gt; &lt;int&gt; 1 21 30 2 21 31 3 19 28 4 20 28 5 20 27 6 17 24 7 16 24 8 17 24 &gt; select(a, hwy, cty) # A tibble: 8 x 2 hwy cty &lt;int&gt; &lt;int&gt; 1 30 21 2 31 21 3 28 19 4 28 20 5 27 20 6 24 17 7 24 16 8 24 17 이러한 성질과 everything() 함수를 이용하면 변수의 순서를 쉽게 바꿀 수 있다. everything()은 이미 선택된 변수를 제외한 나머지 변수를 의미한다. &gt; select(a, cty, hwy, everything()) # A tibble: 8 x 11 cty hwy manufacturer model displ year cyl trans drv fl class &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 21 30 hyundai sonata 2.4 2008 4 auto(l4) f r midsize 2 21 31 hyundai sonata 2.4 2008 4 manual(… f r midsize 3 19 28 hyundai sonata 3.3 2008 6 auto(l5) f r midsize 4 20 28 hyundai tibur… 2 2008 4 manual(… f r subcom… 5 20 27 hyundai tibur… 2 2008 4 auto(l4) f r subcom… 6 17 24 hyundai tibur… 2.7 2008 6 auto(l4) f r subcom… 7 16 24 hyundai tibur… 2.7 2008 6 manual(… f r subcom… 8 17 24 hyundai tibur… 2.7 2008 6 manual(… f r subcom… 7.7 mutate()로 새로운 변수 만들기 mutate()는 기존 변수를 이용하여 새로운 변수를 만들어 데이터 프레임의 가장 마지막 열로 추가한다. mutate(데이터프레임, 새로운_변수=기존_변수_연산식, ....) 다음은 도심 연비와 고속도로 연비의 합과, 평균, 그리고 고속도로 대비 도심 연비의 비율(%)을 계산하여 새로운 열을 만든 예이다. &gt; b &lt;- select(a, -(cyl:drv), -(fl:class)) &gt; b # A tibble: 8 x 6 manufacturer model displ year cty hwy &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 hyundai sonata 2.4 2008 21 30 2 hyundai sonata 2.4 2008 21 31 3 hyundai sonata 3.3 2008 19 28 4 hyundai tiburon 2 2008 20 28 5 hyundai tiburon 2 2008 20 27 6 hyundai tiburon 2.7 2008 17 24 7 hyundai tiburon 2.7 2008 16 24 8 hyundai tiburon 2.7 2008 17 24 &gt; mutate(b, sum=cty + hwy) # A tibble: 8 x 7 manufacturer model displ year cty hwy sum &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 hyundai sonata 2.4 2008 21 30 51 2 hyundai sonata 2.4 2008 21 31 52 3 hyundai sonata 3.3 2008 19 28 47 4 hyundai tiburon 2 2008 20 28 48 5 hyundai tiburon 2 2008 20 27 47 6 hyundai tiburon 2.7 2008 17 24 41 7 hyundai tiburon 2.7 2008 16 24 40 8 hyundai tiburon 2.7 2008 17 24 41 &gt; mutate(b, + sum=cty + hwy, + mean=(cty + hwy) / 2, + ratio= cty / hwy * 100) # A tibble: 8 x 9 manufacturer model displ year cty hwy sum mean ratio &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 hyundai sonata 2.4 2008 21 30 51 25.5 70 2 hyundai sonata 2.4 2008 21 31 52 26 67.7 3 hyundai sonata 3.3 2008 19 28 47 23.5 67.9 4 hyundai tiburon 2 2008 20 28 48 24 71.4 5 hyundai tiburon 2 2008 20 27 47 23.5 74.1 6 hyundai tiburon 2.7 2008 17 24 41 20.5 70.8 7 hyundai tiburon 2.7 2008 16 24 40 20 66.7 8 hyundai tiburon 2.7 2008 17 24 41 20.5 70.8 7.7.1 transmute()로 새로운 변수만 남기기 만약 새롭게 만들어진 변수만 데이터에 남기려면 mutate() 대신 transmute()를 사용한다. 문법은 두 함수가 동일하다. &gt; transmute(b, + sum=cty + hwy, + mean=(cty + hwy) / 2, + ratio= cty / hwy * 100) # A tibble: 8 x 3 sum mean ratio &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 51 25.5 70 2 52 26 67.7 3 47 23.5 67.9 4 48 24 71.4 5 47 23.5 74.1 6 41 20.5 70.8 7 40 20 66.7 8 41 20.5 70.8 7.7.2 새로운 변수를 만들 때 사용할 수 있는 함수들 새로운 변수를 생성할 때, 기존 변수와 관련된 수치, 논리, 문자열 연산을 수행할 수 있다. 다음처럼 제조사와 모델을 하나로 합쳐서 새로운 변수를 만들수도 있고, 배기량이 3 이상인지 여부를 나타내는 변수도 만들 수 있다. &gt; mutate(b, newName=paste(manufacturer, model, sep=&quot;-&quot;), dis3=displ &gt;= 3) # A tibble: 8 x 8 manufacturer model displ year cty hwy newName dis3 &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; 1 hyundai sonata 2.4 2008 21 30 hyundai-sonata FALSE 2 hyundai sonata 2.4 2008 21 31 hyundai-sonata FALSE 3 hyundai sonata 3.3 2008 19 28 hyundai-sonata TRUE 4 hyundai tiburon 2 2008 20 28 hyundai-tiburon FALSE 5 hyundai tiburon 2 2008 20 27 hyundai-tiburon FALSE 6 hyundai tiburon 2.7 2008 17 24 hyundai-tiburon FALSE 7 hyundai tiburon 2.7 2008 16 24 hyundai-tiburon FALSE 8 hyundai tiburon 2.7 2008 17 24 hyundai-tiburon FALSE 아울러 다음 함수가 새로운 변수를 만들 때 자주 사용된다. lead(): 기존 변수를 한 행, 또는 여러 행 빠르게 시작하는 변수 rag(): 기존 변수를 한 행, 또는 여러 행 늦게 시작하는 변수 cumsum(), cummean(): 누적 합과 평균 min_rank(): 가장 작은 것부터 차례대로 크기 순서로 등수를 매기는 함수. desc() 함수를 변수에 적용한 후 등수를 매기면 가장 큰 것부터 순서를 매길 수 있다. dense_rank(), percent_rank(), cume_dist(), ntile() 등도 사용될 수 있다. 자세한 내용은 도움말을 참조하기 바란다. &gt; mutate(b, cty_rank=min_rank(cty), hwy_rank=min_rank(desc(hwy)), desc_hwy=desc(hwy)) # A tibble: 8 x 9 manufacturer model displ year cty hwy cty_rank hwy_rank desc_hwy &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 hyundai sonata 2.4 2008 21 30 7 2 -30 2 hyundai sonata 2.4 2008 21 31 7 1 -31 3 hyundai sonata 3.3 2008 19 28 4 3 -28 4 hyundai tiburon 2 2008 20 28 5 3 -28 5 hyundai tiburon 2 2008 20 27 5 5 -27 6 hyundai tiburon 2.7 2008 17 24 2 6 -24 7 hyundai tiburon 2.7 2008 16 24 1 6 -24 8 hyundai tiburon 2.7 2008 17 24 2 6 -24 7.8 summarize()로 변수 요약하기 summarize(데이터프레임, 요약변수이름=요약함수(변수), ....) summarize() 함수는 변수의 모든 값을 하나의 값으로 요약하는 함수를 이용하여 변수를 요약한다. 대표적인 요약 함수는 다음과 같다. n(): 변수의 크기를 구한다. sum(): 수치 변수의 합을 구한다. mean(): 수치 변수의 균을 구한다. median(): 수치 변수의 중위수를 구한다. sd(): 수치 변수의 표준편차를 구한다. var(): 수치 변수의 분산을 구한다. min(): 수치 변수의 최소값을 구한다. max(): 수치 변수의 최대값을 구한다. quantile(변수, probs): 수치 변수의probs` 분위수를 구한다. 다음은 도심 연비의 데이터 수, 평균, 중위수, 최소값, 최대값을 구한 결과이다. &gt; summarize(b, count=n(), mean=mean(cty), med=median(cty), min=min(cty), max=max(cty)) # A tibble: 1 x 5 count mean med min max &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; 1 8 18.9 19.5 16 21 7.9 group_by()로 그룹 별로 요약하기 group_by(데이터프레임, 그룹기준변수1, 그룹기준변수2, ...) group_by() 함수는 기준이 되는 변수의 구분되는 값에 따라 데이터를 그룹화한다. 그룹화된 결과를 summarize() 함수에 전달하면 그룹별로 요약된 결과를 출력한다. &gt; byModel &lt;- group_by(b, model) &gt; summarize(byModel, count=n(), mean=mean(cty), sd=sd(cty)) `summarise()` ungrouping output (override with `.groups` argument) # A tibble: 2 x 4 model count mean sd &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 sonata 3 20.3 1.15 2 tiburon 5 18 1.87 변수를 여러 개를 조합하여 그룹화를 할 수도 있다. &gt; byModel &lt;- group_by(a, model, cyl) &gt; summarize(byModel, count=n(), mean=mean(cty)) `summarise()` regrouping output by &#39;model&#39; (override with `.groups` argument) # A tibble: 4 x 4 # Groups: model [2] model cyl count mean &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 sonata 4 2 21 2 sonata 6 1 19 3 tiburon 4 2 20 4 tiburon 6 3 16.7 7.10 %&gt;% 파이프 연산자 7.10.1 여러 단계를 거쳐 데이터를 변환할 때 mpg 데이터에서 조사 연도와 모델 별로 데이터 수와 도심 연비의 평균을 구한 후, 평균이 22 이상인 모델로 이루어진 행을 추출하려고 한다. 이를 수행하려면 다음처럼 변수를 이용하여 결과를 차례로 전달하거나, 함수를 결합하여 한 문장에 사용하여야 한다. &gt; byModel &lt;- group_by(mpg, model, year) &gt; meanCty &lt;- summarize(byModel, count=n(), mean=mean(cty)) `summarise()` regrouping output by &#39;model&#39; (override with `.groups` argument) &gt; filter(meanCty, mean &gt;= 22) # A tibble: 5 x 4 # Groups: model [3] model year count mean &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 civic 1999 5 24.8 2 civic 2008 4 24 3 corolla 1999 3 24.7 4 corolla 2008 2 27 5 new beetle 1999 4 26 &gt; filter(summarize(group_by(mpg, model, year), count=n(), mean=mean(cty)), mean &gt;= 22) `summarise()` regrouping output by &#39;model&#39; (override with `.groups` argument) # A tibble: 5 x 4 # Groups: model [3] model year count mean &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 civic 1999 5 24.8 2 civic 2008 4 24 3 corolla 1999 3 24.7 4 corolla 2008 2 27 5 new beetle 1999 4 26 전자는 불피요하게 중간 결과를 저장할 변수를 만들어야 하고, 후자는 복잡하여 이 명령이 무엇을 하는 명령어인지 쉽게 파악하기 힘들다. 또한 중첩된 괄호 때문에 오류가 발생하기 쉽다. 7.10.2 파이프 연산자 파이프 연산자는 데이터 변환이 여러 단계를 거칠 때 불필요한 변수의 생성 없이도 함수 간에 중간 데이터를 전달할 수 있게 해 준다. 파이프 연산자는 앞의 함수의 결과를 뒤 함수의 첫 번째 인수로 전달해 준다. 파이프 연산자를 사용할 때는 그러므로 첫 번째 인수는 생략하여 기술한다. 다음은 앞의 예와 동일한 예를 파이프 연산자를 사용하여 수행한 결과이다. &gt; mpg %&gt;% group_by(model, year) %&gt;% + summarize(count=n(), mean=mean(cty)) %&gt;% + filter(mean &gt;= 22) `summarise()` regrouping output by &#39;model&#39; (override with `.groups` argument) # A tibble: 5 x 4 # Groups: model [3] model year count mean &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 civic 1999 5 24.8 2 civic 2008 4 24 3 corolla 1999 3 24.7 4 corolla 2008 2 27 5 new beetle 1999 4 26 불필요하게 데이터를 기술하는 부분이 사라져서 각 단계에서 수행하는 작업이 무엇인지 명확하게 들어나고 불필요한 중간 변수를 만들지 않아도 되므로 파이프 연산자는 매우 편리하다. 그런데 파이프 연산자를 사용하려면 앞의 함수의 결과가 뒤의 함수의 첫 인수로 사용하기 적절한 형태이어야 한다. dplyr 패키지의 주요 함수들은 정돈 데이터 형식으로 데이터의 결과를 반환하고, 첫 인수가 정돈 데이터 형식의 데이터로 간주한다. 파이프 연산자를 사용할 때 주의할 점은 여러 줄로 명령을 기술할 때, 파이프 연산자로 중간 문장이 종료되어야 한다는 것이다. 그래야 아직 문장이 완료되지 않았다는 것을 이해하여 다음 단계의 명령이 입력되기를 기다린다. 다음처럼 기술하면 R은 명령 입력이 중간에 완료된 것으로 보고 잘못된 결과를 출력한다. &gt; b %&gt;% group_by(model) %&gt;% + summarize(count=n(), mean=mean(cty)) + %&gt;% filter(mean &gt;= 20) Error: &lt;text&gt;:3:3: unexpected SPECIAL 2: summarize(count=n(), mean=mean(cty)) 3: %&gt;% ^ 7.10.3 ungroup() 파이프 연산자를 사용하여 데이터를 전달하다 보면 데이터가 그룹화 된 것을 중간 단계에서 해제하고 싶을 때가 있다. 이 경우에는 ungroup() 명령을 사용한다. &gt; byModel &lt;- b %&gt;% group_by(model) &gt; byModel %&gt;% summarize(count=n()) `summarise()` ungrouping output (override with `.groups` argument) # A tibble: 2 x 2 model count &lt;chr&gt; &lt;int&gt; 1 sonata 3 2 tiburon 5 &gt; byModel %&gt;% ungroup() %&gt;% summarize(count=n()) # A tibble: 1 x 1 count &lt;int&gt; 1 8 반드시 필요한 작업은 아니다. 그렇지만 실행하는 것이 작업할 때 매우 편리하므로 필수적인 작업으로 생각하는 것이 좋다.↩︎ "],
["ch-visualization.html", "Chapter 8 ggplot2를 이용한 데이터 시각화 8.1 ggplot2 시작하기 8.2 도형의 속성에 데이터 열을 대응시키기 (aesthetic mapping) 8.3 ggplot 명령문을 입력할 때 자주 발생하는 문제들 8.4 측면(facets)으로 나누어 그리기 8.5 그래프 계층(layers)과 도형(geoms) 8.6 통계 변환 8.7 위치 조정 8.8 ggplot2 그래프의 종류 8.9 그래프의 외양 바꾸기 8.10 기타 유용한 팁들", " Chapter 8 ggplot2를 이용한 데이터 시각화 이 장에서는 ggplot2를 이용하여 데이터를 시각화하는 방법을 배운다. ggplot2 패키지는 tidyverse 패키지를 설치하였으면 자동으로 설치된다. 그리고 tidyverse 패키지를 적재하면 ggplot2 패키지도 자동 적재된다. &gt; library(tidyverse) ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ── ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 ✓ tibble 3.0.3 ✓ dplyr 1.0.2 ✓ tidyr 1.1.1 ✓ stringr 1.4.0 ✓ readr 1.3.1 ✓ forcats 0.5.0 ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── x dplyr::filter() masks stats::filter() x dplyr::lag() masks stats::lag() 8.1 ggplot2 시작하기 이 절에서는 ggplot2에서 제공하는 mpg 데이터를 이용하여 ‘배기량이 커지면 연비가 낮아지는가?’ 라는 물음을 그래프를 이용하여 탐색해 보자. mpg는 1999년과 2008년에 미국 EPA에서 조사하여 발표한 자동차 주요 모델별 연비 데이터이다. mpg 데이터에 대한 자세한 설명은 7.3 절의 mpg 데이터에 대한 설명이나 R 도움말을 참조하기 바란다. 8.1.1 ggplot2 그래프 그려보기 mpg 데이터로부터 배기량(displ)을 x 축으로, 고속도로 연비(hwy)를 y 축으로 하는 산점도를 그려보자. &gt; ggplot() + + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) 산점도에서 배기량이 커짐지면 연비가 줄어드는 경향을 관찰할 수 있다. 이 산점도를 그린 R 명령어는 두 개의 함수가 결합하여 실행되었다. ggplot(): ggplot2 그래프의 좌표축과 좌표평면을 만드는 함수이다. 뒤에서 살펴보겠지만 그래프에 공통된 데이터와 매핑을 설정할 수 있다. geom_point(): ggplot() 함수가 만들어 놓은 좌표평면 위에, 점이라는 도형을 이용하여 그래프를 그린다. 각 geom 함수의 그래프는 좌표평면 상에서 별도의 층으로 구성된다. ggplot2의 명령문을 입력할 때 여러 함수를 합쳐서 실행하기 위하여 + 연산자를 이용한다. dplyr 패키지의 파이프 연산자와 유사한 역할을 한다. 그러나 문법이 다르기 때문에 ggplot2 명령어 들 사이에는 + 연산자를 사용하여야 한다. 앞의 예에서는 geom_point() 함수의 data와 mapping이라는 인수를 설정하였다. data: 도형으로 표현할 데이터 프레임을 지정한다. mapping: 도형의 시각적 속성과 data에 지정된 데이터 프레임의 열을 쌍으로 대응시킨다. aes() 함수 내에 &lt;도형의 속성&gt;=&lt;데이터 열 이름&gt;의 형식으로 기술된다. 앞의 예에서 점의 x-축 위치에 displ 열이, y-축 위치에 hwy 열이 쌍으로 대응되었다. ggplot2에는 점을 그리는 geom_point() 함수뿐 아니라 다양한 도형을 그리는 geom 함수들이 있다. 이 함수들은 모두 data와 mapping이라는 인수를 가지고 있다. 8.2 도형의 속성에 데이터 열을 대응시키기 (aesthetic mapping) 앞의 산점도에서 배기량에 따라 연비가 줄어드는 관계를 조금 벗어나는 관측치들이 있다. 이 예외적인 관측치들이 자동차 종류의 차이 때문에 발생했다, 라고 가설을 세웠다 하자. 이 가설을 확인해 보려면 자동차 종류별로 관측치를 시각화할 필요가 있다. 앞서 본 geom_point() 함수는 ’점’이라는 도형을 좌표평면 상에서 그린다. 점이라는 도형은 x-축의 위치(x)와 y-축의 위치(y)뿐 아니라 색상(color), 모양(shape), 크기(size), 투명도(alpha) 등의 다른 시각적 속성을 가지고 있다. 우리는 이러한 속성 중 하나에 mpg 데이터의 class 열을 대응시켜 자동차 종류 별로 좌표평면에서 시각적으로 구분되는 점으로 표현할 수 있다. 8.2.1 색상(color) 속성 다음은 관측치의 종류(class)에 따라 점을 서로 다른 색상(color)으로 표현한 예이다. 자동차의 종류에 따라 점이 다른 색상으로 표현되고, 어떤 색상이 어떤 자동차 종류에 대응되었는지에 대한 범례가 자동 생성된다. &gt; ggplot() + + geom_point(mapping=aes(x=displ, y=hwy, color=class), data=mpg) 앞선 그래프에서 이상치로 표현되었던 점들 중 한 점만 제외하고 모두 2seater 자동차의 관측치였음을 알 수 있다. 이 종류의 차는 스포츠카로 배기량에 비해 가벼운 몸체를 가지고 있어 예외적인 연비가 관측된 것으로 보인다. 다음으로 class 열을 shape, size, alpha 등의 속성에 대응시켜 어떤 결과가 나오는지 살펴보자. 8.2.2 모양(shape) 속성 결과에서 보듯이 shape은 최대 6개의 점 모양으로만 구분하여 데이터를 표시하여 suv 데이터를 표시하지 못하였다. &gt; ggplot() + + geom_point(mapping=aes(x=displ, y=hwy, shape=class), data=mpg) Warning: The shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate; you have 7. Consider specifying shapes manually if you must have them. Warning: Removed 62 rows containing missing values (geom_point). 8.2.3 크기(size)와 투명도(alpha) 속성 size와 alpha는 모든 자동차 종류를 구분하여 표시를 해주지만 이산형 데이터를 표시하기에는 적절하지 않아서 관련된 경고 메시지를 표시한다. 왜냐하면 점의 크기와 투명도는 연속적인 값을 가지는 속성이기 때문이다. &gt; ggplot() + + geom_point(mapping=aes(x=displ, y=hwy, size=class), data=mpg) Warning: Using size for a discrete variable is not advised. &gt; ggplot() + + geom_point(mapping=aes(x=displ, y=hwy, alpha=class), data=mpg) Warning: Using alpha for a discrete variable is not advised. 점의 크기와 투명도에 연속형 수치 변수인 도심연비(cty)를 대응시키면 경고 메시지가 나오지 않음을 볼 수 있다. 대체로 고속도로 연비가 좋은 차의 점의 크기가 크고, 더 진해지는 경향이 있음을 볼 수 있다. &gt; ggplot() + + geom_point(mapping=aes(x=displ, y=hwy, size=cty), data=mpg) &gt; ggplot() + + geom_point(mapping=aes(x=displ, y=hwy, alpha=cty), data=mpg) 8.2.4 도형의 여러 속성에 데이터 열을 대응시키기 도형의 여러 속성에 데이터의 한 열을 대응시킬 수도 있다. 다음 예에서는 구동방식(drv)에 따라 점의 모양과 색상을 다르게 표시하였다. 아울러 어떤 구동방식이 어떤 색상과 모양의 점으로 표현되었는지에 대한 범례도 자동 생성되었다. &gt; ggplot() + + geom_point(mapping=aes(x=displ, y=hwy, color=drv, shape=drv), data=mpg) 그래프에서 보듯이 예외적인 관측치를 구동방식의 차이로 설명하기는 어려워 보인다. 예외적인 관측치의 대부분이 후륜구동(r)이긴 하지만 주류적인 연비 경향 안에 포함되어 있는 후륜구동 관측치들도 많기 때문이다. 위의 예에서 color와 shape 속성에 각각 다른 데이터 열을 매핑할 수도 있다. &gt; ggplot() + + geom_point(mapping=aes(x=displ, y=hwy, color=class, shape=drv), data=mpg) 8.2.5 도형 속성에 데이터 열을 매핑하기 - 예제 지금까지 x-축과 y-축을 배기량(displ)과 고속도로 연비(hwy) 열로만 매핑하였다. 다음처럼 도심 연비(cty)와 고속도로 연비(hwy)의 관계를 보기 위하여 x-축과 y-축에 이 두 데이터 열을 매핑하여 그래프를 그릴 수도 있다. &gt; ggplot() + + geom_point(mapping=aes(x=cty, y=hwy, color=drv, shape=drv), data=mpg) iris 데이터는 붓꽃에 대한 데이터이다. &gt; head(iris) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5.0 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa 다음은 iris 데이터의 Sepal.Length와 Sepal.Width를 점의 x-축과 y-축 속성에 매핑하고, 색상과 모양 속성에 Species 열을 매핑한 예이다. &gt; ggplot() + + geom_point(mapping=aes(x=Sepal.Length, y=Sepal.Width, color=Species, shape=Species), data=iris) 8.2.6 도형의 속성에 대응시키기 vs. 도형의 속성 인수를 설정하기 마지막으로 데이터를 도형의 속성으로 대응시키기와 도형의 속성 인수를 설정하기의 차이를 살펴보자. 8.2.6.1 도형의 속성 인수 설정하기 지금까지는 점의 속성에 데이터의 열을 대응시켜 관측치의 값에 따라 점이 시각적으로 다르게 표현되도록 하였다. 그런데 데이터와 무관하게 점의 속성을 특정한 값으로 설정할 수도 있다. 다음은 산점도 점을 모두 파란색으로 지정한 예이다. &gt; ggplot() + + geom_point(mapping=aes(x=displ, y=hwy), data=mpg, color=&quot;blue&quot;) 이처럼 도형의 어떤 속성을 특정한 값으로 지정하는 것을 도형의 속성 인수를 설정한다고 한다. 이 경우 도형의 시각적 속성의 변화는 데이터와는 무관하며, 그렇기 때문에 mapping 인수의 aes() 함수 내에 정의되지 않는다. 대신 aes() 바깥에 별도의 geom 함수의 인수로서 설정된다. 도형의 속성 인수를 설정할 때, 설정되는 값은 인수에 따라 다르다. color 인수: 색상의 이름이 문자열로 부여된다. 부여할 수 있는 생상의 이름을 확인하려면 colors() 함수를 실행해 본다. size 인수: 점의 크기가 mm 단위로 설정된다. shape 인수: 표시할 문자를 직접 설정할 수도 있고, 0에서 24까지의 숫자로도 지정할 수 있다. 다음은 color=\"red\"와 fill=\"blue\"로 인수가 설정되었을 때 shape 인수의 값에 따라 점의 모양을 보여준다. 8.2.6.2 도형의 속성 인수를 속성 대응시키기에 잘못 설정하는 경우 ggplot2의 초보자가 가끔 도형의 속성을 데이터의 열에 대응시키기와 도형의 속성 인수를 설정하는 것을 혼동할 때가 있다. 다음처럼 color=\"blue\"의 인수 설정을 aes() 안에 기술하면 어떻게 될까? 실제 이를 실행해 보면 점들이 파란색이 아니라 빨간색으로 표시되는 것을 볼 수 있다. &gt; ggplot() + + geom_point(mapping=aes(x=displ, y=hwy, color=&quot;blue&quot;), data=mpg) aes() 함수 안에 설정되었기 때문에 ggplot은 color=\"blue\"를 color 속성에 “blue”라는 하나의 값을 가진 열이 대응된 것으로 간주한다. 그러므로 이 값에 적절한 색-이 예에서는 빨간색-을 대응시켜 점을 표시한 후, 범례에 blue라는 값이 빨간색으로 대응되었음을 표시하였다. 따라서 도형 속성을 데이터 열에 대응시키기와 도형의 속성 인수를 설정하는 것을 구분하여 사용하지 않으면 이렇듯 엉뚱한 결과를 얻을 수 있으므로 주의가 필요하다. 8.2.7 group 속성 geom 도형의 대부분의 속성은 도형의 시각적 표현을 직접적으로 변화시키는 속성들이다. 대표적인 예가 x, y, color, shape, size, fill 등의 속성이다. 이러한 속성은 시각적으로 효과가 직접적으로 들어나므로 이해하기 쉽다. 반면 group 속성은 도형의 시각적 속성을 직접 변형하는 것이 아니라, 도형을 그릴 때 데이터를 어떤 식으로 그룹으로 묶어 사용할지만 지정한다. 이를 통해 그래프의 전체 모양에 영향을 준다. geom_point() 함수는 관측치 하나에 점 하나를 대응시켜 그래프를 그린다. 그러나 어떤 geom 함수는 여러 관측치를 그룹으로 묶어서 하나의 도형을 그린다. 대표적인 예가 geom_line()과 geom_smooth() 함수이다. 이 함수들은 여러 관측치를 사용하여 하나의 선을 완성한다. 만약 group 속성이 매핑되어 있지 않으면 모든 데이터를 하나의 그룹으로 하여 선 하나를 그린다. 반면 group 속성이 매핑되면, group속성에 매핑된 값을 기준으로 데이터를 그룹화하여 각각 도형 하나(geom_line()과 geom_smooth() 함수에서는 선 하나)를 그린다. 지금 설명한 내용을 예를 들어 살펴보자. 8.2.8 그룹으로 나누어 선 그래프 그리기 Orange 데이터는 5 그루의 나무에서 age(나이: 일)와 circumference(둘레: mm)을 측정한 결과이다. Tree 변수는 5그루 나무에 붙인 일련번호이다. &gt; Orange Tree age circumference 1 1 118 30 2 1 484 58 3 1 664 87 4 1 1004 115 5 1 1231 120 6 1 1372 142 7 1 1582 145 8 2 118 33 9 2 484 69 10 2 664 111 11 2 1004 156 ...... 다음은 age와 circumference를 x와 y aesthetics에 매핑한 그래프이다. &gt; ggplot() + geom_point(mapping=aes(x=age, y=circumference), data=Orange ) 이번에는 위와 동일한 매핑으로 geom_line()을 그려보자. geom_line()은 x좌표가 작은 것에서 큰 것 순으로 점을 연결하여 하나의 선을 완성한다. &gt; ggplot() + geom_line(mapping=aes(x=age, y=circumference), data=Orange ) 동일한 나이 대의 데이터가 많아서 하나의 선으로 연결한 그래프가 의미를 갖기 어려워 보인다. 이번에는 group 속성에 Tree 변수를 매핑해 보자. 데이터가 Tree의 값에 따라 그룹으로 묶여 선이 각각 그려졌음을 확인할 수 있다. &gt; ggplot() + geom_line(mapping=aes(x=age, y=circumference, group=Tree), data=Orange ) 8.2.9 이산형 변수는 group 속성으로 자동 매핑된다. 각 나무의 데이터를 구분해 보기 위하여 다음처럼 color 속성을 추가해 보자. Tree 변수는 순서형 범주 데이터로 이산형 데이터이므로, color가 뚜렷이 구분되는 색으로 매핑되었다. 그리고 수준의 순서에 따라 범례도 정렬되었다. &gt; Orange$Tree [1] 1 1 1 1 1 1 1 2 2 2 2 2 2 2 3 3 3 3 3 3 3 4 4 4 4 4 4 4 5 5 5 5 5 5 5 Levels: 3 &lt; 1 &lt; 5 &lt; 2 &lt; 4 &gt; ggplot() + + geom_line(mapping=aes(x=age, y=circumference, group=Tree, color=Tree), data=Orange ) 그런데 이를 좀 더 간편히 할 수 있는 방법이 있다. ggplot2는 속성에 매핑된 변수 중에 이산형 변수가 있으면 이를 group 속성에 자동으로 매핑시킨다. 다음처럼 color 속성에 Tree를 매핑만 하면, 자동으로 이를 group 속성에 반영하여 선을 구분하여 그려준다. &gt; ggplot() + + geom_line(mapping=aes(x=age, y=circumference, color=Tree), data=Orange ) 다음 예는 linetype 속성으로 각 나무를 구분한 예이다. &gt; ggplot() + + geom_line(mapping=aes(x=age, y=circumference, linetype=Tree), data=Orange ) 8.2.10 geom_smooth() 함수에서 group 속성 group 속성이 이용되는 또 다른 예가 geom_smmooth() 함수이다. 이 함수는 group에 매핑된 정보에 따라 데이터를 그룹화하여 추세선을 그린다. &gt; ggplot() + + geom_smooth(mapping=aes(x=age, y=circumference), data=Orange ) `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; &gt; ggplot() + + geom_smooth(mapping=aes(x=age, y=circumference, color=Tree), data=Orange ) `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; &gt; ggplot() + + geom_smooth(mapping=aes(x=age, y=circumference, color=Tree), data=Orange, se=F) `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 마지막 예에서는 geom_smooth() 함수의 se 인수를 FALSE로 설정하여 신뢰구간이 표시되지 않도록 하였다. 8.3 ggplot 명령문을 입력할 때 자주 발생하는 문제들 ggplot은 매우 강력한 기능을 가지고 있지만 Excel 등의 GUI 프로그램에만 익숙한 사람은 문자 기반 명령어를 입력하는 것에 어려움을 느낄 수 있다. 컴퓨터는 사람만큼의 유연성을 발휘하지 못하므로 컴퓨터는 자신이 실행해야 할 명령문의 문법에 매우 까다롭게 반응한다. ggplot 명령어 입력시 흔히 발생하는 문제들은 다음과 같다. R 명령문은 대소문자를 구분한다. 따라서 Color와 color는 ggplot에서 서로 다른 인수로 인식되어 오류가 발생한다. ggplot 명령문의 키워드의 철자가 틀리면 다른 키워드로 간주하기 때문에 오류가 발생할 수 있다. 이를 방지하려면 키워드의 일부만 입력한 후 Tab 키를 눌러 자동완성 기능을 사용하여 입력하는 것을 권장한다. ggplot2의 명령문을 입력할 때 여러 함수를 합쳐서 실행하기 위하여 + 연산자를 이용한다.7 ggplot2의 명령문이 길어지면 명령문을 여러 줄로 쓰는 것이 필요한데, 보통 +로 연결되는 곳에서 줄바꿈하는 것이 읽기에 좋다. 이 때 주의할 점이, 줄바꿈을 + 앞이 아니라 뒤에서 해야 한다는 것이다. + 앞에서 하면 R은 명령문의 입력이 완성된 것으로 간주하기 때문이다. R 명령문이 조금 길어지면 가장 흔하게 발생하는 실수가 ( )와 \" \"을 짝을 맞추어 제대로 입력하지 못하는 것이다. ggplot2의 명령문도 많은 함수를 사용하다 보니 이를 주의하여야 한다. R 콘솔은 명령이 계속 입력 중이라고 생각하여 &gt;가 아니라 +를 콘솔의 프롬프트로 표시한다. 이 경우 가장 간단한 해결책은 Esc 키를 눌러 명령 입력에서 빠져나와 다시 명령문을 입력하는 것이다. 8.4 측면(facets)으로 나누어 그리기 8.2 장에서 배기량과 고속도로 연비의 산점도를 자동차 종류에 따라 분리하여 살펴보기 위해 점의 시각적 속성 중 하나에 자동차 종류를 대응시켰다. 원래의 그래프를 또 다른 변수의 측면에서 세분화하여 살펴보는 방법으로는 도형의 다른 속성에 해당 변수를 대응시키는 것 말고도 해당 변수값에 따라 데이터를 나누어 각각에 대한 그래프를 그려볼 수도 있다. ggplot2에서는 이러한 방식으로 그래프를 그리는 것을 측면(facets)으로 나누어 그래프를 그린다고 한다. 8.4.1 facet_wrap()로 일차원 측면 그래프 그리기 다음은 facet_wrap() 함수의 사용법을 보여준다. ~ 은 R에서 수식을 표현할 때 사용되는데, facet_wrap() 함수는 수식을 인수로 입력받는다. facet_wrap() 함수는 ~ 우변에 기술된 변수를 측면(facets)으로 하여 데이터를 나누어 그래프를 그린다. 이 때 측면(facets)으로 사용되는 변수는 범주형 데이터이어야 한다. facet_wrap()은 부분 그래프가 많아지면 줄바꿈하여 그래프를 표시한다. ncol이나 ncol을 설정하면 그래프의 행과 열의 수를 지정하여 줄바꿈 처리를 제어할 수 있다. &gt; ggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) + + facet_wrap(~class, nrow = 2) 두 개 이상의 변수를 조합하여 측면을 만드려면 다음처럼 수식의 우변에 두 개의 변수를 +로 연결하여 기술하면 된다. &gt; ggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) + + facet_wrap(~drv + year, nrow = 2) 8.4.2 facet_grid()로 이차원 측면 그래프 그리기 원래 그래프를 두 변수의 측면에서 나누어 그리기를 하려면 facet_grid()를 사용하는 것이 좋다. facet_grid()도 수식은 인수로 입력 받는데, 수식의 좌변과 우변에 데이터의 변수를 지정할 수 있다. 그러면 수식의 좌변에 기술된 변수를 그래프의 행으로, 우변에 기술된 변수를 그래프의 열로 하여 측면 그래프를 그린다. &gt; ggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) + + facet_grid(drv~cyl) facet_wrap() 함수와 마찬가지로 수식의 좌변과 우변에 +로 하나 이상의 변수를 지정할 수 있다. &gt; ggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) + + facet_grid(drv+year~cyl) 8.5 그래프 계층(layers)과 도형(geoms) ggplot2의 장점은 필요에 따라 다양한 형식의 그래프를 쉽게 만들 수 있고, 만들 수 있는 형식도 무궁무진하다는데 있다. 그리고 ggplot2 그래프의 계층적 구조가 이러한 무궁무진한 그래프 형식을 만들어 내는 핵심 요소라 할 수 있다. 8.5.1 geom 함수의 순서와 그래프 계층 ggplot2는 좌표평면 위에 여러 계층으로 그래프를 그려서 하나의 좌표평명에 나타냄으로써 복잡한 형식의 그래프를 만들어 낼 수 있다. 다음 두 그래프에서는 배기량과 고속도로 연비의 산점도와 추세선을 각각 그렸다. &gt; ggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) &gt; ggplot() + geom_smooth(mapping=aes(x=displ, y=hwy), data=mpg) `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 위의 두 그래프는 다음처럼 한 좌표평면 위에 겹쳐서 그릴 수 있다. ggplot2에서 서로 다른 geom 함수는 서로 다른 도형-앞의 예는 점과 추세선-을 그래프에 표시한다. ggplot() 함수가 여러 개의 geom 함수와 연결되면, 하나의 좌표평면에 각각의 geom() 함수의 결과를 층층이 그린다. 이 때, 명령문에 나타나는 순서에 따라 첫번째 나온 geom 함수의 도형이 가장 아래 계층에, 다음에 나오는 geom 함수의 도형이 차례로 그 윗 계층에 그려진다. &gt; ggplot() + + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) + + geom_smooth(mapping=aes(x=displ, y=hwy), data=mpg) `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 8.5.2 ggplot() 함수는 좌표축을 자동 조정한다. 만약 위의 그래프에 배기량과 도심연비의 산점도와 추세선을 겹쳐서 표시하려면 다음처럼 네 계층으로 이루어진 그래프를 그린다. ggplot() 함수가 데이터에 따라 좌표평면의 범위를 자동적으로 조정하는 것을 볼 수 있다. &gt; ggplot() + + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) + + geom_smooth(mapping=aes(x=displ, y=hwy), data=mpg) + + geom_point(mapping=aes(x=displ, y=cty), data=mpg, col=&quot;red&quot;, shape=1) + + geom_smooth(mapping=aes(x=displ, y=cty), data=mpg, linetype=2, col=&quot;red&quot;) `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 8.5.3 여러 데이터를 사용하여 그래프 계층 만들기 지금까지는 동일한 데이터(data)에 대해서 geom 함수들이 그래프를 그렸다. 그러나 사실 각 계층의 geom 함수가 이용할 data와 mapping을 독립적으로 설정할 수 있다. 다음 예는 mpg 데이터와 함께 R의 기본 패키지에서 제공하는 iris 데이터를 사용하여 그래프를 그려보자. &gt; head(iris) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5.0 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa iris 데이터는 꽃받침의 길이(‘Sepal.Length’)와 폭(‘Sepal.Width’) 열을 가지고 있는데, 이 두 열의 산점도를 앞의 그래프에 겹쳐서 그려보았다. &gt; ggplot() + + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) + + geom_smooth(mapping=aes(x=displ, y=hwy), data=mpg) + + geom_point(mapping=aes(x=displ, y=cty), data=mpg, col=&quot;red&quot;, shape=1) + + geom_smooth(mapping=aes(x=displ, y=cty), data=mpg, linetype=2, col=&quot;red&quot;) + + geom_point(mapping=aes(x=Sepal.Length, y=Sepal.Width), data=iris, col=&quot;orange&quot;) `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 물론 이 그래프는 배기량과 꽃받침의 길이를 같은 x-축으로, 고속도로 연비와 꽃받침의 폭을 같은 y-축으로 그래프를 그렸으므로 억지스러운 측면이 있다. 단지 아주 별개의 데이터를 동시에 사용해서 하나의 그래프를 그릴 수 있다는 것을 보여주기 위해 그린 그래프일 뿐이다. 그러나 이 예에서 다음 사실을 확인할 수 있다. 첫째, 서로 다른 데이터를 사용해도 좌표평면이 자동으로 조정되어 모든 계층의 도형이 모두 적절히 표시된다. 둘째, 아울러 축의 이름은 첫 계층의 geom 함수의 x와 y로 대응된 변수가 자동으로 선택된다. 뒤에서 보겠지만 labs() 함수 등을 사용하면 축의 이름을 자유롭게 변경할 수 있다. 8.5.4 다른 데이터 범위로 그래프 계층 만들기 8.2 절을 시작할 때, 주경향에서 벗어난 점들을 더 큰 빨간색 점으로 표현한 그래프를 보았을 것이다. 이 그래프는 어떻게 그렸을까? 답은 7.4 절에서 설명한 filter() 함수를 이용하여 예외적인 경향의 데이터만 뽑아낸 후, 이 데이터를 가지고 별도의 산점도를 그리는 것이다. 이 데이터를 이용해서 그린 산점도가 마지막 그래프 계층에 그려졌으므로 빨간 점이 원래의 검은 점 위에 그려진다. (8.2 절에 그래프가 있으니 여기서는 결과는 생략한다.) 8.5.5 공통 data와 mapping의 설정 지금까지 geom 함수에 data와 mapping 인수를 각각 설정하였다. 그런데 공통된 data와 mapping을 사용하여 여러 층으로 그래프를 겹쳐 그리는 경우, 이러한 방식으로 data와 mapping을 일일이 설정하는 것은 귀찮을 뿐 아니라 명령문의 오류 가능성을 증가시키고 변경을 어렵게 만든다. 8.5.5.1 ggplot() 함수에 공통 데이터와 매핑 설정하기 ggplot() 함수는 좌표평면을 생성하는 기능뿐 아니라, 그래프 계층에 공통된 data와 mapping을 설정하는 기능도 가지고 있다. 다음 예에서는 배기량과 고속도로 연비의 산점도와 추세선을 공통된 data와 mapping 설정을 이용하여 그렸다. 주의할 점은 data와 mapping 인수의 위치가 geom 함수와 ggplot() 함수에서 반대라는 것이다. &gt; ggplot(data=mpg, mapping=aes(x=displ, y=hwy)) + + geom_point() + geom_smooth() `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 위와 같은 형식으로 명령문을 구성하면, 다음처럼 한 군데만 변경하면 고속도로 연비가 아니라 도심 연비로 산점도와 추세선을 그릴 수 있어 편리하다. (그래프는 지면 제한으로 생략하였다.) &gt; ggplot(data=mpg, mapping=aes(x=displ, y=cty)) + + geom_point() + geom_smooth() 8.5.5.2 geom 함수에서 데이터와 매핑의 재정의 ggplot() 함수에 data와 mapping 인수가 정의되어 있어도, geom 함수에 이를 재지정할 수 있다. 이 경우 각 geom 함수에서 사용하는 data와 mapping은 다음 규칙에 의해 결정된다. geom 함수는 ggplot() 함수에 설정된 data와 mapping을 상속받아 그래프를 그린다. 만약 geom 함수에 data 인수가 설정되면 ggplot() 함수에 설정된 data는 무시된다. 만약 geom 함수에 mapping 인수가 설정되면 ggplot() 함수에 설정된 mapping에 geom 함수에 설정된 mapping이 추가된다. 만약 동일한 도형 속성에 대한 정의가 두 군데 나타나면 geom 함수의 설정이 사용된다. 따라서 배기량과 고속도로 연비의 산점도와 추세선에 배기량과 도심 연비의 추세선을 더한 그래프는 다음 명령으로도 그릴 수 있다. (그래프는 지면 제한으로 생략되었다.) &gt; ggplot(data=mpg, mapping=aes(x=displ, y=hwy)) + + geom_point() + geom_smooth() + + geom_point(mapping=aes(y=cty), col=&quot;red&quot;, shape=1) + + geom_smooth(mapping=aes(y=cty), linetype=2, col=&quot;red&quot;) 8.5.5.3 ggplot()과 geom 함수에서 대표 인수의 이름을 생략하기 지금까지 공통 데이터와 매핑을 ggplot() 함수에 기술하여 명령문을 단순화하였다. 그런데 이 명령문들은 더 단순화할 수 있다. R 함수에서 인수를 인수의 순서대로 입력하는 경우에는 인수의 이름을 굳이 표시하지 않아도 된다. ggplot() 함수의 처음 두 인수는 차례로 data와 mapping이고 모든 geom 함수의 처음 두 인수는 차레로 mapping과 data이다. 또한 aes() 함수의 처음 두 인수는 x와 y이다. 따라서 이 정보를 사용하면 위 명령어는 다음처럼 단순해 진다. 주의할 점은 마지막 점과 추세선 geom 함수의 aes() 함수에서는 y만 나오므로 인수 이름을 사용하였다. &gt; ggplot(mpg, aes(displ, hwy)) + + geom_point() + geom_smooth() + + geom_point(aes(y=cty), col=&quot;red&quot;, shape=1) + + geom_smooth(aes(y=cty), linetype=2, col=&quot;red&quot;) 아울러 다음 세 그래프를 비교해 보자. 첫 번째 그래프에서는 배기량과 고속도로 연비의 산점도와 추세선를 구동방식(drv)에 따라 다른 색으로 표현하였다. 두 번째 그래프는 점은 구동방식에 따라 다른 색으로 표현하였지만 추세선은 모든 데이터에 대하여 하나만 그려지도록 하였다. 세 번째 그래프는 두 번째 그래프에서 추세선을 자동차 종류가 subcompact인 데이터에 대해서만 그려지도록 하였다. 이를 위해 뒤에서 설명할 filter 함수를 이용하여 mpg 데이터에서 class 변수가 subcompact인 관측치만 선택하여 새로운 데이터를 만들어 geom_smooth() 함수의 data 인수에 사용하였다. 세 그래프의 차이를 비교해 보라. &gt; ggplot(mpg, aes(displ, hwy, col=drv)) + geom_point() + geom_smooth() `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; &gt; ggplot(mpg, aes(displ, hwy)) + geom_point(aes(col=drv)) + geom_smooth() `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; &gt; ggplot(mpg, aes(displ, hwy)) + geom_point(aes(col=drv)) + + geom_smooth(data=filter(mpg, class==&quot;subcompact&quot;)) `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 8.6 통계 변환 8.6.1 범주형 변수의 통계 요약 ggplot2 패키지의 diamonds는 약 54,000개의 다이아몬드에 대한 다음 정보를 측정한 데이터이다. caret: 다이아 몬드 무게 cut: 가공의 품질. Fair, Good, Very Good, Premium, Ideal color: 색상. D(최상)에서 F(최하)까지 clarity: 투명도. I1(최하), SI2, SI1, VS2, VS1, VVS2, VVS1, IF(최상) x, y, z: 길이, 폭, 깊이 depth: 깊이 비율 = z / mean(x, y) table: 최대폭 대비 윗면의 폭의 길이 비율 &gt; diamonds # A tibble: 53,940 x 10 carat cut color clarity depth table price x y z &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39 # … with 53,930 more rows 다이아몬드의 가공의 품질(cut) 수준에 따른 빈도를 시각화해 보자. 현재 cut의 수준별 빈도수에 대한 데이터가 없기 때문에 먼저 이 데이터를 구하기 위한 통계적 변환을 수행해야 한다. 이를 위해 뒤에 설명할 dplyr 패키지의 summarize() 함수를 이용하였다. &gt; cut_table &lt;- diamonds %&gt;% + group_by(cut) %&gt;% + summarize(n=n()) `summarise()` ungrouping output (override with `.groups` argument) &gt; cut_table # A tibble: 5 x 2 cut n &lt;ord&gt; &lt;int&gt; 1 Fair 1610 2 Good 4906 3 Very Good 12082 4 Premium 13791 5 Ideal 21551 그리고 geom_col() 함수를 이용하여 막대 그래프를 그린다. geom_col() 함수는 막대라는 도형을 그리는 geom 함수로 x 값의 위치에 y에 매핑된 값을 높이로 가지는 막대를 그린다. &gt; ggplot(cut_table) + geom_col(aes(x=cut, y=n)) 그런데 geom 함수의 stat 인수를 이용하면 원래 데이터를 통계 요약하여 그래프를 그리는 과정을 사용자의 개입없이 쉽게 수행할 수 있다. &gt; ggplot(diamonds) + geom_bar(aes(x=cut), stat=&quot;count&quot;) 그림 8.1는 geom_bar() 함수에서 stat 인수가 어떻게 작동하는지를 보여준다. geom_bar() 함수는 stat 인수에 \"count\"가 설정되면 stat_count() 함수를 사용하여 원래 데이터를 통계 요약한다. stat_count()는 x에 맵핑된 열을 수준(level; 구분되는 값) 별로 절대적 빈도와 상대적 빈도를 계산하여 count와 prop라는 열을 가지는 요약 데이터를 만든다. 그리고 이 요약 데이터를 이용하여 x-축에 원래 변수의 수준을, y-축에 count 변수를 맵핑하여 막대 그래프를 그린다. Figure 8.1: stat의 작동 방식 (출처: R for Data Science) 사실 geom_bar() 함수의 디폴트 stat는 \"count\"이기 때문에, stat를 생략하여도 같은 결과를 얻을 수 있다. &gt; ggplot(diamonds) + geom_bar(aes(x=color)) stat_count()가 요약한 데이터에서 절대 빈도수 count가 아니라 상대 빈도수 prop을 사용하여 그래프를 그리려면 y=..prop..을 mapping에 추가하여야 한다. stat가 생성한 요약 데이터의 열을 지정할 때는 ..&lt;요약 변수 이름&gt;.. 형식으로 지정을 한다. 그래야 원래 데이터가 아니라 요약 데이터에서 해당 열을 찾아 매핑을 한다. 상대 빈도는 group 속성에 따라 계산을 하는데, 전체 데이터를 대상으로 상대 빈도를 구하기 위해 모든 데이터가 동일한 그룹이 되도록 group=1로 설정을 하였다.8 &gt; ggplot(diamonds) + geom_bar(aes(clarity, ..prop.., group=1)) 8.6.2 수치형 변수의 통계 요약 carat 같은 연속형 변수에 geom_bar()를 적용하면 구별되는 모든 수치에 대해 빈도를 계산하여 막대를 그린다. 그러나 연속형 변수는 구별되는 값이 매우 많으므로 이렇게 만들어진 그래프로 데이터의 경향을 파악하긴 어렵다. &gt; ggplot(diamonds) + geom_bar(aes(carat)) 8.6.2.1 stat_bin()을 이용한 히스토그램 연속형 변수는 구분되는 값이 아니라 일정한 구간 별로 빈도를 계산하여 막대 그래프를 그리는 것이 더 적절하다. (이러한 그래프를 히스토그램이라고 한다.) stat 인수에 stat_bin()을 사용하면 x에 맵핑된 연속형 변수의 값을 구간으로 나누어 이러한 작업을 한다. &gt; ggplot(diamonds) + geom_bar(aes(carat), stat=&quot;bin&quot;) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 8.6.2.2 geom_histogram() 사실 stat_bin()을 디폴트 stat로 사용하는 geom 함수가 있다. geom_histogram()이 그 함수이다. geom_histogram()를 이용하면 다음처럼 연속형 변수에 대한 히스토그램을 그릴 수 있다. &gt; ggplot(diamonds) + geom_histogram(aes(depth)) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 그리고 bins 또는 binwidth 인수를 사용하면 구간의 수 또는 구간의 길이를 직접 지정하여 히스토그램을 그릴 수 있다. &gt; ggplot(diamonds) + geom_histogram(aes(table), bins=50) &gt; ggplot(diamonds) + geom_histogram(aes(price), binwidth=500) stat_bin()은 구간 별 절대 빈도수(count)뿐 아니라 구간의 밀도(density)와 빈도수와 밀도의 최대 값이 1이 되도록 규모를 변환한 ncount와 ndensity 변수도 생성한다. 그러므로 필요에 따라 이 값을 이용하여 히스토그램을 그림 수 있다. &gt; ggplot(diamonds) + geom_histogram(aes(x=x, y=..density..)) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. &gt; ggplot(diamonds) + geom_histogram(aes(x=y, y=..ncount..)) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. &gt; ggplot(diamonds) + geom_histogram(aes(x=z, y=..ndensity..)) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 8.6.3 수치형 변수의 범주별 통계요약 다이아몬드의 가격이 가공 품질에 따라 어떤 범위로 움지이는지 살펴보자. 이 때 유용한 geom 함수가 geom_boxplot()이다. geom_boxplot() 함수는 상자그림으로 수치 데이터를 표현한다. 이 함수는 stat로 stat_boxplot()을 디폴트로 사용한다. stat_boxplot()은 x에 매핑된 열의 수준 별로 y에 매핑된 데이터를 모아서 상자그림에 필요한 통계량을 계산한다. &gt; ggplot(diamonds) + geom_boxplot(aes(cut, price)) &gt; ggplot(diamonds) + geom_boxplot(aes(cut, carat), notch=T) 이 외에도 stat_summary()를 이용하면 연속형 변수 데이터를 범주별로 나누어 함수를 적용한 결과를 출력할 수 있다. &gt; ggplot(diamonds, aes(cut, depth)) + + geom_pointrange(stat=&quot;summary&quot;, fun.y=median, fun.ymax=max, fun.ymin=min) Warning: Ignoring unknown parameters: fun.y, fun.ymax, fun.ymin No summary function supplied, defaulting to `mean_se()` 8.7 위치 조정 geom_bar()는 막대의 색상과 관련된 fill, color, alpha라는 속성이 있는데, 각각 막대의 색, 막대 테두리 색, 막대 색의 투명도를 조정한다. 다음은 mpg 데이터에서 class별 빈도를 막대 그래프로 그린 예이다. fill 속성 인수에 남색을 부여하였다. &gt; ggplot(mpg, aes(class)) + geom_bar(fill=&quot;dark blue&quot;) &gt; ggplot(mpg, aes(class)) + geom_bar(color=&quot;dark blue&quot;) 앞의 막대 그래프는 class별로 데이터의 빈도를 구해 한 색상으로 막대를 그렸다. 이번에는 class 별 빈도에 대한 막대 그래프를 그리는데 fill 속성에 drv 열을 매핑하여 어떤 차이가 있는지 살펴보자. &gt; ggplot(mpg, aes(class)) + geom_bar(aes(fill=drv)) fill 속성에 drv라는 이산 변수가 매핑되자, 동일한 class 값이지만 서로 다른 drv의 값을 가지는 경우를 구분하여 다른 색상으로 막대를 그렸다. 그리고 동일한 class인데 drv 값이 다른 막대를 동일한 가록축에 층(stack)으로 쌓아 올렸다. 예를 들어 subcompact 클래스의 경우 drv가 4, f, r이 모두 있으므로 총 3개의 막대가 그려져야 한다. 그러나 이 3 막대는 모두 동일한 x 값을 가지므로 서로 겹치는 것을 피하기 위하여 쌓아 표현하였다. geom 함수에서 position 인수는 동일한 위치의 도형 객체를 어떻게 조화롭게 표현할지를 결정한다. 앞의 예에서는 geom_bar()의 position 인수의 디폴트 값은 \"stack\"이므로 같은 x 위치의 막대를 쌓아 표현하였다. 만약 같은 위치의 막대를 쌓아 표현하지 않고 옆으로 나란히 세워 표현하고 싶으면 postion 인수를 \"dodge\"로 설정한다. &gt; ggplot(mpg, aes(class)) + geom_bar(aes(fill=drv), position=&quot;dodge&quot;) geom 함수에 따라 취할 수 있는 position 인수의 값은 다를 수 있다. geom_bar()의 경우 \"stack\", \"dodge\", \"fill\" 그리고 \"identity\" 값을 가질 수 있다. (여기서 \"fill\"과 \"identity\"는 막대의 fill 속성이나 통계 요약 함수인 stat_identity()와는 상관없는 동일 위치의 도형의 위치 조정에 관한 값이다.) position인수가 \"fill\"이면, 막대의 전체 길이가 1이 되도록 조정하여 동일한 x의 값에서의 상대적 비율을 파악할 수 있게 해준다. &gt; ggplot(mpg, aes(class)) + geom_bar(aes(fill=drv), position=&quot;fill&quot;) position이 \"identity\"로 설정되면 동일한 위치에 겹쳐지는 geom 객체에 아무 조정도 하지 않는다. 앞과 동일한 예에서 position=\"identity\"로 설정해 보자. 모두 동일한 자리에 그려지므로 아래 그려진 막대가 가려지므로 막대의 윤곽선만 그리고 투명도를 조정하여 겹쳐진 막대를 확인할 수 있도록 하자. &gt; ggplot(mpg, aes(class)) + geom_bar(aes(col=drv), position=&quot;identity&quot;, alpha=0.1) 사실 \"identity\" position은 막대 그래프에서 별로 유용한 조정 방법이 아니다. 그러나 geom_frepoly() 등 빈도를 선으로 표현하는 geom 객체에는 매우 유용하다. &gt; ggplot(mpg, aes(hwy)) + geom_freqpoly(aes(color=drv), position=&quot;identity&quot;) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 사실 geom_freqpoly()는 \"identity\"를 position의 디폴트 값으로 가지므로 다음 명령어도 동일한 결과를 준다. &gt; ggplot(mpg, aes(hwy)) + geom_freqpoly(aes(color=drv)) 8.8 ggplot2 그래프의 종류 이 절에서는 ggplot2에서 그릴 수 있는 대표적인 그래프 종류를 하나씩 살펴본다. 그래프는 결국 데이터를 시각적 객체로 변환한 것이므로 그래프의 종류는 그래프가 어떤 geom 객체를 이용하는가에 따라 나눠 볼 수 있다. Table 8.1에는 그래프에서 자주 사용되는 geom 함수들이 제시되어 있다. Table 8.1: geom 함수 함수 도형 도형의.속성 geom_bar() Bar chart color, fill, alpha geom_boxplot() Box plot color, fill, alpha, notch, width geom_density() Density plot color, fill, alpha, linetype geom_histogram() Histogram color, fill, alpha, linetype, binwidth geom_hline() Horizontal lines color, alpha, linetype, size geom_jitter() Jittered points color, size, alpha, shape geom_line() Line graph color, alpha, linetype, size geom_point() Scatterplot color, alpha, shape, size geom_rug() Rug plot color, side geom_smooth() Fitted line method, formula, color, fill, linetype, size geom_text() Text annotations 많은 옵션이 있으므로 도움말 참조 geom_violin() Violin plot color, fill, alpha, linetype geom_vline() Vertical lines color, alpha, linetype, size 한편 그래프는 데이터에 대한 시각적 표현이므로 표현하려는 데이터의 형식에 따라 그래프를 구분해 볼 수도 있다. 데이터의 각 변수는 크게 수치형 변수와 범주형 변수로 나누어 볼 수 있다. 앞으로 우리는 그래프에서 표현하려는 데이터가 무엇인지에 따라 다음처럼 그래프를 분류하여 살펴보고자 한다. 하나의 범주형 변수를 나타내는 그래프 하나의 수치형 변수를 나타내는 그래프 두 개의 범주형 변수의 관계를 나타내는 그래프 하나의 범주형 변수와 하나의 수치형 변수의 관계를 나타내는 그래프 두 개의 수치형 변수의 관계를 나타내는 그래프 세 개 이상의 변수의 관계를 나타내는 그래프 이를 각각 살펴보기에 앞서 그래프에 단순한 선과 도형을 표현하는 기본 함수를 먼저 살펴보자. 8.8.1 기본 그래픽 함수 기본 그래픽 함수를 살펴보기 위해 mpg 데이터에 대한 도심 연비와 고속도로 연비를 나타내는 산점도 그래프를 고려해 보자. &gt; p &lt;- ggplot(mpg, aes(cty, hwy)) + geom_point() &gt; p 앞의 산점도에 도심 연비와 고속도로 연비의 평균을 나타내보자. ggplot2에서는 수평선은 geom_hline(), 수직선은 geom_vline() 함수로 그릴 수 있다. 다음은 geom_vline()으로 도심연비의 평균선을 나타낸 예이다. xintercept는 수직선이 지나가는 x축의 절편의 값이다. linetype 인수는 선의 종류를 결정하는 인수인데, 1은 실선, 2는 파선을 나타낸다. 이 외에도 다양한 linetype을 설정할 수 있으니 자세한 내용은 ??linetype을 이용하여 관련된 설명을 확인해 보길 바란다. &gt; p + geom_vline(xintercept = mean(mpg$cty), linetype=2, color=&quot;red&quot;) 다음으로 geom_hline()으로 고속도로 연비의 평균선을 그려보자. yintercept는 수평선이 지나가는 y 절편의 값이다. &gt; p1 &lt;- p + geom_vline(xintercept = mean(mpg$cty), linetype=2, color=&quot;red&quot;) + + geom_hline(yintercept = mean(mpg$hwy), linetype=2, color=&quot;red&quot;) &gt; p1 이렇게 그려 놓고 보면, 도심 및 고속도로 연비가 모두 평균 이상인 그룹과 어느 하나만 평균 이상인 그룹, 둘 다 평균 이하인 그룹을 구분해 볼 수 있다. 도심 연비와 고속도로 연비의 비율을 알기 위하여 기울기가 1이고 절편이 0인 직선을 그려보자. geom_abline()은 절편이 a, 기울기가 b인 직선을 그래프에 그려준다. 결과에서 확인하듯이 모든 차들이 도심 연비에 비해 고속도로 연비가 좋음을 확인할 수 있다. 아울러 두 연비의 비를 알아볼 수 있도록 scale 함수를 이용하여 좌표축의 범위를 동일하게 설정하였다(8.9 장 참조). &gt; p1 + geom_abline(a=0, b=1, linetype=3, color=&quot;blue&quot;) + + scale_x_continuous(limits = c(0, 45)) + + scale_y_continuous(limits = c(0, 45)) Warning: Ignoring unknown parameters: a, b 8.8.2 한 범주형 변수의 그래프 우리는 이미 geom_bar()를 이용하여 하나의 범주형 변수의 빈도에 대한 막대 그래프를 그리는 법을 보았다. 여기서는 범주형 변수의 막대 그래프 표현에 대하여 좀 더 자세히 살펴본다. 먼저 범주형 변수가 무엇인지 살펴보자. 범주형 변수란 변수의 값이 몇 개의 정해진 범주로 한정되는 변수라고 할 수 있다. 예를 들어 gender라는 변수가 어떤 수업의 수강생의 성별 정보를 표현하고 있다면, 남자 또는 여자라는 두 가지 범주에 의해서 데이터가 표현될 것이다. mpg의 class 열은 연비가 조사된 자동차의 종류를 compact, midsize, suv, 2seater, minivan, pickup, subcompact라는 7 가지 값으로 표현하는 변수이다. 다음 명령을 실행해 데이터를 확인해 보자. &gt; unique(mpg$class) [1] &quot;compact&quot; &quot;midsize&quot; &quot;suv&quot; &quot;2seater&quot; &quot;minivan&quot; [6] &quot;pickup&quot; &quot;subcompact&quot; ggplot2에서는 geom_bar() 함수를 이용하여 다음 형식 중 하나를 선택하여 막대 그래프를 그린다. &gt; ggplot(data=데이터, mapping=aes(x=범주형.변수.이름)) + geom_bar() &gt; ggplot(데이터, aes(범주형.변수.이름)) + geom_bar() &gt; ggplot(데이터) + geom_bar(aes(범주형.변수.이름)) &gt; ggplot() + geom_bar(aes(범주형.변수.이름), 데이터) geom_bar() 함수는 x에 매핑된 변수를 범주형 변수로 간주하고, 해당 변수에서 구분되는 값을 범주로 뽑아낸 후, 범주 별로 빈도수 계산한 후 이를 막대 그래프로 그려준다. (빈도수를 계산하는 과정은 사실 stat_count() 함수가 수행한다.) class 변수는 7가지의 구분되는 값으로 구성되어 있다. 문자열로 표현되는 범주는 알파벳 순으로 정렬되어 그래프의 가록축에 표현된다. 다음은 mpg 데이터의 class 열에 대한 막대 그래프를 그린 예이다. &gt; ggplot(mpg, aes(class)) + geom_bar() mpg 데이터이 cyl 열은 수치로 표현되어 있지만 사실은 실린더 개수이므로 4, 6, 8, 5라는 4 개의 범주를 가진 범주형 변수이다. geom_bar()를 이용하면 이 범주로 이용하여 빈도수를 계산한 후 막대 그래프로 그릴 수 있다. 범주가 수치인 경우에는 수의 크기로 정렬하여 가로축을 생성한다. &gt; ggplot(mpg, aes(cyl)) + geom_bar() 수치형 변수도 구별되는 값의 개수가 많지 않으면 geom_bar()를 이용할 수 있다. 예를 들어 도심 연비를 나타내는 cty는 다음처럼 총 21 개의 값을 가지고 있다. 그러므로 geom_bar()를 이용하여 각 값 별로 데이터의 빈도를 세어 막대 그래프를 그릴 수 있다. &gt; unique(mpg$cty) [1] 18 21 20 16 19 15 17 14 11 13 12 22 9 28 24 25 23 26 33 35 29 &gt; ggplot(mpg, aes(cty)) + geom_bar() 이 경우는 cty 변수에 구별되는 값이 많지 않아 막대 그래프로 표현해도 크게 어색하지 않다. 그러나 대부분의 수치형 변수는 연속적인 값을 가지므로 이런 식으로 막대 그래프를 그리기가 어렵다. 따라서 수치형 변수의 경우 geom_histogram()을 이용하여 구간으로 나누어 구간별 빈도에 대한 막대 그래프를 그리는 것이 좋다. 막대 그래프를 그릴 때 그래프의 x-축에 표현되는 범주의 순서를 바꾸고 싶을 때가 있다. 예를 들어 다음같은 drv에 대한 막대 그래프를 f, r, 4 순으로 막대를 표현하고 싶다고 하자. &gt; ggplot(mpg, aes(drv)) + geom_bar() geom_bar()는 기본적으로 문자는 알파벳 순으로 숫자는 숫자의 크기 순으로 정렬하여 막대를 그리므로 이를 바꾸고 싶으면 요인(factor)로 바꾸어야 한다. 요인의 경우는 수준(levels)에 정의된 순서에 따라 막대 그래프를 그리기 때문이다. 마지막의 labs() 함수는 x-축의 레이블을 \"drv\"로 표시하기 위해 사용되었다. 이 함구가 없으면 x-축 레이블이 어떻게 변하는지 확인해 보라. &gt; ggplot(mpg, aes(factor(drv, levels=c(&quot;f&quot;, &quot;r&quot;, &quot;4&quot;)))) + + geom_bar() + + labs(x=&quot;drv&quot;) 다음 예는 mpg의 class 데이터에서 빈도가 큰 범주부터 차례로 막대가 나오도록 하는 예이다. &gt; x &lt;- table(mpg$class); x 2seater compact midsize minivan pickup subcompact suv 5 47 41 11 33 35 62 &gt; class.levels &lt;- names(x)[order(x, decreasing = T)]; class.levels [1] &quot;suv&quot; &quot;compact&quot; &quot;midsize&quot; &quot;subcompact&quot; &quot;pickup&quot; [6] &quot;minivan&quot; &quot;2seater&quot; &gt; ggplot(mpg, aes(factor(class, levels=class.levels))) + + geom_bar() + + labs(x=&quot;class&quot;, y=&quot;freq&quot;) 범주형 데이터를 막대로 그릴 때, 각 범주별 데이터를 다른 변수로 좀 더 세분화하여 살펴보고 싶을 때가 있다. 이 경우 흔히 한 범주를 표현하는 막대를 다른 변수의 범주에 따라 색상으로 구분하여 세분화하여 표현한다. geom_bar()의 fill aesthetics에 범주형 변수를 매핑하면 각 범주별로 색상을 달리 표시한다. 다음은 class별 막대 그래프를 년도(year)로 더 세분화하여 표현한 경우이다. mpg 데이터의 year 변수는 수치형 데이터로 표현되어 있으므로 factor() 함수를 이용하여 이산형으로 변형하여 `fill`` aesthetics에 매핑하였다. &gt; ggplot(mpg, aes(class, fill=factor(year))) + geom_bar() + labs(fill=&quot;year&quot;) 만약 각 class 값에 따라 1999년도와 2008년도의 상대적 빈도를 비교해 보고 싶다면, 다음처럼 position 인수를 \"fill\"로 설정하면 된다. postion 인수에 대한 자세한 설명은 8.7 절을 참조하기 바란다. 이렇게 하면 막대 그래프를 이용하여 두 범주형 변수의 관계를 살펴볼 수 있다. &gt; ggplot(mpg, aes(class, fill=factor(year))) + + geom_bar(position=&quot;fill&quot;) + labs(fill=&quot;year&quot;) 8.8.3 한 수치형 변수의 그래프 한 수치형 변수에서 일차적으로 확인해야 할 내용은 그 변수의 분포이다. 분포를 확인하는 가장 단순한 방법은 수치를 구간으로 나누어 빈도를 나타내는 히스토그램을 그려보는 것이다. geom_histogram() 함수는 x로 매핑된 변수를 구간으로 나누어 빈도수를 구한 후 - 이 작업은 stat_bin() 함수가 수행한다 - 막대 형태의 히스토그램 그래프를 그려준다. 다음은 고속도로 연비 데이터를 구간 크기를 2로하여 나눈 후 히스토그램을 그린 예이다. 구간의 길이는 bandwidth 인수를 이용하여 설정한다. &gt; ggplot(mpg, aes(hwy)) + geom_histogram(binwidth=2) 히그토그램은 구간의 크기에 따라 다른 모양의 그래프가 나오므로, 구간의 크기를 변화시키면서 분포를 가장 적절하게 나타내는 구간크기를 찾아 보아야 한다. &gt; ggplot(mpg, aes(hwy)) + geom_histogram(binwidth=1) 그런데 앞의 고속도로 연비 히스토그램을 보면 두 개의 봉우리를 가지는 분포를 보인다. 이처럼 분포에 여러 봉우리가 나타날 때는 서로 다른 특성을 가지는 데이터 그룹이 하나로 섞여 있기 때문인 경우가 많다. 예를 들어 성인의 키의 분포를 그리면 남자와 여자라는 서로 다른 특성의 그룹 때문에 쌍봉 형태의 그래프가 나온다. 고속도로 연비가 쌍봉 형태를 보이는 것이 자동차의 구동 방식 때문인지를 한번 살펴보자. 다음처럼 fill aesthetics에 drv 변수를 매핑하면 빈도를 drv 요소로 분해하여 살펴볼 수 있다. 결과에서 보듯이 왼쪽 봉우리는 주로 4륜 구동(4) 차가, 오른쪽 봉우리는 전륜 구동(f) 차가 분포의 대부분을 차지하고 있음을 볼 수 있다. &gt; ggplot(mpg, aes(hwy, fill=drv)) + geom_histogram(binwidth=1) 그런데 앞의 예에서 geom_histogram()은 디폴트 position이 \"stack\"으로 설정되어 있어서 쌓인 형태로 막대 그래프가 나타났다. 쌓인 그래프 형태로 표현되다 보니 각 구동방식에 따른 고속도로 연비의 분포를 파악하기는 어렵다. 이런 경우 geom_freqpoly()를 이용하여 각 범주별 분포를 분리하여 그려보면 좋다. geom_freqpoly()는 geom_histogram()과 마찬가지로 연속형 수치 변수를 구간으로 나누어 빈도를 보여주는데, 막대가 아니라 선을 이용하여 빈도를 보여준다. &gt; ggplot(mpg, aes(hwy)) + geom_freqpoly(binwidth=2) 따라서 여러 그룹으로 나누어 구간으로 나누어 빈도를 보일 때도 서로 구분이 용이하다. geom_freqpoly()의 디폴트 position은 \"identity\"이다. 아래 그래프를 보면 4륜 구동과 전륜 구동의 분포에 의해 전체 분포에서 쌍봉이 나타났음을 뚜렷하게 확인할 수 있다. &gt; ggplot(mpg, aes(hwy, color=drv)) + geom_freqpoly(binwidth=2) 그런데 위의 그래프는 구동방식에 따라 구간별 고속도로 연비의 절대빈도를 보여준다. 따라서 데이터 수가 적은 후륜 구동(r)의 경우 매우 작게 표시되어 상대적인 분포를 확인하기 어렵다. 이런 경우 전체 면적을 1로하는 상대빈도를 이용하여 그래프를 나타내는 것이 더 좋다. geom_histogram()과 geom_freqpoly() 모두 디필트 stat로 stat_bin()을 이용하는데, 이 함수는 x로 매핑된 변수를 구간으로 나누어 구간별 빈도(count), 밀도(density), 최대값이 1로 조정된 빈도(ncount), 최대값이 1로 조정된 밀도(ndensity) 등을 산출한다. 특별한 지시가 없으면 stat_bin()은 count 변수를 y로 매핑하여 준다. 그리고 이 y 값을 geom_histogram()에서는 막대의 높이로, geom_freqpoly()에서는 선의 y 값으로 이용한다. count 대신 density를 이용하여 그래프를 그리고 싶으면, aes() 매핑에서 y가 density가 되도록 매핑하면 된다. 단, 이 때 stat 함수에 의해 계산된 변수는 ..&lt;변수이름&gt;.. 형태로 표시한다. &gt; ggplot(mpg, aes(hwy, ..density.., color=drv)) + geom_freqpoly(binwidth=2) 4륜 구동 차는 15에서 20사이의 구간에서 가장 많은 빈도를 보였고, 후륜구동 차는 15에서 30 사이로 펴져서 분포를 하고 있고, 전륜구동 차는 25에서 30에서 가장 많은 빈도를 보이는 것을 확인할 수 있다. 8.8.4 두 범주형 변수의 그래프 두 범주형 변수의 관계는 8.8.2 절에서 본 것과 같이 한 범주형 변수의 막대 그래프에 fill aesthetics에 다른 범주형 변수를 매핑하여 두 변수의 관계를 살펴보거나, 아니면 다음처럼 facet을 이용하여 한 범주형 변수의 값을 고정시켜 놓고 다른 범주형 변수에 대해 막대 그래프를 그려 두 변수의 관계를 살펴본다. &gt; ggplot(mpg, aes(class)) + geom_bar() + + facet_wrap(~drv) 이 경우 절대빈도로 막대 그래프가 표시되어 facet에 지정된 변수의 값에 따라 분포가 다른지 비교하기가 어렵다. geom_bar()의 디폴트 stat인 stat_count()는 x로 매핑된 변수에 대해 범주별로 빈도수를 세어 count 변수에 저장하고, 상대빈도를 prop 변수에 저장한다. stat_count()는 디폴트로 count 변수의 값을 y에 매핑한다. 만약 prop 변수를 막대 그래프의 y의 값으로 매핑하려면, y를 ..prop..으로 지정한다. (8.8.3 절에서 설명한 바와 같이 stat 함수가 생성한 변수의 지정은 ..&lt;변수 이름&gt;..의 형식을 사용한다.) 그러면 각 범주별 상대 빈도가 나타나 facet으로 지정된 변수의 값에 따라 상대적 비율이 달라지는지 비교해 볼 수 있다. &gt; ggplot(mpg, aes(class, ..prop.., group=drv)) + geom_bar() + + facet_wrap(~drv) 두 범주형 변수의 관계를 살펴보는 또 다른 방법은 두 범주형 변수의 데이터를 산점도로 표시해 보는 것이다. &gt; ggplot(mpg, aes(class, drv)) + geom_point() 그런데, 문제는 같은 값을 갖는 데이터가 너무 많으므로 여러 데이터가 한 점으로 표시되어 빈도를 알 수 없다. 이 경우 geom_jitter()를 사용하면 각 점의 x, y 좌표에 임의의 변동을 주어 겹치는 점이 다른 곳에 표시되도록 할 수 있다. width와 height 인수는 임의의 변동의 최대값이다. 범주형 변수의 범주 사이의 길이는 1이므로 다음의 예는 붙어 있는 두 범주 사이의 거리의 약 \\(\\pm\\) 20% 정도의 변동이 일어나도록 조정한 예라 할 수 있다. &gt; ggplot(mpg, aes(class, drv)) + geom_jitter(width=0.2, height=0.2) 그러나 산저도의 점의 수가 많으면 두 변수의 관계를 명확하게 알기는 힘들다. 이 경우 geom_count()를 이용하면 빈도에 따라 더 큰 원이 그려지는 그래프를 그릴 수 있다. &gt; ggplot(mpg, aes(class, drv)) + geom_count() 8.8.5 범주형 변수와 수치형 변수의 그래프 범주형 변수와 수치형 변수의 관계를 살펴보는 가장 쉬운 방법은 범주형 변수에 따른 수치형 변수의 분포를 산점도로 나타내 보는 것이다. 다음은 클래스별 도심 연비의 산점도를 보여준다. 비슷한 데이터와 매핑으로 그래프를 여러번 그릴 것이므로 ggplot2 그래프를 변수에 할당하여 사용해 보자. &gt; p &lt;- ggplot(mpg, aes(class, cty)) &gt; p + geom_point() 그런데 실제 데이터보다 점이 더 적게 찍힌 것을 볼 수 있다. 이는 동일한 지점에 여러 데이터가 표현되었기 때문이다.geom_jitter() 함수는 앞서 설명하였드시 동일한 지점의 점을 임의로 조금씩 변동시켜 점을 표시한다. width와 height 인수를 설정하면 임의의 변동의 폭과 높이의 범위를 설정할 수 있다. 다음은 폭을 \\(\\pm 0.2\\)로 제한한 경우이다. 이산시간 변수는 한 칸이 1로 계산되므로 총 공간의 40% 정도에 임의로 변동된 점이 놓이게 된다. &gt; p + geom_jitter(width = 0.2) geom_jitter()로 범주별로 수치 변수의 대락적 분포를 확인할 수는 있으나 전체적인 분포를 요약하여 비교하긴 어렵다. geom_boxplot()를 이용하면 각 범주에서의 수치형 변수의 분포를 상자 그림으로 요약하여 보여준다. 상자의 상한은 3분위수, 상자의 하한은 1분위수, 상자 안의 가로선은 중위수를 나타낸다. 상자 밖의 위와 아래에 그려진 선은 상자 높이(IQR)의 1.5배 내의 데이터 중 최대값과 최소값을 보여준다. 그 범위 밖의 데이터는 이상치로 간주하여 별도의 점으로 나타낸다. &gt; p + geom_boxplot() 앞의 그래프는 자동차 종류 별로 도심 연비의 중위수가 차이가 나는지를 살펴볼 수 있게 해준다. 그런데, 그래프에 나타난 중위수는 조사된 데이터, 즉 표본의 중위수이므로 모집단의 중위수와 다를 수 있다. 모집단 중위수에 대한 신뢰구간을 같이 표시하고 싶으면 notch=TRUE로 하여 상자그림을 그린다. 만약 두 종류의 차의 V자 모양의 notch가 서로 겹치지 않는다면 두 종류의 차의 도심 연비의 중위수가 통계적으로 유의미하게 다르다는 것을 의미한다. 데이터가 적은 클래스의 경우에 notch의 크기가 너무 커져서 상자 바깥까지 그려지는 경우도 있다. 이 경우 경고 메시지가 출력된다. &gt; p + geom_boxplot(notch = T) notch went outside hinges. Try setting notch=FALSE. notch went outside hinges. Try setting notch=FALSE. notch went outside hinges. Try setting notch=FALSE. 상자 그래프 자주 같이 표시되는 정보가 수치 데이터의 평균에 대한 정보이다. stat_summary()를 이용하면 범주별 평균을 구할 수 있고, geom_point()로 범주별 평균을 상자 그림 위에 덧붙일 수 있다. &gt; p + geom_boxplot(notch = T) + + geom_point(stat=&quot;summary&quot;, fun.y=mean, color=&quot;red&quot;, size=5, shape=&quot;*&quot;) Warning: Ignoring unknown parameters: fun.y No summary function supplied, defaulting to `mean_se()` notch went outside hinges. Try setting notch=FALSE. notch went outside hinges. Try setting notch=FALSE. notch went outside hinges. Try setting notch=FALSE. 상자 그래프는 수치형 데이터를 분위수와 이상치로 요약된 정보를 주는 장점이 있지만 실제 분포를 파악하기 어렵다. 바이올린 차트는 상자 그래프의 이러한 단점을 보완해 준다. 바이롤린 차트는 수치 변수의 확률밀도를 추정하여 확률밀도가 높은 곳은 폭이 넓게, 확률밀도가 낮은 곳은 폭이 좁게 그래프를 그려주는데, 이 모향이 바이올린 모양을 닯아서 바이올린 차트라 한다. &gt; p + geom_violin() 그런데 바이올린 차트는 확률밀도를 계산할 때 확률밀도가 연속적이고 유한한 값을 가지는 함수라는 가정하에 각 지점에 작은 정규분포를 적합하여 이를 연결하여 확률밀도를 추정한다. 그런데 이런 가정이 적합하지 않을 때도 있으니 이 경우 바이올린 차트를 사용하지 않는 것이 좋다. 다음은 바이올린 차트와 상자그림을 겹쳐 그린 그래프이다. &gt; p + geom_boxplot(width=0.1) + + geom_violin(alpha=0.3) 8.8.6 두 수치형 변수의 그래프 우리는 앞선 여러 예제에서 geom_point()를 이용하여 두 수치형 변수의 산점도와 geom_smooth()를 이용하여 평균 적합선을 그려보았다. 여기서는 다른 방식으로 두 수치형 변수의 관계를 그래프로 나나태 보자. geom_text() 두 수치형 변수의 데이터를 나타낼 때, 점 대신 텍스트로 표현하고 싶을 때가 있다. 다음 예는 geom_text()로 midsize 차의 2008년도의 도심 및 고속도로 연비 데이터를 모델명으로 보여주는 그래프이다. &gt; df &lt;- mpg[mpg$class == &quot;midsize&quot; &amp; mpg$year==2008,] &gt; ggplot(df, aes(cty, hwy)) + geom_text(aes(label=model)) 앞의 예는 동일한 데이터를 가지는 차의 이름이 겹쳐서 표현되어 구분이 어렵다. 이를 개선하기 위하여 글자의 크기(size 인수)를 줄이고 다음처럼 position 인수에 position_jitter() 함수를 이용하여 텍스트 위치에 임의적인 변동을 주어 같은 자리의 데이터가 겹치지 않도록 해 본다. &gt; ggplot(df, aes(cty, hwy)) + + geom_text(aes(label=model), size=3, + position=position_jitter(width=0.3, height=0.3)) 텍스트를 겹치지 않게 만드는 또다른 방법은 check_overlap=TRUE로 설정하여 이미 한 자리에 텍스트가 놓이면 같은 위치에 텍스트가 더 이상 쓰이지 않도록 하는 것이다. 이 경우 뒤에 나타나는 동일한 위치의 데이터는 그래프에 표시되지 못할 것이다. &gt; ggplot(df, aes(cty, hwy)) + geom_text(aes(label=model), check_overlap = T) 텍스트로 관측치의 위치를 표현하면, 텍스트의 길이가 가변적이라 관측치의 정확한 위치를 파악하기 어렵다. 따라서 관측치의 위치는 점으로 표현한 후, 점의 옆이나 위, 아래에 텍스트를 같이 표현하기도 한다. geom_text() 함수의 nudge_x와 nudge_y는 원래 관측치의 위치에서 정해진 크기만큼 표시할 텍스트의 위치를 이동시킨다. 다음은 텍스트를 점 위로 0.3 정도 이동시켜 표시한 예이다. &gt; ggplot(df, aes(cty, hwy)) + geom_point() + + geom_text(aes(label=model), nudge_y=0.3, size=3) 위의 경우에는 동일한 위치에 여러 텍스트가 겹치므로 position_jitter()를 이용하여 임의로 위치로 텍스트를 조정할 수도 있다. 참고로 position_jitter()와 nudge_x/nudge_y`는 함께 사용될 수 없다. &gt; ggplot(df, aes(cty, hwy)) + + geom_point() + + geom_text(aes(label=model), size=3, + position=position_jitter(width=0.3, height=0.3)) geom_label() geom_label()은 geom_text()와 거의 유사한데, 텍스트를 박스 안에 넣어 글자를 구별하기 좀 더 쉽도록 해 준다. &gt; ggplot(df, aes(cty, hwy)) + + geom_point() + + geom_label(aes(label=model), nudge_y=0.2, size=3) geom_bin2d() 두 변수의 결합 분포를 확인하고 싶을 때는 geom_bin2d()를 이용하여 두 수치형 변수를 각각 구간으로 나눈 후, 각 셀별로 빈도수를 계산한다. 그리고 각 셀의 빈도에 따라 색상을 다르게 하여 그래프에 표시한다. binwidth 인수는 가로축과 세로축의 구간을 길이를 지정한다. &gt; ggplot(mpg, aes(cty, hwy)) + geom_bin2d(binwidth=c(2,2)) 8.8.7 세 변수 이상의 그래프 3개 변수 이상의 관계를 파악하고자 할 때 조건부 그래프이다. 조건부 그래프는 관심의 대상인 한 변수의 분포 또는 두 변수의 관계가 다른 변수의 값이 변함에 따라 어떻게 변하는지를 보여준다. ggplot2에서는 facet을 사용하여 이를 수행한다. 다음은 구동 방식(drv)의 차이에 따라 배기량(displ)과 도심 연비(cty)의 관계가 어떻게 변하는지를 보여주는 그래프이다. 전륜 구동(f)의 차일수록 배기량이 커짐에 따라 도심 연비의 감쇄가 크게 나타남을 볼수 있다. &gt; ggplot(mpg, aes(displ, cty)) + + geom_point() + geom_smooth(method=&quot;lm&quot;) + + facet_wrap(~drv) `geom_smooth()` using formula &#39;y ~ x&#39; 위에서 사용된 facet_wrap() 함수는 그래프가 매우 많으면 그래프를 줄 바꾸기를 하여 배치를 한다. &gt; ggplot(mpg, aes(displ, cty)) + + geom_point() + geom_smooth(method=&quot;lm&quot;) + + facet_wrap(~class) `geom_smooth()` using formula &#39;y ~ x&#39; 3개 변수 이상의 관계를 파악할 때 조건부 그래프뿐 아니라, 산점도 상에서 색상 등의 다른 aethetics를 사용하여 제 3의 변수의 영향을 살펴볼 수도 있다. 다음은 구동 방식의 차이를 색상으로 구분하여 한 산점도에 나타낸 예이다. &gt; ggplot(mpg, aes(displ, cty, col=drv)) + + geom_point() + geom_smooth(method=&quot;lm&quot;) `geom_smooth()` using formula &#39;y ~ x&#39; 색상 등의 aesthetics를 제 3의 변수에 매핑하여 그래프를 그리는 것은 한 그래프에 그래프가 모두 함께 표시되어 비교가 쉬운 장점이 있다. 그러나 제 3의 변수가 여러 값을 가지거나 제3, 4, 5의 변수들이 관심있는 두 변수에 영향을 미치는 것을 살펴보려면 너무 그래프가 복잡해서 파악이 어려운 단점이 있다. 다음은 구동방식뿐 아니라 조사 년도(year)가 배기량과 도심 연비의 관계에 어떤 영향을 미치는지 보기 위해 추가적으로 year 변수를 linetype에 매핑한 결과이다. 여러 그래프가 한 곳에 그려지다 보니 구분이 어려운 것을 볼 수 있다. 또한 연도별로 구동방식으로 나누어 비교를 하기도 어렵다. &gt; ggplot(mpg, aes(displ, cty, col=drv, linetype=factor(year))) + + geom_point() + geom_smooth(method=&quot;lm&quot;) + labs(linetype=&quot;year&quot;) `geom_smooth()` using formula &#39;y ~ x&#39; facet을 사용하면 제3, 4 변수의 값에 따라 그래프 각각 그린 후 행과 열로 배치해 주므로 그래프를 좀 더 체계적으로 비교해 볼 수 있다. 다음은 drv와 year의 값에 따라 displ와 cty의 관계가 어떻게 변하는지는 facet을 이용하여 그래프를 그린 예이다. facet_grid()은 수식 표현을 사용하여 그래프 배열의 행과 열의 기준이 되는 변수를 지정한다. &gt; ggplot(mpg, aes(displ, cty)) + + geom_point() + geom_smooth(method=&quot;lm&quot;) + + facet_grid(year~drv) `geom_smooth()` using formula &#39;y ~ x&#39; facet_wrap()이 한 변수를 조건으로 하여 그래프를 그린다면 facet_grid()는 두 변수를 조건으로 그래프를 그려준다. 행이 될 변수를 수식의 왼편에 열이 될 변수를 수식의 오른편에 기술을 한다. 앞의 예에서는 조사 년도별 차이는 행으로, 구동 방식의 차이는 열로 구분되어 그래프를 표시하였다. 전륜 구동(f)의 차들의 연비 감쇄 현상이 더 가파른 것은 연도별로 차이가 없었지만, 1999년도에 비해 2008년도의 전륜구동(f)과 후륜구동(r)의 차들 중에 배기량이 큰 차들이 출시되었고 배기량에 따른 연비 감쇄 경향도 줄어들었음을 볼 수 있다. 8.9 그래프의 외양 바꾸기 ggplot2는 사용자가 데이터를 geom의 각 aesthetics 요소로 매핑하면 자동으로 가로축과 세로축의 스케일을 결정하고, 표시할 색상의 스케일도 결정하고, 축과 범례에 표시될 레이블도 결정하여 그래프를 그려준다. 이러한 ggplot2의 기능은 사용자가 그래프의 세부 사항이 아니라 그래프의 핵심적인 매핑과 형태에만 집중할 수 있게 해주므로 매우 편리하다. 그러나 가끔은 ggplot2가 생성한 그래프의 모양이 최종적으로 원하는 형태가 아닐 수 있다. 이러한 경우에 그래프의 세부적인 사항을 조정할 필요가 있다. 사실 발표용 그래프는 세심한 조정이 필요한 경우가 더 많다. 이 장에서는 ggplot2로 그래프를 그린 후 자주 조정하게 되는 요소를 어떻게 변경할 수 있는지를 살펴본다. 8.9.1 좌표축의 조정 ggplot2는 데이터가 x와 y aesthetics에 매핑되면, 이를 이용하여 가로축과 세로축의 축척(scale)를 생성한다. x와 y에 매핑된 변수가 수치형 변수이면 scale_x_continous()와 scale_y_continous()가, 범주형 변수이면 scale_x_discrete()와 scale_y_discrete()가 사용되어 가로축과 세로축의 축척을 생성한다. 좌표축의 축적을 위한 이러한 함수들은 매핑된 데이터의 값을 이용하여 다음 사항을 적절히 결정한다. name: 축의 이름 breaks: 축에 표시될 눈금의 위치 labels: 축 눈금에 씌여질 레이블 lmites: 축의 상한과 하한 trans: 축에 별도의 변환을 적용할지 여부 position: 축의 그래프 상에서의 위치 등 ggplot2가 자동으로 설정한 이러한 요소가 원하는 것이 아니라면 직접 이를 조정해야 한다. midwest 데이터는 미국 중서부의 각 카운티(county)의 인구통계 정보이다. &gt; midwest # A tibble: 437 x 28 PID county state area poptotal popdensity popwhite popblack popamerindian &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 561 ADAMS IL 0.052 66090 1271. 63917 1702 98 2 562 ALEXA… IL 0.014 10626 759 7054 3496 19 3 563 BOND IL 0.022 14991 681. 14477 429 35 4 564 BOONE IL 0.017 30806 1812. 29344 127 46 5 565 BROWN IL 0.018 5836 324. 5264 547 14 6 566 BUREAU IL 0.05 35688 714. 35157 50 65 7 567 CALHO… IL 0.017 5322 313. 5298 1 8 8 568 CARRO… IL 0.027 16805 622. 16519 111 30 9 569 CASS IL 0.024 13437 560. 13384 16 8 10 570 CHAMP… IL 0.058 173025 2983. 146506 16559 331 # … with 427 more rows, and 19 more variables: popasian &lt;int&gt;, popother &lt;int&gt;, # percwhite &lt;dbl&gt;, percblack &lt;dbl&gt;, percamerindan &lt;dbl&gt;, percasian &lt;dbl&gt;, # percother &lt;dbl&gt;, popadults &lt;int&gt;, perchsd &lt;dbl&gt;, percollege &lt;dbl&gt;, # percprof &lt;dbl&gt;, poppovertyknown &lt;int&gt;, percpovertyknown &lt;dbl&gt;, # percbelowpoverty &lt;dbl&gt;, percchildbelowpovert &lt;dbl&gt;, percadultpoverty &lt;dbl&gt;, # percelderlypoverty &lt;dbl&gt;, inmetro &lt;int&gt;, category &lt;chr&gt; area: 면적 poptotal: 총 인수수 popdensity: 인구밀도 popwhite: 백인 거주자수 popblack: 흑인 거주자수 popamerindian: 인디언 거주자수 popasian: 아시아인 거주자수 popother: 다른 인종 거주자수 percwhite, percwhite, percamerindan, percasian, percother: 각 인종의 비율 popadults: 성인 거주자수 percollege: 대학 졸업자 비율 percprof: 전문직 비율 다음은 백인 거주자 비율과 대학 졸업자 비율에 대한 산점도이다. &gt; p &lt;- ggplot(midwest, aes(percwhite, percollege)) + geom_point() &gt; p 위의 그래프에서 가로축은 백인의 비율인데 25% 단위로 주눈금(breaks)과 눈금의 값이 레이블(labels)로 표시되어 있다. 아울러 주눈금 사이에 보조 눈금(minor.breaks)이 하나씩 그려져 있고 별도의 레이블은 표시되어 있지 않다. 위의 가록축을 10% 단위로 주눈금을 표시하고 보조눈금은 디폴트 값인 주눈금 사이에 하나의 보조눈금이 그려지도록 그래프를 조정해 보자. 또한 눈금에 표시되는 레이블도 숫자만이 아니라 %가 같이 표시되도록 해 본다. &gt; p + scale_x_continuous(breaks=seq(0, 100, by=10), + labels=paste0(seq(0, 100, by=10),&quot;%&quot;)) 현재 x와 y 축은 데이터의 최소값과 최대값이 모두 표시될 수 있도록 적절히 그 범위가 설정되어 있다. 그런데 현재 백인의 비율은 대부분 80% 이상이어서 데이터가 서로 구분이 되지 않는다. 따라서 x축을 60에서 100%까지만 표시되도록 조정해 보자. 또한 y축의 이름을 “Percent college educated”로 바꾸어 보자. 이 경우 2개의 관측치가 그래프에 표시되지 않으므로 그에 대한 정보가 함께 출력된다. &gt; p + scale_x_continuous(breaks=seq(0, 100, by=10), + labels=paste0(seq(0, 100, by=10),&quot;%&quot;), + limits=c(60, 100)) + + scale_y_continuous(name=&quot;Percent college educated&quot;) Warning: Removed 2 rows containing missing values (geom_point). 아울러 position 인수를 사용하면 좌표축의 위치를 지정할 수 있다. “left”, “right”, “top”, “bottom”의 값이 사용되는데 다음 예는 가로축과 세로축을 좌표평면의 맨 위와 맨 오른쪽으로 조정한 예이다. &gt; p + scale_x_continuous(position=&quot;top&quot;) + + scale_y_continuous(position=&quot;right&quot;) 다음은 각 카운티의 면적과 인구의 산점도이다. &gt; ap &lt;- ggplot(midwest, aes(area, poptotal)) + geom_point() + + geom_smooth(method=&quot;lm&quot;) &gt; ap `geom_smooth()` using formula &#39;y ~ x&#39; 대부분의 인구가 100만 미만에 몰려 있어서 그래프를 확인하기 어렵다. 이렇듯 한쪽으로 편향된 데이터를 가진 경우 로그 변환을 하면 데이터를 구분하기 좋은 때가 많다. 앞의 그래프의 y축을 로그 축적으로 변경해 보자. &gt; ap + scale_y_continuous(trans=&quot;log10&quot;) `geom_smooth()` using formula &#39;y ~ x&#39; 8.9.2 좌표계의 변경 가끔은 그래프의 x와 y축을 변경하고 싶을 때가 있다. 산점도의 경우는 x와 y의 매핑을 바꾸면 간단히 축을 서로 바꿀 수 있지만 다음처럼 히스토그램의 가로축과 세로축을 바꾸려면 좀 복잡한 작업이 필요하다. &gt; p &lt;- ggplot(mpg, aes(cty)) + geom_histogram(binwidth=1) &gt; p 이럴 때 쉽게 사용할 수 있는 것이 coord_flip() 함수이다. coord_flip() 함수는 그래프의 가로축과 세로축을 바꾸어 준다. &gt; p + coord_flip() coord_flip() 함수 말고도 좌표계를 변경하는 함수들이 있다. coord_polar()는 직교좌표계를 극좌표계로 변경해 준다. &gt; p + coord_polar() &gt; ggplot(mpg, aes(class, fill=drv)) + geom_bar(position=&quot;fill&quot;) + coord_polar() 8.9.3 색상 척도(color scales)의 변경 ggplot2는 x와 y에 매핑되는 데이터 열의 값의 범위에 따라 좌표축을 자동 생성한다. 마찬가지로 color나 fill 등의 속성에 매핑되는 데이터 열에 따라 자동으로 색상의 척도를 자동으로 지정하여, 데이터의 값에 따라 적절한 색상을 선택하여 그래프를 그린다. ggplot2는 데이터 열을 색상 속성에 매핑할 때 데이터 열이 연속형 변수인지, 이산형 변수인지에 따라 색상 척도를 다르게 설정한다. 다음 두 그래프를 비고해 보자. 첫번째 그래프는 점의 color 속성에 이산형 변수인 drv가 매핑되었고, 두번재 그래프는 color에 연속형 변수인 cty가 매핑되었다. &gt; p &lt;- ggplot(mpg, aes(displ, hwy)) &gt; p + geom_point(aes(color=drv), size=2) &gt; p + geom_point(aes(color=cty), size=2) 이산형 변수는 구분되는 색상이 지정되는 반면, 연속형 변수는 색상의 그라데이션으로 매핑이 되는 것을 볼 수 있다. 그 이유는 이산형 변수는 구분되는 제한된 값만 가지므로 정해진 색상으로 그래프를 표현할 수 있는 반면, 연속형 변수는 무수히 많은 값을 가질 수 있으므로 색상의 그라데이션의 연속적인 변화로 표현하는 것이 더 적절하기 때문이다. 가끔 데이터의 열이 수치로 입력이 되었지만 이산형 데이터인 경우가 있다. 예를 들어 mpg 데이터의 year는 수치로 데이터가 입력되었지만 구분되는 두 개의 연도를 가진 변수이다. 이렇듯 이산형 변수가 수치로 입력이 되어 있으면 ggplot2는 이 데이터가 연속형 수치로 판단을 하여 그라데이션으로 색상을 표현한다. 이를 방지하려면 원래의 데이터를 factor로 변환하여 이산형 변수로 변환해 주면 구별되는 색상으로 그래프를 표현한다. &gt; p &lt;- ggplot(mpg, aes(displ, hwy)) &gt; p + geom_point(aes(color=year), size=2) &gt; p + geom_point(aes(color=factor(year)), size=2) ggplot2가 디폴트로 매핑한 색상이 마음에 들지 않으면 이를 직접 조정할 수 있다. 이를 위해서는 색상에 대한 기본적인 지식을 가지고 있어야 한다. 이 책에서는 세부적인 색상 지정과 관련된 내용은 다루지 않고, 대신 이산형 변수와 연속형 변수에 대해서 이미 만들어져 있는 색상 척도 중 하나로 색상 척도를 변경하는 방법만 다루도록 한다. 이산형 변수의 색상 매핑은 ColorBrewer에서 지정한 색상 매핑(팔레트)을 사용할 수 있다. RColorBrewer 패키지는 ColorBrewer에서 제공하는 다양한 색상 척도를 R에서 사용할 수 있도록 해 준다. RColorBrewer 패키지에서 사용할 수 있는 색상 팔레트를 확인해 보려면 다음 명령을 실행해 본다. &gt; RColorBrewer::display.brewer.all() 이산형 변수로 매핑된 color 또는 fill의 ColorBrewer 척도를 바꾸려면 scale_color_brewer() 또는 scale_fill_brewer()를 사용한다. &gt; p_drv &lt;- p + geom_point(aes(color=drv), size=2) &gt; p_drv &gt; p_drv + scale_color_brewer(palette = &quot;Set1&quot;) &gt; p_drv + scale_color_brewer(palette = &quot;Accent&quot;) &gt; p_drv + scale_color_brewer(palette = &quot;Spectral&quot;) 연속형 변수로 매핑된 color 또는 fill도 ColorBrewer 척도를 이용하여 연속적인 그라데이션으로 연속형 변수의 값을 표현할 수 있다. ColorBrewer 척도를 바꾸려면 scale_color_distiller() 또는 scale_fill_distiller()를 사용한다. &gt; p_cty &lt;- p + geom_point(aes(color=cty), size=2) &gt; p_cty &gt; p_cty + scale_color_distiller(palette = &quot;RdPu&quot;) &gt; p_cty + scale_color_distiller(palette = &quot;YlOrBr&quot;) &gt; p_cty + scale_color_distiller(palette = &quot;Greens&quot;) 8.9.4 레이블 조정 labs() 함수는 그래프의 제목, 축 이름, 범례의 이름을 쉽게 바꿀 수 있게 해준다. &gt; p &lt;- ggplot(mpg, aes(displ, cty, color=class, shape=factor(cyl))) + geom_point() &gt; p 위 그래프를 다음처럼 범례 이름, 축의 이름, 그래프의 제목을 바꾸어 보자. &gt; p &lt;- p + labs(title=&quot;displacement vs. city fuel economy&quot;, + x=&quot;displacement(liter)&quot;, y=&quot;city fuel economy(city)&quot;, + color=&quot;car class&quot;, shape=&quot;number of cylinder&quot;) &gt; p 8.9.5 테마 변경 테마는 ggplot2 그래프의 전체적인 외양을 결정한다. 테마는 그래프의 배경 색, 글자 폰트, 격자선 모양, 범례의 위치 등의 그래프의 외양을 결정한다. theme_gray()는 디폴트 테마이며, 다음처럼 테마 함수를 추가하면 관련 테마가 적용된다. &gt; p + theme_gray() &gt; p + theme_bw() &gt; p + theme_dark() &gt; p + theme_light() &gt; p + theme_classic() &gt; p + theme_minimal() 사용자는 테마를 바꾸는 것뿐만 아니라, 현재 적용된 테마에 설정된 각 요소를 theme() 함수를 사용하여 직접 변경할 수 있다. 테마에서 가장 빈번이 변경되는 요소가 범례의 위치이다. &gt; p + theme(legend.position = &quot;bottom&quot;) 이 외에도 그래프 레이블들의 형태와 백그라운드 색 등 다양한 요소를 조정할 수 있다. 더 자세한 내용을 알고싶으면 ??theme을 이용하여 관련 도움말을 확인하기 바란다. 만약 빈번히 사용되는 테마 요소가 있다면 다음 예처럼 변수에 저장을 해 둔 후, 여러 그래프에 적용시킬 수 있다. &gt; myTheme &lt;- theme( + plot.title=element_text(face=&quot;bold.italic&quot;, size=16, color=&quot;orange&quot;, hjust=0.5), + panel.background = element_rect(fill=&quot;lightyellow&quot;, color=&quot;green&quot;), + legend.position = &quot;top&quot;) &gt; p + myTheme &gt; ggplot(mpg, aes(hwy, fill=drv)) + geom_histogram() + + labs(title=&quot;A graph with my theme&quot;) + myTheme `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 8.10 기타 유용한 팁들 8.10.1 여러 그래프를 한 도표에 넣기 ggplot2에서 그린 여러 그래프를 한 도표에 넣으려면 gridExtra 패키지의 grid.arrange() 함수를 이용하면 편리하다. gridExtra 패키지를 사용하려면 먼저 설치를 해야 한다. &gt; install.packages(&quot;gridExtra&quot;) 그리고 나서 메모리에 적재한다. &gt; library(gridExtra) Attaching package: &#39;gridExtra&#39; The following object is masked from &#39;package:dplyr&#39;: combine 다음처럼 4개의 그래프를 ggplot2로 그렸다고 해보자. grid.arrange() 함수는 다양한 방식으로 그래프를 조합하여 하나의 도표를 만들 수 있다. &gt; p1 &lt;- ggplot(mpg, aes(drv, displ)) + geom_jitter() &gt; p2 &lt;- ggplot(mpg, aes(drv, displ)) + geom_boxplot() &gt; p3 &lt;- ggplot(mpg, aes(drv, displ)) + geom_violin() &gt; grid.arrange(p1, p2, p3, ncol=3) &gt; grid.arrange(p1, p2, p3, nrow=2, ncol=2) &gt; grid.arrange(p1, p2, p3, ncol=3, widths=c(0.5, 0.25, 0.25)) &gt; grid.arrange(p1, p2, p3, nrow=3, heights=c(0.25, 0.25, 0.5)) 다음은 arrangeGrob() 함수로 그래프를 묶은 다음 다시 이를 grid.arrange()에 보내 좀더 다양한 레이아웃의 그래프를 그린 예이다. &gt; grid.arrange(p1, arrangeGrob(p2, p3, ncol=2, widths=c(0.6, 0.4)), nrow=2, heights=c(0.4, 0.6)) 8.10.2 그래프 저장하기 RStudio 사용자가 R에서 그린 그래프를 저장하려면, RStudio의 [Plot] 패널에서 [Export]-[Save as Image…] 메뉴를 이용하면 된다. 이 메뉴를 사용하면 그래프를 저장할 파일 형식, 위치, 이름, 크기를 지정하여 저장할 수 있다. R 콘솔에서 그래프를 저장하려면 다음처럼 ggsave() 함수를 이용한다. &gt; p &lt;- ggplot(mpg, aes(cty, hwy)) + geom_point() &gt; ggsave(file=&quot;myplot.png&quot;, plot=p, width=5, height=4) 함수를 +로 결합시키는 것은 ggplot2에서만 사용하는 방식으로 다른 R 함수에는 적용되지는 않는다.↩︎ mapping에 범주형 변수가 맵핑되면 group 속성에 함께 이용되므로, group=``이 없으면 이 예에서는cut`의 수준별로 상대 빈도를 구하게 된다.↩︎ "],
["ch-R-Advanced-Data-Mgmt.html", "Chapter 9 R 고급 데이터 변환 9.1 데이터의 단순 결합 9.2 관계형 데이터베이스처럼 데이터 결합하기 9.3 tidyr 패키지를 이용하여 정돈 데이터 형식으로 바꾸기", " Chapter 9 R 고급 데이터 변환 7 장과 8 장에서 정돈 형식의 데이터를 변환하고 시각화하는 방법을 배웠다. 그러나 실제 데이터 분석에서는 분석하고자 하는 데이터가 하나의 데이터 프레임으로 정돈 형식으로 제공되는 경우가 많지 않다. 대부분의 경우 다음 두 가지 작업 중 하나 또는 두 가지 모두가 필요한 경우가 많다. [Merge] 다양한 원천에서 획득된 데이터를 하나의 정돈 형식의 데이터로 결합하기 [Reshape] 비정돈 형식의 데이터를 정돈 데이터 형식으로 변형하기 본 장에서는 이러한 데이터의 전처리에 필요한 다양한 기법을 논의한다. 데이터의 결합을 위해서는 dplyr 패키지를 사용할 것이며, 비정돈 형식의 데이터를 정돈 데이터 형식으로 변형하기 위해서는 tidyr 패키지를 사용할 것이다. 이 두 패키지는 모두 tidyverse 패키지에 속해 있으므로, 이 두 패키지를 사용하기 위해서 tidyverse 패키지를 적재한다. &gt; library(tidyverse) 9.1 데이터의 단순 결합 행으로 결합 vs. 열로 결합 데이터에 대한 결합이 필요한 다음 두 가지 상황을 고려해 보자. 데이터가 동일한 열 형식으로 여러 파일로 나뉘어져 있는 경우: 예를 들어 판매 실적 데이터가 2015년 데이터는 2015.csv 파일에 2016년 데이터는 2016.csv 파일에 있다고 가정해 보자. 이 경우 각 파일을 별도의 데이터 프레임으로 읽어들인 후 rbind() 함수를 이용하여 결합시킬 수 있다. 데이터가 동일한 행으로 되어 있으나, 서로 다른 열을 가지고 있는 경우: 예를 들어 사원 번호 순으로 한 파일에는 입사시점의 개인 정보가, 다른 파일에는 작년 인사 평가 결과 데이터가 있다고 하자. 두 파일에 동일한 사원 번호 순으로 데이터가 기록되어 있다면 두 파일의 정보를 데이터 프레임으로 읽어들인 후 cbind()로 결합할 수 있을 것이다. 데이터 프레임을 행과 열로 결합은 6 장에서 rbind()와 cbind() 함수를 사용하는 것을 보았을 것이다. 지금부터 설명하는 데이터를 행과 열로 결합하는 내용은 R의 기본 함수인 rbind()와 cbind()를 사용하여도 수행할 수 있다. 그러나 이 책에서는 dplyr 패키지의 bind_rows()와 bind_cols() 함수를 사용하여 여러 데이터 프레임을 행과 열로 결합할 것이다. bind_rows()와 bind_cols() 함수를 사용하는 이유는 이 두 함수가 R의 기본 함수보다 처리 속도가 빠를 뿐 아니라, R의 기본 함수보다는 편리한 기능을 가지고 있기 때문이다. 9.1.1 데이터를 행으로 결합하기 열 구조가 다른 데이터를 행으로 결합하기 데이터를 행으로 결합하는 작업이 필요한 경우, 데이터가 동일한 열 구조를 가지고 있지 않은 경우가 종종 발생한다. 동일한 열을 가지고 있더라도 열 이름이 서로 다른 경우도 있다. 이런 경우에는 결합하려는 데이터 프레임을 동일한 열 구조로 변형하여 결합하여야 한다. 예를 들어 다음과 같이 classData.RData에 포함된 class1과 class2 데이터에는 두 분반의 중간 및 기말 고사 정보 등이 들어 있다고 하자. &gt; load(&quot;advancedDataMgmt.RData&quot;) &gt; class1 ID Name Gender Year Address Midterm Final Team 1 15 김철수 M 1 서울 78 59 A 2 18 김영희 F 3 경기 85 87 A 3 25 이철수 M 3 충남 80 70 B 4 34 이영희 F 2 대전 92 89 B 5 151 홍길동 Male 4 세종 58 66 B &gt; class2 ID Mid Final Name Team Gen Year 1 12 75 79 장철수 C M 2 2 19 75 89 장영희 C F 2 3 28 87 76 최철수 D M 1 4 45 82 79 최영희 D F 30 두 파일 모두 학번(ID), 중간고사(Midterm), 기말고사(Final), 프로젝트 팀(Team), 성별(Gender), 학년(Year)에 대한 정보를 포함하고 있으나, class1에는 학생의 주소(Address) 정보가 포함되어 있고 class2는 그렇지 않다. 또한 두 파일의 열의 위치도 다르고 열의 이름도 조금 다르다. rbind()는 열의 개수가 다른 데이터 프레임을 행으로 결합하지 못한다. 두 분반 학생의 점수를 통합하여 성적 처리를 하기 위해 두 분반의 데이터를 결합하려고 한다고 하자. 이를 어떻게 수행하여야 할까? rbind()로 먼저 두 데이터 프레임을 통합하려고 시도해 보자. &gt; rbind(class1, class2) Error in rbind(deparse.level, ...): numbers of columns of arguments do not match 열의 수가 다르기 때문에 결합이 되지 않음을 알 수 있다. 따라서 rbind()로 두 데이터를 결합하려면 class1에만 있는 Address 열을 어떻게 처리할지를 결정해야 한다. 일반적으로 다음 둘 중 하나의 방법을 택해야 문제를 해결한다. 첫번째 방법은 class1의 Address 열을 제외하고 결합하는 것이고, 두번째 방법은 class2에 Address 열을 추가하고 결측치(NA)로 값을 준 후 결합하는 것이다. bind_rows()는 열의 개수가 다른 데이터 프레임임도 행으로 결합을 한다. 두 분반 학생의 데이터를 dplyr 패키지의 bind_rows() 함수를 사용하여 연결해 보자. &gt; bind_rows(class1, class2) ID Name Gender Year Address Midterm Final Team Mid Gen 1 15 김철수 M 1 서울 78 59 A NA &lt;NA&gt; 2 18 김영희 F 3 경기 85 87 A NA &lt;NA&gt; 3 25 이철수 M 3 충남 80 70 B NA &lt;NA&gt; 4 34 이영희 F 2 대전 92 89 B NA &lt;NA&gt; 5 151 홍길동 Male 4 세종 58 66 B NA &lt;NA&gt; 6 12 장철수 &lt;NA&gt; 2 &lt;NA&gt; NA 79 C 75 M 7 19 장영희 &lt;NA&gt; 2 &lt;NA&gt; NA 89 C 75 F 8 28 최철수 &lt;NA&gt; 1 &lt;NA&gt; NA 76 D 87 M 9 45 최영희 &lt;NA&gt; 30 &lt;NA&gt; NA 79 D 82 F 열의 개수가 달라도 결합이 이루어지는 것을 볼 수 있다. 두 데이터에서 서로 없는 열은 결측치 NA로 처리되어 결합이 이루어지는 것을 볼 수 있다. 그러나 사실 class1의 Midterm과 class2의 Mid는 중간고사 점수 열로 같으나 이름이 다른 것 뿐이다. bind_rows()는 이름이 다르면 서로 다른 열이라고 생각하여 각각의 새로운 열을 만들어 결합을 한다. 그러므로 사실상 같은 열이 서로 다른 이름으로 되어 있는지 살펴보아야 한다. rbind()는 두 데이터의 열의 이름이 다른 경우 행으로 결합하지 못한다. class1 데이터의 Address 열을 제외하고 두 데이터를 다시 rbind()로 결합해 보자. &gt; rbind(select(class1, -Address), class2) Error in match.names(clabs, names(xi)): names do not match previous names rbind()는 열의 개수가 동일하더라도 두 데이터 프레임의 열의 이름이 서로 다르면 행으로 결합하지 못함을 볼 수 있다. 지금 중간고사 점수 열과 성별 열의 이름이 서로 다르기 때문에 연결이 안되는 것이므로 다음처럼 열의 이름을 변경한 후 두 데이터 프레임을 행으로 연결시킨다. &gt; rbind(select(class1, -Address), rename(class2, Midterm = Mid, Gender = Gen)) ID Name Gender Year Midterm Final Team 1 15 김철수 M 1 78 59 A 2 18 김영희 F 3 85 87 A 3 25 이철수 M 3 80 70 B 4 34 이영희 F 2 92 89 B 5 151 홍길동 Male 4 58 66 B 6 12 장철수 M 2 75 79 C 7 19 장영희 F 2 75 89 C 8 28 최철수 M 1 87 76 D 9 45 최영희 F 30 82 79 D rbind()와 bind_rows()는 열의 순서를 자동으로 맞춘다. 이제 두 데이터 프레임의 열의 형태가 같아졌으므로 bind_rows()로 두 데이터를 원하는 방식으로 합칠 수 있다. 두 데이터 프레임의 열의 순서가 다른 경우 rbind()와 bind_rows()는 첫번째 데이터 프레임의 열 이름을 기준으로 열의 순서를 자동으로 맞추어 준다. &gt; class12 &lt;- bind_rows(class1, rename(class2, Midterm = Mid, Gender = Gen)) &gt; class12 ID Name Gender Year Address Midterm Final Team 1 15 김철수 M 1 서울 78 59 A 2 18 김영희 F 3 경기 85 87 A 3 25 이철수 M 3 충남 80 70 B 4 34 이영희 F 2 대전 92 89 B 5 151 홍길동 Male 4 세종 58 66 B 6 12 장철수 M 2 &lt;NA&gt; 75 79 C 7 19 장영희 F 2 &lt;NA&gt; 75 89 C 8 28 최철수 M 1 &lt;NA&gt; 87 76 D 9 45 최영희 F 30 &lt;NA&gt; 82 79 D 실제 데이터를 행으로 결합하는 과정에는 훨씬 더 다양한 문제들이 발생한다. 예를 들어 동일한 키를 나타내는 열이 하나는 cm로 하나는 m 단위로 정보가 주어져 있으면 이를 하나의 단위로 통일해야 한다. 그러나 복잡한 문제들도 결국 서로 다른 열 구조를 행으로 결합하기 위해서 어떤 열을 추가하거나 제외할 것인지를 결정하고, 열의 형식과 이름을 어떻게 통일할 것인가를 고려하는 과정이라는 점에서 본질적으로는 앞의 예와 동일하다 할 수 있다. 9.1.2 데이터를 열로 결합하기 행 순서가 다른 데이터를 열로 결합하기 데이터를 열로 결합하는 경우 실제 데이터가 동일한 행 순서로 정렬되어 있지 않은 경우가 종종 있다. 예를 들어 앞의 예에서 성적 처리를 위해서는 학생의 중간, 기말 고사 점수와 함께 출석 점수를 고려해야 한다고 하자. 그리고 출석점수는 attendance 데이터 프레임에 다음과 같이 class1과 class2의 모든 학생의 학번(ID) 순으로 정렬되어 분반 정보(Class)와 출석 점수(Attend)가 저장되어 있다고 하자. &gt; attendance ID Class Attend 1 12 2 185 2 15 1 90 3 18 1 95 4 19 2 100 5 25 1 100 6 28 2 100 7 34 1 100 8 45 2 100 9 151 1 95 앞서 두 분반의 중간 및 기말 고사 데이터가 합쳐진 class12는 학번이 기준이 아니라 분반으로 정렬되어 있다. 따라서 이 두 데이터 프레임을 단순하게 열로 결합하면 출석점수가 엉뚱한 학생에게 부여된다. 정렬 후 열로 결합하기 이를 해결하는 가장 간단한 방법은 두 데이터 프레임을 동일한 기준으로 정렬한 후 cbind()나 bind_cols()를 수행하는 것이다. 먼저 class12를 ID 순으로 정렬한 후 열로 결합해 보자. 그런데 ID 열은 두 데이터 프레임에 모두 있으므로 하나는 불필요하다. 따라서 attendance 데이터 프레임의 ID 정보는 제거한 후 결합한다. &gt; class12.a &lt;- bind_cols(arrange(class12, ID), select(attendance, -ID)) &gt; class12.a ID Name Gender Year Address Midterm Final Team Class Attend 1 12 장철수 M 2 &lt;NA&gt; 75 79 C 2 185 2 15 김철수 M 1 서울 78 59 A 1 90 3 18 김영희 F 3 경기 85 87 A 1 95 4 19 장영희 F 2 &lt;NA&gt; 75 89 C 2 100 5 25 이철수 M 3 충남 80 70 B 1 100 6 28 최철수 M 1 &lt;NA&gt; 87 76 D 2 100 7 34 이영희 F 2 대전 92 89 B 1 100 8 45 최영희 F 30 &lt;NA&gt; 82 79 D 2 100 9 151 홍길동 Male 4 세종 58 66 B 1 95 다른 방법으로 attendance 데이터 프레임을 Class와 ID 열로 정렬한 후 class12 데이터 프레임과 결합할 수도 있다. &gt; class12.b &lt;- bind_cols(class12, attendance %&gt;% arrange(Class, ID) %&gt;% select(-ID)) &gt; class12.b ID Name Gender Year Address Midterm Final Team Class Attend 1 15 김철수 M 1 서울 78 59 A 1 90 2 18 김영희 F 3 경기 85 87 A 1 95 3 25 이철수 M 3 충남 80 70 B 1 100 4 34 이영희 F 2 대전 92 89 B 1 100 5 151 홍길동 Male 4 세종 58 66 B 1 95 6 12 장철수 M 2 &lt;NA&gt; 75 79 C 2 185 7 19 장영희 F 2 &lt;NA&gt; 75 89 C 2 100 8 28 최철수 M 1 &lt;NA&gt; 87 76 D 2 100 9 45 최영희 F 30 &lt;NA&gt; 82 79 D 2 100 실제 데이터는 이보다 더 복잡한 문제를 가지고 있는 경우가 많다. 예를 들어 한 파일에 있는 행이 다른 파일에는 없는 경우도 있다. 이러한 경우엔 그 행의 정보를 모두 제거할 것인지, 아니면 그 행에 대해 없는 정보는 NA로 하여 결합을 할지 결정해야 한다. 결국 cbind()나 bind_rows()를 이용하여 열로 결합하기 위해서는 두 데이터의 행이 동일한 개체에 대한 정보가 되도록 일치시키는 것이 중요하다. 그런데 매번 두 데이터가 동일한 행으로 결합되도록 정렬하여 결합하는 작업을 사용자가 직접 하는 것은 오류 발생 가능성이 많다. 따라서 이 작업은 다음에 소개하는 ’관계형 데이터베이스처럼 데이터 결합하기’에 소개하는 방법을 사용할 것을 권장한다. 9.2 관계형 데이터베이스처럼 데이터 결합하기 관계형 데이터베이스에서는 서로 다른 열 정보를 담고 있는 두 데이터 테이블을 key를 사용하여 join이라는 방식을 이용하여 연결시킨다. 여기서 key란 앞서 성적 데이터와 출석 데이터에서 특정 학생 정보임을 식별할 수 있는 학번(ID) 등을 말한다. R에서도 두 데이터 프레임을 관계형 데이터베이스의 join과 같은 방식으로 결합시킬 수 있다. 이 작업은 R의 기본 함수인 merge() 함수를 이용하여 수행할 수도 있고, dplyr 패키지의 join 함수들을 사용하여 수행할 수도 있다. 이 책에서는 dplyr의 join 함수들을 이용하여 관계형 데이터베이스처럼 결합하기를 수행하는 방법을 설명하도록 한다. 9.2.1 Inner join과 outer join 앞의 예에서 우리는 중간, 기말 고사 점수를 가지고 있는 class12 데이터 프레임과 출석 점수를 가지고 있는 attendance 데이터 프레임을 합치기 위해 ID 열로 데이터 프레임을 정렬한 후 bind_cols()로 연결하였다. 이 작업은 dplyr의 inner_join() 함수를 이용하면 더 손쉽게 수행할 수 있다. inner_join() inner_join() 함수는 결합할 두 데이터 프레임을 인수로 먼저 기술한 다음 by 인수에 어떤 열을 기준으로 결합할 것인지를 열 이름으로 기술한다. inner_join() 함수는 두 데이터 프레임에서 by 인수로 주어진 열의 값이 동일한 행을 서로 연결하여 새로운 데이터 프레임을 만든다. 또한 새로 만들어진 데이터 프레임은 by 열을 기준으로 정렬이 이루어진다. &gt; inner_join(class12, attendance, by=&quot;ID&quot;) ID Name Gender Year Address Midterm Final Team Class Attend 1 15 김철수 M 1 서울 78 59 A 1 90 2 18 김영희 F 3 경기 85 87 A 1 95 3 25 이철수 M 3 충남 80 70 B 1 100 4 34 이영희 F 2 대전 92 89 B 1 100 5 151 홍길동 Male 4 세종 58 66 B 1 95 6 12 장철수 M 2 &lt;NA&gt; 75 79 C 2 185 7 19 장영희 F 2 &lt;NA&gt; 75 89 C 2 100 8 28 최철수 M 1 &lt;NA&gt; 87 76 D 2 100 9 45 최영희 F 30 &lt;NA&gt; 82 79 D 2 100 만약 두 데이터 프레임이 결합의 기준이 되는 열의 이름이 다르면 `by = c(“key.x” = “key.y”) 형식으로 두 데이터 프레임의 키 열의 이름을 기술하여 결합하면 된다. 만약 결합의 기준이 되는 열이 두 개 이상이면 `by = c(“key1”, “key2”) 형식으로 기술한다. 만약 결합의 기준이 되는 열이 두 개 이상이고 서로 이름이 다르면 by = c(\"key1.x\" = \"key1.y\", \"key2.x\" = \"key2.y\") 형식으로 두 데이터 프레임의 키 열의 이름을 기술한다. 관련 정보는 inner_join() 함수의 도움말을 참조하라. 1:1 inner join 앞의 예처럼 데이터가 결합되는 방식을 1 대 1 inner join이라고 부른다. 두 데이터 프레임에 ID가 동일한 학생은 오직 한 명만 존재하고, 두 데이터 프레임의 학생의 ID가 일 대 일로 대응된다. 따라서 두 데이터 프레임의 행들이 일 대 일로 결합되어 새로운 데이터 프레임이 생성된다. by 인수가 주어지지 않으면 inner_join() 함수는 두 데이터 프레임에서 이름이 같은 열을 찾고 그 열을 기준으로 결합을 한다. 따라서 위의 경우 by 인수를 설정하지 않으면, 두 데이터 프레임에 공통으로 있는 ID 열을 기준으로 데이터가 결합된다. &gt; inner_join(class12, attendance) Joining, by = &quot;ID&quot; ID Name Gender Year Address Midterm Final Team Class Attend 1 15 김철수 M 1 서울 78 59 A 1 90 2 18 김영희 F 3 경기 85 87 A 1 95 3 25 이철수 M 3 충남 80 70 B 1 100 4 34 이영희 F 2 대전 92 89 B 1 100 5 151 홍길동 Male 4 세종 58 66 B 1 95 6 12 장철수 M 2 &lt;NA&gt; 75 79 C 2 185 7 19 장영희 F 2 &lt;NA&gt; 75 89 C 2 100 8 28 최철수 M 1 &lt;NA&gt; 87 76 D 2 100 9 45 최영희 F 30 &lt;NA&gt; 82 79 D 2 100 0:1 inner join 앞서 inner_join() 함수는 두 데이터 프레임에서 by 인수로 주어진 열의 값이 같은 행을 서로 연결한다고 했다. 그러면 한 데이터 프레임에는 해당 개체의 정보가 있으나 다른 데이터 프레임에는 해당 개체의 정보가 없는 경우에 두 데이터 프레임을 연결하면 어떻게 될까? 다음 예처럼 class1에는 1분반 학생의 데이터만 있고, attendance는 1, 2분반의 학생 데이터가 모두 있는 경우 두 데이터 프레임을 ID 열로 결합하는 경우를 고려해 보자. attendance에는 동일한 ID를 가지고 있는 학생이 오직 한 명만 존재하고, class1에는 attendance에 있는 학생 정보가 0개 또는 1개가 있는 경우이다. 이러한 데이터 결합 방식을 0 대 1 inner join이라고 부른다. Inner join은 두 데이터 프레임에서 by로 지정된 열이 값이 서로 대응이 되는 행만 남겨둔다. 따라서 위의 경우에는 class1에 있는 학생의 행으로만 구성된 데이터 프레임이 생성된다. 즉, by 인수에 주어진 열이 서로 동일한 값을 가진 행만 결합되어 결과가 나오므로 한 쪽 데이터 프레임에 없는 행은 제거되었음을 알 수 있다. &gt; inner_join(class1, attendance, by=&quot;ID&quot;) ID Name Gender Year Address Midterm Final Team Class Attend 1 15 김철수 M 1 서울 78 59 A 1 90 2 18 김영희 F 3 경기 85 87 A 1 95 3 25 이철수 M 3 충남 80 70 B 1 100 4 34 이영희 F 2 대전 92 89 B 1 100 5 151 홍길동 Male 4 세종 58 66 B 1 95 outer join 한 쪽 데이터 프레임에 해당 행이 없더라도 어느 한쪽의 데이터 프레임에 행이 있으면 그 행을 포함시킬 필요가 있는 경우가 있다. 예를 들어 앞의 예에서 2분반의 중간 및 기말 고사 정보가 나중에 획득되면 추후 보강하기로 하고 현재 출석 점수가 있는 모든 학생의 정보가 나오도록 중간과 기말 점수와 출석 데이터를 결합한다고 하자. 이러한 경우 outer_join 함수들을 사용한다. Outer join 함수는 다음 세 가지가 있다. left_join(x, y): x에 있는 행을 모두 유지하여 join을 수행한다. right_join(x, y): y에 있는 행을 모두 유지하여 join을 수행한다. full_join(x, y): x와 y의 모든 행을 유지하여 join을 수행한다. 대신 한 쪽에 없는 정보는 모두 결측치 NA가 입력되어 결합된다. 다음은 inner_join(), left_join(), right_join(), full_join()의 차이가 무엇인지를 보여주는 예이다. &gt; x &lt;- data.frame(id = 1:3, name = letters[1:3]); x id name 1 1 a 2 2 b 3 3 c &gt; y &lt;- data.frame(id = 2:4, addr = LETTERS[2:4]); y id addr 1 2 B 2 3 C 3 4 D &gt; inner_join(x, y) Joining, by = &quot;id&quot; id name addr 1 2 b B 2 3 c C &gt; left_join(x, y) Joining, by = &quot;id&quot; id name addr 1 1 a &lt;NA&gt; 2 2 b B 3 3 c C &gt; right_join(x, y) Joining, by = &quot;id&quot; id name addr 1 2 b B 2 3 c C 3 4 &lt;NA&gt; D &gt; full_join(x, y) Joining, by = &quot;id&quot; id name addr 1 1 a &lt;NA&gt; 2 2 b B 3 3 c C 4 4 &lt;NA&gt; D 다음은 class1과 attendance 데이터에서 attendance의 모든 행을 남겨두는 outer join을 수행한 결과이다. &gt; right_join(class1, attendance, by=&quot;ID&quot;) ID Name Gender Year Address Midterm Final Team Class Attend 1 15 김철수 M 1 서울 78 59 A 1 90 2 18 김영희 F 3 경기 85 87 A 1 95 3 25 이철수 M 3 충남 80 70 B 1 100 4 34 이영희 F 2 대전 92 89 B 1 100 5 151 홍길동 Male 4 세종 58 66 B 1 95 6 12 &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; NA NA &lt;NA&gt; 2 185 7 19 &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; NA NA &lt;NA&gt; 2 100 8 28 &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; NA NA &lt;NA&gt; 2 100 9 45 &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; NA NA &lt;NA&gt; 2 100 1:n inner join 만약에 한 데이터 프레임에서 결합의 기준이 되는 열에 동일한 값이 여러번 나오면 어떻게 될까? 다음의 예를 살펴보면서 그 결과가 어떻게 되는지 확인해 보자. 지금까지 우리는 class12.a라는 데이터 프레임에 중간, 기말, 출석 점수를 통합하였다. 그런데 다음과 같이 프로젝트 팀별로 프로젝트 평가 점수가 있다고 하자. &gt; pjt Team Project 1 A 80 2 B 90 3 C 85 4 D 75 한 프로젝트 팀에는 2, 3 명의 학생이 포함되고, 프로젝트 점수는 프로젝트 팀별로 주어지고 학생 개별로는 부여되지 않는다. 따라서 학생의 성적을 산정하려면 각 학생이 어떤 프로젝트 팀에 속한지를 확인한 후 학생이 속한 프로젝트 팀의 점수를 그 학생의 프로젝트 점수로 부여하는 작업이 필요하다. 이 경우 class12.a와 pjt 데이터 프레임이 결합되어야 하는데, 결합의 기준 열은 프로젝트 팀을 나타내는 Team 열이 되어야 한다. 그런데 pjt 데이터 프레임에는 한 팀에 해당되는 행이 오직 한 개만 존재하지만, class12.a 데이터 프레임에는 한 팀에 속한 학생이 여러 명 있으므로 여러 행이 존재한다. 이러한 경우의 데이터 결합 방식을 1 대 n inner join이라고 한다. 다음은 inner_join()를 사용하여 n 대 1의 관계의 두 데이터 프레임을 inner join 한 결과이다. &gt; class12.c &lt;- inner_join(class12.a, pjt, by=&quot;Team&quot;) &gt; class12.c ID Name Gender Year Address Midterm Final Team Class Attend Project 1 12 장철수 M 2 &lt;NA&gt; 75 79 C 2 185 85 2 15 김철수 M 1 서울 78 59 A 1 90 80 3 18 김영희 F 3 경기 85 87 A 1 95 80 4 19 장영희 F 2 &lt;NA&gt; 75 89 C 2 100 85 5 25 이철수 M 3 충남 80 70 B 1 100 90 6 28 최철수 M 1 &lt;NA&gt; 87 76 D 2 100 75 7 34 이영희 F 2 대전 92 89 B 1 100 90 8 45 최영희 F 30 &lt;NA&gt; 82 79 D 2 100 75 9 151 홍길동 Male 4 세종 58 66 B 1 95 90 결과에서 보듯이 by 인수로 Team을 주게 되면, pjt 데이터 프레임에서 Team이 A인 행은 하나지만, class12.a에서 Team이 A이고 학번이 15번과 18번인 학생과 관련된 두 행이 존재하므로, pjt의 한 행이 이 두 행에 차례로 결합되어 새로운 행을 만들었음을 알 수 있다. 이처럼 inner_joint()는 by 인수로 주어진 행에 동일한 값이 여러번 있으면 해당 값으로 결합이 여러번 발생한다. 두 열 이상을 기준으로 join Join의 기준이 되는 열은 하나가 아니라 여러 개가 될 수 있다. 다음과 같은 두 개의 데이터 프레임이 있다고 하자. 그리고 이 두 데이터 프레임을 하나의 데이터 프레임으로 결합한다고 하자. &gt; cAge first.name last.name age 1 James Bolton 34 2 James Tiger 26 3 Goerge Tiger 47 &gt; cIncome first.name last.name income 1 Goerge Tiger 35 2 James Bolton 24 3 James Tiger 18 두 데이터 프레임 각각에는 한 사람에 대한 정보는 오직 한 행에만 정보가 기술되어 있다. 그러나 두 데이터 프레임에서 first.name이 동일한 사람이 2명, last.name이 동일한 사람이 2명이 있다. 그래서 first.name이나 last.name만으로 데이터를 결합한다면 동일한 이름을 가진 사람이 있어서 원하는 결과를 얻을 수 없다. 다음은 first.name으로 결합한 결과이다. &gt; inner_join(cAge, cIncome, by=&quot;first.name&quot;) first.name last.name.x age last.name.y income 1 James Bolton 34 Bolton 24 2 James Bolton 34 Tiger 18 3 James Tiger 26 Bolton 24 4 James Tiger 26 Tiger 18 5 Goerge Tiger 47 Tiger 35 결과에서 보듯이 cAge의 James Bolton 행은 cIncome의 James Bolton과 James Tiger 행과 first.name이 동일하므로 두 번 결합이 이루어진다. 마찬가지로 cAge의 James Tiger 행도 cIncome의 James Bolton과 James Tiger 행과 first.name이 동일하므로 역시 두 번 행 결합이 발생한다. 그래서 결합된 결과가 3건이 아니라 총 5건의 데이터 행을 갖는다. 그리고 cAge와 cIncome 모두 last.name 열이 있어서 어떤 last.name을 남겨두어야 할지 모르므로, 첫번째 데이터 프레임에서 온 열은 .x, 두번째 데이터 프레임에서 온 열은 .y라는 접미사를 붙여서 열을 만들었다. 이러한 경우는 first.name과 last.name이 모두 같은 경우에만 행이 결합되도록 하는 것이 더 바람직하다. 그렇게 하려면 이 두 열의 이름을 모두 by 인수로 전달하면 된다. &gt; inner_join(cAge, cIncome, by=c(&quot;last.name&quot;, &quot;first.name&quot;)) first.name last.name age income 1 James Bolton 34 24 2 James Tiger 26 18 3 Goerge Tiger 47 35 9.2.2 Filtering join 지금까지는 두 데이터 프레임의 키 값이 같은 행을 inner 또는 outer join으로 연결하는 방법을 살펴보았다. 그런데 어떤 경우에는 한 데이터 프레임의 데이터를 다른 데이터 프레임의 정보를 사용하여 필터링해야 하는 경우가 있다. 다음의 두 예를 고려해 보자. 어떤 도시의 거주자의 자산 데이터와 그 도시의 세금 체납자 데이터가 있다고 하자. 이 때 거주자의 자산 정보에서 세금 체납자의 자산 정보만 뽑아서 분석하려고 한다. 어떻게 이 정보를 뽑아낼 수 있을까? 어떤 텍스트에서 사용된 단어 데이터와 의마가 없는 단어인 불용어 데이터가 있다고 하자. 이 때 텍스트의 단어 데이터에서 불용어는 제외하고 데이터를 분석하려고 한다. 어떻게 이 정보를 뽑아낼 수 있을까? dplyr 패키지에는 이 작업을 위해 다음 두 함수를 제공한다. semi_join(x, y): x 데이터 프레임에서 y에 있는 데이터만 뽑아낸다. Inner join과 다른 점은 두 데이터 프레임의 정보를 결합하지 않는다는 것이다. x 데이터 프레임에서 남겨둘 행을 지정하기 위해서만 y를 사용한다. anti_join(x, y): x 데이터 프레임에서 y에 있는 행은 제외한다. &gt; x %&gt;% semi_join(y, by = &quot;id&quot;) id name 1 2 b 2 3 c &gt; x %&gt;% anti_join(y, by = &quot;id&quot;) id name 1 1 a 9.2.3 Join을 수행하는 다른 방법들 9.2.3.1 merge() 함수 R의 기본 함수인 merge() 함수는 dplyr 패키지의 inner와 outer join을 수행해 준다. &gt; merge(x, y) # inner join id name addr 1 2 b B 2 3 c C &gt; merge(x, y, all.x = TRUE) # left join id name addr 1 1 a &lt;NA&gt; 2 2 b B 3 3 c C &gt; merge(x, y, all.y = TRUE) # right join id name addr 1 2 b B 2 3 c C 3 4 &lt;NA&gt; D &gt; merge(x, y, all = TRUE) # full join id name addr 1 1 a &lt;NA&gt; 2 2 b B 3 3 c C 4 4 &lt;NA&gt; D sqldf 패키지 지금까지 dplyr의 join 함수를 이용하여 관계형 데이터베이스의 join과 유사한 데이터 결합을 어떻게 수행하는지 살펴보았다. 그런데 관계형 데이터베이스의 SQL에 익숙한 사람들은 R에서 SQL처럼 좀 더 다양한 방식으로 join을 수행할 수 없을까라는 의문을 가질 수 있다. sqldf 패키지는 SQL 문법을 이용하여 R의 데이터 프레임에서 데이터를 조회하거나 결합할 수 있도록 해 준다. 이러한 기능이 필요한 사람은 이 패키지의 문서를 참조하기 바란다. 그러나 R은 데이터 분석을 위한 도구이지 관계형 데이터베이스와 같은 일을 수행하기 위한 도구가 아님을 명심할 필요가 있다. 대량의 데이터의 결합이 필요하다면 관계형 데이터베이스에서 SQL을 이용하여 이를 먼저 수행한 후 최종 결과를 R로 보내어 분석을 수행하는 것이 일반적으로 더 효율적인 방법이다. 9.3 tidyr 패키지를 이용하여 정돈 데이터 형식으로 바꾸기 tidyr 패키지는 tidyverse 패키지에 포함된 패키지로 비정돈 형식의 데이터를 정돈 형식으로 바꾸어주는 함수를 가지고 있다. 9.3.1 pivot_longer: 여러 열에 걸친 한 변수의 데이터를 하나의 열로 길게 모으기 정돈 데이터는 한 열이 하나의 변수에 대응을 해야 한다. 그러나 현실의 데이터에서는 동일한 변수의 값이 여러 열에 흩뿌려져 있는 경우가 발생한다. 시계열 데이터들이 대표적인 사례라 할 수 있다. 다음은 tidyr에 포함된 table4a 데이터이다. 세 나라의 1999년도와 2000년도의 어떤 사건의 발생 건수를 보여주고 있다. 발생 건수를 나타내는 데이터 열이 두 개의 열로 나눠져 있음을 볼 수 있다. &gt; table4a # A tibble: 3 x 3 country `1999` `2000` * &lt;chr&gt; &lt;int&gt; &lt;int&gt; 1 Afghanistan 745 2666 2 Brazil 37737 80488 3 China 212258 213766 table4a를 정돈 데이터로 바꾸려면 두 열을 한 열로 모아야 한다. tidyr의 pivot_longer() 함수는 그러한 역할을 수행한다. &gt; table4a %&gt;% + pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, values_to =&quot;cases&quot;) # A tibble: 6 x 3 country year cases &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 Afghanistan 1999 745 2 Afghanistan 2000 2666 3 Brazil 1999 37737 4 Brazil 2000 80488 5 China 1999 212258 6 China 2000 213766 pivot_longer()에 모아야 할 열의 이름을 지정한다. 이 예에서는 1999와 2000이다. 두 열의 이름은 숫자로 시작하고 있어서 표준적인 형태를 따르지 않아서 ` `으로 둘러쌓여 표현되었다. 원 데이터의 열 이름을 표현할 변수를 names_to로 지정한다. 원 데이터의 열의 값을 표현할 변수를 values_to로 지정한다. 원 데이터의 열 이름은 변수로서 따옴표 없이 지정되고, 결과 데이터에 만들 열 이름은 아직 만들어진 변수가 아니므로 변수의 이름이 따옴표로 둘러쌓여 문자열로 전달된다. 다음 그림은 앞의 pivot_longer() 함수의 작동 방식을 보여준다. 원 데이터보다 길어진 형식으로 데이터가 변환되므로 longer라는 표현이 사용되었다. Figure 9.1: pivot_longer 작동 방식 (출처: R for Data Science) 결측치가 있는 경우 table4a에서 중국의 2000년도 데이터가 조사되지 않아서 NA로 표시되어 있다면 pivot_longer()는 어떤 결과를 줄까? 다음 결과에서 보듯이 결측치가 있는 셀도 모두 별도의 행으로 표현이 된다. &gt; na_table4a &lt;- table4a &gt; na_table4a$`2000`[3] &lt;- NA &gt; na_table4a # A tibble: 3 x 3 country `1999` `2000` &lt;chr&gt; &lt;int&gt; &lt;int&gt; 1 Afghanistan 745 2666 2 Brazil 37737 80488 3 China 212258 NA &gt; na_table4a %&gt;% + pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, values_to = &quot;cases&quot;) # A tibble: 6 x 3 country year cases &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 Afghanistan 1999 745 2 Afghanistan 2000 2666 3 Brazil 1999 37737 4 Brazil 2000 80488 5 China 1999 212258 6 China 2000 NA 만약 긴 형식에서는 결측치인 행을 없애고 싶으면 values_drop_na 인수를 TRUE로 설정한다. &gt; na_long_table4a &lt;- na_table4a %&gt;% + pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, + values_to = &quot;cases&quot;, values_drop_na = T) &gt; na_long_table4a # A tibble: 5 x 3 country year cases &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 Afghanistan 1999 745 2 Afghanistan 2000 2666 3 Brazil 1999 37737 4 Brazil 2000 80488 5 China 1999 212258 gather 함수 tidyr 패키지는 1.0 버전이 출시되면서 많은 변화가 있었다. 이전 버전의 에서는 gather() 함수가 pivot_longer() 함수의 역할을 수행하였다. 그리고 호환성을 위해 현재의 버전에서도 gather() 함수를 사용할 수 있다. 아직도 많은 R 관련 책에서 이 함수를 사용하고 있어서 사용법을 여기에 기술한다. &gt; table4a %&gt;% + gather(`1999`, `2000`, key = &quot;year&quot;, value =&quot;cases&quot;) # A tibble: 6 x 3 country year cases &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 Afghanistan 1999 745 2 Brazil 1999 37737 3 China 1999 212258 4 Afghanistan 2000 2666 5 Brazil 2000 80488 6 China 2000 213766 pivot_longer와 유사한 형식인데, gather에서는 합칠 열의 이름을 각각의 인수로 전달된다. names_to와 values_to라는 원 데이터 입장에서의 인수 이름이 gather에서는 합쳐진 데이터 입장에서의 인수 이름인 key와 value라고 기술된다. 9.3.2 pivot_wider: 한 열에 기술된 여러 변수의 데이터를 여러 열로 넓게 펼치기 정돈 데이터는 하나의 열은 하나의 변수에 대응을 해야 한다. 그러나 현실의 데이터에서는 한 열에 여러 변수의 값이 표현되어 있는 경우도 있다. 다음 데이터는 세 나라의 어떤 년도의 사건의 발생 건수와 인구수가 count라는 한 열에 표현되었다. 그렇기 때문에 count 열은 인구수와 사건 횟수라는 두 변수의 값을 모두 포함한 열이 되었다. &gt; table2 # A tibble: 12 x 4 country year type count &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; 1 Afghanistan 1999 cases 745 2 Afghanistan 1999 population 19987071 3 Afghanistan 2000 cases 2666 4 Afghanistan 2000 population 20595360 5 Brazil 1999 cases 37737 6 Brazil 1999 population 172006362 7 Brazil 2000 cases 80488 8 Brazil 2000 population 174504898 9 China 1999 cases 212258 10 China 1999 population 1272915272 11 China 2000 cases 213766 12 China 2000 population 1280428583 table2를 정돈 데이터로 바꾸려면 count 열의 데이터를 인구수와 사건 횟수를 나타내는 열로 분리하여 한다. tidyr의 pivot_wider() 함수는 그러한 역할을 수행한다. &gt; table2 %&gt;% + pivot_wider(names_from = type, values_from = count) # A tibble: 6 x 4 country year cases population &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 Afghanistan 1999 745 19987071 2 Afghanistan 2000 2666 20595360 3 Brazil 1999 37737 172006362 4 Brazil 2000 80488 174504898 5 China 1999 212258 1272915272 6 China 2000 213766 1280428583 pivot_wider()는 결과 펼쳐진 결과 데이터에서 열의 이름으로 사용될 변수를 names_from 인수로 지정한다. 펼쳐진 결과 데이터에서 열의 값으로 사용될 변수를 values_from 인수로 지정한다. names_from과 values_from 인수를 지정할 때, 원 데이터의 열을 지정하는 것이므로 따옴표 없이 변수로서 지정한다. 다음 그림은 앞의 pivot_wider() 함수의 작동 방식을 보여준다. Figure 9.2: pivot_wider의 작동 방식 (출처: R for Data Science) 결측치가 있는 경우 앞서 pivot_longer()에서 중국의 2000년도 데이터에 결측값이 있는 행을 제거하여 데이터 프레임을 만들었다. &gt; na_long_table4a # A tibble: 5 x 3 country year cases &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 Afghanistan 1999 745 2 Afghanistan 2000 2666 3 Brazil 1999 37737 4 Brazil 2000 80488 5 China 1999 212258 만약 이 데이터를 넓은 형식으로 합치면 어떤 결과가 나올까? 결과에서 보듯이 결측이 있는 곳이 NA로 표시되고 데이터가 넓은 형식으로 변환된다. &gt; na_long_table4a %&gt;% + pivot_wider(names_from = year, values_from = cases) # A tibble: 3 x 3 country `1999` `2000` &lt;chr&gt; &lt;int&gt; &lt;int&gt; 1 Afghanistan 745 2666 2 Brazil 37737 80488 3 China 212258 NA spread 함수 tidyr 패키지는 1.0 버전이 출시되면서 많은 변화가 있었다. 이전 버전의 에서는 spread() 함수가 pivot_wider() 함수의 역할을 수행하였다. 그리고 호환성을 위해 현재의 버전에서도 spread() 함수를 사용할 수 있다. 아직도 많은 R 관련 책에서 이 함수를 사용하고 있어서 사용법을 여기에 기술한다. &gt; table2 %&gt;% + spread(key = type, value = count) # A tibble: 6 x 4 country year cases population &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 Afghanistan 1999 745 19987071 2 Afghanistan 2000 2666 20595360 3 Brazil 1999 37737 172006362 4 Brazil 2000 80488 174504898 5 China 1999 212258 1272915272 6 China 2000 213766 1280428583 pivot_wider와 유사한 형식인데 names_from와 values_from이라는 인수 이름이 spread에서는 key와 value라고 기술된다. 9.3.3 seperate: 한 셀을 여러 셀로 분리하기 한 셀에 여러 값이 기술되어 있으면 정돈 형식의 데이터가 아니다. table3의 rate 열은 사건의 수와 인구수 데이터가 문자열 형식으로 표현된 열이다. &gt; table3 # A tibble: 6 x 3 country year rate * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; 1 Afghanistan 1999 745/19987071 2 Afghanistan 2000 2666/20595360 3 Brazil 1999 37737/172006362 4 Brazil 2000 80488/174504898 5 China 1999 212258/1272915272 6 China 2000 213766/1280428583 9.3.3.1 특정 문자를 기준으로 분리하기 seperate()는 정해진 열을 sep에 지정된 문자를 기준으로 분리하여 분리된 값을 into에 지정된 열 이름으로 분리한다. 앞의 다른 함수와 마찬가지로 원 데이터의 열은 변수로서 따옴표 없이 지정되었고 결과 데이터에 사용될 열 이름은 따옴표를 사용하여 문자열로 전달되었다. &gt; table3 %&gt;% + separate(rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot;) # A tibble: 6 x 4 country year cases population &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 1999 745 19987071 2 Afghanistan 2000 2666 20595360 3 Brazil 1999 37737 172006362 4 Brazil 2000 80488 174504898 5 China 1999 212258 1272915272 6 China 2000 213766 1280428583 다음 그림은 앞의 seperate() 함수의 작동 방식을 보여준다. Figure 9.3: separate의 작동 방식 (출처: R for Data Science) sep은 구분자로 사용할 일반 문자뿐 아니라 정규 표현식을 사용하여 문자를 분리할 수 있다. 9.3.3.2 분리한 열의 형변환 앞의 결과를 보면 rate 열의 데이터가 문자열이기 때문에 결과 열도 모두 문자열 형식임을 볼 수 있다. 그런데 cases와 population 열은 모두 숫자로서 의미를 가지고 있으므로 숫자로 변환되는 것이 좋다. 셀의 내용을 분리한 후 숫자나 논리값으로 변형이 가능하면 변형을 하려면 convert 인수를 TRUE로 설정한다. &gt; x &lt;- table3 %&gt;% + separate(rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot;, convert = TRUE) &gt; x # A tibble: 6 x 4 country year cases population &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 Afghanistan 1999 745 19987071 2 Afghanistan 2000 2666 20595360 3 Brazil 1999 37737 172006362 4 Brazil 2000 80488 174504898 5 China 1999 212258 1272915272 6 China 2000 213766 1280428583 &gt; x %&gt;% summarise(total_cases=sum(cases), mean_pop=mean(population)) # A tibble: 1 x 2 total_cases mean_pop &lt;int&gt; &lt;dbl&gt; 1 547660 490072924. 9.3.3.3 문자 수를 기준으로 분리하기 sep 인수에 문자 대신 숫자를 입력하면 문자 수를를 기준으로 열을 분리한다. 양수이면 왼쪽에서 시작하여 sep에 입력된 문자 수까지와 그 이후로 열을 분리하고, 음수이면 오른쪽을 기준으로 sep에 입력된 문자 수까지와 그 이전으로 열을 분리한다. &gt; table3 %&gt;% + separate(rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=3) # A tibble: 6 x 4 country year cases population &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 1999 745 /19987071 2 Afghanistan 2000 266 6/20595360 3 Brazil 1999 377 37/172006362 4 Brazil 2000 804 88/174504898 5 China 1999 212 258/1272915272 6 China 2000 213 766/1280428583 &gt; table3 %&gt;% + separate(rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=-3) # A tibble: 6 x 4 country year cases population &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 1999 745/19987 071 2 Afghanistan 2000 2666/20595 360 3 Brazil 1999 37737/172006 362 4 Brazil 2000 80488/174504 898 5 China 1999 212258/1272915 272 6 China 2000 213766/1280428 583 앞의 예에서 숫자열인 year에 적용하여 세기와 나머지 년도로 분리해 내보자. &gt; table3 %&gt;% + separate(year, into=c(&quot;century&quot;, &quot;year&quot;), sep=2) # A tibble: 6 x 4 country century year rate &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 19 99 745/19987071 2 Afghanistan 20 00 2666/20595360 3 Brazil 19 99 37737/172006362 4 Brazil 20 00 80488/174504898 5 China 19 99 212258/1272915272 6 China 20 00 213766/1280428583 만약 세기와 연도를 숫자로 표현하는 것이 필요하다면 앞서 설명한 것처럼 convert 인수를 TRUE로 설정하면 된다. 이 경우 00년도가 모두 숫자 0으로 변환된 것을 볼 수 있다. &gt; table3 %&gt;% + separate(year, into=c(&quot;century&quot;, &quot;year&quot;), sep=2, convert = T) # A tibble: 6 x 4 country century year rate &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; 1 Afghanistan 19 99 745/19987071 2 Afghanistan 20 0 2666/20595360 3 Brazil 19 99 37737/172006362 4 Brazil 20 0 80488/174504898 5 China 19 99 212258/1272915272 6 China 20 0 213766/1280428583 9.3.4 unite: 여러 셀의 데이터를 하나의 셀로 병합하기 separate() 함수와 반대 작용을 하는 함수가 unite() 함수이다. unite() 함수는 여러 셀의 내용을 하나의 셀로 합친다. table5는 년도 데이터가 세기(century)와 나머지 년도(year)로 나뉘어져 있는 데이터이다. 세기와 무관하게 년도 별로 데이터를 분석하려고 하면 이 두 열을 합쳐서 온전한 년도 데이터를 만들어야 한다. &gt; table5 %&gt;% + unite(c(century, year), col = &quot;year&quot;) # A tibble: 6 x 3 country year rate &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 19_99 745/19987071 2 Afghanistan 20_00 2666/20595360 3 Brazil 19_99 37737/172006362 4 Brazil 20_00 80488/174504898 5 China 19_99 212258/1272915272 6 China 20_00 213766/1280428583 unite()의 기본 설정은 _을 구분자로 사용하여 합쳐진 셀의 내용을 연결한다. 이를 조정하려면, sep 인수를 설정하면 된다. 다음처럼 하면 구분자 없이 연결을 수행한다. &gt; table5 %&gt;% + unite(c(century, year), col = &quot;year&quot;, sep=&quot;&quot;) # A tibble: 6 x 3 country year rate &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 1999 745/19987071 2 Afghanistan 2000 2666/20595360 3 Brazil 1999 37737/172006362 4 Brazil 2000 80488/174504898 5 China 1999 212258/1272915272 6 China 2000 213766/1280428583 "],
["ch-R-Programming-Structure.html", "Chapter 10 R 프로그래밍 구조 10.1 R 조건문 10.2 R 반복문 10.3 R 함수", " Chapter 10 R 프로그래밍 구조 R은 통계 및 데이터 처리를 위한 프로그래밍 언어이다. 모든 언어가 그렇지만 처음 언어를 배울 때는 여러 단어와 표현 패턴에 익숙해지는 과정을 거친다. 그러나 좀 더 정확하고 복잡한 표현을 하기 위해서는 단순히 표현 패턴을 익히는 것에서 벗어나 그 언어의 고유한 문법 체계를 이해하는 것이 필요하다. R은 프로그래밍 언어이므로 프로그램 흐름을 제어하는 조건문과 반복문을 가지고 있다. 조건문은 조건에 따라 프로그램 흐름을 분기하고, 반복문은 조건에 따라 프로그램의 부분을 계속 반복 수행한다. 10.1 R 조건문 10.1.1 if 조건문 if-else 조건문 R은 if를 이용하여 조건문을 만든다. 표준적인 if-else 조건문은 다음 형식을 취한다. &gt; if (statement1) statement2 else statement3 statement1은 TRUE 또는 FALSE의 논리값을 결과로 주는 표현식이어야 한다. 예로 \\(4 &gt; 2\\) 이나 \\(x &lt; 0\\) 처럼 참 또는 거짓으로 판별될 수 있어야 한다. statement1이 참이면 statement2가 실행되고 statement1이 거짓이면 else 다음의 statement3이 실행된다. 그림 10.1의 (a)는 if-else 조건문에 의해 발생하는 프로그램의 제어 흐름은 보여준다. Figure 10.1: 단순한 형태의 if 조건문에서의 제어 흐름 다음은 if-else 조건문의 예이다. x가 0보다 크면 y에 1이 할당되고 작거나 같으면 y에 0이 할당된다. &gt; x &lt;- 4 &gt; if( x &gt; 0 ) y &lt;- 1 else y &lt;- 0 &gt; y [1] 1 만약 statement1 조건이 참이냐 거짓이냐에 따라 여러 문장이 함께 실행되어야 하면 다음과 같이 statment2나 statement3 표현식을 블록으로 만들면 된다. 다음 예에서 중괄호로 묶인 두 개의 블럭이 statement2와 statement3을 대체하고 있음을 볼 수 있다. 중괄호로 묶인 여러 표현식으로 구성된 블록은 마치 하나의 표현식처럼 동시에 평가가 이루어진다. 블록 표현식을 사용할 때 주의할 점은 statment2의 블록이 종료되는 같은 줄에 else가 기술되어야 한다는 것이다. 그래야 if-else 문이 하나의 명령으로 취급되어 처리된다. &gt; x &lt;- -5 &gt; if (x&gt;0) { + y &lt;- 1 + z &lt;- &quot;success&quot; + } else { + y &lt;- 0 + z &lt;- &quot;fail&quot; + } &gt; y;z [1] 0 [1] &quot;fail&quot; 단순 if 조건문 어떤 경우에는 조건이 만족하면 어떤 작업을 수행하지만, 그렇지 않은 경우에는 아무 것도 하지 않아야 할 때가 있다. 그러한 경우에는 다음처럼 else 부분이 제외된 단순한 형태의 if 조건문을 사용하면 된다. statement1이 참이면 statement2가 실행되는 것은 if-else 조건문과 마찬가지이지만, statement1이 거짓이면 statement2를 건너띄고 if 조건문 다음으로 프로그램의 실행 흐름이 넘어간다(그림 10.1의 (b) 참조). if-else 조건문과 마찬가지로 statement2는 블럭 표현식으로 대체될 수 있다. &gt; if (statement1) statement2 다음 예는 x가 0보다 크면 n을 하나씩 증가시키지만, 그렇지 않은 경우에는 n을 증가시키지 않는 예이다. &gt; n &lt;- 0 &gt; x &lt;- 5 &gt; if (x&gt;0) n &lt;- n + 1 &gt; n [1] 1 &gt; x &lt;- -4 &gt; if (x&gt;0) n &lt;- n + 1 &gt; n [1] 1 복합 조건문 지금까지는 하나의 조건에 의해서 두 가지 방향으로 프로그램 실행이 분기되는 경우를 살펴보았다. 그런데 어떤 경우에는 조건에 따라 세 개 이상으로 프로그램 실행을 분기하고 싶을 때가 있다. 예를 들어, if-else 조건문의 예에서 x가 양수이면 y에 1을 부여하고 x가 0 이하이면 0을 부여하였는데, 이를 바꾸어 x가 양수이면 그대로 y는 1이지만, x가 0이면 0, x가 음수이면 -1을 넣고 싶다고 하자. 이럴 땐 어떻게 해야 할까? 이런 경우에는 다음처럼 else 다음의 statement3 부분에 또 다른 if 조건문을 넣으면 된다. 이렇게 else 이후에 또 다른 조건문을 실행하는 조건문을 복합 조건문이라고 한다. &gt; if (statement1) { + statement2 + } else if (statement3.1) { + statement3.2 + } else { + statement3.3 + } 이 경우 statement1이 TRUE이면 statement2가 실행되고 else 부분은 실행이 되지 않는다. statement1이 FALSE이면 statement2는 건너뛰고 첫번째 else 부분이 실행된다. 그런데 else 다음에 기술된 statement3이 단순한 실행문이 아니라 그 자체가 또 다른 if 조건문이다. 따라서 statement1이 FALSE인 경우에는 else의 if문이 실행되어 statement3.1 조건을 비교하고, statement3.1이 TRUE이면 statement3.2가 실행되고, FALSE이면 statement3.3이 실행된다. 그림 10.2의 (a)는 복합 조건문의 제어 흐름을 보여준다. Figure 10.2: 복잡한 형태의 if 조건문에서의 제어 흐름 다음 예를 살펴보자. x가 0이므로 처음 조건은 FALSE가 되어 첫번째 else 부분이 실행된다. 두번째 조건은 TRUE이므로 statement3.2 부분이 최종적으로 실행된다. x의 값에 따라 어떤 부분이 실행되는지 확인해 보라. &gt; x &lt;- 0 &gt; if (x&gt;0) { + print(&quot;statement2&quot;) + y &lt;- 1 + } else if ( x == 0 ) { + print(&quot;statment3.2&quot;) + y &lt;- 0 + } else { + print(&quot;statement3.3&quot;) + y &lt;- -1 + } [1] &quot;statment3.2&quot; &gt; y [1] 0 복합 조건문의 조건은 계속 추가될 수 있다. 앞의 예는 세 개의 분기를 가지고 있지만, 두번째 else 부분에 다시 if 문을 연결하면 네 개의 분기가 되도록 조건을 더 세분화할 수 있다. 중첩 조건문 복합 조건문이 else 부분에 if 조건문으로 꼬리를 물듯이 이어 나가면서 분기를 세분화한다면, 중첩 조건문은 if문의 statement2와 statement3의 안에 또 다른 if 문을 두어 분기를 세분화하는 경우이다. 그림 10.2의 (b)는 중첩 조건문의 제어 흐름을 보여준다. &gt; if (statement1) { + ... + if (statement2.1) { + statement2.2 + } else { + statement2.3 + } + ... + } else { + ... + if (statement3.1) { + statement3.2 + } else { + statement3.3 + } + ... + } 다음 예를 살펴보자. if-else 조건문의 예처럼 x가 양수인지에 따라 y에 1 또는 0으로 부여하는 것뿐 아니라, x가 양수이고 홀수이면 z에 1을, 짝수이면 z에 2를 부여하고 싶다고 하자. 그리고 x가 0 이하이고 3의 배수이면 z에 3을, 3의 배수가 아니면 z에 4를 부여하고 싶다. 이러한 경우는 다음과 같은 중첩 조건문을 사용하면 쉽게 구현할 수 있다. 다음 예에서 x를 다양한 수로 바꾸어 가며 실행해 보라. 그리고 y와 z의 값이 어떻게 부여되는지 살펴보라. &gt; x &lt;- 5 &gt; if (x&gt;0) { + y &lt;- 1 + if (x %% 2 == 0) z &lt;- 2 else z &lt;- 1 + } else { + y &lt;- 0 + if (x %% 3 == 0) z &lt;- 3 else z &lt;- 4 + } &gt; y; z [1] 1 [1] 1 중첩 조건문은 여러번 조건문을 중첩시킬 수 있다. 그러나 너무 많이 조건문을 중첩시키거나, 너무 복잡한 복합 조건문을 사용하는 것은 프로그램 흐름을 이해하기 어렵게 만들므로 되도록 피하는 것이 좋다. 조건문의 결과가 두 개 이상의 논리값을 주는 경우 지금까지 if 문의 statement1 조건에 들어가는 표현식이 하나의 논리값을 가진 경우만을 다루었다. 만약에 이 표현식의 결과가 길이가 2 이상인 논리값 벡터이면 어떻게 될까? 다음 예에서 보듯이 R은 조건의 논리값 결과가 2개 이상인 경우, 첫번째 논리값만 사용하여 분기를 실행한다. 그리고 이에 대한 경고 메시지를 출력한다. &gt; x &lt;- c(5, 0, -5) &gt; x &gt; 0 [1] TRUE FALSE FALSE &gt; if (x &gt; 0) y &lt;- 1 else y &lt;- 0 Warning in if (x &gt; 0) y &lt;- 1 else y &lt;- 0: the condition has length &gt; 1 and only the first element will be used &gt; y [1] 1 따라서 조건의 결과가 여러 개가 될 수 있는 경우에는 논리값 벡터의 어떤 요소를 사용할지를 특정하여 조건문을 실행하는 것이 좋다. &gt; if (x[3] &gt; 0) y &lt;- 1 else y &lt;- 0 &gt; y [1] 0 복합 조건 지금까지의 예는 statement1에 단순 조건을 사용하였다. 어떨 때는 AND나 OR 등의 논리값 연산자로 단순 조건을 연결하여 복합 조건을 만들어 statement1에 부여하는 것이 프로그램을 간단하게 만들 수 있다. 다음 예를 살펴 보자. x와 y가 모두 0보다 크면 두 수의 합을 출력하지만 그렇지 않으면 두 수가 모두 0 이상이어야 한다는 경고 메시지를 출력하도록 해 보자. 물론 이를 다음처럼 중첩 또는 복합 조건문으로 구현할 수 있다. &gt; x &lt;- 3 &gt; y &lt;- -4 &gt; if ( x &gt;= 0 ) { + if ( y &gt;= 0 ) { + print(x + y) + } else { + warning(&quot;x와 y는 모두 0 이상이어야 합니다.&quot;) + } + } else { + warning(&quot;x와 y는 모두 0 이상이어야 합니다.&quot;) + } Warning: x와 y는 모두 0 이상이어야 합니다. 이러한 경우에는 동일한 경고 메시지를 여러 분기에서 출력하도록 해야 한다. 만약 경고의 방식이 바뀌면 x와 y가 0 이상인 분기를 제외하고 관련 부분을 모두 변경해야 한다. 동일한 코드를 여러 부분에 산재시키는 방식은 프로그램이 진화함에 따라 프로그램 유지 보수를 어렵게 만들고 오류 발생의 근원이 되므로 좋지 않은 방식이라 할 수 있다. 이 경우에는 두 조건을 AND로 연결하여 표현하면 if 조건문의 표현이 단순해진다. &gt; if ( x &gt;= 0 &amp;&amp; y &gt;= 0 ) { + print(x + y) + } else { + warning(&quot;x와 y는 모두 0 이상이어야 합니다.&quot;) + } Warning: x와 y는 모두 0 이상이어야 합니다. 그런데 여기서 논리값 벡터의 연산에서 설명한 AND 연산자인 ‘&amp;’ 대신 ‘&amp;&amp;’를 사용하였다.’&amp;’ 연산자는 논리값 벡터의 AND 연산자로 논리값 벡터들의 같은 위치의 요소별로 AND를 수행하여 그 결과를 반환한다. 반면 ‘&amp;&amp;’ 연산자는 각 논리값 벡터의 첫번째 요소만 취하여 AND 결과를 제공한다. 따라서 다음 예처럼 조건의 벡터가 여러 개의 요소를 가질 때 불필요한 경고가 발생되는 것을 막을 수 있다. &gt; a &lt;- c(T, F) &gt; b &lt;- c(T, T) &gt; a &amp; b [1] TRUE FALSE &gt; a &amp;&amp; b [1] TRUE &gt; if (a &amp; b) print(&quot;TRUE&quot;) else print(&quot;FALSE&quot;) Warning in if (a &amp; b) print(&quot;TRUE&quot;) else print(&quot;FALSE&quot;): the condition has length &gt; 1 and only the first element will be used [1] &quot;TRUE&quot; &gt; if (a &amp;&amp; b) print(&quot;TRUE&quot;) else print(&quot;FALSE&quot;) [1] &quot;TRUE&quot; 마찬가지로 OR 연산자로는 ‘’ 대신 ’’가 있다. &gt; a | b [1] TRUE TRUE &gt; a || b [1] TRUE &gt; if (a &amp; b) print(&quot;TRUE&quot;) else print(&quot;FALSE&quot;) Warning in if (a &amp; b) print(&quot;TRUE&quot;) else print(&quot;FALSE&quot;): the condition has length &gt; 1 and only the first element will be used [1] &quot;TRUE&quot; &gt; if (a &amp;&amp; b) print(&quot;TRUE&quot;) else print(&quot;FALSE&quot;) [1] &quot;TRUE&quot; 따라서 만약 앞의 예에서 x와 y 둘 중에 하나만 0 이상이면 합을 출력한다면 다음처럼 수정하면 된다. &gt; if ( x &gt;= 0 || y &gt;= 0 ) { + print(x + y) + } else { + warning(&quot;x와 y는 모두 0 이상이어야 합니다.&quot;) + } [1] -1 if-else 조건문은 ifelse() 함수와는 다르다. 그리고 본 절에서 배운 if-else 조건문은 ifelse() 함수와는 다르다는 것에 주의해야 한다. 이 절에서 배운 if-else 조건문은 프로그램의 흐름을 조건에 따라 분기하기 위한 표현식이다. 반면 ifelse() 함수는 첫번째 인수인 논리값 벡터에 따라 새로운 벡터를 만들어주는 함수이다. 다음은 벡터의 값이 음수이면 절대값으로 바꾸어 주는 예이다. (물론 우리는 절대값을 만들어주는 abs() 함수를 이용할 수 있지만 예제를 위하여 ifelse() 함수를 사용하였다.) ifelse() 함수는 요소별로 논리값에 따라 결과 요소를 선택함을 볼 수 있다. 반면 if-else 문은 조건에 대한 하나의 논리값에 따라 한번만 프로그램 실행 흐름에 대한 분기가 이루어지는 점이 다르다. &gt; e &lt;- c(5, -4, 3) &gt; ifelse(e &gt;=0, e, -e) [1] 5 4 3 10.1.2 switch 함수 switch()는 하나의 함수이지만 if-else 조건문처럼 프로그램 흐름 제어에 사용될 수 있다. switch() 함수는 다음의 함수 형식을 갖는다. &gt; switch(EXPR, expression_1, ..., expression_n) switch()의 EXPR 인수에는 하나의 숫자나 문자열로 평가되는 표현식이 부여된다. EXPR 인수 다음에는 표현식의 목록이 나온다. expression_1부터 expression_n까지 n 개의 표현식이 EXPR 인수 다음에 인수로 추가되어 있다고 하자. EXPR 인수의 평가 결과가 숫자이고 그 숫자가 1부터 n 사이이면, switch() 함수는 해당 숫자 위치에 있는 expression 표현식을 실행하고 실행 결과를 반환한다. 만약 EXPR의 결과가 그 외의 숫자라면 아무 것도 수행하지 않고 NULL을 반환한다. 다음 예를 살펴보자. &gt; i &lt;- 2 &gt; switch(i, 10, 1:5, pi) [1] 1 2 3 4 5 &gt; i &lt;- 3 &gt; switch(i, 10, 1:5, pi) [1] 3.141593 &gt; i &lt;- 4 &gt; switch(i, 10, 1:5, pi) switch()의 EXPR 인수의 결과가 하나의 문자열이 될 수 있는데, 그 경우에는 EXPR 뒤에 나오는 표현식 앞에 이름을 붙인다. EXPR 인수 뒤에 나오는 표현식 중 하나는 이름이 없을 수 있다. 이 경우 EXPR의 결과값과 같은 이름을 가진 표현식이 실행된 후 그 결과값이 반환된다. 만약 EXPR 결과값이 뒤에 나오는 어떠한 표현식의 이름과도 같지 않으면, 이름이 없는 expression_default 표현식이 실행된다. &gt; switch(EXPR, name_1=expression_1, ..., + name_n=expression_n, expression_default) 다음은 사용자에게 메뉴를 선택하게 하여 사용자가 선택한 메뉴에 따라 다른 내용을 출력하는 예이다. 예에서 repeat 반복문이 사용되는 데 관련 내용은 다음 절을 참조하기 바란다. &gt; menu &lt;- c(&quot;(b)anana&quot;, &quot;(o)range&quot;, &quot;(s)trawberry&quot;) &gt; repeat{ + price &lt;- 0 + cat(&quot;\\n다음 중 메뉴를 골라주세요:&quot;, paste(1:3, menu, sep=&quot;.&quot;), &quot;\\n&quot;) + choice &lt;- readline(&quot;메뉴 선택 [b|o|s] 또는 종료 [q]: &quot;) + switch(choice, + b = {cat(&quot;바나나가 나왔습니다.\\n&quot;); price &lt;- 1000}, + o = {cat(&quot;오렌지가 나왔습니다.\\n&quot;); price &lt;- 1200}, + s = {cat(&quot;딸기가 나왔습니다.\\n&quot;); price &lt;- 1500}, + q = break, + cat(&quot;번호를 잘못 눌렀습니다.\\n&quot;)) + cat(&quot;이번 거래는 총&quot;, price, &quot;원 입니다.\\n&quot;) + } 10.2 R 반복문 10.2.1 for 반복문 프로그램을 작성하다 보면 변수의 값을 변화시키면서 동일한 작업을 반복할 필요가 있는 경우가 있다. 이러한 경우 for 반복문을 이용하면 좋다. 벡터의 각 요소별로 반복하기 &gt; for ( variable in vector ) statement for문은 vector의 요소를 차례로 변수 variable에 넣은 후 statement를 vector의 요소별로 한번씩 반복 실행한다. 다음은 for 반복문을 이용하여 1부터 5까지의 합을 구한 예이다. n의 각 요소가 차례로 x에 들어가서 s에 x를 더하는 작업이 반복된다. (물론 우리는 sum() 함수로 이를 더 빨리 수행할 수 있다. 그러니 실제 프로그램에서는 이러한 방식의 반복문을 만들지 말라. 이 예는 단지 이해를 위해 만든 예제이다.) &gt; n &lt;- 1:5 &gt; s &lt;- 0 &gt; for (x in n) s &lt;- s + x &gt; s [1] 15 반복할 명령문이 여러개이면 statement 부분에 블록 표현식을 이용하면 된다. 위의 예에서 반복문이 실제로 어떻게 수행되었는지를 확인해보기 위해서 반복되는 부문에 몇 가지 명령문을 추가해 보자. cat() 함수는 나열된 인수를 차례로 콘솔에 출력하는 함수이다. 아래 결과에서 블록 표현식 부분이 x값이 바뀌면서 5번 실행되었음을 볼 수 있다. 그리고 왜 s가 x의 합이 되는지 그 이유도 보여주고 있다. &gt; s &lt;- 0 &gt; for (x in n) { + cat(&quot;반복 시작: x=&quot;,x, &quot;, s=&quot;, s, &quot;\\n&quot;) + s &lt;- s + x + cat(&quot;반복 끝 : x=&quot;,x, &quot;, s=&quot;, s, &quot;\\n\\n&quot;) + } 반복 시작: x= 1 , s= 0 반복 끝 : x= 1 , s= 1 반복 시작: x= 2 , s= 1 반복 끝 : x= 2 , s= 3 반복 시작: x= 3 , s= 3 반복 끝 : x= 3 , s= 6 반복 시작: x= 4 , s= 6 반복 끝 : x= 4 , s= 10 반복 시작: x= 5 , s= 10 반복 끝 : x= 5 , s= 15 다음은 중첩 조건문을 설명할 때 사용한 예를 x의 값을 변화시키면서 실행해 본 예이다. 중첩 조건문의 예에서 x의 값을 바꾸며 실행해 보려면 사람이 일일이 x의 값을 바꾸며 재실행해 보아야 했다. 여기서는 for 반복문을 통해 한번에 이와 같은 일을 수행할 수 있다. &gt; n &lt;- c(1, 2, -3, -4) &gt; for( x in n) { + if (x&gt;0) { + y &lt;- 1 + if (x %% 2 == 0) z &lt;- 2 else z &lt;- 1 + } else { + y &lt;- 0 + if (x %% 3 == 0) z &lt;- 3 else z &lt;- 4 + } + cat(&quot;x=&quot;, x, &quot;y=&quot;, y, &quot;z=&quot;, z, &quot;\\n&quot;) + } x= 1 y= 1 z= 1 x= 2 y= 1 z= 2 x= -3 y= 0 z= 3 x= -4 y= 0 z= 4 벡터의 인덱스를 이용하여 벡터 요소 반복하기 for 반복문에서는 반복 실행의 대상이 되는 벡터의 요소를 변수 variable에 넣어 반복 실행을 수행한다. 그런데 어떤 경우는 벡터의 요소를 variable에 부여하는 것이 아니라 벡터의 인덱스를 variable에 부여하여 반복하는 것이 편리한 경우가 있다. 이 경우는 앞의 for 반복문의 vector 부분에 반복의 대상이 되는 벡터 자체가 아니라 벡터의 인덱스 벡터를 부여한다. 조건문을 설명할 때 사용한 x와 y 벡터가 모두 0 이상이면 합을 출력하지만 그렇지 않은 경우에는 경고를 출력하는 예를 고려해 보자. for 반복문을 이용하여 이 조건문을 테스트하려고 한다. 이 때는 테스트에 필요한 벡터가 x, y로 2개나 되어서 for 문의 vector에 어떤 벡터를 넣어야 할지 고민이 된다. 이런 경우 vector 부분에 인덱스 벡터를 넣어 for 반복문을 실행하면 문제가 해결된다. x의 모든 요소에 대한 자연수 인덱스 벡터를 구하기 위해서 seq() 함수를 이용하였다. seq() 함수는 along 인수에 주어진 벡터의 모든 요소에 대한 자연수 인덱스 벡터를 반환한다. &gt; x &lt;- rep(c(1, -1), each=2) &gt; y &lt;- rep(c(1, -1), times=2) &gt; x [1] 1 1 -1 -1 &gt; y [1] 1 -1 1 -1 &gt; n &lt;- seq(along=x); n [1] 1 2 3 4 &gt; for ( i in n ) { + cat(i, &quot;번째 실행\\n&quot;) + if ( x[i] &gt;= 0 &amp;&amp; y[i] &gt;= 0 ) { + print(x[i] + y[i]) + } else { + cat(&quot;\\t x와 y는 모두 0 이상이어야 합니다. \\n&quot;) + } + } 1 번째 실행 [1] 2 2 번째 실행 x와 y는 모두 0 이상이어야 합니다. 3 번째 실행 x와 y는 모두 0 이상이어야 합니다. 4 번째 실행 x와 y는 모두 0 이상이어야 합니다. 10.2.2 while 반복문 조건에 따라 반복하기 for 반복문처럼 처음부터 반복할 횟수가 벡터의 크기로 정해져 있는 경우도 있지만 어떤 경우에는 사전에 몇번을 반복할지 결정이 안되어 있는 경우도 있다. 어떤 조건이 만족될 때는 반복이 계속되지만 그렇지 않은 경우에는 반복이 종료되는 경우가 대표적인 예이다. 이러한 경우에는 while 문을 이용하여 반복문을 구현하는 경우가 많다. &gt; while (statement1) statement2 while 문은 statement1이 TRUE이면 statement2를 실행한다. 그리고 다시 while 문의 맨 앞으로 돌아와 다시 statement1 조건을 비교하는 작업을 수행한다. 만약 statement1이 FALSE가 되면 statement2를 실행하지 않고 반복문에서 빠져나온다. 다음은 for 문을 사용하여 1부터 5까지 더한 예를 while 문으로 다시 수행한 예이다. 다음 예에서 statement2 부분은 블록문으로 구현되었다. &gt; s &lt;- 0 &gt; x &lt;- 1 &gt; while ( x &lt;= 5 ) { + s &lt;- s + x + x &lt;- x + 1 + } &gt; s [1] 15 무한 반복이 발생하는 경우 while 문에서는 statement2에서 statement1이 FALSE가 되도록 하는 부분이 있어야 한다. 만약 없다면 while 문은 무한 반복된다. 위의 예에서 반복이 일어나는 블록문에서 x를 하나씩 증가시키는 부분을 제외시켜 보라. 그러면 프로그램은 무한 반복에 빠질 것이다. (프로그램이 무한 반복에 들어가면 ESC 키를 눌러라. 그러면 프로그램의 실행에서 빠져나올 수 있다.) 사용자의 입력에 따라 반복할지 결정하기 while 문은 사용자 입력에 따라 반복을 할지 말지를 결정하는 경우에 자주 사용된다. 다음과 같은 예를 생각해 보자. iris 데이터 프레임에 대해 사용자에게 히스토그램을 그릴 열 번호를 입력받은 후, 해당 열에 대한 히스토그램을 그려주려고 한다. 사용자의 입력을 받아 히스토그램을 그린 후에는 다시 사용자의 입력을 받는 작업을 반복하고자 한다. 그리고 사용자의 입력이 숫자가 아니라 ‘q’이면 이러한 반복을 종료하고자 한다. 다음 예는 while 문을 이용하여 위에 설명한 기능을 구현한 예이다. 여기서는 사용자가 ’q’ 또는 0부터 4까지의 정수만 정확히 입력한다고 가정하여, 사용자가 이외의 값을 입력할 때의 예외 처리는 수행하지 않았다. 사용자의 입력은 readline() 함수를 이용하여 수행하였다. readline()은 콘솔 또는 파일에서 한 줄씩 입력을 받아 그 결과를 전달하는 함수이다. 이에 대한 자세한 설명은 R 도움말을 참조하라. &gt; num &lt;- &quot;1&quot; &gt; while ( num != &quot;0&quot;) { + n &lt;- as.integer(num) + hist(iris[[n]], main = names(iris)[n]) + + cat(&quot;히스토그램을 출력할 열을 선택하세요[1-4]. 종료를 원하면 0을 입력&quot;) + num &lt;- readline() + } 10.2.3 repeat 반복문 repeat 문은 다음과 같은 형식을 가진다. 벡터의 패턴을 반복하여 새로운 벡터를 만들어 주는 rep() 함수와 혼동하는 경우가 많으니 주의하길 바란다. &gt; repeat statement repeat 문의 무한 반복은 break 문으로 빠져나온다. while 문은 statement1 부분에 반복의 종료 조건이 명시적으로 기술되는데 반해, repeat 문은 반복의 종료 조건이 명시적으로 표시되지 않는다. repeat 문은 statement를 그저 무한 반복할 뿐이다. 반복을 중지하려면 repeat 문 안에 break 문을 넣어 반복에서 직접 빠져나와야 한다. 다음은 iris 데이터에 대한 히스토그램을 그리는 예를 repeat 문으로 수행한 예이다. while 문은 처음에 조건을 비교하여 반복을 결정하므로 초기에 num을 1로 설정하였으나 repeat 문을 이용하는 경우 그럴 필요가 없다. repeat 문 안에서 사용자 입력이 처음으로 이루어진 후 ’0’인지를 비교하여 빠져나올지 아닐지를 결정하면 된다. &gt; repeat { + cat(&quot;히스토그램을 출력할 열을 선택하세요[1-4]. 종료를 원하면 0을 입력&quot;) + num &lt;- readline() + if (num == &quot;0&quot;) { + cat(&quot;Bye~~!&quot;) + break + } + n &lt;- as.integer(num) + hist(iris[[n]], main = names(iris)[n]) + } repeat 문은 블록문 내부 어디서나 반복 종료의 조건이 발생하면 break 문을 이용하여 자유롭게 빠져 나올 수 있으므로 매우 유연한 반복문을 만들 수 있는 장점이 있다. 하지만 반복문의 종료 조건이 무엇인지 파악하려면 repeat 문 전체를 살펴보아야 하는 단점이 있다. 특히 반복되는 부분이 길면 이를 파악하는 것이 쉽지가 않다. 반면 for 문과 while 문은 종료 조건이 반복문 앞에 명시적으로 놓이므로 이를 파악하기가 쉽다. 10.2.4 반복문의 제어 명령 우리는 앞서서 repeat 반복문에서 break 명령문을 이용하여 반복문을 빠져 나오는 방법을 배웠다. 사실 break 문은 모든 반복문에서 사용이 가능하다. for 문이나 while 문이 아직 종료 조건이 되지 않았다 하더라도 반복 중에 break 문을 만나면 즉시 실행이 종료된다. 보통 프로그램에서 복구할 수 없는 오류를 인지했을 때 종료 조건이 만족되지 않아도 break 문으로 프로그램 반복을 빠져 나오도록 하는 경우가 많다. break 문과 함께 반복문을 제어하는 명령문으로 next가 있다. 이 명령이 실행되면 반복문을 완전히 빠져나오지는 않지만, 이번 차의 반복에서 빠져 나와 다음번 차의 반복이 실행한다. 다음은 for 문을 사용하여 벡터에서 홀수만을 더한 예이다. a가 짝수이면 next 문을 이용하여 s에 a가 더해지는 부분을 건너띄고 다음번 회차의 반복으로 넘어가고 있다. &gt; x &lt;- c(5, 4, 8, 9, 10, 11) &gt; s &lt;- 0 &gt; for (a in x) { + if( a %% 2 == 0) next + cat(a, s, &quot;\\n&quot;) + s &lt;- s + a + } 5 0 9 5 11 14 &gt; s [1] 25 10.2.5 R에서 반복문 사용의 주의점 명시적 반복문은 되도록 피하는 것이 좋다. 지금까지 R의 다양한 반복문의 문법에 대해서 설명하였지만, 사실 R에서는 반복문이 꼭 필요한 경우가 아니라면 반복문의 사용을 피하는 것이 좋다. R은 사실 함수 프로그래밍 언어로서 앞의 모든 명령문은 함수 호출로 구현된다. 따라서 반복문의 반복 횟수가 커지면 엄청나게 많은 함수 호출이 발생한다. 일반적으로 프로그래밍 언어에서 함수 호출은 스택 프레임 등을 설정해야 하므로 계산 시간이 많이 요구되는 고비용 작업이다. 벡터화된 내장 함수로 암시적인 반복을 수행하라. 많은 R의 함수들은 벡터가 인수로 전달될 때, 벡터 요소 전체에 대해 암시적인 방식으로 반복 작업을 수행하여 결과를 제공한다. 이러한 R 함수를 벡터화(vectorized) 되었다고 하는데, 보통 벡터화된 내장 함수는 C로 구현되어 매우 빠른 계산 반복을 수행하므로, 명시적으로 반복문을 이용하는 것보다 훨씬 빠른 시간 내에 결과를 제공해 준다. 다음은 x와 y의 두 벡터의 같은 위치의 요소를 비교하여 둘 중 더 큰 요소만을 뽑아서 합을 구한 예이다. R의 ifelse()와 sum()를 이용하면 이를 쉽게 수행할 수 있다. 이 두 함수는 벡터화된 내장 함수이다. system.time() 함수는 함수의 인수로 전달된 표현식을 실행하고 이 표현식을 실행하는 데 걸린 시간을 반환해 준다. &gt; set.seed(123) &gt; n &lt;- 1000000 &gt; x &lt;- rnorm(n) &gt; y &lt;- rnorm(n) &gt; system.time(sum(ifelse(x &gt; y, x, y))) user system elapsed 0.024 0.012 0.037 앞의 문제를 for 문을 이용하여 구현한 후, 실행 시간을 측정해 보자. 쉽게 두 방식의 시간 차이를 확인할 수 있을 것이다. &gt; s &lt;- 0 &gt; system.time({ + for (i in 1:n){ + if (x[i] &gt; y[i]) s &lt;- s + x[i] else s &lt;- s + y[i] + } + }) user system elapsed 0.082 0.000 0.082 다음은 -1000부터 1000사이의 정수에서 복원 추출로 1,000,000 개의 수를 뽑은 후, 그 중 3의 배수가 되는 원소만 뽑아서 합을 구한 예이다. 첫번째 방식은 벡터 인덱싱과 sum() 함수를 이용했고, 두번째 방식은 for() 문을 이용해 각 원소별로 반복 작업을 하였다 그리고 이 두 방식의 실행 시간을 비교하였다. 마찬가지로 큰 시간 차이를 보임을 알 수 있다. &gt; set.seed(111) &gt; n &lt;- 1000000 &gt; x &lt;- sample(-1000:1000, n, replace=T) &gt; &gt; system.time({ + sum( x[x %% 3 == 0] ) + }) user system elapsed 0.028 0.000 0.028 &gt; system.time({ + s &lt;- 0 + for (a in x) { + if (a %% 3 == 0) + s &lt;- s + a + } + print(s) + }) [1] 198993 user system elapsed 0.177 0.000 0.178 apply 계열 함수로 암시적인 반복을 수행하라. R에서는 리스트의 요소에 대해 동일한 작업을 반복할 때, lapply나 sapply() 함수를 이용하여 암시적인 반복을 수행한다. 또한 행렬의 열이나 행에 반복 작업을 할 때에도 apply() 함수를 사용한다. 이러한 작업은 for 반복문 등을 이용해서도 수행할 수 있다. 사실 C나 다른 언어에 익숙한 사람이 R을 처음 접하게 되면 반복이 필요한 경우 for 반복문 등을 이용하여 명시적인 반복을 하는 경우가 많다. 그러면 이 두 가지 반복 방법 중 어느 것이 더 권장되어야 할까? 가끔 apply 종류 함수가 더 빠르게 실행하기 때문에 명시적 반복보다는 apply 계열 함수로 암시적 반복을 하라는 의견들을 볼 수 있는데, 이러한 주장은 신빙성이 크지는 않다. 다음은 예에서는 -1000부터 1000사이의 정수에서 복원 추출로 100,000 개의 수를 뽑아내는 작업을 100번 반복하여 x라는 리스트의 요소로 넣었다. 그 후 리스트의 각 요소에서 3의 배수의 합을 구한 후 합의 최대값을 구하였다. 필요한 반복 작업은 lappy, sapply 함수에 의해 수행되었다. &gt; set.seed(11) &gt; n &lt;- 100000 &gt; x &lt;- lapply(1:100, function(i) sample(-1000:1000, n, replace=T)) &gt; &gt; system.time( { + s &lt;- sapply(x, function(y) sum(y[y %% 3 == 0])) + print(max(s)) + }) [1] 285816 user system elapsed 0.228 0.000 0.228 다음은 for 문을 이용하여 x의 요소에 대하여 같은 작업을 반복하였다. 계산 시간의 차이를 비교해 보자. 결과에서 보듯이 두 방법 모두 벡터화된 함수를 적절히 이용하면 속도의 차이는 거의 나지 않는다. &gt; system.time({ + s.max &lt;- -Inf + for(i in 1:length(x)) { + s &lt;- sum(x[[i]][x[[i]] %% 3 == 0]) + if(s &gt; s.max) s.max &lt;- s + } + print(s.max) + }) [1] 285816 user system elapsed 0.228 0.004 0.232 그렇다면 두 방법 중 어느 것을 선택해도 될까? 일반적으로 이 두 방법 중 어느 것이 더 좋다고 확언하기는 어렵지만 다음의 두 가지 이유 때문에 apply 계열 함수를 이용하는 것이 더 선호된다. 첫째, apply 계열 함수를 이용하면 코드를 더 간단하게 작성할 수 있어 코드의 가독성이 증가한다. 둘째, apply 계열 함수는 데이터 요소에 적용할 함수를 인수로 전달하는 방식으로 암시적 반복이 이루어진다. 따라서 함수 프로그래밍의 특징인 반복 실행의 부수적인 효과(side effect)가 반복문 바깥으로 전달되지 않는다. 따라서 동일한 프로그램을 병렬 프로그램으로 전환하기가 더 용이하다. 그러므로 처리해야 할 데이터가 커지면 병렬 프로그래밍 기법을 이용하여 추가적인 속도 향상을 꾀할 수 있는 가능성이 커진다. 10.3 R 함수 함수의 필요성 우리는 앞서서 반복문을 사용하여 동일한 작업을 재입력 없이 원하는 횟수만큼 반복시킬 수 있음을 보았다. 그런데 어떤 경우에는 동일한 작업을 입력 변수에 따라 다른 출력 결과로 얻고 싶을 때가 있다. 예를 들어 1부터 시작하여 자연수 n까지의 홀수의 합을 구하고 싶은데, 매번 다른 n에 대하여 결과를 구하고 싶다고 하자. 이러한 경우에 함수를 이용하면 원하는 결과를 얻을 수 있다. 함수는 입력 변수에 따라 다른 결과를 반환하는 일련의 프로그램 덩어리라 할 수 있다. R은 함수를 closure 타입의 객체로 생성한다. R에서 제공하는 많은 함수들은 내장 함수(builtin functions)를 제외하고는 사용자가 생성하는 함수와 본질적으로 동일하다. 다음은 R에서 자주 사용되는 함수의 타입을 보여준다. sum() 함수를 제외하고는 모두 closure 타입임을 알 수 있다. &gt; typeof(sum) [1] &quot;builtin&quot; &gt; typeof(mean) [1] &quot;closure&quot; &gt; typeof(summary) [1] &quot;closure&quot; &gt; typeof(plot) [1] &quot;closure&quot; 10.3.1 함수의 생성과 호출 함수 정의하기 R에서 함수 만들기는 function() 함수의 호출에 의해 이뤄진다. (함수를 생성하는 것을 함수를 정의한다라고 한다.) &gt; function_name &lt;- function(formal_arg1, formal_arg2, ...) + function_body_expression function() 함수를 호출하여 그 결과를 변수에 할당하는데, 그 변수 이름이 함수의 이름으로 사용된다. funtion()의 인수로는 새롭게 생성할 함수에 사용할 형식 인수(formal_arg 부분)가 나열된다. 그리고는 함수가 호출되면 실행될 함수 본문 표현식(function_body_expression 부분)을 기술한다. 함수 본문 표현식은 R의 어떠한 표현식도 가능하며 함수 본문 표현식이 실행된 결과가 함수의 결과값으로 반환된다. 보통은 함수가 실행될 때 여러 개의 명령문이 실행되어야 하는 경우가 많다. 이러한 경우 함수 본문 표현식을 { }을 이용한 블록 표현식으로 표현하다. 그러면 return() 함수로 명시적으로 반환한 결과값을 지정하지 않을 경우, 블록 표현식 안의 마지막 표현식의 실행 결과가 함수의 결과값으로 반환된다. 다음은 함수 g()를 생성한 예이다. g() 함수를 생성하려면 function()의 결과가 할당되는 변수의 이름이 g이어야 한다. 그리고 g() 함수의 형식 인수로 x, y, z가 정의되었고, 함수 본문 표현식은 \\(100x + 10y + z\\)로 정의되었다. 따라서 g() 함수는 호출될 때마다 x, y, z 인수에 값을 전달받아, \\(100x + 10y + z\\)를 계산하여 반환하도록 정의된 것이다. &gt; g &lt;- function(x, y, z) 100 * x + 10 * y + z 함수도 객체이다. 함수 객체가 잘 생성되었는지를 확인하기 위해 함수 객체 g를 출력해 보았다. R 콘솔에서 변수 이름을 입력하면 변수가 지정하고 있는 객체의 내용을 출력하게 되는데, closure 객체는 함수 정의를 출력한다. &gt; g function(x, y, z) 100 * x + 10 * y + z 함수 호출하기 함수에 정의된 프로그램 덩어리를 실행시키는 과정을 함수를 호출한다고 표현한다. 함수에 대한 호출은 다음의 형태로 이루어진다. 먼저 함수의 이름을 적고 괄호 안에 함수의 형식 인수에 전달할 값을 기술한다(이를 실질 인수라고 한다). 함수를 호출할 때, 다음처럼 실질 인수 값만 기술하여 함수를 호출할 수도 있고, 실질 인수가 어떤 형식 인수로 전달될지를 (형식 인수)=(실질 인수)의 쌍으로 기술하여 호출할 수도 있다. &gt; function_name(actual_arg1, actual_arg2, ...) &gt; function_name(formal_arg1=actual_arg1, formal_arg2=actual_arg2, ...) 형식 인수를 지정하지 않고 호출하기 형식 인수를 지정하지 않고 실질 인수를 기술하여 호출하면, 함수 정의 때 기술된 형식 인수 순으로 실질 인수가 차례로 전달된다. 다음은 실질 인수를 1, 2, 0으로 하여 g() 함수를 호출한 예이다. g() 함수의 정의에서 형식 인수가 x, y, z 순으로 정의되었으므로, x에 1, y에 2, z에는 0이 전달되어 함수 본문 표현식이 실행된다. 따라서, 함수 본문 표현식의 결과인 9가 함수 호출의 결과로 반환된다. &gt; g(1, 2, 0) [1] 120 다음은 실질 인수 값을 바꾸어 가면서 g() 함수를 호출한 결과이다. &gt; g(2, 1, 0) [1] 210 &gt; g(0, 7, 1) [1] 71 벡터화된 함수 그런데 g() 함수 본문 표현식에서 곱하기와 더하기 연산자만을 사용하였다. 이 연산자들은 벡터의 요소끼리 곱하기와 더하기를 수행해 주는 연산자이다. 따라서, g() 함수의 실질 인수에 숫자 하나뿐 아니라 여러 숫자를 가진 벡터가 전달되어도 요소끼리 계산이 수행되어 벡터로서 결과가 반환될 수 있다. g() 함수처럼 벡터가 인수로 전달되면 벡터의 인수별로 계산을 수행하여 벡터로 결과를 주는 함수를 벡터화(vectorization)된 함수라고 한다. 일반적으로 R의 기본 연산자와 함수는 벡터화되어 있는 경우가 많으므로, 이러한 함수와 연산자를 이용하여 함수를 만들면 이 함수 역시 벡터화된 함수가 된다. 다음 예에서는 벡터가 인수로 전달될 때, 벡터의 요소끼리 계산과 벡터의 재사용이 일어남을 볼 수 있다. 주의할 점은 모든 함수가 벡터화되어 있지는 않다는 것이다. 따라서 어떤 함수가 벡터화된 함수인지를 확인하려면 도움말을 참조하거나 직접 테스트를 해보아야 한다. &gt; g(1:3, 1, c(2, 4, 6)) [1] 112 214 316 형식 인수를 지정하여 함수 호출 하기 함수 호출 시에 실질 인수가 어떤 형식 인수로 전달할지를 지정할 수 있다. 그러면 함수 호출 시의 실질 인수의 순서는 중요하지 않고, 실질 인수에 지정된 형식 인수로 값이 전달되어 함수 본문이 실행된다. &gt; g(y=2, x=1, z=0) [1] 120 &gt; g(z=0, x=1, y=2) [1] 120 &gt; g(1, 2, x=3) [1] 312 &gt; g(x=1, 2, y=0) [1] 102 마지막 두 예에서 볼 수 있듯이 실질 인수에 형식 인수가 지정된 것과 그렇지 않은 실질 인수가 섞여서 호출이 이루어질 수도 있다. 이 경우 형식 인수가 지정된 실질 인수는 해당 형식 인수로 전달되지만, 나머지 실질 인수는 아직 실질 인수가 부여되지 않은 형식 인수에 함수 정의에 기술된 순서대로 차례로 전달된다. 형식 인수 수와 실질 인수의 수가 다르면 오류가 발생한다. 다음처럼 형식 인수 수와 호출 시 전달되는 실질 인수 수가 맞지 않으면 오류가 발생한다. 첫번째 예는 형식 인수 z에 전달되는 값이 없어서 오류가 발생하였고, 두번째 예는 실질 인수 4를 전달할 형식 인수가 없어서 오류가 발생하였다. &gt; g(1, x=2) Error in g(1, x = 2): argument &quot;z&quot; is missing, with no default &gt; g(1, 2, 3, 4) Error in g(1, 2, 3, 4): unused argument (4) 형식 인수의 초기값 설정하기 그런데 함수를 정의할 때 형식 인수에 초기값을 설정할 수 있다. 이러한 경우에는 함수 호출 시 형식 인수에 실질 인수 값이 전달되지 않으면 초기값을 형식 인수에 부여한 후 함수 본문을 실행한다. 초기값은 함수 정의 시 형식 인수를 나열할 때, (형식 인수)=(초기값) 형태로 기술하면 된다.9 형식 인수의 초기값이 어떻게 작동하는지를 살펴보기 위해서 1부터 어떤 자연수 b까지 홀수의 합을 구하는 다음과 같은 oddsum() 함수를 고려해 보자. &gt; oddsum &lt;- function(b) sum(seq(from=1, to=b, by=2)) &gt; oddsum(5) [1] 9 &gt; oddsum(10) [1] 25 앞서 설명하였듯이 형식 인수 b에 값을 전달하지 않으면 oddsum() 함수의 호출은 오류가 난다. &gt; oddsum() Error in seq(from = 1, to = b, by = 2): argument &quot;b&quot; is missing, with no default 그런데 다음처럼 형식 인수 b에 초기값으로 100을 설정해 두면, 형식 인수 b에 전달할 실질 인수가 없어도 b에 100이 전달되어 잘 실행됨을 볼 수 있다. 그리고 형식 인수 b에 실질 인수가 부여되면 초기값은 무시되고 실질 인수 값으로 함수가 수행됨을 볼 수 있다. &gt; oddsum &lt;- function(b=100) sum( seq(from=1, to=b, by=2) ) &gt; oddsum() [1] 2500 &gt; oddsum(3) [1] 4 위의 oddsum() 함수는 형식 인수 b를 이용하여 1부터 시작하는 홀수 수열의 종료 지점만을 입력받아 합을 구하도록 구현되어 있다. 이 함수의 범용성을 높이기 위해 홀수 수열의 시작 지점을 형식 인수 a에 입력받아 홀수 합을 구하도록 개선해 보자. 그런데, 이렇게 함수를 개선하면 기존에 이 함수를 이용하는 프로그램은 형식 인수 a에 값을 부여하지 않고 호출하기 때문에 모두 오류가 발생할 것이다. 따라서 앞서 작동하던 방식과 호환성을 유지하기 위해 호출시 시작 지점 a가 지정되지 않으면 1부터 시작하는 홀수 수열의 합을 구하도록 개선된 함수를 정의해 보자. &gt; oddsum &lt;- function(b=100, a=1) sum(seq(from=a, to=b, by=2)) &gt; oddsum(a=5, b=10) [1] 21 &gt; oddsum(3) [1] 4 위의 예의 마지막 oddsum() 함수 호출에서 실질 인수가 하나밖에 없으므로 형식 인수 정의 순서에서 가장 빠른 b에 3이 부여된다. 그러므로 a는 값이 지정되지 않았으므로 초기값 1이 부여되어 실행된다. b도 초기값이 지정되어 있으므로 a 값만 지정하여 호출도 가능하다. 이 경우 형식 인수 a가 형식 인수 b 뒤에 정의되어 있으므로 a에만 실질 인수를 전달하고 실질 인수 앞에 형식 인수 a를 지정하여 호출해야 한다. &gt; oddsum(a=97) [1] 196 R 기본 함수에서의 초기값 사용 이러한 원리로 R의 많은 함수들이 함수의 모든 인수를 일일이 지정하지 않아도 호출이 가능하도록 정의되어 있다. 예를 들어 수열을 만드는 seq() 함수는 from 인수는 초기값이 1, to 인수도 초기값이 1, by 인수는 to부터 from 사이를 1씩 증가하도록 초기값이 설정되어 있다. 그리고, 형식 인수의 정의 순서는 from, to, by 순으로 되어 있다. 이러한 사실을 고려하면 왜 다음의 seq() 호출이 해당 결과를 출력하는지 이해할 수 있을 것이다. &gt; seq() [1] 1 &gt; seq(by=2) [1] 1 &gt; seq(1, 5, 2) [1] 1 3 5 &gt; seq(to=4) [1] 1 2 3 4 &gt; seq(to=-5) [1] 1 0 -1 -2 -3 -4 -5 &gt; seq(to=10, by=2) [1] 1 3 5 7 9 또 다른 예로 CSV 파일에서 데이터 프레임을 읽어들이는 read.csv() 파일의 정의를 살펴보자. &gt; read.csv function (file, header = TRUE, sep = &quot;,&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;.&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) read.table(file = file, header = header, sep = sep, quote = quote, dec = dec, fill = fill, comment.char = comment.char, ...) &lt;bytecode: 0x557adbea46b8&gt; &lt;environment: namespace:utils&gt; 첫번째 형식 인수가 file로서 초기값이 없으므로 항상 read.csv() 호출시에는 파일 이름이 제공되어야 함을 알 수 있다. 두번째 형식 인수는 header인데 TRUE로 초기값을 가지고 있다. 따라서 header 인수를 지정하지 않고 호출하면 파일에 header가 있는 것으로 생각하고 파일을 읽어들인다. 그리고 sep 형식 인수는 파일이 데이터의 필드(열)를 무엇으로 분리하고 있는지를 전달하는 인수이다. 초기값이 ’,’로 되어 있어서 함수 호출시 특별한 지정이 없으면 쉼표로 데이터를 분리하여 인식한다는 것을 알 수 있다.10 ... 형식 인수 R 함수의 형식 인수 중에 ...라는 형식 인수가 있다. 이 형식 인수는 함수 정의 때 기술된 형식 인수 말고 다른 형식 인수 이름으로 실질 인수를 전달받을 수 있게 해준다. 다음 예에서 g()에서 w 형식 인수가 정의되어 있지 않아, 실질 인수 1을 형식 인수 w로 전달하려는 호출에 오류가 발생하는 것을 볼 수 있다. &gt; g(x=1, y=1, z=1, w=1) Error in g(x = 1, y = 1, z = 1, w = 1): unused argument (w = 1) 그런데 함수를 정의할 때, 형식 인수 목록에 ’...’를 지정하면, 정의된 형식 인수 말고 다른 이름의 형식 인수로 실질 인수를 전달받아도 오류가 나지 않음을 알 수 있다. &gt; g &lt;- function(x, y, z, ...) 100 * x + 10 * y + z &gt; g(x=1, y=1, z=1, w=1, r=2) [1] 111 그런데 위의 예에서는 전달 받은 w나 r을 함수 본문에서 전혀 사용하지 않았으므로 쓸모 없는 실질 인수의 전달이 되었다. 만약 위의 예가 x, y, z로 전달된 인수뿐 아니라 다른 이름으로 전달된 인수를 모두 출력한 후 그 인수들을 합산하여 결과에 반영한다고 하면 새롭게 전달된 형식 인수들이 의미를 가질 것이다. 다음은 ’...’를 이용하여 이름이 지정되지 않은 형식 인수를 전달받아 처리하는 예를 보여준다. &gt; g &lt;- function(x, y, z, ...) { + cat(..., sep=&quot;,&quot;) + cat(&quot;를 추가적으로 입력받았습니다.\\n&quot;) + 100 * x + 10 * y + z + sum(...) + } &gt; g(x=1, y=1, z=1, w=1, r=2) 1,2를 추가적으로 입력받았습니다. [1] 114 일반적으로 ... 인수는 다음 두 가지 경우에 많이 사용된다. c()나 sum() 함수처럼 개수가 지정되지 않은 여러 개의 요소를 받아서 일괄적인 처리가 필요한 경우이다. 이 경우 몇 개의 실질 인수가 전달될지 모르기 때문에 이름을 가진 형식 인수로 실질 인수를 전달받을 수 없다. &gt; c function (...) .Primitive(&quot;c&quot;) &gt; c(1:2, c(3, 6), 7:2) [1] 1 2 3 6 7 6 5 4 3 2 &gt; sum function (..., na.rm = FALSE) .Primitive(&quot;sum&quot;) &gt; sum(1:2, c(3, 6), 7:2) [1] 39 두번째는 자신에게 전달된 부차적인 인수들을 자신이 직접 처리하지 않고, 다른 함수에게 전달하여 처리하는 경우이다. plot()의 주요한 형식 인수는 그래프 상에서의 점을 그릴 x 축과 y 축의 좌표이다. &gt; x &lt;- 1:30 &gt; y &lt;- x^2 &gt; plot(x, y) plot() 함수는 이러한 주요 인수뿐 아니라 ... 인수를 이용하여 다양한 그래픽 매개변수를 선택적으로 전달받을 수 있다. &gt; plot function (x, y, ...) UseMethod(&quot;plot&quot;) &lt;bytecode: 0x557adbe3aaf0&gt; &lt;environment: namespace:base&gt; &gt; plot(x, y, type=&quot;o&quot;, col=&quot;red&quot;, pch=&quot;*&quot;, lty=1, lwd=1.5) 실제로는 이렇게 전달받은 선택적인 인수는 자신이 직접 처리하는 것이 아니라 par() 함수 등에 전달하여 처리한다. 그런데 par() 함수에 전달될 수 있는 인수는 매우 다양하므로 이를 일일이 plot()의 형식 인수로 지정하는 것은 힘든 일이 될 것이다. 또한 이를 모두 지정할 수 있다 하더라도 par() 함수에 새로운 인수가 추가되면 plot() 함수의 정의도 변경되어야 한다. 이러한 경우 ... 인수를 이용하여 기타 선택적인 인수를 전달받은 후 모두 par() 함수에 전달하여 처리하면 편리하다. R의 기본 함수 중에는 자신이 받은 인수를 다른 함수에 전달하여 실행하는 경우가 많아서 의외로 ... 인수가 정의된 함수들이 많이 있다. 함수의 반환값 앞에서 함수가 반환하는 값은 함수 본문 표현식의 평가 결과라고 말하였다. 보통 함수 본문 표현식은 블록 표현식인 경우가 많으므로 블록 표현식의 평가 결과는 블록 표현식의 마지막 명령문의 평가 결과가 된다. 따라서 블록 표현식이 함수 본문인 경우 마지막 명령문의 실행 결과가 반환되게 된다. 그런데 함수 본문의 중간에서 결과를 반환한 필요가 있을 때가 있다. 이런 경우에는 return() 함수를 이용하여 명시적으로 함수를 종료하고 특정 표현식의 결과 값을 반환하도록 할 수 있다. 다음 예는 입력 변수 x의 값의 0이거나 양수이면 x의 제곱근의 값을 반환하지만 x가 음수이면 제곱근을 구할 수 없기 때문에 관련된 메시지를 출력하고 NULL을 반환하는 함수를 만든 예이다. &gt; h &lt;- function(x) { + if (x &lt; 0) { + cat(&quot;x must be positive.\\n&quot;) + return(NULL) + } + sqrt(x) + } &gt; h(2) [1] 1.414214 &gt; h(-2) x must be positive. NULL 위의 예에서 return()을 이용하여 함수 본문의 마지막에 도달하기 전에 함수를 종료시키고 원하는 값을 반환하였다. 함수 본문의 마지막 부분에도 명시적으로 return() 함수를 이용하여 값을 반환할 수 있다. 그러나 일반적으로 R에서는 마지막 평가식의 결과를 반환할 때는 return() 함수를 사용하지 않는 경향이 많다. 10.3.2 함수 객체를 인수로 사용하기 함수도 객체이므로 실질 인수가 될 수 있다. lapply() 함수와 sapply() 함수는 리스트의 각 요소에 원하는 함수를 반복적으로 적용할 수 있게 해준다. 이 때 리스트 요소에 적용할 함수를 lapply()와 sapply()의 실질 인수로 전달하였다. 이러한 일이 가능한 이유는 R에서는 함수도 객체이므로 일반 벡터나 행렬처럼 함수의 인수로 함수를 전달할 수 있기 때문이다. 다음은 숫자 벡터들을 요소로 하는 리스트에 대해, 각 요소의 평균을 구한 예이다. 이 예에서 sapply() 함수 호출 시 첫번째 인수로 리스트를, 두번째 인수로 mean() 함수 객체를 전달하고 있음을 볼 수 있다. &gt; a &lt;- list(x=x, y=y, z=sqrt(x)) &gt; sapply(a, mean) x y z 15.500000 315.166667 3.736095 &gt; mean function (x, ...) UseMethod(&quot;mean&quot;) &lt;bytecode: 0x557ad9d21380&gt; &lt;environment: namespace:base&gt; apply 계열 함수에 사용자 함수 적용하기 그런데 apply 계열 함수에는 R에서 기본적으로 제공하는 함수뿐만 아니라 사용자가 직접 정의한 함수를 포함한 어떠한 함수도 전달이 가능하다. 다음은 벡터에서 10 이상의 숫자의 개수를 세는 count10()이라는 사용자 함수를 정의한 후 이를 sapply()에 인수로 전달한 예이다. &gt; count10 &lt;- function(x) sum(x &gt;= 10) &gt; sapply(a, count10) x y z 21 27 0 무기명 함수 그런데 count10()이 다른 데서도 사용할 만한 범용적인 함수라면 이를 위의 예처럼 변수에 할당하여 계속 사용하는 것이 좋겠지만, 이 sapply() 함수 호출에만 이용하는 임시적인 함수라면 굳이 변수에 할당하여 메모리에 저장해 둘 이유가 없다. 이런 경우에는 sapply()의 두번째 인수 부분에 직접 함수 객체를 만들어 전달하는 것이 더 효율적이다. 이 함수는 변수로 저장되지 않았으므로 추후에 다시 호출할 수 있는 방법은 없다. 이러한 함수를 무기명 함수(anonymous functions)라고 한다. 다음은 무기명 함수를 이용하여 리스트의 요소에서 5이상의 수의 개수를 세는 예이다. &gt; sapply(a, function(x) sum(x &gt;= 5)) x y z 26 28 6 무기명 함수를 이용하면 한번만 사용될 함수를 메모리에 남겨두지 않을 수 있고, sapply() 호출 문장에 함수가 바로 정의되어 있어서 리스트 요소에 적용되는 함수의 내용을 바로 그 지점에서 파악이 가능한 장점이 있다. 사실 무기명 함수는 함수 객체를 변수에 부여하지 않는다는 측면에서, 다음처럼 한번만 사용될 데이터 객체를 굳이 변수에 넣지 않는 예와 일맥상통하다고 할 수 있다. 이 경우에도 sapply()에 사용된 리스트가 변수에 할당되지 않았으므로 다시 이 데이터에 접근할 수 있는 방법은 없다. &gt; sapply(list(x=1:5, y=x^2, z=sqrt(x)), mean) x y z 3.000000 315.166667 3.736095 10.3.3 R 연산자 R에서는 연산자도 사실 함수이다. 대신 연산자의 함수 이름을 쓰기 위해서는 ` ` 안에 연산자를 표현해야 한다. &gt; 1 + 3 [1] 4 &gt; typeof(`+`) [1] &quot;builtin&quot; &gt; `+`(1, 2) [1] 3 &gt; `-`(1, 2) [1] -1 R 사용자는 함수를 정의하는 방식과 같은 방법으로 자신만의 연산자를 정의할 수 있다. 다만 사용자가 정의하는 연산자의 함수이름은 %연산자이름% 형식으로 정의하여야 한다. 다음과 같은 f 연산자를 만들어 보자. &gt; `%f%` &lt;- function(x, y) x^2 - y &gt; 2 %f% 4 [1] 0 &gt; 3 %f% 0 [1] 9 &gt; `%f%`(1, 2) [1] -1 10.3.4 변수 범위 프로그램이 복잡해지면 많은 변수를 사용하게 된다. 이 때 변수 이름 간에 서로 충돌이 나지 않도록 조심해야 한다. 중복된 이름을 사용하면 의도하지 않은 결과를 얻게 될 수 있다. 변수 범위의 필요성 혼자 프로그램을 할 때는 일정한 규칙에 따라 변수 이름을 부여해 나가면 변수 이름의 충돌을 어느 정도 방지할 수 있다. 그러나 여러 사람이 같이 협력하여 큰 프로그램을 완성하거나, 다른 사람이 이미 만들어둔 패키지나 함수들을 이용해야 한다면 변수 이름의 충돌은 빈번하게 발생할 가능성이 크다. 예를 들어 x라는 변수 이름은 많은 사람들이 즐겨 사용할 만한 이름이어서 프로그램의 서로 다른 부분에서 x를 다르게 정의하여 사용할 가능성이 커진다. 그러므로 내가 사용하는 변수 x와 다른 사람이 정의한 함수 내의 x를 서로 구분할 수 있는 방법이 필요하다. 그렇지 않다면 변수 이름을 하나 작명하는 데에도 다른 사람들이 이미 작성한 함수에서 사용한 변수의 이름을 먼저 조사해야 할 것이다. 실제 R에서는 엄청나게 많은 함수들이 존재하고 이를 수행한다는 것은 사실 불가능에 가깝다. 이러한 변수 이름의 충돌 문제를 거의 대부분의 고급 프로그래밍 언어는 변수의 범위(scope)라는 개념을 이용하여 해결한다. R도 예외는 아니다. 변수의 범위란 해당 변수가 유효한 영역을 의미하며, 서로 다른 범위에 있는 같은 이름의 변수는 서로 충돌이 나지 않도록 해준다. 사실 변수 범위와 관련된 내용은 매우 복잡한 주제이다. 이 절에서는 함수 내에서의 변수 사용과 관련된 기본적 문제에 관련해서만 변수 범위를 논하도록 한다.11 함수 본문에 사용되는 변수의 종류 함수의 본문에 나타나는 변수는 세 범주로 분류된다. 첫번째 범주는 함수의 형식 인수(formal arguments)로 함수의 인수 리스트로 표현된다. 함수의 형식 인수의 값은 함수 호출 시 함수의 실질 인수 값으로 바인딩이 이루어진다. 두번째 범주는 지역 변수(local variables)로 함수 본문 안에서 할당이 이루어진 변수이다. 세번째 범주는 자유 변수(free variables)로 형식 인수도 아니고 지역 변수도 아닌 변수이다. 자유 변수는 함수가 만들어진 환경에서 변수의 값을 찾는다. 자유 변수가 함수 안에서 할당이 이루어지면 지역 변수가 된다. 지역 변수, 형식 인수, 자유 변수의 순으로 변수의 평가가 이루어진다. R은 함수에서 어떤 변수의 값을 평가할 때, 맨 먼저 이 변수가 지역 변수인지 살펴본다. 지역 변수여서 함수 본문 내부에서 할당되어 있으면, 그 할당된 값으로 변수를 평가한다. 지역 변수가 아니라면 형식 인수인지 살펴본다. 형식 인수이면 형식 인수에 전달된 실질 인수의 값으로 그 변수를 평가한다. 형식 인수도 아니면 자유 변수로 간주하여 함수가 생성되었던 환경에서 변수를 찾는다. 함수의 외부 환경에서도 변수를 찾을 수 없으면 변수를 찾을 수 없다는 오류가 발생한다. 다음 예에선 함수 f는 변수 x, y, z의 합을 반환한다. 여기서 x는 형식 인수로 함수 f가 호출될 때마다 함수의 실질 인수의 값으로 바인딩된다. y는 지역 변수로 함수 본문 안에서 정의되어 10으로 할당이 되었다. 변수 z는 형식 인수도 지역 변수도 아닌 자유 변수이다. 자유 변수는 함수 내부에서 그 값을 찾을 수 없으므로 함수가 정의된 환경에서 그 값을 찾는다. 우리는 현재 R 콘솔에서 작업을 하고 있으므로 함수 f()는 R 콘솔의 전역 공간인 R_GlobalEnv에서 정의되었고 여기서 z의 값을 찾게 된다. &gt; rm(x, y, z) &gt; f &lt;- function(x) { + y &lt;- 10 + x + y + z + } 자유 변수는 함수가 정의가 이루어진 환경에서 함수가 호출될 때 평가가 이루어진다. 맨 처음 함수 f를 실행할 때 f를 정의한 작업 공간에 z에 대한 정의가 없으므로 함수 f를 호출하면 오류가 발생한다. R 콘솔에서 z라는 변수를 할당한 후 다시 f를 호출하면 외부 환경에 정의된 z의 값이 결과에 반영됨을 볼 수 있다. &gt; f(1) Error in f(1): object &#39;z&#39; not found &gt; z &lt;- 3 &gt; f(1) [1] 14 동일한 이름이어도 함수 내부의 변수와 외부의 변수는 별개의 변수이다. 그런데 함수의 형식 인수와 함수 내부의 지역 변수는 함수 내부에서만 의미를 갖는다. (즉 함수 내부로 범위가 설정된다). 따라서 함수 바깥 범위에서는 형식 인수 x와 지역 변수 y에 대해서는 알지 못한다. &gt; x Error in eval(expr, envir, enclos): object &#39;x&#39; not found &gt; y Error in eval(expr, envir, enclos): object &#39;y&#39; not found 다음처럼 R 콘솔에서 x와 y를 정의한 후 다시 f()를 실행해 보자. &gt; x &lt;- 0; y &lt;- 0 &gt; f(2) [1] 15 &gt; x; y [1] 0 [1] 0 함수의 외부 환경에서 x와 y 변수가 만들어져서 0의 값이 할당되었지만, 함수를 호출하면 함수 본문에서 x, y는 모두 형식 인수에 부여된 실질 인수 값 2와 지역 변수로서 할당된 값 10으로 평가되었음을 확인할 수 있다. 왜냐하면 R은 함수 실행시 변수를 지역 변수와 형식 인수에서 먼저 찾기 때문에, 변수에 대한 값을 함수 내부에서 찾으면 전역 공간에 정의된 x, y는 참고하지 않기 때문이다. 그리고 함수 본문에서 x는 2와 y는 10으로 값이 주어졌지만, 함수 바깥의 x, y 변수에는 전혀 영향을 주지 못함을 볼 수 있다. 다만 z는 함수 내부에 정의된 변수가 아니고 함수 외부에서 찾아야 하는 자유 변수이므로 전역 공간에서 z의 값이 변경되면 함수의 평가시에도 그 변화가 반영됨을 알 수 있다. &gt; z &lt;- 10 &gt; f(2) [1] 22 자유 변수를 함수 내부에서 할당하면 새로운 지역 변수가 된다. 만약 자유 변수 z를 함수 내부에서 값을 변경하면 어떻게 될까? &gt; z &lt;- 10 &gt; f &lt;- function(x) { + y &lt;- 10 + a &lt;- x + y + z + z &lt;- 0 + b &lt;- x + y + z + c(a, b) + } &gt; f(2) [1] 22 12 &gt; z [1] 10 결과에서 보듯이 전역 변수 z의 값은 전혀 변화가 없다. 위의 예에서 a의 변수에 x, y, z의 합을 할당할 때까지는 함수 내부에서 z 변수에 대한 할당이 이루어지 않았으므로 전역 공간의 z를 참조하여 10이라는 값으로 z를 평가하여 계산한다. 그 다음에 z에 0을 할당하면 함수 내부에 z라는 별도의 지역 변수가 만들어지게 되고, 전역 변수 z와는 전혀 무관한 변수가 된다. 따라서 b에 x, y, z의 합을 할당하는 문장에서는 z를 먼저 지역 변수에서 찾으므로 지역 변수 z에 할당된 0의 값으로 평가하게 된다. 마지막으로 z가 함수 내부에서 0으로 할당된 것은 함수 내부의 지역 변수에 할당이 이루어진 것이므로 전역 변수 z에는 전혀 영향을 미치지 못한다. 함수 외부 환경의 변수에 값 할당하기 그런데 가끔은 함수 내부에서 함수 외부의 전역 변수의 값을 변경해야 할 경우가 있다. 함수 내부의 지역 변수와 형식 인수는 함수 호출 시에만 생성되었다가 함수 실행이 완료되면 사라진다. 따라서 함수 f() 내부의 x, y는 함수 f()가 실행될 때마다 새로 만들어지고 사라지게 된다. 따라서 함수의 호출과 무관하게 데이터를 유지해야 할 필요가 있을 때는 함수 외부 환경의 전역 변수를 사용해야 한다. 다음 예를 살펴보자. 다음의 call.count() 함수는 자신이 총 몇번 호출되었는지를 기록하는 함수이다. &gt; x &lt;- 0 &gt; call.count &lt;- function() { + x &lt;- x + 1 + cat(x, &quot;번 호출되었습니다.&quot;) + } &gt; call.count() 1 번 호출되었습니다. &gt; call.count() 1 번 호출되었습니다. &gt; x [1] 0 call.count() 함수는 자신이 호출될 때마다 전역 변수 x의 값을 읽은 후 1을 더하여 다시 x에 할당하려고 한다. 그러나 x를 하나씩 증가시키는 할당문이 실행될 때, 오른편의 x는 아직 x가 함수 내부에 할당되기 전이기에 전역 변수 x를 참조하지만, 할당문 왼편의 x는 함수 내부에서 할당이 이루어진 것이므로, 함수 내부의 지역 변수가 되어 전역 변수와 무관해 진다. 따라서 함수의 지역 변수 x에만 1이 할당되었다. 그런데 첫번째 함수 호출이 끝나면 함수 내부의 지역 변수는 모두 사라진다. 따라서 두번째 호출시 할당문의 오른편이 실행될 때는 역시 지역 변수 x는 존재하지 않으므로 다시 전역 변수 x를 참조하게 된다. 전역 변수는 변화가 없었으므로 0의 값을 계속 가지고 있고 첫번째 호출과 같은 결과만 얻을 뿐이다. 수퍼 할당 연산자 이 문제를 해결하는 방법은 함수 내부에서 외부 전역 변수에 값을 할당할 수 있도록 하는 것이다. 일반 할당 연산자 &lt;-로는 지역 변수만 생성될 뿐이다. 그러나 수퍼 할당 연산자 &lt;&lt;-를 이용하여 할당을 하면 지역 변수가 아닌 함수의 외부 환경에서 변수를 찾아서 할당을 시도한다. 이를 이용하면 위의 call.count()는 다음처럼 개선될 수 있다. &gt; call.count &lt;- function() { + x &lt;&lt;- x + 1 + cat(x, &quot;번 호출되었습니다.&quot;) + } &gt; call.count() 1 번 호출되었습니다. &gt; call.count() 2 번 호출되었습니다. &gt; x [1] 2 이번에는 함수 호출의 결과로 전역 변수가 변경되고 원하는 결과를 얻을 수 있었다. 수퍼 할당 연산자로 값을 부여하고자 하는 변수가 외부 환경에 없으면 외부 환경에 해당 변수를 만든다. 마치 외부 환경에서 변수에 할당할 때 변수가 없으면 새로운 변수를 만드는 것과 동일한 작용을 하게 된다. &gt; rm(w) Warning in rm(w): object &#39;w&#39; not found &gt; w Error in eval(expr, envir, enclos): object &#39;w&#39; not found &gt; sq &lt;- function(a) w &lt;&lt;- a^2 &gt; sq(10) &gt; w [1] 100 함수의 외부 환경이 함수인 경우 R에서는 함수 내부에서 벡터, 리스트 등의 객체를 변수에 할당할 수 있듯이, 함수 내부에서 함수를 정의하여 변수에 할당할 수 있다. 이런 경우 함수의 변수 범위는 계층 구조를 가지게 된다. 함수 내부에서 정의된 안쪽 함수의 외부 환경은 바깥쪽 함수가 된다. 그리고 바깥쪽 함수의 외부 환경은 R 콘솔의 전역 공간이 된다. 다음의 예를 살펴보자. &gt; f.out &lt;- function(y){ + f.in &lt;- function(z){ + x &lt;- 2 + x + y + z + } + return(f.in) + } &gt; &gt; x &lt;- 1; y &lt;- 10; z &lt;- 100 &gt; a &lt;- f.out(20) &gt; a(200) [1] 222 출력 결과를 이해하기 위해서는 f.out()을 정의한 후 일어나는 일들은 차례대로 따라가볼 필요가 있다. 만약에 f.out()에 다른 값을 실질 인수로 하여 호출하면 어떻게 될까? &gt; b &lt;- f.out(30) &gt; b(300) [1] 332 마찬가지로 f.out(30) 호출에 의해 f.in() 함수 객체가 반환되어 변수 b에 할당된다. b(300) 호출이 이루어지면, f.in() 함수가 실행되는데, x는 지역 변수이므로 함수 내부에서 정의된 2의 값이 할당되고, y는 자유 변수인데 이번에 생성된 함수 b는 f.out(30) 호출에 의해 만들어진 함수이므로 f.out(30)이 자신의 외부 환경이 된다. 따라서 y는 30의 값으로 평가된다. z는 자신의 형식 인수로 300이 호출시 주어졌다. 이것들이 합산되어 332의 결과가 반환된다. environment() f.out() 함수에서 생성되어 반환된 두 함수 객체 a, b의 외부 환경이 무엇인지 확인해 보자. environment() 함수는 인수로 전달된 함수 객체의 외부 환경이 무엇인지를 알려준다. &gt; environment(f.out) &lt;environment: R_GlobalEnv&gt; &gt; environment(a); parent.env(environment(a)) &lt;environment: 0x557adda531c8&gt; &lt;environment: R_GlobalEnv&gt; &gt; environment(b); parent.env(environment(b)) &lt;environment: 0x557adbfa62e8&gt; &lt;environment: R_GlobalEnv&gt; &gt; environment(f.in) Error in environment(f.in): object &#39;f.in&#39; not found f.out() 함수는 전역 공간에서 정의하였으므로 전역 공간이 자신의 외부 환경임을 알려준다. a, b는 각자 서로 다른 외부 환경을 가지고 있음을 볼 수 있다. 그러나 a, b 각각의 외부 환경의 부모 외부 환경은 전역 공간임을 볼 수 있다. 참고로 f.in() 함수는 f.out() 함수의 호출 환경에서 정의된 함수 객체이므로 전역 공간에서는 모르는 함수이다. 따라서 전역 공간에서 f.in() 함수를 찾으면 찾을 수 없다는 결과가 나온다. ls()와 get() ls() 함수를 이용하면 환경에 정의되어 있는 변수 정보를 얻을 수 있고, get() 함수를 이용하면 변수 이름으로 변수 값을 확인할 수 있다. &gt; ls(environment(a)) [1] &quot;f.in&quot; &quot;y&quot; &gt; ls(environment(b)) [1] &quot;f.in&quot; &quot;y&quot; &gt; get(&quot;y&quot;, envir=environment(a)) [1] 20 &gt; get(&quot;y&quot;, envir=environment(b)) [1] 30 &gt; get(&quot;y&quot;, envir=.GlobalEnv) [1] 10 함수 객체 a와 b의 외부 환경인 f.out 호출 환경에는 y와 f.in이라는 변수가 모두 존재한다. 그러나 get() 함수로 확인한 이 두 환경에 있는 y 변수의 값을 서로 다름을 알 수 있다. 그리고 전역 공간인 .GlobalEnv에 있는 변수 y의 값과도 다름을 알 수 있다. 이처럼 R은 함수에 사용되는 변수를 먼저 자기 내부에서 조회해 보고, 없으면 자신이 정의된 외부 환경, 거기에도 없으면 외부 환경의 부모 환경으로 거슬러 올라가며 조회해 나간다. 만약 최상위 환경(여기서는 .GlobalEnv)에도 찾는 변수가 없으면, 그 다음에는 검색 경로(search path)를 거슬러 올라가며 변수를 찾는다. 변수 검색 경로는 현재의 전역 공간을 시작으로 적재된 R 패키지와 attach() 함수로 포함된 데이터 프레임들이 되며, 맨 마지막은 R의 기본 패키지인 base 패키지 환경이 된다. 이 모든 곳에서 해당 변수를 찾을 수 없으면, 변수를 찾을 수 없다는 오류를 발생시킨다. 검색 경로에 대한 설명은 데이터 프레임의 attach() 관련 절을 확인하기 바란다. 아울러 현 작업 공간의 검색 경로는 searchpaths() 함수로 확인할 수 있다. 함수 정의 시 형식 인수의 초기값은 symbol=expression 형태로 정의된다. symbol은 함수 내에서 사용할 형식 인수의 이름이고, expression은 초기값이 계산되는 표현식이다. 따라서 단순히 정해진 상수만 초기값에 부여되는 것이 아니라 함수가 호출되는 시점에 expression에 대한 평가가 이루어져 그 결과가 초기값으로 부여될 수도 있다.↩︎ 아울러 함수 본문 표현식을 보면 read.csv() 함수는 함수 본문에서 read.table() 함수를 호출하여 작업을 처리한다는 것을 알 수 있다. read.table() 함수를 출력해 보면 형식 인수 sep의 초기값이 ‘`’’으로 정의되어 있음을 알 수 있다. read.table()은 sep 인수가 이 값일 때는 공백문자(space, tab, 줄바꿈 등)를 이용하여 데이터 필드를 분리해 낸다.↩︎ R은 대부분은 프로그래밍 언어처럼 정적 변수 범위 설정(static scoping 또는 lexical scoping)을 이용한다. 이 의미는 함수에서 사용되는 변수들은 함수가 정의되는 시점의 컨텍스트에 의해 평가된다는 것이다. 그러나 R 언어는 FPL로서 함수의 생성과 조작이 매우 동적으로 이루어지므로 사실 변수 범위 설정의 문제가 매우 복잡해진다.↩︎ "],
["ch-R-OOP.html", "Chapter 11 R 객체 지향 프로그래밍 11.1 객체 지향 프로그래밍 11.2 S3 클래스 11.3 S4 클래스", " Chapter 11 R 객체 지향 프로그래밍 11.1 객체 지향 프로그래밍 객체 지향 프로그램(Object-Oriented Programming(OOP))이 무엇인지, 그것이 왜 필요한지를 논의하려면 별도로 한 장이 할애되어야 할 것이다. 여기서는 객체 지향 프로그래밍의 개요에 대해서만 간단히 짚어본다. OOP는 복잡한 프로그램을 구조화하는 방식에 대한 하나의 관점 또는 패러다임이라 할 수 있다. 간단한 프로그램은 어떠한 방식으로 작성하여도 이해하거나 수정이 어렵지 않다. 그러나 프로그램이 복잡해지면 프로그램을 적절한 단위로 구조화해야 프로그램 전체를 이해할 수 있고 유지보수가 가능해진다. 절차적 프로그래밍 vs. 객체 지향 프로그래밍 이러한 프로그램 구조화 패러다임 중 가장 오래된 방식이 절차적 프로그래밍(procedural programming) 패러다임이다. 절차적 프로그래밍은 프로그램을 기능적으로 유사한 부분으로 분절한다. 이러한 분절은 전체 프로그램을 기능에 따라 프로그램-모듈-함수/서브루틴/프로시저 등으로 계층적으로 구조화한다. 반복되어 사용되는 부분을 함수나 프로시저로 구현한 후, 필요할 때마다 해당 함수나 프로시저를 호출하여 사용할 수 있게 함으로써 비슷한 기능에 대한 구현이 프로그램 전체에 산재하여 유지보수하기 어렵게 되는 것을 막아 준다. 절차적 프로그래밍 방식을 비유적으로 말하자면, 어떤 복잡한 조직을 총무부, 인사부, 생산부, 자재부 등의 기능조직으로 나누어 구조화하는 방식과 비슷하다고 하겠다. 특화된 기능 조직이 비슷한 기능을 효율적으로 전담하여 반복수행하는 것처럼, 특화된 모듈과 함수는 비슷한 작업을 호출할 때마다 반복수행한다. 프로그래밍 언어와 프로그래밍 방식이 일 대 일로 대응되는 것은 아니지만, 절차적 프로그래밍 방식을 주로 사용하는 프로그래밍 언어로는 C 언어를 들 수 있다. 객체 지향 프로그래밍(OOP)는 복잡한 프로그램을 객체를 중심으로 구조화한다. 절차적 프로그래밍이 함수나 프로시저 등을 이용하여 기능 중심으로 프로그램을 분절한다면, OOP는 데이터를 중심으로 동일한 형식의 데이터를 처리하는 부분으로 프로그램을 분절한다. 이를 비유적으로 말하자면 절차적 프로그래밍이 기능 조직이어서 여러 사업과 관련된 동일한 기능이 하나의 기능 부서에 통합되어 있는 형식이라면, OOP는 사업부 조직으로서 하나의 사업이라는 내용을 중심으로 총무, 인사, 생산, 자재 등의 기능이 뭉쳐 있는 형식이라 할 수 있다. OOP를 따르는 주요 언어로는 C++, Java 등이 있다. R은 이러한 언어와는 조금 다르지만 기본적인 OOP 특성을 가지고 있다. OOP의 기본 특징 OOP가 가져야 하는 기본 특징은 다음과 같다. 11.2 S3 클래스 R은 OOP 개념을 처음에는 S3 클래스로 구현하였다. 그러나 S3 클래스는 캡슐화 및 데이터 보안에 취약한 점이 있으므로 이를 강화할 수 있는 S4 클래스를 나중에 도입하였다. 그러나 아직까지 대다수의 R 패키지는 S3 클래스에 의해 OOP를 구현하고 있고, 아직도 많은 R 사용자가 S3 클래스로 개발하는 것을 선호하고 있다. 11.2.1 S3 클래스 객체 만들기 본질적으로 S3 클래스 객체란 R의 리스트 객체에 class 속성을 부여한 것뿐이다. 앞서 본 lm() 함수의 결과 객체 a는 lm 클래스 객체였다. 이 객체를 unclass() 함수를 이용하여 클래스 속성을 제외하면 단순한 리스트임을 확인할 수 있다. S3 클래스 객체는 리스트에 class 속성 부여하여 만든다. 사용자도 리스트와 class() 함수를 이용하여 자신만의 S3 클래스를 만들 수 있다. 다음은 학생 관련 정보를 담는 student 클래스를 만든 예이다. &gt; st1 &lt;- list(name=&quot;Gildong&quot;, year=2, GPA=3.2) &gt; class(st1) &lt;- &quot;student&quot; &gt; st1 $name [1] &quot;Gildong&quot; $year [1] 2 $GPA [1] 3.2 attr(,&quot;class&quot;) [1] &quot;student&quot; student 객체를 출력해 보면 여느 리스트와 동일하게 각 요소를 출력하고, 마지막으로 부가 정보인 속성 정보를 출력하였다. 속성 정보는 오직 하나 class 속성만 있는 것을 확인할 수 있다. student 클래스는 print 메소드가 구현되어 있지 않았으므로, 객체가 출력될 때 객체의 타입인 리스트가 출력되는 형식으로 출력되었다. 11.2.2 포괄 함수(generic functions) 포괄 함수는 UseMethod()로 클래스에 따라 적절한 메소드를 호출한다. 포괄 함수란 print() 함수처럼 여러 클래스의 객체에 적용 가능한 함수를 의미한다. 포괄 함수는 인수로 주어진 객체의 클래스에 따라 클래스에 적합한 기능을 수행한다. 그러면 포괄 함수는 어떻게 객체에 따라 적절한 기능을 수행할 수 있는 것일까? 심지어 print() 함수 같은 포괄 함수는 자신이 구현된 이후에 새로운 클래스가 추가되어도 새로운 클래스에 적합한 기능을 수행할 수 있다. 포괄 함수는 사실 분배기의 역할만을 수행하기 때문에 이러한 기능이 가능한 것이다. 포괄 함수는 호출이 되면 UseMethod() 라는 분배 기능을 가지는 함수를 호출한다. 이 함수는 포괄 함수에 첫번째 인수로 부여된 객체의 클래스에 따라 포괄 함수를 대신하여 실행될 해당 클래스의 메소드를 호출한다. 그리고 포괄 함수는 해당 클래스의 메소드가 객체에 실행된 결과를 반환한다. 다음은 print() 함수가 호출되면 무엇이 수행되는지를 보여준다. UseMethod()가 호출되는 것을 볼 수 있다. &gt; print function (x, ...) UseMethod(&quot;print&quot;) &lt;bytecode: 0x558533579e08&gt; &lt;environment: namespace:base&gt; methods() 그러면 클래스별로 print 메소드는 어디에 있는 것일끼? methods() 함수를 이용하면 각 포괄 함수에 대해 구현된 모든 메소드를 확인할 수 있다. 다음은 그 중 일부만을 보여주고 있다. &gt; head(methods(print)) [1] &quot;print.acf&quot; &quot;print.AES&quot; &quot;print.anova&quot; &quot;print.aov&quot; [5] &quot;print.aovlist&quot; &quot;print.ar&quot; 메소드 이름 규칙 메소드 함수는 다음과 같은 이름으로 정의되어 있다. &gt; generic_function_name.class_name 따라서 data.frame 클래스의 print 메소드는 print.data.frame이 된다. 이 메소드를 data.frame 객체에 적용하나, 포괄 함수인 print를 data.frame 객체에 적용하나 동일한 결과를 얻는다. 사실 R 콘솔은 명령문을 평가한 후 자동으로 print() 함수를 실행하므로 클래스에 대한 print 메소드 구현은 매우 중요하다. 다음은 R 콘솔에서 print(f)나, print.data.frame(f)나, f는 동일한 결과를 주는 것을 보여준다. &gt; print(f) X1.3 X6.8 1 1 6 2 2 7 3 3 8 &gt; print.data.frame(f) X1.3 X6.8 1 1 6 2 2 7 3 3 8 &gt; f X1.3 X6.8 1 1 6 2 2 7 3 3 8 앞에서 확인할 수 있듯이 지금까지 객체가 R 콘솔에 출력될 때, 해당 객체의 클래스의 print 메소드들이 적절히 호출되어 해당 클래스에 적합한 형식으로 데이터를 보여 주었던 것이다. 그러면 integer, character, list 등을 위한 메소드들도 있을까? grep() 함수로 해당 이름의 메소드를 찾아보면 그렇지 않음을 알 수 있다. 그러면 이 클래스의 객체들은 어떻게 출력이 이루어지는 걸까? &gt; grep(&quot;integer&quot;, methods(print)) integer(0) &gt; grep(&quot;character&quot;, methods(print)) integer(0) &gt; grep(&quot;list&quot;, methods(print)) [1] 5 35 79 84 116 165 166 177 204 &gt; methods(print)[grep(&quot;list&quot;, methods(print))] [1] &quot;print.aovlist&quot; &quot;print.check_package_datalist&quot; [3] &quot;print.Dlist&quot; &quot;print.dummy_coef_list&quot; [5] &quot;print.listof&quot; &quot;print.shiny.tag.list&quot; [7] &quot;print.simple.list&quot; &quot;print.summary.aovlist&quot; [9] &quot;print.xfun_strict_list&quot; 해당 클래스의 메소드가 없으면 UseMethod() 분배 함수는 default 메소드를 호출한다. default 메소드는 generic_function_name.default 형식으로 이름이 주어진다. print 포괄 함수의 경우 print.defualt 메소드이다. 디폴트 메소드 &gt; print.default function (x, digits = NULL, quote = TRUE, na.print = NULL, print.gap = NULL, right = FALSE, max = NULL, width = NULL, useSource = TRUE, ...) { args &lt;- pairlist(digits = digits, quote = quote, na.print = na.print, print.gap = print.gap, right = right, max = max, width = width, useSource = useSource, ...) missings &lt;- c(missing(digits), missing(quote), missing(na.print), missing(print.gap), missing(right), missing(max), missing(width), missing(useSource)) .Internal(print.default(x, args, missings)) } &lt;bytecode: 0x558532641c50&gt; &lt;environment: namespace:base&gt; 보통 default 메소드는 데이터가 가지는 기본적 타입에 대해 적절한 포괄 함수 관련 처리를 수행하도록 구현되어 있다. print.default는 기본적인 데이터의 타입에 따라 적절한 출력을 보여준다. 앞서 우리는 student 클래스 객체를 만들었다. 그런나 print.student라는 메소드는 존재하지 않으므로 콘솔에서 해당 객체가 입력되었을 때, print.defualt가 student의 출력을 담당하였다. 따라서 student의 데이터 기본 타입인 list의 형식으로 데이터가 출력이 된것이다. methods() 함수의 class 인수를 이용하면 해당 클래스를 위해 정의된 모든 메소드의 목록을 볼 수 있다. student 클래스를 위한 어떠한 메소드도 구현되지 않았음을 볼 수 있다. &gt; methods(class=&quot;lm&quot;) [1] add1 alias anova case.names coerce [6] confint cooks.distance deviance dfbeta dfbetas [11] drop1 dummy.coef effects extractAIC family [16] formula hatvalues influence initialize kappa [21] labels logLik model.frame model.matrix nobs [26] plot predict print proj qr [31] residuals rstandard rstudent show simulate [36] slotsFromS3 summary variable.names vcov see &#39;?methods&#39; for accessing help and source code &gt; methods(class=&quot;student&quot;) no methods found &gt; print.default(st1) $name [1] &quot;Gildong&quot; $year [1] 2 $GPA [1] 3.2 attr(,&quot;class&quot;) [1] &quot;student&quot; 메소드 정의하기 다음처럼 student 클래스를 위한 print 메소드를 만들어 보자. S3 클래스에서는 함수의 이름을 (포괄 함수명).(클래스명)으로 부여하면 된다. 그러면 UseMethod()가 해당 클래스를 위해 정의된 메소드를 호출해 준다. &gt; print.student &lt;- function(x) { + cat(x$name, &quot;\\n&quot;) + cat(&quot;year&quot;, x$year, &quot;\\n&quot;) + cat(&quot;GPA&quot;, x$GPA, &quot;\\n&quot;) + } &gt; methods(class=&quot;student&quot;) [1] print see &#39;?methods&#39; for accessing help and source code &gt; print(st1) Gildong year 2 GPA 3.2 위의 예에서 보듯이 student 클래스를 위한 print 메소드가 구현되었으므로 이제는 default 메소드가 아니라 student 클래스를 위한 print 메소드가 실행된다. 일반적으로 복잡한 클래스일수록 자신만의 print 메소드를 구현한다. 그래야 복잡한 내부 데이터를 모두 출력하지 않고 필요한 정보만 효율적으로 보여줄 수 있기 때문이다. 그리고 R을 처음 접한 사람들이 의아해 하는 사항이 있다. 그것은 대부분의 클래스에서 print 메소드보다는 summary 메소드가 더 자세한 정보를 출력한다는 것이다. 문자 그대로 해석한다면 print() 함수는 모든 내용을 출력해야 하고, summary() 함수는 좀 더 요약된 정보를 제공해야 할 것 같은데 말이다. lm 클래스도 print() 함수 보다는 summary() 함수가 훨씬 더 자세한 정보를 제공한다. &gt; summary(a) Call: lm(formula = cars) Residuals: Min 1Q Median 3Q Max -7.5293 -2.1550 0.3615 2.4377 6.4179 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 8.28391 0.87438 9.474 1.44e-12 *** dist 0.16557 0.01749 9.464 1.49e-12 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 3.156 on 48 degrees of freedom Multiple R-squared: 0.6511, Adjusted R-squared: 0.6438 F-statistic: 89.57 on 1 and 48 DF, p-value: 1.49e-12 이러한 일이 발생하는 이유는 R에서 print() 함수는 R 콘솔에 사용자의 명령이 입력될 때마다 실행되는 함수이기 때문이다. 따라서 print() 함수의 결과가 자칫 필요 이상으로 길고 복잡해지면 R 콘솔 작업이 어려워질 수 있기 때문에 대부분의 클래스에서는 휠씬 요약된 정보만을 print 메소드가 제공하도록 하고 있다. 하지만 기본 데이타 타입의 경우는 print.defualt 메소드가 데이터의 내용을 가감 없이 보여주기 때문에 그러한 현상은 나타나지 않는다. 11.2.3 S3에서 상속성의 구현 상속성은 객체 지향 프로그래밍의 매력 중에 하나이다. 새로운 클래스를 만들 때 이전의 클래스를 상위 클래스로 하고 자신을 하위 클래스로 하면, 상위 클래스에 정의된 메소드들을 하위 클래스 객체가 이용할 수 있다. 상위 클래스와 하위 클래스 이 때 주의할 점은 하위 클래스 객체는 상위 클래스에 부분집합의 관계를 가져야 한다는 것이다. 예를 들어 MTB 자전거라는 하위 클래스를 자전거라는 상위 클래스를 상속받아 구현하였다면, MTB 자전거 객체는 역시 자전거 객체이기도 해야 한다는 것이다. 따라서 하위 클래스의 데이터 구조는 상위 클래스의 데이터 요소를 모두 포함하고 있어야 하고, 거기에 덧붙여 자신만의 데이터와 기능을 더 포함하는 구조이어야 한다. 상속성을 구현하는 방법 S3 클래스에서 상속성의 구현은 객체를 생성할 때 단지 class 속성에 하위 클래스 이름 다음에 상위 클래스 이름을 모두 나열하기만 하면 된다. 그러면 UseMethod() 분배 함수는 class 속성에 부여된 클래스 순으로 메소드를 찾아 실행한다. 따라서 하위 클래스를 위한 메소드가 없으면 다음에 정의되어 있는 상위 클래스의 메소드를 실행해 준다. 하위 클래스가 상속받은 상위 클래스가 또 다른 클래스를 상속 받았다면, class 속성에는 하위 클래스, 상위 클래스, 상위-상위 클래스 순으로 차례대로 기술해 주면 된다. S3 클래스에서 상속성이 어떻게 수행되는지 다음 예로 살펴보자. 현재 student 클래스를 이용하여 대학생과 대학원생 정보를 모두 처리하고 있다고 하자. 그런데 대학원생의 경우에는 student에 있는 데이터뿐 아니라 지도교수(advisor)에 대한 정보가 추가되어 관리되는 것이 편리하다고 판단되어, 지도교수 정보를 포함하는 gradstudent 클래스를 정의하고자 한다. 다음 예에서 st2 객체를 생성할 때 리스트에 advisor 요소가 추가되었다. 그리고 class 속성에 먼저 하위 클래스 이름인 gradstudent, 그리고 상위 클래스 이름인 student가 기술되었다. 물론 아직은 gradstudent 클래스에 대한 어떠한 메소드도 존재하지 않는다. &gt; st2 &lt;- list(name=&quot;Gilsan&quot;, year=1, GPA=3.8, advisor=&quot;Sejong&quot;) &gt; class(st2) &lt;- c(&quot;gradstudent&quot;, &quot;student&quot;) &gt; methods(class=&quot;gradstudent&quot;) no methods found 그러면 gradstudent 클래스인 st2를 출력해 보자. 그러면 UseMethod() 함수는 먼저 gradstudent 클래스를 위한 print 메소드를 찾는다. 해당 메소드가 없으므로 두번째로 기술되어 있는 student 클래스의 print 메소드를 찾는다. 해당 메소드가 있으므로 이 메소드로 출력을 수행한다. 이마저도 없으면 default 메소드가 수행될 것이다. 물론 student 클래스를 위한 print 메소드는 이미 구현되어 있기 때문에, 대학원생 정보인 st2도 student 클래스의 출력 형식에 맞추어 출력이 이루어진다. 따라서 gradstudent 객체는 student 클래스의 메소드를 상속 받았다고 볼 수 있다. &gt; st2 Gilsan year 1 GPA 3.8 메소드 overiding 만약 gradstudent 객체의 출력에 지도 교수 정보도 같이 출력되기를 원한다면, 다음처럼 gradstudent 클래스의 print 메소드를 구현하면 된다. 이 경우 gradstudent 클래스만의 메소드가 상속받은 student 클래스의 메소드를 overiding 하였다고 표현한다. &gt; print.gradstudent &lt;- function(x) { + print.student(x) + cat(&quot;Advisor&quot;, x$advisor, &quot;\\n&quot;) + } &gt; st2 Gilsan year 1 GPA 3.8 Advisor Sejong 11.3 S4 클래스 S3 클래스의 안전성 문제 S3 클래스는 Java 같은 OOP 언어와 비교해 보면 다음과 같은 안전성(safety) 문제를 가지고 있다. 클래스 정의를 사전에 하지 않으므로 객체 생성시 필요한 요소가 누락되거나 이름이 잘못 부여될 수 있다. 클래스의 메소드도 이름으로 파악하므로, 메소드 구현시 함수 이름이 잘못 부여되어도 이를 바로 확인할 수 없다. 데이터가 근본적으로 리스트 객체이므로 클래스 내부 데이터에 대한 잘못된 접근을 막을 수 없다. 이러한 문제를 해결하기 위해 S4 클래스가 개발되었다. 표 11.112은 두 클래스의 차이를 보여준다. 이 절에서는 S4 클래스의 몇 가지 특징에 대해서만 짚어보기로 한다. Table 11.1: S3 클래스 vs. S4 클래스 (Source: The Art of R Programming) 작업 S3 S4 클래스 정의 명시적 정의 없음 setClass()로 클래스 정의 객체 생성 리스트 생성 후 class 속성 부여 new()로 명시적 객체 생성 클래스 요소 접근 $ @ f 메소드 구현 f.classname() 함수 정의 setMethod()로 명시적 구현 포괄 함수 구현 포괄 함수에 UseMethod() 이용 setGeneric()로 명시적 구현 클래스 정의 setClass() 다음은 setClass() 함수로 newstudent라는 새로운 클래스를 생성한 예이다. 데이터의 요소는 앞서 S3 클래스로 생성한 student 클래스와 동일하다. setClass()의 첫번째 인수로는 클래스 이름이, representation 인수는 클래스의 데이터 요소의 이름과 각 데이터 요소의 클래스가 명시된다. 이를 통해 해당 클래스 객체가 생성될 때 객체 요소의 데이터의 이름과 타입이 같아지도록 강제할 수 있다. &gt; setClass(&quot;newstudent&quot;, + representation(name=&quot;character&quot;, year=&quot;numeric&quot;, GPA=&quot;numeric&quot; )) 객체 생성 new() 클래스로부터 새로운 객체를 생성할 때는 new() 함수를 이용한다. new() 함수는 첫번째 인수로 클래스 이름을, 나머지 인수로 객체의 각 데이터 요소를 정의한다. &gt; st3 &lt;- new(&quot;newstudent&quot;, name=&quot;Gildong&quot;, year=2, GPA=3.2) &gt; st3 An object of class &quot;newstudent&quot; Slot &quot;name&quot;: [1] &quot;Gildong&quot; Slot &quot;year&quot;: [1] 2 Slot &quot;GPA&quot;: [1] 3.2 setClass()에 의해 클래스의 형태가 이미 정의되어 있어서 new()로 객체 생성 시 틀린 이름이나 틀린 타입의 데이터가 입력되면 오류가 발생하므로 항상 정확한 이름과 형식으로 객체가 생성되도록 강제할 수 있다. &gt; st4 &lt;- new(&quot;newstudent&quot;, sname=&quot;Gildong&quot;, year=2, GPA=3.2) Error in initialize(value, ...): invalid name for slot of class &quot;newstudent&quot;: sname &gt; st4 &lt;- new(&quot;newstudent&quot;, name=&quot;Gildong&quot;, year=2, GPA=&quot;3.2&quot;) Error in validObject(.Object): invalid class &quot;newstudent&quot; object: invalid object for slot &quot;GPA&quot; in class &quot;newstudent&quot;: got class &quot;character&quot;, should be or extend class &quot;numeric&quot; 객체 요소에 접근 slot() S4 클래스에서 객체의 각 데이터 요소(멤버 변수라고 한다)를 슬롯(slot)이라 하며, @ 또는 slot()으로 접근한다. S4 클래스는 정의되지 않은 멤버 변수의 생성을 허용하지 않는다. 반면 S3는 단순한 리스트 객체이므로 아무 제약 없이 새로운 요소를 추가하거나 기존 요소를 삭제할 수 있다. &gt; st3@name [1] &quot;Gildong&quot; &gt; slot(st3, &quot;GPA&quot;) [1] 3.2 &gt; st3@year &lt;- 4 &gt; st3@GPa &lt;- 4.0 Error in (function (cl, name, valueClass) : &#39;GPa&#39; is not a slot in class &quot;newstudent&quot; &gt; st3 An object of class &quot;newstudent&quot; Slot &quot;name&quot;: [1] &quot;Gildong&quot; Slot &quot;year&quot;: [1] 4 Slot &quot;GPA&quot;: [1] 3.2 S4 클래스 메소드 생성 setMethod() S4 클래스에서는 메소드는 setMethod() 함수에 의해 정의된다. 앞에서 생성한 newstudent 객체에 summary() 함수를 적용하면 해당 클래스의 summary 메소드가 구현되지 않았으므로 디폴트로 제공되는 메소드에 의해 객체에 대한 매우 간략한 요약 정보만 출력한다. &gt; summary(st3) Length Class Mode 1 newstudent S4 newstudent 클래스에 summary 메소드를 다음과 같이 추가해 보자. setMethod() 함수는 첫번째 인수로 메소드 이름, 두번째 인수로 클래스 이름, 세번째 인수로 메소드 호출시 실행될 함수 객체를 받는다. &gt; setMethod(&quot;summary&quot;, &quot;newstudent&quot;, + function(object){ + cat(object@name, &quot; is a &quot;, + object@year, &quot;th year student with GPA &quot;, + object@GPA, &quot;\\n&quot;, sep=&quot;&quot;) + }) &gt; summary(st3) Gildong is a 4th year student with GPA 3.2 만약 명시적으로 생성한 메소드를 제거하려면 removeMethod() 함수를 이용한다. &gt; removeMethod(&quot;summary&quot;, &quot;newstudent&quot;) [1] TRUE &gt; summary(st3) Length Class Mode 1 newstudent S4 Matloff, Norman. The Art of R Programming: A Tour of Statistical Software Design. No Starch Press, 2011.↩︎ "]
]
