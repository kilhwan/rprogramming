<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Chapter 11 R 객체 지향 프로그래밍 | R 프로그래밍 (개정판)</title>
<meta name="author" content="Kilhwan Kim">
<meta name="description" content="11.1 객체 지향 프로그래밍 객체 지향 프로그램(Object-Oriented Programming(OOP))이 무엇인지, 그것이 왜 필요한지를 논의하려면 별도로 한 장이 할애되어야 할 것이다. 여기서는 객체 지향 프로그래밍의 개요에 대해서만 간단히 짚어본다. OOP는 복잡한 프로그램을 구조화하는 방식에 대한 하나의 관점 또는 패러다임이라 할 수...">
<meta name="generator" content="bookdown 0.33 with bs4_book()">
<meta property="og:title" content="Chapter 11 R 객체 지향 프로그래밍 | R 프로그래밍 (개정판)">
<meta property="og:type" content="book">
<meta property="og:description" content="11.1 객체 지향 프로그래밍 객체 지향 프로그램(Object-Oriented Programming(OOP))이 무엇인지, 그것이 왜 필요한지를 논의하려면 별도로 한 장이 할애되어야 할 것이다. 여기서는 객체 지향 프로그래밍의 개요에 대해서만 간단히 짚어본다. OOP는 복잡한 프로그램을 구조화하는 방식에 대한 하나의 관점 또는 패러다임이라 할 수...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chapter 11 R 객체 지향 프로그래밍 | R 프로그래밍 (개정판)">
<meta name="twitter:description" content="11.1 객체 지향 프로그래밍 객체 지향 프로그램(Object-Oriented Programming(OOP))이 무엇인지, 그것이 왜 필요한지를 논의하려면 별도로 한 장이 할애되어야 할 것이다. 여기서는 객체 지향 프로그래밍의 개요에 대해서만 간단히 짚어본다. OOP는 복잡한 프로그램을 구조화하는 방식에 대한 하나의 관점 또는 패러다임이라 할 수...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.4.2/transition.js"></script><script src="libs/bs3compat-0.4.2/tabs.js"></script><script src="libs/bs3compat-0.4.2/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-176754989-1"></script><script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-176754989-1');
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<style type="text/css">
    /* Used with Pandoc 2.11+ new --citeproc when CSL is used */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
        }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
<link rel="stylesheet" href="style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">R 프로그래밍 (개정판)</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Preface</a></li>
<li><a class="" href="ch-intro.html"><span class="header-section-number">1</span> R 설치 및 시작</a></li>
<li><a class="" href="ch-R-Data-Basic.html"><span class="header-section-number">2</span> R 데이터 기초</a></li>
<li><a class="" href="ch-R-Vectors.html"><span class="header-section-number">3</span> R 벡터</a></li>
<li><a class="" href="ch-R-Matrix.html"><span class="header-section-number">4</span> R 행렬</a></li>
<li><a class="" href="ch-R-List.html"><span class="header-section-number">5</span> R 리스트</a></li>
<li><a class="" href="ch-R-Data-Frame.html"><span class="header-section-number">6</span> R 데이터 프레임</a></li>
<li><a class="" href="ch-dataTransformation.html"><span class="header-section-number">7</span> dplyr을 이용한 데이터 변환</a></li>
<li><a class="" href="ch-visualization.html"><span class="header-section-number">8</span> ggplot2를 이용한 데이터 시각화</a></li>
<li><a class="" href="ch-R-Advanced-Data-Mgmt.html"><span class="header-section-number">9</span> R 고급 데이터 변환</a></li>
<li><a class="" href="ch-R-Programming-Structure.html"><span class="header-section-number">10</span> R 프로그래밍 구조</a></li>
<li><a class="active" href="ch-R-OOP.html"><span class="header-section-number">11</span> R 객체 지향 프로그래밍</a></li>
<li class="book-part">Appendix</li>
<li><a class="" href="ch-RandPython.html"><span class="header-section-number">A</span> R과 Python 연동하기</a></li>
<li><a class="" href="ch-RTips.html"><span class="header-section-number">B</span> R 관련 여러 주제들</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="ch-R-OOP" class="section level1" number="11">
<h1>
<span class="header-section-number">11</span> R 객체 지향 프로그래밍<a class="anchor" aria-label="anchor" href="#ch-R-OOP"><i class="fas fa-link"></i></a>
</h1>
<div id="객체-지향-프로그래밍" class="section level2" number="11.1">
<h2>
<span class="header-section-number">11.1</span> 객체 지향 프로그래밍<a class="anchor" aria-label="anchor" href="#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D"><i class="fas fa-link"></i></a>
</h2>
<p>객체 지향 프로그램(Object-Oriented Programming(OOP))이 무엇인지, 그것이 왜 필요한지를 논의하려면 별도로 한 장이 할애되어야 할 것이다. 여기서는 객체 지향 프로그래밍의 개요에 대해서만 간단히 짚어본다.</p>
<p>OOP는 복잡한 프로그램을 구조화하는 방식에 대한 하나의 관점 또는 패러다임이라 할 수 있다. 간단한 프로그램은 어떠한 방식으로 작성하여도 이해하거나 수정이 어렵지 않다. 그러나 프로그램이 복잡해지면 프로그램을 적절한 단위로 구조화해야 프로그램 전체를 이해할 수 있고 유지보수가 가능해진다.</p>
<div id="절차적-프로그래밍-vs.-객체-지향-프로그래밍" class="section level4 unnumbered">
<h4>절차적 프로그래밍 vs. 객체 지향 프로그래밍<a class="anchor" aria-label="anchor" href="#%EC%A0%88%EC%B0%A8%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-vs.-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D"><i class="fas fa-link"></i></a>
</h4>
<p>이러한 프로그램 구조화 패러다임 중 가장 오래된 방식이 절차적 프로그래밍(procedural programming) 패러다임이다. 절차적 프로그래밍은 프로그램을 기능적으로 유사한 부분으로 분절한다. 이러한 분절은 전체 프로그램을 기능에 따라 프로그램-모듈-함수/서브루틴/프로시저 등으로 계층적으로 구조화한다.
반복되어 사용되는 부분을 함수나 프로시저로 구현한 후, 필요할 때마다 해당 함수나 프로시저를 호출하여 사용할 수 있게 함으로써 비슷한 기능에 대한 구현이 프로그램 전체에 산재하여 유지보수하기 어렵게 되는 것을 막아 준다. 절차적 프로그래밍 방식을 비유적으로 말하자면, 어떤 복잡한 조직을 총무부, 인사부, 생산부, 자재부 등의 기능조직으로 나누어 구조화하는 방식과 비슷하다고 하겠다.
특화된 기능 조직이 비슷한 기능을 효율적으로 전담하여 반복수행하는 것처럼, 특화된 모듈과 함수는 비슷한 작업을 호출할 때마다 반복수행한다.
프로그래밍 언어와 프로그래밍 방식이 일 대 일로 대응되는 것은 아니지만, 절차적 프로그래밍 방식을 주로 사용하는 프로그래밍 언어로는 C 언어를 들 수 있다.</p>
<p>객체 지향 프로그래밍(OOP)는 복잡한 프로그램을 객체를 중심으로 구조화한다. 절차적 프로그래밍이 함수나 프로시저 등을 이용하여 기능 중심으로 프로그램을 분절한다면, OOP는 데이터를 중심으로 동일한 형식의 데이터를 처리하는 부분으로 프로그램을 분절한다. 이를 비유적으로 말하자면 절차적 프로그래밍이 기능 조직이어서 여러 사업과 관련된 동일한 기능이 하나의 기능 부서에 통합되어 있는 형식이라면, OOP는 사업부 조직으로서 하나의 사업이라는 내용을 중심으로 총무, 인사, 생산, 자재 등의 기능이 뭉쳐 있는 형식이라 할 수 있다. OOP를 따르는 주요 언어로는 C++, Java 등이 있다. R은 이러한 언어와는 조금 다르지만 기본적인 OOP 특성을 가지고 있다.</p>
</div>
<div id="oop의-기본-특징" class="section level4 unnumbered">
<h4>OOP의 기본 특징<a class="anchor" aria-label="anchor" href="#oop%EC%9D%98-%EA%B8%B0%EB%B3%B8-%ED%8A%B9%EC%A7%95"><i class="fas fa-link"></i></a>
</h4>
OOP가 가져야 하는 기본 특징은 다음과 같다.
</div>
</div>
<div id="s3-클래스" class="section level2" number="11.2">
<h2>
<span class="header-section-number">11.2</span> S3 클래스<a class="anchor" aria-label="anchor" href="#s3-%ED%81%B4%EB%9E%98%EC%8A%A4"><i class="fas fa-link"></i></a>
</h2>
<p>R은 OOP 개념을 처음에는 S3 클래스로 구현하였다. 그러나 S3 클래스는 캡슐화 및 데이터 보안에 취약한 점이 있으므로 이를 강화할 수 있는 S4 클래스를 나중에 도입하였다. 그러나 아직까지 대다수의 R 패키지는 S3 클래스에 의해 OOP를 구현하고 있고, 아직도 많은 R 사용자가 S3 클래스로 개발하는 것을 선호하고 있다.</p>
<div id="s3-클래스-객체-만들기" class="section level3" number="11.2.1">
<h3>
<span class="header-section-number">11.2.1</span> S3 클래스 객체 만들기<a class="anchor" aria-label="anchor" href="#s3-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B0%9D%EC%B2%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0"><i class="fas fa-link"></i></a>
</h3>
<p>본질적으로 S3 클래스 객체란 R의 리스트 객체에 class 속성을 부여한 것뿐이다. 앞서 본 lm() 함수의 결과 객체 a는 lm 클래스 객체였다. 이 객체를 unclass() 함수를 이용하여 클래스 속성을 제외하면 단순한 리스트임을 확인할 수 있다.</p>
<div id="s3-클래스-객체는-리스트에-class-속성-부여하여-만든다." class="section level4 unnumbered">
<h4>S3 클래스 객체는 리스트에 class 속성 부여하여 만든다.<a class="anchor" aria-label="anchor" href="#s3-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B0%9D%EC%B2%B4%EB%8A%94-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%97%90-class-%EC%86%8D%EC%84%B1-%EB%B6%80%EC%97%AC%ED%95%98%EC%97%AC-%EB%A7%8C%EB%93%A0%EB%8B%A4."><i class="fas fa-link"></i></a>
</h4>
<p>사용자도 리스트와 class() 함수를 이용하여 자신만의 S3 클래스를 만들 수 있다. 다음은 학생 관련 정보를 담는 student 클래스를 만든 예이다.</p>
<div class="sourceCode" id="cb2202"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">st1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>name<span class="op">=</span><span class="st">"Gildong"</span>, year<span class="op">=</span><span class="fl">2</span>, GPA<span class="op">=</span><span class="fl">3.2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/class.html">class</a></span><span class="op">(</span><span class="va">st1</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="st">"student"</span></span>
<span><span class="va">st1</span></span></code></pre></div>
<pre><code>#&gt; $name
#&gt; [1] "Gildong"
#&gt; 
#&gt; $year
#&gt; [1] 2
#&gt; 
#&gt; $GPA
#&gt; [1] 3.2
#&gt; 
#&gt; attr(,"class")
#&gt; [1] "student"</code></pre>
<p>student 객체를 출력해 보면 여느 리스트와 동일하게 각 요소를 출력하고, 마지막으로 부가 정보인 속성 정보를 출력하였다. 속성 정보는 오직 하나 class 속성만 있는 것을 확인할 수 있다. student 클래스는 print 메소드가 구현되어 있지 않았으므로, 객체가 출력될 때 객체의 타입인 리스트가 출력되는 형식으로 출력되었다.</p>
</div>
</div>
<div id="포괄-함수generic-functions" class="section level3" number="11.2.2">
<h3>
<span class="header-section-number">11.2.2</span> 포괄 함수(generic functions)<a class="anchor" aria-label="anchor" href="#%ED%8F%AC%EA%B4%84-%ED%95%A8%EC%88%98generic-functions"><i class="fas fa-link"></i></a>
</h3>
<div id="포괄-함수는-usemethod로-클래스에-따라-적절한-메소드를-호출한다." class="section level4 unnumbered">
<h4>포괄 함수는 UseMethod()로 클래스에 따라 적절한 메소드를 호출한다.<a class="anchor" aria-label="anchor" href="#%ED%8F%AC%EA%B4%84-%ED%95%A8%EC%88%98%EB%8A%94-usemethod%EB%A1%9C-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90-%EB%94%B0%EB%9D%BC-%EC%A0%81%EC%A0%88%ED%95%9C-%EB%A9%94%EC%86%8C%EB%93%9C%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%9C%EB%8B%A4."><i class="fas fa-link"></i></a>
</h4>
<p>포괄 함수란 print() 함수처럼 여러 클래스의 객체에 적용 가능한 함수를 의미한다. 포괄 함수는 인수로 주어진 객체의 클래스에 따라 클래스에 적합한 기능을 수행한다.</p>
<p>그러면 포괄 함수는 어떻게 객체에 따라 적절한 기능을 수행할 수 있는 것일까? 심지어 print() 함수 같은 포괄 함수는 자신이 구현된 이후에 새로운 클래스가 추가되어도 새로운 클래스에 적합한 기능을 수행할 수 있다.
포괄 함수는 사실 분배기의 역할만을 수행하기 때문에 이러한 기능이 가능한 것이다. 포괄 함수는 호출이 되면 UseMethod() 라는 분배 기능을 가지는 함수를 호출한다. 이 함수는 포괄 함수에 첫번째 인수로 부여된 객체의 클래스에 따라 포괄 함수를 대신하여 실행될 해당 클래스의 메소드를 호출한다. 그리고 포괄 함수는 해당 클래스의 메소드가 객체에 실행된 결과를 반환한다. 다음은 print() 함수가 호출되면 무엇이 수행되는지를 보여준다. UseMethod()가 호출되는 것을 볼 수 있다.</p>
<div class="sourceCode" id="cb2204"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">print</span></span></code></pre></div>
<pre><code>#&gt; function (x, ...) 
#&gt; UseMethod("print")
#&gt; &lt;bytecode: 0x560c126fb5f0&gt;
#&gt; &lt;environment: namespace:base&gt;</code></pre>
</div>
<div id="methods" class="section level4 unnumbered">
<h4>methods()<a class="anchor" aria-label="anchor" href="#methods"><i class="fas fa-link"></i></a>
</h4>
<p>그러면 클래스별로 print 메소드는 어디에 있는 것일끼? methods() 함수를 이용하면 각 포괄 함수에 대해 구현된 모든 메소드를 확인할 수 있다. 다음은 그 중 일부만을 보여주고 있다.</p>
<div class="sourceCode" id="cb2206"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/utils/methods.html">methods</a></span><span class="op">(</span><span class="va">print</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt; [1] "print.acf"               "print.activeConcordance"
#&gt; [3] "print.AES"               "print.anova"            
#&gt; [5] "print.aov"               "print.aovlist"</code></pre>
</div>
<div id="메소드-이름-규칙" class="section level4 unnumbered">
<h4>메소드 이름 규칙<a class="anchor" aria-label="anchor" href="#%EB%A9%94%EC%86%8C%EB%93%9C-%EC%9D%B4%EB%A6%84-%EA%B7%9C%EC%B9%99"><i class="fas fa-link"></i></a>
</h4>
<p>메소드 함수는 다음과 같은 이름으로 정의되어 있다.</p>
<div class="sourceCode" id="cb2208"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">generic_function_name.class_name</span></span></code></pre></div>
<p>따라서 data.frame 클래스의 print 메소드는 print.data.frame이 된다. 이 메소드를 data.frame 객체에 적용하나, 포괄 함수인 print를 data.frame 객체에 적용하나 동일한 결과를 얻는다. 사실 R 콘솔은 명령문을 평가한 후 자동으로 print() 함수를 실행하므로 클래스에 대한 print 메소드 구현은 매우 중요하다. 다음은 R 콘솔에서 print(f)나, print.data.frame(f)나, f는 동일한 결과를 주는 것을 보여준다.</p>
<div class="sourceCode" id="cb2209"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">f</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt;   X1.3 X6.8
#&gt; 1    1    6
#&gt; 2    2    7
#&gt; 3    3    8</code></pre>
<div class="sourceCode" id="cb2211"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/print.dataframe.html">print.data.frame</a></span><span class="op">(</span><span class="va">f</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt;   X1.3 X6.8
#&gt; 1    1    6
#&gt; 2    2    7
#&gt; 3    3    8</code></pre>
<div class="sourceCode" id="cb2213"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">f</span></span></code></pre></div>
<pre><code>#&gt;   X1.3 X6.8
#&gt; 1    1    6
#&gt; 2    2    7
#&gt; 3    3    8</code></pre>
<p>앞에서 확인할 수 있듯이 지금까지 객체가 R 콘솔에 출력될 때, 해당 객체의 클래스의 print 메소드들이 적절히 호출되어 해당 클래스에 적합한 형식으로 데이터를 보여 주었던 것이다.</p>
<p>그러면 integer, character, list 등을 위한 메소드들도 있을까? grep() 함수로 해당 이름의 메소드를 찾아보면 그렇지 않음을 알 수 있다. 그러면 이 클래스의 객체들은 어떻게 출력이 이루어지는 걸까?</p>
<div class="sourceCode" id="cb2215"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/grep.html">grep</a></span><span class="op">(</span><span class="st">"integer"</span>, <span class="fu"><a href="https://rdrr.io/r/utils/methods.html">methods</a></span><span class="op">(</span><span class="va">print</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt; integer(0)</code></pre>
<div class="sourceCode" id="cb2217"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/grep.html">grep</a></span><span class="op">(</span><span class="st">"character"</span>, <span class="fu"><a href="https://rdrr.io/r/utils/methods.html">methods</a></span><span class="op">(</span><span class="va">print</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt; integer(0)</code></pre>
<div class="sourceCode" id="cb2219"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/grep.html">grep</a></span><span class="op">(</span><span class="st">"list"</span>, <span class="fu"><a href="https://rdrr.io/r/utils/methods.html">methods</a></span><span class="op">(</span><span class="va">print</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt;  [1]   6  40  97 106 133 144 198 211 213 224 251</code></pre>
<div class="sourceCode" id="cb2221"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/methods.html">methods</a></span><span class="op">(</span><span class="va">print</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/grep.html">grep</a></span><span class="op">(</span><span class="st">"list"</span>, <span class="fu"><a href="https://rdrr.io/r/utils/methods.html">methods</a></span><span class="op">(</span><span class="va">print</span><span class="op">)</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<pre><code>#&gt;  [1] "print.aovlist"                    "print.check_package_datalist"    
#&gt;  [3] "print.Dlist"                      "print.dummy_coef_list"           
#&gt;  [5] "print.htmltools.selector.list"    "print.listof"                    
#&gt;  [7] "print.rlang:::list_of_conditions" "print.shiny.tag.list"            
#&gt;  [9] "print.simple.list"                "print.summary.aovlist"           
#&gt; [11] "print.xfun_strict_list"</code></pre>
<p>해당 클래스의 메소드가 없으면 UseMethod() 분배 함수는 default 메소드를 호출한다. default 메소드는 <code>generic_function_name.default</code> 형식으로 이름이 주어진다. print 포괄 함수의 경우 print.defualt 메소드이다.</p>
</div>
<div id="디폴트-메소드" class="section level4 unnumbered">
<h4>디폴트 메소드<a class="anchor" aria-label="anchor" href="#%EB%94%94%ED%8F%B4%ED%8A%B8-%EB%A9%94%EC%86%8C%EB%93%9C"><i class="fas fa-link"></i></a>
</h4>
<div class="sourceCode" id="cb2223"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">print.default</span></span></code></pre></div>
<pre><code>#&gt; function (x, digits = NULL, quote = TRUE, na.print = NULL, print.gap = NULL, 
#&gt;     right = FALSE, max = NULL, width = NULL, useSource = TRUE, 
#&gt;     ...) 
#&gt; {
#&gt;     args &lt;- pairlist(digits = digits, quote = quote, na.print = na.print, 
#&gt;         print.gap = print.gap, right = right, max = max, width = width, 
#&gt;         useSource = useSource, ...)
#&gt;     missings &lt;- c(missing(digits), missing(quote), missing(na.print), 
#&gt;         missing(print.gap), missing(right), missing(max), missing(width), 
#&gt;         missing(useSource))
#&gt;     .Internal(print.default(x, args, missings))
#&gt; }
#&gt; &lt;bytecode: 0x560c12dcd4d8&gt;
#&gt; &lt;environment: namespace:base&gt;</code></pre>
<p>보통 default 메소드는 데이터가 가지는 기본적 타입에 대해 적절한 포괄 함수 관련 처리를 수행하도록 구현되어 있다. print.default는 기본적인 데이터의 타입에 따라 적절한 출력을 보여준다.</p>
<p>앞서 우리는 student 클래스 객체를 만들었다. 그런나 print.student라는 메소드는 존재하지 않으므로 콘솔에서 해당 객체가 입력되었을 때, print.defualt가 student의 출력을 담당하였다. 따라서 student의 데이터 기본 타입인 list의 형식으로 데이터가 출력이 된것이다.</p>
<p>methods() 함수의 class 인수를 이용하면 해당 클래스를 위해 정의된 모든 메소드의 목록을 볼 수 있다. student 클래스를 위한 어떠한 메소드도 구현되지 않았음을 볼 수 있다.</p>
<div class="sourceCode" id="cb2225"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/methods.html">methods</a></span><span class="op">(</span>class<span class="op">=</span><span class="st">"lm"</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt;  [1] add1           alias          anova          case.names     coerce        
#&gt;  [6] confint        cooks.distance deviance       dfbeta         dfbetas       
#&gt; [11] drop1          dummy.coef     effects        extractAIC     family        
#&gt; [16] formula        hatvalues      influence      initialize     kappa         
#&gt; [21] labels         logLik         model.frame    model.matrix   nobs          
#&gt; [26] plot           predict        print          proj           qr            
#&gt; [31] residuals      rstandard      rstudent       show           simulate      
#&gt; [36] slotsFromS3    summary        variable.names vcov          
#&gt; see '?methods' for accessing help and source code</code></pre>
<div class="sourceCode" id="cb2227"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/methods.html">methods</a></span><span class="op">(</span>class<span class="op">=</span><span class="st">"student"</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt; no methods found</code></pre>
<div class="sourceCode" id="cb2229"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/print.default.html">print.default</a></span><span class="op">(</span><span class="va">st1</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt; $name
#&gt; [1] "Gildong"
#&gt; 
#&gt; $year
#&gt; [1] 2
#&gt; 
#&gt; $GPA
#&gt; [1] 3.2
#&gt; 
#&gt; attr(,"class")
#&gt; [1] "student"</code></pre>
</div>
<div id="메소드-정의하기" class="section level4 unnumbered">
<h4>메소드 정의하기<a class="anchor" aria-label="anchor" href="#%EB%A9%94%EC%86%8C%EB%93%9C-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0"><i class="fas fa-link"></i></a>
</h4>
<p>다음처럼 student 클래스를 위한 print 메소드를 만들어 보자. S3 클래스에서는 함수의 이름을 (포괄 함수명).(클래스명)으로 부여하면 된다. 그러면 UseMethod()가 해당 클래스를 위해 정의된 메소드를 호출해 준다.</p>
<div class="sourceCode" id="cb2231"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">print.student</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="va">x</span><span class="op">$</span><span class="va">name</span>, <span class="st">"\n"</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"year"</span>, <span class="va">x</span><span class="op">$</span><span class="va">year</span>, <span class="st">"\n"</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"GPA"</span>, <span class="va">x</span><span class="op">$</span><span class="va">GPA</span>, <span class="st">"\n"</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/methods.html">methods</a></span><span class="op">(</span>class<span class="op">=</span><span class="st">"student"</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt; [1] print
#&gt; see '?methods' for accessing help and source code</code></pre>
<div class="sourceCode" id="cb2233"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">st1</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt; Gildong 
#&gt; year 2 
#&gt; GPA 3.2</code></pre>
<p>위의 예에서 보듯이 student 클래스를 위한 print 메소드가 구현되었으므로 이제는 default 메소드가 아니라 student 클래스를 위한 print 메소드가 실행된다. 일반적으로 복잡한 클래스일수록 자신만의 print 메소드를 구현한다. 그래야 복잡한 내부 데이터를 모두 출력하지 않고 필요한 정보만 효율적으로 보여줄 수 있기 때문이다.</p>
<p>그리고 R을 처음 접한 사람들이 의아해 하는 사항이 있다. 그것은 대부분의 클래스에서 print 메소드보다는 summary 메소드가 더 자세한 정보를 출력한다는 것이다. 문자 그대로 해석한다면 print() 함수는 모든 내용을 출력해야 하고, summary() 함수는 좀 더 요약된 정보를 제공해야 할 것 같은데 말이다. lm 클래스도 print() 함수 보다는 summary() 함수가 훨씬 더 자세한 정보를 제공한다.</p>
<div class="sourceCode" id="cb2235"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt; 
#&gt; Call:
#&gt; lm(formula = cars)
#&gt; 
#&gt; Residuals:
#&gt;     Min      1Q  Median      3Q     Max 
#&gt; -7.5293 -2.1550  0.3615  2.4377  6.4179 
#&gt; 
#&gt; Coefficients:
#&gt;             Estimate Std. Error t value Pr(&gt;|t|)    
#&gt; (Intercept)  8.28391    0.87438   9.474 1.44e-12 ***
#&gt; dist         0.16557    0.01749   9.464 1.49e-12 ***
#&gt; ---
#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
#&gt; 
#&gt; Residual standard error: 3.156 on 48 degrees of freedom
#&gt; Multiple R-squared:  0.6511, Adjusted R-squared:  0.6438 
#&gt; F-statistic: 89.57 on 1 and 48 DF,  p-value: 1.49e-12</code></pre>
<p>이러한 일이 발생하는 이유는 R에서 print() 함수는 R 콘솔에 사용자의 명령이 입력될 때마다 실행되는 함수이기 때문이다. 따라서 print() 함수의 결과가 자칫 필요 이상으로 길고 복잡해지면 R 콘솔 작업이 어려워질 수 있기 때문에 대부분의 클래스에서는 휠씬 요약된 정보만을 print 메소드가 제공하도록 하고 있다. 하지만 기본 데이타 타입의 경우는 print.defualt 메소드가 데이터의 내용을 가감 없이 보여주기 때문에 그러한 현상은 나타나지 않는다.</p>
</div>
</div>
<div id="s3에서-상속성의-구현" class="section level3" number="11.2.3">
<h3>
<span class="header-section-number">11.2.3</span> S3에서 상속성의 구현<a class="anchor" aria-label="anchor" href="#s3%EC%97%90%EC%84%9C-%EC%83%81%EC%86%8D%EC%84%B1%EC%9D%98-%EA%B5%AC%ED%98%84"><i class="fas fa-link"></i></a>
</h3>
<p>상속성은 객체 지향 프로그래밍의 매력 중에 하나이다. 새로운 클래스를 만들 때 이전의 클래스를 상위 클래스로 하고 자신을 하위 클래스로 하면, 상위 클래스에 정의된 메소드들을 하위 클래스 객체가 이용할 수 있다.</p>
<div id="상위-클래스와-하위-클래스" class="section level4 unnumbered">
<h4>상위 클래스와 하위 클래스<a class="anchor" aria-label="anchor" href="#%EC%83%81%EC%9C%84-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%ED%95%98%EC%9C%84-%ED%81%B4%EB%9E%98%EC%8A%A4"><i class="fas fa-link"></i></a>
</h4>
<p>이 때 주의할 점은 하위 클래스 객체는 상위 클래스에 부분집합의 관계를 가져야 한다는 것이다. 예를 들어 MTB 자전거라는 하위 클래스를 자전거라는 상위 클래스를 상속받아 구현하였다면, MTB 자전거 객체는 역시 자전거 객체이기도 해야 한다는 것이다. 따라서 하위 클래스의 데이터 구조는 상위 클래스의 데이터 요소를 모두 포함하고 있어야 하고, 거기에 덧붙여 자신만의 데이터와 기능을 더 포함하는 구조이어야 한다.</p>
</div>
<div id="상속성을-구현하는-방법" class="section level4 unnumbered">
<h4>상속성을 구현하는 방법<a class="anchor" aria-label="anchor" href="#%EC%83%81%EC%86%8D%EC%84%B1%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95"><i class="fas fa-link"></i></a>
</h4>
<p>S3 클래스에서 상속성의 구현은 객체를 생성할 때 단지 class 속성에 하위 클래스 이름 다음에 상위 클래스 이름을 모두 나열하기만 하면 된다. 그러면 UseMethod() 분배 함수는 class 속성에 부여된 클래스 순으로 메소드를 찾아 실행한다. 따라서 하위 클래스를 위한 메소드가 없으면 다음에 정의되어 있는 상위 클래스의 메소드를 실행해 준다. 하위 클래스가 상속받은 상위 클래스가 또 다른 클래스를 상속 받았다면, class 속성에는 하위 클래스, 상위 클래스, 상위-상위 클래스 순으로 차례대로 기술해 주면 된다.</p>
<p>S3 클래스에서 상속성이 어떻게 수행되는지 다음 예로 살펴보자. 현재 student 클래스를 이용하여 대학생과 대학원생 정보를 모두 처리하고 있다고 하자. 그런데 대학원생의 경우에는 student에 있는 데이터뿐 아니라 지도교수(advisor)에 대한 정보가 추가되어 관리되는 것이 편리하다고 판단되어, 지도교수 정보를 포함하는 gradstudent 클래스를 정의하고자 한다.
다음 예에서 st2 객체를 생성할 때 리스트에 advisor 요소가 추가되었다. 그리고 class 속성에 먼저 하위 클래스 이름인 gradstudent, 그리고 상위 클래스 이름인 student가 기술되었다. 물론 아직은 gradstudent 클래스에 대한 어떠한 메소드도 존재하지 않는다.</p>
<div class="sourceCode" id="cb2237"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">st2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>name<span class="op">=</span><span class="st">"Gilsan"</span>, year<span class="op">=</span><span class="fl">1</span>, GPA<span class="op">=</span><span class="fl">3.8</span>, advisor<span class="op">=</span><span class="st">"Sejong"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/class.html">class</a></span><span class="op">(</span><span class="va">st2</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"gradstudent"</span>, <span class="st">"student"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/methods.html">methods</a></span><span class="op">(</span>class<span class="op">=</span><span class="st">"gradstudent"</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt; no methods found</code></pre>
<p>그러면 gradstudent 클래스인 st2를 출력해 보자. 그러면 UseMethod() 함수는 먼저 gradstudent 클래스를 위한 print 메소드를 찾는다. 해당 메소드가 없으므로 두번째로 기술되어 있는 student 클래스의 print 메소드를 찾는다. 해당 메소드가 있으므로 이 메소드로 출력을 수행한다. 이마저도 없으면 default 메소드가 수행될 것이다. 물론 student 클래스를 위한 print 메소드는 이미 구현되어 있기 때문에, 대학원생 정보인 st2도 student 클래스의 출력 형식에 맞추어 출력이 이루어진다. 따라서 gradstudent 객체는 student 클래스의 메소드를 상속 받았다고 볼 수 있다.</p>
<div class="sourceCode" id="cb2239"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">st2</span></span></code></pre></div>
<pre><code>#&gt; Gilsan 
#&gt; year 1 
#&gt; GPA 3.8</code></pre>
</div>
<div id="메소드-overiding" class="section level4 unnumbered">
<h4>메소드 overiding<a class="anchor" aria-label="anchor" href="#%EB%A9%94%EC%86%8C%EB%93%9C-overiding"><i class="fas fa-link"></i></a>
</h4>
<p>만약 gradstudent 객체의 출력에 지도 교수 정보도 같이 출력되기를 원한다면, 다음처럼 gradstudent 클래스의 print 메소드를 구현하면 된다. 이 경우 gradstudent 클래스만의 메소드가 상속받은 student 클래스의 메소드를 overiding 하였다고 표현한다.</p>
<div class="sourceCode" id="cb2241"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">print.gradstudent</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">print.student</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"Advisor"</span>, <span class="va">x</span><span class="op">$</span><span class="va">advisor</span>, <span class="st">"\n"</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="va">st2</span></span></code></pre></div>
<pre><code>#&gt; Gilsan 
#&gt; year 1 
#&gt; GPA 3.8 
#&gt; Advisor Sejong</code></pre>
</div>
</div>
</div>
<div id="s4-클래스" class="section level2" number="11.3">
<h2>
<span class="header-section-number">11.3</span> S4 클래스<a class="anchor" aria-label="anchor" href="#s4-%ED%81%B4%EB%9E%98%EC%8A%A4"><i class="fas fa-link"></i></a>
</h2>
<div id="s3-클래스의-안전성-문제" class="section level4 unnumbered">
<h4>S3 클래스의 안전성 문제<a class="anchor" aria-label="anchor" href="#s3-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EC%95%88%EC%A0%84%EC%84%B1-%EB%AC%B8%EC%A0%9C"><i class="fas fa-link"></i></a>
</h4>
<p>S3 클래스는 Java 같은 OOP 언어와 비교해 보면 다음과 같은 안전성(safety) 문제를 가지고 있다.</p>
<ul>
<li>클래스 정의를 사전에 하지 않으므로 객체 생성시 필요한 요소가 누락되거나 이름이 잘못 부여될 수 있다.</li>
<li>클래스의 메소드도 이름으로 파악하므로, 메소드 구현시 함수 이름이 잘못 부여되어도 이를 바로 확인할 수 없다.</li>
<li>데이터가 근본적으로 리스트 객체이므로 클래스 내부 데이터에 대한 잘못된 접근을 막을 수 없다.</li>
</ul>
<p>이러한 문제를 해결하기 위해 S4 클래스가 개발되었다. 표 <a href="ch-R-OOP.html#tab:S3vsS4">11.1</a><a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;Matloff, Norman. The Art of R Programming: A Tour of Statistical Software Design. No Starch Press, 2011.&lt;/p&gt;"><sup>14</sup></a>은 두 클래스의 차이를 보여준다. 이 절에서는 S4 클래스의 몇 가지 특징에 대해서만 짚어보기로 한다.</p>
<pre><code>#&gt; Rows: 5 Columns: 3
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: "&amp;"
#&gt; chr (3): 작업 ,  S3 ,  S4 
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<div class="inline-table"><table class="table table-sm">
<caption>
<span id="tab:S3vsS4">Table 11.1: </span>S3 클래스 vs. S4 클래스 (Source: The Art of R Programming)</caption>
<colgroup>
<col width="22%">
<col width="41%">
<col width="36%">
</colgroup>
<thead><tr class="header">
<th align="left">작업</th>
<th align="left">S3</th>
<th align="left">S4</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">클래스 정의</td>
<td align="left">명시적 정의 없음</td>
<td align="left">setClass()로 클래스 정의</td>
</tr>
<tr class="even">
<td align="left">객체 생성</td>
<td align="left">리스트 생성 후 class 속성 부여</td>
<td align="left">new()로 명시적 객체 생성</td>
</tr>
<tr class="odd">
<td align="left">클래스 요소 접근</td>
<td align="left"><code>$</code></td>
<td align="left"><code>@</code></td>
</tr>
<tr class="even">
<td align="left">f 메소드 구현</td>
<td align="left">f.classname() 함수 정의</td>
<td align="left">setMethod()로 명시적 구현</td>
</tr>
<tr class="odd">
<td align="left">포괄 함수 구현</td>
<td align="left">포괄 함수에 UseMethod() 이용</td>
<td align="left">setGeneric()로 명시적 구현</td>
</tr>
</tbody>
</table></div>
</div>
<div id="클래스-정의-setclass" class="section level4 unnumbered">
<h4>클래스 정의 setClass()<a class="anchor" aria-label="anchor" href="#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%95%EC%9D%98-setclass"><i class="fas fa-link"></i></a>
</h4>
<p>다음은 setClass() 함수로 newstudent라는 새로운 클래스를 생성한 예이다. 데이터의 요소는 앞서 S3 클래스로 생성한 student 클래스와 동일하다. setClass()의 첫번째 인수로는 클래스 이름이, representation 인수는 클래스의 데이터 요소의 이름과 각 데이터 요소의 클래스가 명시된다. 이를 통해 해당 클래스 객체가 생성될 때 객체 요소의 데이터의 이름과 타입이 같아지도록 강제할 수 있다.</p>
<div class="sourceCode" id="cb2244"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/methods/setClass.html">setClass</a></span><span class="op">(</span><span class="st">"newstudent"</span>, </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/methods/representation.html">representation</a></span><span class="op">(</span>name<span class="op">=</span><span class="st">"character"</span>, year<span class="op">=</span><span class="st">"numeric"</span>, GPA<span class="op">=</span><span class="st">"numeric"</span> <span class="op">)</span><span class="op">)</span></span></code></pre></div>
</div>
<div id="객체-생성-new" class="section level4 unnumbered">
<h4>객체 생성 new()<a class="anchor" aria-label="anchor" href="#%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1-new"><i class="fas fa-link"></i></a>
</h4>
<p>클래스로부터 새로운 객체를 생성할 때는 new() 함수를 이용한다. new() 함수는 첫번째 인수로 클래스 이름을, 나머지 인수로 객체의 각 데이터 요소를 정의한다.</p>
<div class="sourceCode" id="cb2245"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">st3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/methods/new.html">new</a></span><span class="op">(</span><span class="st">"newstudent"</span>, name<span class="op">=</span><span class="st">"Gildong"</span>, year<span class="op">=</span><span class="fl">2</span>, GPA<span class="op">=</span><span class="fl">3.2</span><span class="op">)</span></span>
<span><span class="va">st3</span></span></code></pre></div>
<pre><code>#&gt; An object of class "newstudent"
#&gt; Slot "name":
#&gt; [1] "Gildong"
#&gt; 
#&gt; Slot "year":
#&gt; [1] 2
#&gt; 
#&gt; Slot "GPA":
#&gt; [1] 3.2</code></pre>
<p>setClass()에 의해 클래스의 형태가 이미 정의되어 있어서 new()로 객체 생성 시 틀린 이름이나 틀린 타입의 데이터가 입력되면 오류가 발생하므로 항상 정확한 이름과 형식으로 객체가 생성되도록 강제할 수 있다.</p>
<div class="sourceCode" id="cb2247"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">st4</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/methods/new.html">new</a></span><span class="op">(</span><span class="st">"newstudent"</span>, sname<span class="op">=</span><span class="st">"Gildong"</span>, year<span class="op">=</span><span class="fl">2</span>, GPA<span class="op">=</span><span class="fl">3.2</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt; Error in initialize(value, ...): invalid name for slot of class "newstudent": sname</code></pre>
<div class="sourceCode" id="cb2249"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">st4</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/methods/new.html">new</a></span><span class="op">(</span><span class="st">"newstudent"</span>, name<span class="op">=</span><span class="st">"Gildong"</span>, year<span class="op">=</span><span class="fl">2</span>, GPA<span class="op">=</span><span class="st">"3.2"</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt; Error in validObject(.Object): 잘못된 클래스 "newstudent" 객체입니다: invalid object for slot "GPA" in class "newstudent": got class "character", should be or extend class "numeric"</code></pre>
</div>
<div id="객체-요소에-접근-slot" class="section level4 unnumbered">
<h4>객체 요소에 접근 slot()<a class="anchor" aria-label="anchor" href="#%EA%B0%9D%EC%B2%B4-%EC%9A%94%EC%86%8C%EC%97%90-%EC%A0%91%EA%B7%BC-slot"><i class="fas fa-link"></i></a>
</h4>
<p>S4 클래스에서 객체의 각 데이터 요소(멤버 변수라고 한다)를 슬롯(slot)이라 하며, <code>@</code> 또는 slot()으로 접근한다. S4 클래스는 정의되지 않은 멤버 변수의 생성을 허용하지 않는다. 반면 S3는 단순한 리스트 객체이므로 아무 제약 없이 새로운 요소를 추가하거나 기존 요소를 삭제할 수 있다.</p>
<div class="sourceCode" id="cb2251"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">st3</span><span class="op">@</span><span class="va">name</span></span></code></pre></div>
<pre><code>#&gt; [1] "Gildong"</code></pre>
<div class="sourceCode" id="cb2253"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/methods/slot.html">slot</a></span><span class="op">(</span><span class="va">st3</span>, <span class="st">"GPA"</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt; [1] 3.2</code></pre>
<div class="sourceCode" id="cb2255"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">st3</span><span class="op">@</span><span class="va">year</span> <span class="op">&lt;-</span> <span class="fl">4</span></span>
<span><span class="va">st3</span><span class="op">@</span><span class="va">GPa</span> <span class="op">&lt;-</span> <span class="fl">4.0</span></span></code></pre></div>
<pre><code>#&gt; Error in (function (cl, name, valueClass) : 'GPa'는 클래스 "newstudent"내에 있는 슬롯이 아닙니다</code></pre>
<div class="sourceCode" id="cb2257"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">st3</span></span></code></pre></div>
<pre><code>#&gt; An object of class "newstudent"
#&gt; Slot "name":
#&gt; [1] "Gildong"
#&gt; 
#&gt; Slot "year":
#&gt; [1] 4
#&gt; 
#&gt; Slot "GPA":
#&gt; [1] 3.2</code></pre>
</div>
<div id="s4-클래스-메소드-생성-setmethod" class="section level4 unnumbered">
<h4>S4 클래스 메소드 생성 setMethod()<a class="anchor" aria-label="anchor" href="#s4-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%83%9D%EC%84%B1-setmethod"><i class="fas fa-link"></i></a>
</h4>
<p>S4 클래스에서는 메소드는 setMethod() 함수에 의해 정의된다. 앞에서 생성한 newstudent 객체에 summary() 함수를 적용하면 해당 클래스의 summary 메소드가 구현되지 않았으므로 디폴트로 제공되는 메소드에 의해 객체에 대한 매우 간략한 요약 정보만 출력한다.</p>
<div class="sourceCode" id="cb2259"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">st3</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt;     Length      Class       Mode 
#&gt;          1 newstudent         S4</code></pre>
<p>newstudent 클래스에 summary 메소드를 다음과 같이 추가해 보자. setMethod() 함수는 첫번째 인수로 메소드 이름, 두번째 인수로 클래스 이름, 세번째 인수로 메소드 호출시 실행될 함수 객체를 받는다.</p>
<div class="sourceCode" id="cb2261"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/methods/setMethod.html">setMethod</a></span><span class="op">(</span><span class="st">"summary"</span>, <span class="st">"newstudent"</span>,</span>
<span>    <span class="kw">function</span><span class="op">(</span><span class="va">object</span><span class="op">)</span><span class="op">{</span></span>
<span>      <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="va">object</span><span class="op">@</span><span class="va">name</span>, <span class="st">" is a "</span>, </span>
<span>          <span class="va">object</span><span class="op">@</span><span class="va">year</span>, <span class="st">"th year student with GPA "</span>, </span>
<span>          <span class="va">object</span><span class="op">@</span><span class="va">GPA</span>, <span class="st">"\n"</span>, sep<span class="op">=</span><span class="st">""</span><span class="op">)</span></span>
<span>    <span class="op">}</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">st3</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt; Gildong is a 4th year student with GPA 3.2</code></pre>
<p>만약 명시적으로 생성한 메소드를 제거하려면 removeMethod() 함수를 이용한다.</p>
<div class="sourceCode" id="cb2263"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/methods/removeMethod.html">removeMethod</a></span><span class="op">(</span><span class="st">"summary"</span>, <span class="st">"newstudent"</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt; [1] TRUE</code></pre>
<div class="sourceCode" id="cb2265"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">st3</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt;     Length      Class       Mode 
#&gt;          1 newstudent         S4</code></pre>

</div>
</div>
</div>



<div class="chapter-nav">
<div class="prev"><a href="ch-R-Programming-Structure.html"><span class="header-section-number">10</span> R 프로그래밍 구조</a></div>
<div class="next"><a href="ch-RandPython.html"><span class="header-section-number">A</span> R과 Python 연동하기</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#ch-R-OOP"><span class="header-section-number">11</span> R 객체 지향 프로그래밍</a></li>
<li><a class="nav-link" href="#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D"><span class="header-section-number">11.1</span> 객체 지향 프로그래밍</a></li>
<li>
<a class="nav-link" href="#s3-%ED%81%B4%EB%9E%98%EC%8A%A4"><span class="header-section-number">11.2</span> S3 클래스</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#s3-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B0%9D%EC%B2%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0"><span class="header-section-number">11.2.1</span> S3 클래스 객체 만들기</a></li>
<li><a class="nav-link" href="#%ED%8F%AC%EA%B4%84-%ED%95%A8%EC%88%98generic-functions"><span class="header-section-number">11.2.2</span> 포괄 함수(generic functions)</a></li>
<li><a class="nav-link" href="#s3%EC%97%90%EC%84%9C-%EC%83%81%EC%86%8D%EC%84%B1%EC%9D%98-%EA%B5%AC%ED%98%84"><span class="header-section-number">11.2.3</span> S3에서 상속성의 구현</a></li>
</ul>
</li>
<li><a class="nav-link" href="#s4-%ED%81%B4%EB%9E%98%EC%8A%A4"><span class="header-section-number">11.3</span> S4 클래스</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>
</div>

  

  

</div>
 <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>R 프로그래밍 (개정판)</strong>" was written by Kilhwan Kim. It was last built on 2023-09-06.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
