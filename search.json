[{"path":"index.html","id":"preface","chapter":"Preface","heading":"Preface","text":"","code":""},{"path":"index.html","id":"판-서문","chapter":"Preface","heading":"1판 서문","text":"이 책을 쓰게 된 동기를 설명하기에 앞서 개인적인 경력을 밝히는 것이 좋겠다. 저자는 경영과학과 산업공학을 전공하였기 때문에 대학과 대학원 시절 통계학에 대한 다양한 강의를 수강하였고, Minitab, SPSS, SAS 등의 통계 패키지도 접할 기회를 가졌다. 그러나 정작 졸업 후 경력의 대부분을 업계에서 보내며 통계 분석과는 동떨어진 정보시스템 개발과 컨설팅 업무를 주로 수행하였다. 그러는 과정에서 저자는 C, Java, JavaScript 등의 다양한 프로그래밍 언어를 다루게 되었고 시스템 개발에 대한 폭넓은 이해를 하게 되었다.세월이 흘러 저자는 박사과정에 진학하여 대학교에 교편을 잡게 되었고, 세상은 바야흐로 빅데이터의 시대로 접어들어 R이 데이터 분석의 강력한 수단으로 각광받게 되었다. 물론 R은 이전부터 통계 전문가들 사이에선 잘 알려져 있었지만, 지금처럼 많은 분야에서 주목받지는 못했다. 이러한 흐름에 맞추어 저자는 여러 해 동안 R을 이용한 통계 분석 및 데이터 마이닝을 공부해 왔고 관련된 강의와 연구 프로젝트도 수행하게 되었다.이 책은 저자가 R을 공부할 때 느낀 불만족스러운 부분에서 시작되었다. 현재 국내에는 R을 이용하고자 하는 두 부류의 집단이 있는 것 같다. 한 부류는 통계학과 유사 학문을 전공한 사람들로 R에 대해서는 프로그래밍 언어적 측면보다는 데이터 분석 패키지로서 관심이 많다. 이 부류의 사람들은 즉각적인 데이터 분석을 위해 임의적인 방식으로 R의 명령어를 사용하는 것을 선호한다. 다른 부류는 전문가로서 빅데이터 분석에 대한 시대적 요구가 커짐에 따라 R에 관심을 갖게 된 사람들이다. 이들은 통계나 수학적 배경 지식은 약하나 프로그래밍 언어에 대한 이해가 높은 사람들로서, R을 체계적인 방식으로 사용하여 시스템을 구축하는데 관심이 많다. 그런데 국내의 R 관련 서적들은 대부분 R을 통계 분석과 데이터 마이닝 알고리즘을 수행할 수 있는 단편적인 명령어 중심으로 소개하고 있다. R의 프로그래밍 언어로서의 측면을 체계적인 방식으로 다루는 책은 오히려 드문 편이다. 저자가 판단하기에 국내 서적 중 R의 프로그래밍 언어적 측면을 본격적으로 다룬 유일한 책이 Norman Matloff의 Art R Programming의 번역본이 아닐까 한다.다행히 저자는 부족하나마 통계학과 데이터 마이닝에 대한 지식과 경험, 그리고 프로그래밍 언어에 대한 지식과 시스템 개발 경험을 두루 갖출 수 있었다. 물론 두 분야의 전문가가 보면 부족한 수준일 것이다. 그러나 이러한 양 분야의 지식과 경험이 저자에게 R을 매우 종합적으로 조망하게 해 주었다. 그 결과 R을 단순하게 통계 분석의 툴로서만 이용하는 사람들에게 R의 프로그래밍 언어적 특성을 체계적으로 알려주는 게 필요하다고 판단하게 되었다. 왜냐하면, 빅데이터 분석을 위해서는 선진 데이터 분석 알고리즘을 깊이 이해하고 적용하는 것만큼이나, 대규모 데이터를 시스템적으로 처리하는 프로그래밍 기술이 중요해지기 때문이다. 따라서 앞으로 데이터 분석가가 시스템 개발에 직접 참여하게 될 일들이 점차 많아질 것이고, 자신이 가장 익숙한 언어로 프로그램을 개발할 수 있는 능력은 중요한 핵심역량이 될 것이다.이 책은 통계 및 데이터 마이닝을 공부하는 학생이나 전문가가 R의 프로그래밍 언어적 특성을 이해하는 것을 돕기 위해 집필되었다. 그러나 역으로 프로그래밍 언어에 익숙한 독자가 R의 특성을 파악하는 데에도 도움을 주리라 생각된다. 다른 프로그램 언어에 이미 익숙한 저자로서는 R을 공부할 때 답답했던 측면 중 하나가 R의 프로그램 언어적 특성을 명확하게 설명해 주는 자료가 흔치 않다는 점이었다. R이 기존의 프로그래밍 언어와 다르게 작동되는 부분을 만날 때마다 어리둥절함에 빠질 때가 많았기 때문이다.\n이 책은 저자가 몸담고 있는 대학의 강의를 위해 준비했던 자료를 기반으로 원고가 작성되었다. 부족한 지식이나마 책으로 펼칠 수 있도록 격려해 주신 학과 교수님들과, 부족한 강의를 들으며 다양한 피드백을 해준 상명대학교 경영공학과 학생들에게 감사의 말씀을 전한다. 아울러 이 책을 준비할 때 물심양면 지원해준 가족에게도 감사의 말을 전한다.\n2017년 2월상명대학교 천안캠퍼스에서","code":""},{"path":"index.html","id":"판-서문-1","chapter":"Preface","heading":"2판 서문","text":"1판이 출간된지 3년 반이 지났습니다. 1판을 작성하였을 때는 R의 버전이 3이었지만 현재 버전 4가 출시되어 사용되고 있습니다. R의 기본 기능은 크게 바뀌지 않았지만 데이터 프레임의 처리 방식 등에 근본적인 변화가 있었습니다. 아울러 Hadley Wickham의 tidyverse 패키지가 R 작업의 표준으로 자리잡아 가고 있습니다. 2판은 이러한 변화를 반영하였습니다. 기존의 데이터 변환과 관련된 내용을 모두 R의 기본 기능을 사용하는 방식에서 tidyverse 패키지를 사용하는 방식으로 바꾸었습니다. 그래픽과 시각화와 관련된 내용도 R의 기본 graphics 패키지 대신 ggplot2 패키지를 사용하도록 변경하였습니다.현재까지 2판은 완성되지 않았습니다. 강의와 더불어 2판은 조금씩 수정돼 나갈 것입니다. 온라인 상에서 수정된 내용을 계속 확인하실 수 있습니다. 그러므로 2판의 서문도 계속 바뀌어져 나갈 것입니다.\n2020년 8월상명대학교 천안캠퍼스에서\n2판 초안을 마무리하며","code":""},{"path":"index.html","id":"판의-주요-개정-2022년-7월-이후부터","chapter":"Preface","heading":"2판의 주요 개정 (2022년 7월 이후부터)","text":"2022/8/3:\nR 4.2 버전의 변경 사항 반영: 조건문에서 여러 논리값을 가지는 경우에 대한 내용 변경\nAppendix에 R과 Python 연동 방안 추가\nR 4.2 버전의 변경 사항 반영: 조건문에서 여러 논리값을 가지는 경우에 대한 내용 변경Appendix에 R과 Python 연동 방안 추가2022/8/31\n윈도우즈에서 winget을 이용한 R 및 RStudio 설치 방법 추가\n윈도우즈에서 winget을 이용한 R 및 RStudio 설치 방법 추가2022/10/12\nreadxl과 writexl을 이용한 Excel 데이터 읽고 쓰는 방법 추가\n6.6 절 예제로 사용된 파일을 본문에 첨부\nreadxl과 writexl을 이용한 Excel 데이터 읽고 쓰는 방법 추가6.6 절 예제로 사용된 파일을 본문에 첨부2023/3/13\ndplyr 패키지의 slice 함수에 대한 설명 추가\ndplyr 패키지의 slice 함수에 대한 설명 추가","code":""},{"path":"index.html","id":"일러두기","chapter":"Preface","heading":"일러두기","text":"절의 제목 뒤에 * 표시가 있는 절은 처음 R을 접하는 초심자는 건너뛰어도 되는 내용들이다. 이러한 절들은 R의 프로그래밍 언어로서의 특징과 세부사항을 더 잘 이해하고 싶은 독자들을 위한 내용이다.절의 제목 뒤에 * 표시가 있는 절은 처음 R을 접하는 초심자는 건너뛰어도 되는 내용들이다. 이러한 절들은 R의 프로그래밍 언어로서의 특징과 세부사항을 더 잘 이해하고 싶은 독자들을 위한 내용이다.이 책은 R의 프로그래밍 언어적 특성을 주로 다루고 있다. R을 이용한 통계분석 방법을 배우기를 원하는 독자는 졸저 R을 이용한 통계 분석이나 다른 책 등을 참고하기 바란다.이 책은 R의 프로그래밍 언어적 특성을 주로 다루고 있다. R을 이용한 통계분석 방법을 배우기를 원하는 독자는 졸저 R을 이용한 통계 분석이나 다른 책 등을 참고하기 바란다.","code":""},{"path":"ch-intro.html","id":"ch-intro","chapter":"1 R 설치 및 시작","heading":"1 R 설치 및 시작","text":"","code":""},{"path":"ch-intro.html","id":"sec-Rintro","chapter":"1 R 설치 및 시작","heading":"1.1 R 소개","text":"R은 통계 계산과 그래픽을 위한 프로그래밍 언어이자 소프트웨어 환경이다.\nR은 1960년대와 1970년대 Bell 연구소에서 개발된 S라는 데이터 처리 언어에 기반을 두고 있다.\n1990년대 중반 뉴질랜드 오클랜드 대학의 로스 이하카와 로버트 젠틀맨에 의해 시작되어 현재는 R의 핵심 기능은 R 코어 팀이, 다양한 추가 기능은 자발적 기여자들에 의해 개발되고 있다.\nR은 GPL 하에 배포되는 공개 소프트웨어로 누구나 자유롭게 이용할 수 있다.R은 빅데이터 분석에 널리 사용되고 있으며, 패키지 개발이 용이하여 통계 분석가들 사이에서 통계 소프트웨어 개발에 많이 쓰이고 있다.R은 데이터 조작, 계산, 그래픽 표현을 위한 소프트웨어이다. R의 주요 기능은 다음과 같다.효율적이고 편련한 데이터 조작 및 처리 기능데이터를 다양한 그래프로 표현해주는 데이터 시각화 기능통계 분석 및 데이터 마이닝 알고리즘 수행 기능분석 결과를 문서 및 발표 자료로 생성하는 기능간단하며 효과적인 프로그래밍 언어로서의 기능이 장에서는 R을 설치하고 실행하는 방법과 R의 개괄적인 기능을 소개한다.","code":""},{"path":"ch-intro.html","id":"sec-installation","chapter":"1 R 설치 및 시작","heading":"1.2 R 설치하기","text":"R 설치는 윈도우즈가 설치된 컴퓨터를 기준으로 설명한다.","code":""},{"path":"ch-intro.html","id":"r을-윈도우즈에-설치할-때-주의-사항","chapter":"1 R 설치 및 시작","heading":"1.2.1 R을 윈도우즈에 설치할 때 주의 사항","text":"한글 윈도우에서 R과 RStudio를 설치하여 사용할 때 이유를 알 수 없는 여러 문제가 발생할 수 있다. 이러한 문제의 대부분은 파일과 디렉토리(폴더)의 경로명에 한글이 들어간 경우에 발생한다. 특히 윈도우 사용자 이름이 한글인 경우 이러한 문제가 빈번히 발생하는데, R이나 RStudio가 사용자 폴더의 하위 폴더에 필요한 파일과 디렉토리를 만들기 때문이다.이러한 문제를 미연에 방지하려면 설치 전에 윈도우 사용자 이름이 한글인지 확인하고, 한글이면 영문 사용자 이름으로 관리자 계정을 하나 더 만들어 그 계정으로 R과 RStudio의 설치를 진행하는 것이 좋다.물론 한글 사용자 이름을 사용하더라도 환경변수의 임시 디렉토리 설정을 변경하여 발생할 수 있는 대부분의 문제를 해결할 수 있지만, 새로운 패키지나 함수를 사용할 때마다 이러한 문제가 잠복되어 있다가 다른 방식으로 다시 발생할 수 있다. R에 대한 이해가 높지 않은 초심자의 경우 이러한 문제가 발생하면 문제의 원인을 파악하기 어렵다. 그렇기 때문에 영문 이름으로 된 관리자 권한의 사용자로서 R과 RStudio를 설치하기를 강력히 권장한다.","code":""},{"path":"ch-intro.html","id":"winget","chapter":"1 R 설치 및 시작","heading":"1.2.2 winget 명령어로 설치하기","text":"winget 명령어를 사용하면 R의 설치, 제거 등을 하나의 명령어로 수행할 수 있어 편리하다.\nwinget 명령줄 도구는 윈도우즈의 앱 설치 관리자로 윈도우즈 11이나 최신 버전의 윈도우즈 10에는 이미 설치되어 있다.\n만약 winget 명령줄 도구가 설치되어 있지 않으면 Microsoft Store에서 앱 설치 관리자를 설치하거나 업데이트하면 winget 명령을 사용할 수 있다.\nwinget에 대한 자세한 설명은 Microsoft의 공식 문서나 인터넷 상의 자료를 참조하기 바란다.winget이 설치되어 있으면 cmd 창이나 윈도우즈 Power Shell 창에서 다음 명령을 수행한다. 참고로 cmd 창은 윈도우즈 검색 창에 cmd라고 검색하면 cmd 창을 실행시킬 수 있다.)이 명령을 실행하면 R 배포판을 내려받고 설치 관리자를 자동 실행할 것이다.\n관련된 물음에 ’Yes’라고 대답하면 설치가 실행될 것이다.\n처음 winget을 실행하는 경우에는 winget에 대한 안내 메시지가 나올 수 있다.R 이전 버전이 설치되어 있다면 다음 명령을 먼저 실행하여 이전 버전을 제거한다.R 설치 관리자는 자동으로 이전 버전을 제거하지 않기 때문에 최신 버전을 설치하기 전에 이전 버전을 제거하는 것이 좋다. 경우에 따라서는 winget이 이전에 설치된 R을 제거하지 못할 때도 있다. 이 경우에는 윈도우즈 설정에서 직접 R 이전 버전을 제거한다.만약 winget 명령어를 사용할 수 없으면, 아래 내용처럼 R 배포판을 직접 내려받아 설치한다.","code":"winget install --id RProject.Rwinget uninstall --id RProject.R"},{"path":"ch-intro.html","id":"r-배포판-내려받기","chapter":"1 R 설치 및 시작","heading":"1.2.3 R 배포판 내려받기","text":"앞 절에서 winget을 사용하여 R을 설치하였으면 이 절의 내용은 수행하지 않고 1.3 절로 가서 RStudio를 설치하도록 한다. 이 절은 winget으로 R을 설치하지 못하였거나, 윈도우즈 이외의 운영체제를 사용하는 독자를 위해 R을 직접 내려받아 설치하는 방법을 설명한다.R을 설치하기 위해서는 R 배포판을 먼저 구해야 한다. R은 공개 소프트웨어이므로 무료로 R 공식 웹 사이트에서 내려받을 수 있다.R 공식 사이트의 첫 화면의 내용 중 download R 을 클릭하면 R 배포판을 내려받기할 CRAN 미러를 선택하는 화면으로 이동하게 된다.지리적으로 가까운 CRAN 미러 서버를 선택하거나, 맨 위의 “0-Cloud”를 선택한다. 그러면 설치할 R 배포판을 선택하는 화면으로 이동한다.R 배포판을 선택하는 화면에서 Download R Windows를 클릭하여 윈도우용 배포판을 선택한다.1윈도우용 배포판 중 어떤 항목을 내려받을 것인지를 물어보는데 처음 설치하는 것이므로 Base를 선택한다.그러면 32/64bits 겸용 윈도우용 R 바이너리 파일을 내려받을 수 있는 화면으로 이동한다. Download R x.x.x windows를 클릭하여 배포판을 내려받는다. 여기서 x.x.x는 내려받기를 하는 R 배포판의 버전을 의미한다.","code":""},{"path":"ch-intro.html","id":"r-설치하기","chapter":"1 R 설치 및 시작","heading":"1.2.4 R 설치하기","text":"내려받은 R 설치 파일을 실행시켜 R을 설치한다.설치 과정 중 사용할 언어 선택 화면이 나타나면 한국어를 선택한 후 [확인]을 클릭한다.설치 과정 중 사용할 언어 선택 화면이 나타나면 한국어를 선택한 후 [확인]을 클릭한다.GNU 라이선스 정보 화면이 나타나면 [다음]을 클릭한다.GNU 라이선스 정보 화면이 나타나면 [다음]을 클릭한다.설치할 위치를 선택하는 화면이 나타나면 [찾아보기]를 클릭하여 적절한 설치 폴더를 직접 지정하거나 기본 값으로 설치한다. [다음]을 클릭한다.설치할 위치를 선택하는 화면이 나타나면 [찾아보기]를 클릭하여 적절한 설치 폴더를 직접 지정하거나 기본 값으로 설치한다. [다음]을 클릭한다.구성 요소 설치를 묻는 화면이 나타나면 위쪽에 있는 선택 리스트를 이용하여 32-bit 사용자 편의를 위한 쉬운 설치 또는 64-bit 사용자 편의를 위한 쉬운 설치 중 자신의 윈도우즈 시스템이 32-bit 윈도우인지 64-bit 윈도우인지에 따라 선택한다. 그리고 [다음]을 클릭한다.(자신의 윈도우 종류를 모르겠으면 사용자 편의를 위한 쉬운 설치를 선택하여 전체를 다 설치하여도 된다. Windows 10을 기준으로 몇 bits 운영체제인지를 확인하려면, 시작 메뉴에서 [제어판]을 선택한 후 [시스템]-[정보]를 선택하면 시스템 종류에 해당 정보가 나온다.)구성 요소 설치를 묻는 화면이 나타나면 위쪽에 있는 선택 리스트를 이용하여 32-bit 사용자 편의를 위한 쉬운 설치 또는 64-bit 사용자 편의를 위한 쉬운 설치 중 자신의 윈도우즈 시스템이 32-bit 윈도우인지 64-bit 윈도우인지에 따라 선택한다. 그리고 [다음]을 클릭한다.(자신의 윈도우 종류를 모르겠으면 사용자 편의를 위한 쉬운 설치를 선택하여 전체를 다 설치하여도 된다. Windows 10을 기준으로 몇 bits 운영체제인지를 확인하려면, 시작 메뉴에서 [제어판]을 선택한 후 [시스템]-[정보]를 선택하면 시스템 종류에 해당 정보가 나온다.)R을 시작할 때의 사용하는 스타트업 옵션을 조정할 것인지를 묻는 화면이 나온다. 지금은 그냥 (기본값 사용)을 선택하도록 한다. 그리고 [다음]을 클릭한다.R을 시작할 때의 사용하는 스타트업 옵션을 조정할 것인지를 묻는 화면이 나온다. 지금은 그냥 (기본값 사용)을 선택하도록 한다. 그리고 [다음]을 클릭한다.시작 메뉴 폴더를 선택하도록 하는데, 기본 값인 `R’을 이용하도록 한다. [다음]을 클릭한다.시작 메뉴 폴더를 선택하도록 하는데, 기본 값인 `R’을 이용하도록 한다. [다음]을 클릭한다.추가 사항 적용은 특별한 요구가 없는 한 기본 설정을 이용하도록 한다. [다음]을 클릭하면 설치가 실행된다.추가 사항 적용은 특별한 요구가 없는 한 기본 설정을 이용하도록 한다. [다음]을 클릭하면 설치가 실행된다.설치가 완료되면 [완료]를 클릭한다.설치가 완료되면 [완료]를 클릭한다.윈도우즈 시작 메뉴에 가면 R 폴더가 생성되어 있고 그 안의 메뉴를 클릭하면 R이 실행된다.윈도우즈 시작 메뉴에 가면 R 폴더가 생성되어 있고 그 안의 메뉴를 클릭하면 R이 실행된다.","code":""},{"path":"ch-intro.html","id":"sec-RStudio","chapter":"1 R 설치 및 시작","heading":"1.3 RStudio","text":"R 배포판이 제공하는 기능만으로도 기본적인 프로그래밍이나 데이터 분석이 가능하다. 그러나 프로그래밍이나 데이터 분석 작업이 복잡해지면 R을 좀 더 편리하게 사용할 수 있는 통합된 개발 환경(IDE: Integrated Development Environment)이 큰 도움이 된다.RStudio는 R을 위한 강력한 통합 개발 환경을 제공해 준다. R과 마찬가지로 공개 소프트웨어로 누구나 자유롭게 이용할 수 있다. 따라서 많은 R 사용자가 RStudio를 사용하고 있다.","code":""},{"path":"ch-intro.html","id":"winget을-이용한-rstudio-설치","chapter":"1 R 설치 및 시작","heading":"1.3.1 winget을 이용한 RStudio 설치","text":"winget에 대한 설명은 1.2.2 절을 참조한다.\ncmd 창이나 PowerShell 창에서 다음 명령을 실행하면 RStudo를 내려받고 설치 관리자를 실행한다.설치 관리자가 설치할 것인지 확인하면 ’Yes’를 선택한다.\n만약 이전 버전의 RStudio가 이미 설치되어 있다면, 업그레이드 하도록 다음 명령을 실행한다.\nR과 달리 RStudio 설치 관리자는 이전 버전을 지우고 신규 버전을 재설치 한다.winget으로 RStudio를 설치할 수 없으면 다음 절의 설명을 참조하여 직접 RStudio를 내려받고 설치를 수행한다.","code":"winget install --id RStudio.RStudio.OpenSourcewinget upgrade --id RStudio.RStudio.OpenSource"},{"path":"ch-intro.html","id":"rstudio-설치","chapter":"1 R 설치 및 시작","heading":"1.3.2 RStudio 설치","text":"앞 절에서 winget을 사용하여 RStudio를 설치하였으면 이 절의 내용은 수행하지 않아도 된다. 이 절은 winget으로 RStudio를 설치하지 못하였거나, 윈도우즈 이외의 운영체제를 사용하는 독자를 위해 R을 직접 내려받아 설치하는 방법을 설명한다.RStudio 다운로드 웹페이지에 접속하면 RStudio를 내려 받을 수 있다. RStudio는 데스크탑용과 서버용이 있다. 데스크탑 버전은 개별 사용자를 위한 버전이고, 서버용 버전은 여러 사람이 동시에 데이터를 분석하거나 원격에서 데이터를 분석하기에 좋은 환경이다. 서버용 버전과 관련된 정보는 RStudio 홈페이지를 참조하기 바란다.RStudio Desktop은 무료용 Open Source License (Free) 버전과 상업용 Commercial License 버전이 있다. 데스크탑용 RStudio는 무료용이나 상업용이나 기능상 차이는 없다. 상업용에는 별도의 기술 지원이 추가된다. Open Source License (Free)에서 [DOWNLOAD]을 클릭하여 다운로드 페이지로 이동한다.그러면 자동으로 접속자의 환경을 파악하여 사용자가 사용하는 운영체제에 적절한 RStudio 데스크탑 버전을 선택해 준다. 윈도우즈 사용자들은 [DOWNLOAD RSTUDIO WINDOWS]가 나타날 것이다. 이를 클릭하면 RStudio가 다운로드 될 것이다. 만약 다른 운영체제의 RStudio가 필요하면 하단의 목록에서 적절한 배포한을 선택한다. (RStudio는 공개 소프트웨어로 프로그램 소스 파일도 함께 공개되어 있어, 같은 페이지 하단에서 볼 수 있는 바와 같이 RStudio 소스를 내려받을 수도 있다.)내려받은 파일을 실행하면 RStudio 설치를 완료할 수 있다.","code":""},{"path":"ch-intro.html","id":"sec-R-start","chapter":"1 R 설치 및 시작","heading":"1.4 RStudio로 R 시작하기","text":"RStudio를 설치하면 윈도우 시작메뉴에 RStudio를 실행할 수 있는 메뉴가 나타난다. 이를 실행하면 다음 그림처럼 RStudio가 실행된다.기본 설정은 왼편에 R 콘솔이나 코드 편집기 창들이 위치하고, 오른편에 작업 환경, 명령어 히스토리, 파일, 그림, 패키지, 도움말 관련 창들이 위치하도록 되어 있다.","code":""},{"path":"ch-intro.html","id":"r-콘솔과-프롬프트","chapter":"1 R 설치 및 시작","heading":"1.4.1 R 콘솔과 프롬프트","text":"R은 기본적으로 텍스트 기반의 명령문을 입력받아 명령문에 대한 응답하는 방식으로 작동한다. R 콘솔은 사용자의 명령문을 받고 텍스트 기반 결과물을 출력하는 곳이다.R 콘솔은 사용자의 명령을 받을 준비가 되어 있다는 것을 나타내기 위해 명령 프롬프트인 `>’ 기호를 표시한다. 프롬프트가 보이면 R 명령문을 입력하고 Enter 키를 누르면 입력된 R 명령문이 R에 전달되어 실행된다.명령문의 실행 결과가 텍스트이면 R 콘솔에 결과가 나타나고 그래프이면 오른편의 Plots 창에 그래프가 나타난다.이 책에서는 아래에 나오는 형태로 R 콘솔의 입출력을 표시한다. >가 있는 행은 사용자가 입력한 행이고 >가 없는 행은 R의 출력 결과로 표시한다.R을 맛보기 위해 R이 제공하는 cars 데이터에 대해 기초적인 분석을 수행해보자. 이 절에서 이용되는 R 명령어에 대해서는 현재 시점에선 이해할 필요가 없다. 이 책이 진행되면서 차근차근 설명될 것이다.\n먼저 다음과 같이 cars 데이터를 화면에 출력해 보자. 콘솔에 cars라고 입력 후 Enter를 입력한다.cars 데이터는 자동차의 속력(speed)과 제동 거리(dist)에 대한 50 개의 관찰값으로 구성되어 있다. cars 데이터에 대하여 자세한 정보를 얻어보자. ?를 명령어에 붙이면 명령어에 대한 설명을 오른편의 Help 창에 도움말이 나타난다.summary() 함수를 이용하여 자동차의 속력과 제동 거리에 대한 최소값, 최대값, 평균, 사분위수 등 기본 통계치를 구해 보자.자동차의 속력과 제동 거리의 상관 관계를 보기 위해 plot() 함수를 이용하여 산점도(scatter plot)를 그려 본다.자동차의 속력과 제동 거리의 관계를 선형 모형으로 나타내기 위해 다음 명령어를 이용하여 cars 데이터에 대한 선형회귀분석을 수행한다.제동 거리를 속도로 회귀분석해 보면 절편이 -17.579이고 기울기가 3.932가 됨을 알 수 있다.앞에 그린 산점도에 abline() 함수를 이용하여 회귀 적합선을 그려 넣어 본다.본 절에서 수행한 명령어가 궁금한 독자는 help(명령어)나 ?명령어를 R 콘솔에 입력해 보라. 관련 도움말을 얻을 수 있을 것이다.","code":"\ncars#>   speed dist\n#> 1     4    2\n#> 2     4   10\n#> 3     7    4\n#> 4     7   22\n#> 5     8   16\n#> 6     9   10#> ...\n?cars\nsummary(cars)#>      speed           dist       \n#>  Min.   : 4.0   Min.   :  2.00  \n#>  1st Qu.:12.0   1st Qu.: 26.00  \n#>  Median :15.0   Median : 36.00  \n#>  Mean   :15.4   Mean   : 42.98  \n#>  3rd Qu.:19.0   3rd Qu.: 56.00  \n#>  Max.   :25.0   Max.   :120.00\nplot(cars)\nlm.cars <- lm(dist ~ speed, data=cars)\nlm.cars#> \n#> Call:\n#> lm(formula = dist ~ speed, data = cars)\n#> \n#> Coefficients:\n#> (Intercept)        speed  \n#>     -17.579        3.932\nplot(cars)\nabline(lm.cars, col=\"blue\")"},{"path":"ch-intro.html","id":"r-콘솔-사용과-관련된-몇-가지-팁","chapter":"1 R 설치 및 시작","heading":"1.4.2 R 콘솔 사용과 관련된 몇 가지 팁","text":"","code":""},{"path":"ch-intro.html","id":"입력-시-주의-사항","chapter":"1 R 설치 및 시작","heading":"입력 시 주의 사항","text":"R 명령문은 대문자와 소문자를 다른 문자로 간주한다. 그러니 함수명이나 변수명을 입력할 때 대소문자가 틀리지 않도록 해야 한다.R 명령문 입력시 가장 많이 틀리는 부분이 ' ', \" \", ( ), { } 등이 서로 짝이 맞지 않는 경우다.R 명령문을 입력하고 Enter를 입력하였는데, 결과가 출력되지 않고 프롬프트가 +로 바뀌는 경우에는, 입력한 명령문이 완전하지 않기 때문에 나머지 입력을 받기 위해 기다리고 있다는 것을 나타낸다.주로 앞서 설명한 ' ', \" \", ( ), { } 등이 서로 맞지 않아 발생하는 경우가 많다.이를 해결하는 두 가지 방법이 있다. 명령문의 나머지를 + 프롬프트 뒤에 입력한 후 Enter를 입력하여 명령문을 마무리하거나, Esc를 눌러 지금까지 입력된 내용을 취소하는 것이다.RStudio의 콘솔은 몇 가지 편의 기능을 제공한다. 이 기능들을 이용하면 작업의 생산성을 향상시킬 수 있다.","code":""},{"path":"ch-intro.html","id":"코드-완성","chapter":"1 R 설치 및 시작","heading":"코드 완성","text":"RStudio 콘솔에서 Tab 키를 사용하여 코드를 자동 완성시킬 수 있다.예를 들어 앞 절에 나온 lm.cars 변수를 사용하는 예제를 수행한 뒤라면, lm.c 까지만 입력한 후 Tab 키를 눌러보자. 그러면 자동으로 변수의 전체 이름을 완성해 줄 것이다.코드 완성 기능을 이용하여 변수 이름을 입력하는 것을 습관화 하면 좋다. 변수의 이름을 잘못 입력하여 발생하는 오류를 줄일 수 있다.코드 완성 기능은 함수에도 이용할 수 있다. sum까지만 입력한 후 Tab을 눌러보자. 그러면 다음 그림 처럼 sum으로 시작하는 함수의 목록이 나타난다. 목록 중 원하는 함수를 선택하면 해당 함수 이름을 콘솔에 자동 완성해 준다. 필요한 함수의 정확한 이름이 생각나지 않을 때 매우 유용하다.코드 완성 기능은 함수의 인수 입력에도 이용할 수 있다. summary(라고 입력한 후에* Tab 키를 누르면 함수 인수의 목록과 설명이 나온다. R 함수들의 인수 이름을 정확히 기억하는 것은 쉽지 않다. 코드 완성 기능을 오류 없이 정확한 명령어를 빠르게 입력할 수 있도록 도와준다.","code":""},{"path":"ch-intro.html","id":"이전-명령문-불러오기","chapter":"1 R 설치 및 시작","heading":"이전 명령문 불러오기","text":"R 콘솔에서는 이전에 입력한 명령을 불러와 다시 실행하거나 수정하여 실행시킬 수 있다. 이전 명령은 위와 아래 화살표 키를 이용하여 불러온다.[위 화살표 키] 이전에 입력한 명령을 차례대로 불러온다.[아래 화살표 키] 위 화살표 키와 반대로 불러온다.[Ctrl + 위 화살표 키] 이전 명령의 목록을 보여준다.","code":""},{"path":"ch-intro.html","id":"r-스크립트-파일-만들기","chapter":"1 R 설치 및 시작","heading":"1.4.3 R 스크립트 파일 만들기","text":"R 콘솔에서 대화 형식으로 명령문을 입력하고 결과를 받는 것은 단순한 작업의 경우에는 편리하지만, 복잡한 분석을 위해 입력해야 할 명령문이 많거나 추후에 동일한 또는 유사한 작업을 할 예정이라면 R 스크립트 파일을 작성하여 명령문을 저장해 두는 것이 좋다.R 스크립트는 한번에 실행할 명령문을 단순한 텍스트 형식으로 기술한 파일이다. R 스크립트에는 실행할 명령문을 한 줄씩 입력한다. R은 스크립트를 읽어들여서 줄바꿈이 되는 곳을 기준으로 한 줄씩 처리한다.","code":"#> summary(cars)\n#> lm.cars <- lm(dist~speed, data=cars)\n#> lm.cars\n#> plot(dist~speed, cars)\n#> abline(lm.cars)"},{"path":"ch-intro.html","id":"rstudio-코드-편집기","chapter":"1 R 설치 및 시작","heading":"RStudio 코드 편집기","text":"RStudio의 코드 편집기는 R 스크립트 등 다양한 파일을 작성하는 것을 도와준다. 문법 강조 표현, 코드 완성 등 다양한 기능들을 가지고 있다. 또한 코드 편집기에 입력한 R 명령을 콘솔에서 즉시 실행해 볼 수도 있다.많은 R 사용자가 R 명령을 콘솔에서 직접 실행하는 것보다 코드 편집기에서 스크립트로 작성한 후 실행하는 것을 선호한다. 왜냐하면 코드 편집기를 이용하면 실행한 R 명령을 파일에 저장해 둘 수 있으므로, 나중에 동일한 코드를 재실행할 수 있을 뿐 아니라 함수 등으로 쉽게 변환할 수 있기 때문이다.","code":""},{"path":"ch-intro.html","id":"rstudio에서-지원하는-주요-파일-형식","chapter":"1 R 설치 및 시작","heading":"RStudio에서 지원하는 주요 파일 형식","text":"RStudio는 다음 형식의 파일에 대하여 문법 강조 표현 및 특화된 코드 편집 기능을 제공한다.R 스크립트: R 명령어 코드와 주석만을 포함하는 파일이다.R 노트북: R 명령어와 함께 실행 결과를 Mathematica 노트북 형태로 저장해주는 파일이다.R Markdown 문서: 마크다운이라는 매우 단순한 형식으로 문서 모양을 지정할 수 있다. R 명령어와 마크다운이 같이 한 문서에 사용되어 동적인 문서를 생성한다. R 마크다운 문서는 HTML, 워드 문서, PDF 문서로 변환이 가능하다.Shiny Web App: RStudio에서 개발한 R을 이용해 웹 응용을 쉽게 개발하도록 지원하는 웹 응용 개발 체계이다.R Sweave 문서: LaTex 문서 내에 R 명령어를 포함하여 동적인 LaTex 파일을 만들어 주는 형식이다.R HTML 문서: HTML 문서 내에 R 명령어를 포함하여 동적으로 HTML 파일을 만들어 주는 형식이다.R Presentation 문서: HTML5 기능을 이용하여 HTML 기반의 동적인 프리젠테이션 파일을 만들어 주는 파일 형식이다.R Documentation 문서: R 프로그램에 대한 문서화를 지원해 주는 파일 형식이다.","code":""},{"path":"ch-intro.html","id":"스크립트-파일-만들기","chapter":"1 R 설치 및 시작","heading":"스크립트 파일 만들기","text":"일반적인 사용자는 보통 R 스크립트 파일, R 마크다운 파일, R 프리젠테이션 파일을 많이 사용한다. RStudio에서 새로운 파일을 생성하려면 File->New File 메뉴를 이용하거나 그림처럼 새 파일을 만드는 명령 단추를 클릭한다.기존 파일을 열기 위해서는 File->Open File… 또는 File->Recent Files 메뉴를 이용하거나, 파일 열기 명령 단추를 클릭한다.RStudio에서 여러 파일을 열게 되면 탭으로 각 파일을 표시해 준다. 매우 많은 파일이 열려서 탭을 모두 표시할 수 없으면 우측 상단에 >> 또는 좌측 상단에 << 아이콘이 표시되어 보이지 않는 파일 탭 사이를 전환할 수 있도록 해 준다.","code":""},{"path":"ch-intro.html","id":"편집기의-코드-완성-기능","chapter":"1 R 설치 및 시작","heading":"편집기의 코드 완성 기능","text":"코드 편집기는 Tab 키를 이용하여 자동 코드 완성을 지원한다. 코드 완성 기능은 콘솔과 마찬가지니 콘솔의 설명을 참조하기 바란다.","code":""},{"path":"ch-intro.html","id":"문자-찾기와-바꾸기","chapter":"1 R 설치 및 시작","heading":"문자 찾기와 바꾸기","text":"코드 편집기는 문서의 문자를 찾거나 바꾸는 기능을 지원한다. Ctrl +F 단축키를 이용하거나 Edit->Find 또는 Edit->Replace Find 메뉴를 이용한다.","code":""},{"path":"ch-intro.html","id":"코드-실행","chapter":"1 R 설치 및 시작","heading":"코드 실행","text":"RStudio는 코드 편집기의 코드를 직접 실행시킬 수 있다. 실행할 코드는 콘솔에 자동 입력되어 실행되고 그 결과도 콘솔에 표시된다.코드의 한 줄 또는 일부 여러 줄을 실행하려면 그 줄을 선택한 후 코드 편집기의 도구 모음에서 Run를 실행하거나 Ctrl+Enter 키를 이용한다.코드 전체를 실행하기 위해서는 코드 편집기의 도구 모음에서 Source -> Source Echo를 실행하거나 Ctrl+Shift+Enter 키를 이용한다.코드 편집기의 도구 모음에서 그냥 Source를 실행하면 파일의 명령문이 실행은 되나 결과가 콘솔에 출력되지 않는다.","code":""},{"path":"ch-intro.html","id":"주석-처리","chapter":"1 R 설치 및 시작","heading":"주석 처리","text":"R 스트립트에 명령문이 아닌 내용을 입력하고 싶으면 #을 앞에 사용하여 주석 처리를 한다. # 뒤에 입력된 내용은 명령문으로 간주하지 않고 무시한다.주석문은 명령문의 의미를 나중에 이해하기 쉽도록 기술하거나, R 스크립트 개발 과정에서 디버깅이나 다른 이유로 명령문을 실행에서 제외할 때 사용한다.직접 #를 입력하는 방법뿐 아니라, Edit->Comment/Uncomment Lines 메뉴나 코드 편집기 상단의 코드 명령 단추에서 해당 메뉴를 이용하면 선택한 코드 부분 전체를 주석 처리하거나 주석 처리를 취소할 수 있다.","code":""},{"path":"ch-intro.html","id":"들여쓰기","chapter":"1 R 설치 및 시작","heading":"들여쓰기","text":"코드를 작성할 때 동일한 논리적 단위들을 동일하게 들여쓰기하면 코드를 읽기가 쉬워진다. RStudio는 코드 작성시 현재의 들여쓰기 옵션에 따라 자동으로 들여쓰기를 해 준다.코드를 작성한 후 들여쓰기를 직접 조정하고 싶으면, 코드를 선택한 후 Tab 키를 누른다. 그러면 Tab 키를 누른 횟수만큼 들여쓰기가 된다.반대로 Shift+Tab 키를 누르면, 누른 횟수만큼 내어쓰기가 된다.참고로 RStudio는 Tab 한 회에 공백 2문자만큼 들여쓰기를 한다. 이를 조절하고 싶으면 [Toos]-[Global Options]-[Code] 메뉴에 가서 Tab 한 회당 들여쓰기할 공백 문자 수를 조절하면 된다.","code":""},{"path":"ch-R-Data-Basic.html","id":"ch-R-Data-Basic","chapter":"2 R 데이터 기초","heading":"2 R 데이터 기초","text":"R은 통계 데이터 분석 툴이기도 하지만 그 자체로 프로그래밍 언어이다. 한국어, 영어와 같은 모든 언어가 그러하듯이 R에도 자기만의 어휘와 표현법, 표현 형태들이 있다. 외국어에 익숙해지기 위해 기본적인 문법 요소와 다양한 문형들을 익혀야 하는 것처럼 R도 R의 기본 표현법과 표현 형태를 익혀야만 사용할 수 있다. 고급 문법과 문형에 익숙할수록 더 유창한 언어 실력을 보일 수 있듯이 R도 고급 표현을 익히면 더 다양한 분석을 수행할 수 있다.이 장에서는 R의 가장 기초적인 데이터 요소를 배운다. 3에서 6 장까지는 이 장에서 배운 내용을 기초로 R의 기초 데이터를 확장해 나간다. 이 장의 내용은 프로그래밍 언어에 익숙한 독자들에게는 이미 익숙한 내용일 것이다. 그런 독자들은 다음 장부터 시작하여도 무방하다.","code":""},{"path":"ch-R-Data-Basic.html","id":"단순한-데이터-형식-data-types","chapter":"2 R 데이터 기초","heading":"2.1 단순한 데이터 형식 (data types)","text":"","code":""},{"path":"ch-R-Data-Basic.html","id":"r의-기본적-데이터-형식-숫자-문자-논리값","chapter":"2 R 데이터 기초","heading":"R의 기본적 데이터 형식: 숫자, 문자, 논리값","text":"R은 데이터를 다룬다. R에서 다루는 기본적인 데이터 형식은 숫자, 문자, 논리값이다. 어떤 학생의 키가 172.2이면 이 데이터의 형식은 숫자이다. 그 학생의 이름이 ’홍길동’이면 이 데이터는 문자 데이터이다. 그리고 이 학생이 남자인지 여부를 TRUE 또는 FALSE로 표현하였다면 이 데이터의 형식은 논리값이다. R의 모든 복잡한 데이터 형식은 이러한 숫자, 문자, 논리값을 기반으로 구성된다.아래는 R의 콘솔에서 숫자, 문자, 논리값을 차례대로 입력해 본 결과이다. ‘>’ 다음 부분을 R 콘솔에 입력한 후 Enter 키를 누른다. 그러면 입력한 내용이 R에 전달되어 출력 결과가 그 다음 줄에 나타난다(’>’가 없는 줄).","code":"10#> [1] 10TRUE#> [1] TRUE\"홍길동\"#> [1] \"홍길동\""},{"path":"ch-R-Data-Basic.html","id":"vs-10","chapter":"2 R 데이터 기초","heading":"10 vs ‘10’","text":"여기서 주의할 점은 숫자와 논리값과는 달리 문자 데이터는 큰 따옴표나 작은 따옴표로 시작과 끝을 표현해 주어야 한다는 것이다. 따라서 사칙연산이 가능한 숫자 10과 문자 \"10\"은 서로 다르다. 마찬가지로 논리값 TRUE와 문자열 \"TRUE\"도 다른 의미를 가진다.","code":""},{"path":"ch-R-Data-Basic.html","id":"단순-연산","chapter":"2 R 데이터 기초","heading":"2.2 단순 연산","text":"","code":""},{"path":"ch-R-Data-Basic.html","id":"사칙-연산","chapter":"2 R 데이터 기초","heading":"사칙 연산","text":"R은 더하기, 빼기, 곱하기, 나누기 등의 사칙연산에 대한 기본적 기능을 제공한다. 아래의 ‘>’ 이후의 부분을 입력 후 Enter 키를 누르면 그 아래에 출력 결과가 나온다.","code":"\n2 + 2#> [1] 4\n2 - 2#> [1] 0\n2 * 2#> [1] 4\n2 / 2#> [1] 1"},{"path":"ch-R-Data-Basic.html","id":"몫과-나머지","chapter":"2 R 데이터 기초","heading":"몫과 나머지","text":"R에서 나눗셈은 부동 소수점 형식의 실수(real numbers)로 계산된다. 만약 정수의 나눗셈에서 몫과 너머지를 구하려면 %/%과 %% 연산자를 사용한다.","code":"\n11 / 3#> [1] 3.666667\n11 %/% 3  # 몫#> [1] 3\n11 %% 3   # 나머지#> [1] 2"},{"path":"ch-R-Data-Basic.html","id":"거듭-제곱-연산","chapter":"2 R 데이터 기초","heading":"거듭 제곱 연산","text":"또한 ‘^’ 연산자를 이용해 거듭제곱도 가능하다. 아래의 예는 2의 1제곱부터 4제곱까지의 결과이다. 여기서 4개의 거듭제곱 연산 명령문 (Enter 키를 쳐서 R로 보내는 내용)을 한 줄로 보내기 위해 ’;’로 각각의 명령문을 나누어 한번의 Enter 키로 명령을 실행하였다. 각 명령문의 결과는 다른 줄로 출력되었음을 볼 수 있다.R은 파이썬처럼 ** 연산자를 거듭 제곱 연산자로 사용할 수도 있다.","code":"\n2^1; 2^2; 2^3; 2^4#> [1] 2\n#> [1] 4\n#> [1] 8\n#> [1] 16\n2**4#> [1] 16"},{"path":"ch-R-Data-Basic.html","id":"비교-연산-vs.","chapter":"2 R 데이터 기초","heading":"비교 연산 ‘==’ vs. ‘=’","text":"R은 사칙연산뿐 아니라 부등호와 등호를 이용한 비교연산도 가능하다. 아래는 비교 연산을 수행한 경우이다. ‘>=’와’<=’ 연산자는 같거나 크다 또는 같거나 작다를 의미한다. ‘==’ 연산자는 같다를 의미하고 ‘!=’ 연산자는 같지 않다를 의미한다. 여기서 주의할 점은 등호가 ‘=’가 아니라’==‘라는 점이다.’=’ 연산자는 뒤에서 살펴볼 변수에 값을 할당하는데 이용된다.","code":"\n2 > 2; 2 >= 2; 2 < 2 ; 2 <= 2#> [1] FALSE#> [1] TRUE#> [1] FALSE#> [1] TRUE\n2 == 2; 2 != 2#> [1] TRUE#> [1] FALSE"},{"path":"ch-R-Data-Basic.html","id":"논리값-연산","chapter":"2 R 데이터 기초","heading":"논리값 연산","text":"논리값은 ‘&’, ‘\\verb1|1’, ‘!’, xor(x, y) 연산자를 이용하여 논리적 , , , XOR 연산의 수행도 가능하다.","code":"\nTRUE & FALSE#> [1] FALSE\nTRUE | FALSE#> [1] TRUE\n!TRUE#> [1] FALSE\nxor(TRUE, TRUE)#> [1] FALSE"},{"path":"ch-R-Data-Basic.html","id":"문자열-결합-연산-paste","chapter":"2 R 데이터 기초","heading":"문자열 결합 연산 paste()","text":"문자열에 대한 연산으로는 paste() 함수를 이용하여 문자를 연결하는 연산이 있다. paste() 함수는 문자열을 공백 하나를 사이에 두고 하나의 문자열로 합쳐준다. 숫자처럼 문자가 아닌 것은 문자로 변환한 후 합쳐준다. sep인자를 이용하면 두 문자열의 사이에 다양한 문자를 넣을 수 있다.","code":"\npaste(2014, 3)#> [1] \"2014 3\"\npaste(\"March\", 11, 2014)#> [1] \"March 11 2014\"\npaste(2014, 3, 11, sep=\"-\")#> [1] \"2014-3-11\"\npaste(2014, 3, 11, sep=\"/\")#> [1] \"2014/3/11\"\npaste(2014, 3, 11, sep=\"\")#> [1] \"2014311\""},{"path":"ch-R-Data-Basic.html","id":"문자열-분리-연산-strsplit","chapter":"2 R 데이터 기초","heading":"문자열 분리 연산 strsplit()","text":"paste와 반대로 하나의 문자열을 여러 문자열로 분리해 내는 strsplit 함수도 있다. split인자에 문자열을 분리하는 기준이 되는 문자 또는 문자열을 지정해 준다.strsplit의 split 인자는 사실 정규식 표현도 가능하다. (정규식에 대해서는 regular expression에 대한 다른 자료를 참조하길 바란다.) 다음은 정규식을 이용하여 ‘-’나,’ ‘(공백)나,’:’ 문자가 있는 곳 모두를 분리한 예이다.","code":"\nstrsplit(\"2016-3-11 11:16:22\", split=\" \")#> [[1]]\n#> [1] \"2016-3-11\" \"11:16:22\"\nstrsplit(\"2016-3-11 11:16:22\", split=\"-\")#> [[1]]\n#> [1] \"2016\"        \"3\"           \"11 11:16:22\"\nstrsplit(\"2016-3-11 11:16:22\", split=\":\")#> [[1]]\n#> [1] \"2016-3-11 11\" \"16\"           \"22\"\nstrsplit(\"2016-3-11 11:16:22\", split=c(\"16\"))#> [[1]]\n#> [1] \"20\"        \"-3-11 11:\" \":22\"\nstrsplit(\"2016-3-11 11:16:22\", split=\"[- :]\")#> [[1]]\n#> [1] \"2016\" \"3\"    \"11\"   \"11\"   \"16\"   \"22\""},{"path":"ch-R-Data-Basic.html","id":"변수와-할당","chapter":"2 R 데이터 기초","heading":"2.3 변수와 할당","text":"","code":""},{"path":"ch-R-Data-Basic.html","id":"변수는-메모리-공간에-붙이는-레이블","chapter":"2 R 데이터 기초","heading":"변수는 메모리 공간에 붙이는 레이블","text":"R에서 연산을 수행하다 보면 연산의 중간 결과를 저장해둘 필요가 있다. 이 때 이용할 수 있는 것이 변수이다. 변수는 데이터를 저장해 두는 공간이라고 생각하면 쉽다. 변수는 사실 데이터를 저장해 두는 공간에 라벨을 붙여두는 것이다. 다시 그 데이터가 필요할 때 라벨을 이용하여 데이터가 저장된 공간에 가서 그 데이터 값을 가져와 이용하면 된다.","code":""},{"path":"ch-R-Data-Basic.html","id":"변수에-값-할당하기","chapter":"2 R 데이터 기초","heading":"변수에 값 할당하기","text":"할당(assignments)이란 어떤 변수에 데이터를 저장하는 것을 말한다. 예를 들어 x에 5라는 숫자 데이터를 할당하였다면 5라는 숫자가 x라는 라벨이 붙은 저장 공간에 들어간 것과 마찬가지이다. 우리는 x라는 라벨을 이용하여 필요할 때 x라는 라벨이 붙은 저장공간에 저장된 데이터 값을 가져올 것이다.","code":""},{"path":"ch-R-Data-Basic.html","id":"할당-연산자","chapter":"2 R 데이터 기초","heading":"할당 연산자","text":"변수에 데이터를 할당하는 것은 ‘<-’ 또는 ‘=’ 연산자를 이용하여 이루어진다. 이 책에는 할당 연산자로 ‘<-’을 이용할 것이다. 할당 연산자의 모양에서도 알 수 있듯이’<-’ 연산자 오른쪽의 데이터를 왼쪽의 변수에 집어넣는다. x라는 변수에 저장된 데이터 값을 알고 싶으면 x를 입력한 후 Enter 키를 누르면 x의 값이 출력된다.","code":"\nx <- 5\nx#> [1] 5"},{"path":"ch-R-Data-Basic.html","id":"연산에-변수-사용하기","chapter":"2 R 데이터 기초","heading":"연산에 변수 사용하기","text":"x를 이용하여 다양한 명령을 수행할 수 있다. 뿐만 아니라 괄호 등을 이용하여 복잡한 연산을 수행할 수 있다.위의 마지막 결과에서 볼 수 있듯이 변수의 값은 ‘<-’ 연산자에 의해 다시 다른 값으로 할당되지 않으면 연산에서 사용되어도 원래의 값이 변하지 않는다.","code":"\nx + 2#> [1] 7\nx * 2#> [1] 10\nx^2#> [1] 25\n(x+3)^2 + 5#> [1] 69\nx#> [1] 5"},{"path":"ch-R-Data-Basic.html","id":"변수에-값-재할당하기","chapter":"2 R 데이터 기초","heading":"변수에 값 재할당하기","text":"변수는 데이터의 저장공간일 뿐이므로 현재 들어간 데이터 값 대신 다른 값을 재할당할 수도 있다. 다음의 예는 x에 7을 재할당한 후 앞서 수행한 연산을 다시 수행해 본 것이다.이제 x라는 라벨이 붙은 저장공간에 7이라는 숫자 데이터가 들어가 있으므로 x를 이용한 연산 결과가 앞의 예와는 다르게 나옴을 볼 수 있다.","code":"\nx <- 7\nx + 2#> [1] 9\nx*2#> [1] 14\nx^2#> [1] 49\n2^x#> [1] 128"},{"path":"ch-R-Data-Basic.html","id":"할당문은-우변이-수행된-후-좌변으로-할당이-이루어진다.","chapter":"2 R 데이터 기초","heading":"할당문은 우변이 수행된 후 좌변으로 할당이 이루어진다.","text":"한 명령문 안에서 x의 값을 가져와 연산에 이용한 후 그 결과를 다시 x에 재할당할 수 있다. 이 경우 ‘<-’ 연산자 오른편의 연산이 먼저 수행된 후 ‘<-’ 연산자에 의해 왼편의 변수로 할당이 이루어진다.마찬가지로 한 변수의 값을 이용하여 연산을 수행한 후 다른 변수에 값을 할당할 수도 있다. 아래 예에서도 볼 수 있듯이 x가 연산에 이용되더라도 재할당이 이루어지지 않으면 x라고 라벨이 붙은 저장공간에 들어가 있는 데이터 값은 동일하다.여기서도 변수의 값은 할당문에 의해 할당 또는 재할당이 이루어지지 않으면 변화가 없음을 다시 확인할 수 있다.","code":"\nx <- x + 1; x#> [1] 8\nx <- 2 + x; x#> [1] 10\nx <- x*2; x#> [1] 20\nx <- x^2; x#> [1] 400\nx#> [1] 400\ny <- 2 * x\ny#> [1] 800\nx#> [1] 400"},{"path":"ch-R-Data-Basic.html","id":"변수-제거하기-rm","chapter":"2 R 데이터 기초","heading":"변수 제거하기 rm()","text":"여러 가지 이유로 변수를 제거할 필요가 있을 수 있다. 변수를 제거하려면 rm() 함수를 이용하면 된다. 제거할 변수를 rm() 함수 내에 기술하면 이 변수가 사라지게 된다.rm() 함수로 변수를 제거하면 변수가 사용하는 메모리는 자유롭게 되며, R이 다른 용도로 이용할 수 있다. 여기서 주의할 점은 rm()에 의해서 메모리가 자유롭게 되더라도 R이 사용하던 메모리가 운영체제로 바로 반환되지는 않는다는 것이다. 이를 처리하려면 gc() 함수를 이용하여 garbage collection을 하도록 해야 한다. 그러나 사실 R은 주기적으로 garbage collection을 하므로 특별한 이유가 없으면 이를 별도로 수행할 필요는 없다.","code":"\nx; y#> [1] 400#> [1] 800\nrm(x, y)\nx#> Error in eval(expr, envir, enclos): 객체 'x'를 찾을 수 없습니다\ny#> Error in eval(expr, envir, enclos): 객체 'y'를 찾을 수 없습니다"},{"path":"ch-R-Data-Basic.html","id":"변수-목록-확인하기-ls","chapter":"2 R 데이터 기초","heading":"변수 목록 확인하기 ls()","text":"ls() 함수를 이용하면 현재 환경에서 정의되어진 모든 변수의 이름을 출력해 준다. 반면 rm() 함수는 list 인자에 변수의 이름을 주면 해당 변수를 메모리에서 제거한다. 따라서 아래와 같은 방식을 이용하면 현재 환경에 정의되어 있는 모든 변수를 제거할 수 있다.","code":"\na <- 5\nb <- 7\nls()#> [1] \"a\" \"b\"\nrm(list=ls())\nls()#> character(0)"},{"path":"ch-R-Data-Basic.html","id":"assign","chapter":"2 R 데이터 기초","heading":"assign()","text":"참고로 assign() 함수로도 변수의 할당은 할 수 있다. 대부분의 경우는 assign() 함수를 이용하는 것보다는 앞서 설명한 할당 연산자를 이용하여 변수에 값을 할당하는 것이 편리하고 이해하기도 쉽다. 그러나 가끔 많은 변수를 자동적으로 생성해야 하는 경우나 데이터베이스에서 변수의 이름을 읽어들여와 값을 할당하는 등의 경우에는 assign() 함수를 이용하는 것이 필요하다.assign() 함수는 첫번째 인수로 변수의 이름을 문자열로 갖고, 두번째 인수로 변수에 할당한 값을 갖는다.위의 예에서 x1이라는 변수가 없었는데, assign() 함수에 의해 x1 변수가 할당되었음을 볼 수 있다. 주의할 점은 보통의 할당문에서는 변수가 문자열과 구분되도록 따옴표 없이 사용되나, assign() 함수에서는 변수의 이름이 문자열로 따옴표와 함께 표시된다는 것이다.","code":"\nx1#> Error in eval(expr, envir, enclos): 객체 'x1'를 찾을 수 없습니다\nassign(\"x1\", 5)\nx1#> [1] 5\nassign(\"x1\", x1 + 3)\nx1#> [1] 8"},{"path":"ch-R-Data-Basic.html","id":"함수를-이용한-연산","chapter":"2 R 데이터 기초","heading":"2.4 함수를 이용한 연산","text":"R의 기본 기능에는 다양한 함수가 포함되어 있다. 사용자도 자신만의 함수를 만들 수 있다. 함수는 입력으로 어떤 값을 받은 후 출력으로 어떤 값을 반환한다. 함수가 어떤 값을 입력받고 반환하는지는 함수마다 다르다.","code":""},{"path":"ch-R-Data-Basic.html","id":"함수-호출-하기","chapter":"2 R 데이터 기초","heading":"함수 호출 하기","text":"R에서 함수를 이용하려면 다음의 형태로 함수를 호출하여야 한다.아래는 제곱근을 구하는 sqrt() 함수의 예이다. 함수의 입력 인수(arguments)로는 4가 주어져 있고 제곱근을 구하는 함수는 입력된 4를 가지고 결과인 2를 반환하고 있다. 함수는 연산자와 함께 사용될 수 있고 함수의 결과가 다시 다른 함수의 입력 인수가 될 수 있다.Table 2.1: 수학 관련 주요 함수","code":"> 함수이름(함수 입력 인수)\n함수 출력 값\nsqrt(4)#> [1] 2\n(sqrt(9) + 2) / 4#> [1] 1.25\nsin( (sqrt(9) + 2)/ 4 )#> [1] 0.9489846"},{"path":"ch-R-Data-Basic.html","id":"실수를-정수로-변환하는-함수","chapter":"2 R 데이터 기초","heading":"실수를 정수로 변환하는 함수","text":"표 2.1은 R에 내장되어 있는 수학 관련 주요 함수를 보여준다. 다음 예는 함수를 이용하여 숫자에 대한 올림, 내림, 버림, 반올림 등을 수행한 결과이다.","code":"\na <- 3.141593\nceiling(a) #> [1] 4\nfloor(a) #> [1] 3\ntrunc(a)  #> [1] 3\nround(a) #> [1] 3\nround(a, digits=2)#> [1] 3.14"},{"path":"ch-R-Data-Basic.html","id":"순열과-조합-함수","chapter":"2 R 데이터 기초","heading":"순열과 조합 함수","text":"다음은 순열(factorial)과 조합(combination)의 값을 구한 결과이다. 30에 대한 순열 값은 매우 커서 공학 형식으로 숫자가 표시된다. 이를 일반적인 형식으로 표시하기 위해서 format 함수를 이용하였다.함수에 대한 자세한 내용은 10 장의 함수(function)와 관련된 내용을 참조한다.","code":"\nfactorial(5)#> [1] 120\nfactorial(30)#> [1] 2.652529e+32\nformat(factorial(30), scientific = FALSE, )#> [1] \"265252859812191032188804700045312\"\nchoose(5, 2)#> [1] 10\nchoose(45, 6)#> [1] 8145060"},{"path":"ch-R-Vectors.html","id":"ch-R-Vectors","chapter":"3 R 벡터","heading":"3 R 벡터","text":"벡터는 R의 통계 분석에서 가장 중요한 데이터 형식이다. 다른 범용의 프로그래밍 언어와는 다르게 R은 벡터 단위의 연산 및 조작을 지원함으로써 통계 데이터 분석에 매우 편리한 이점을 제공한다.","code":""},{"path":"ch-R-Vectors.html","id":"벡터는-동일-형식-데이터의-나열","chapter":"3 R 벡터","heading":"벡터는 동일 형식 데이터의 나열","text":"벡터는 50명 학생들의 키 데이터 (162.1, 175.8, 183.2, …), 50명 학생들의 성별 데이터 (\"여\", \"남\", \"남\", ...)처럼 한가지 타입의 데이터를 나열한 것이다. 여기서 타입이란 1, 2 등의 숫자 타입, \"yes\", \"\" 등의 문자열 타입, TRUE/FALSE의 논리적 타입을 의미한다. 숫자 벡터에는 숫자 데이터만 나열되고, 문자 벡터나 논리 벡터에는 각각 문자열과 논리값만이 나열된다.","code":""},{"path":"ch-R-Vectors.html","id":"벡터의-길이크기","chapter":"3 R 벡터","heading":"벡터의 길이/크기","text":"벡터가 포함하고 있는 데이터의 개수를 벡터의 길이 또는 크기라고 한다. 따라서 50 명 학생의 키 데이터는 길이가 50인 벡터가 된다. 사실 R은 벡터가 아닌 숫자, 문자, 논리값은 없다. 10이라는 숫자 하나도 사실은 길이가 1인 숫자 벡터이고, 문자열도 논리값도 길이가 1인 문자 벡터와 논리 벡터일 뿐이다.","code":""},{"path":"ch-R-Vectors.html","id":"숫자-벡터","chapter":"3 R 벡터","heading":"3.1 숫자 벡터","text":"","code":""},{"path":"ch-R-Vectors.html","id":"c-함수를-이용한-숫자-벡터-만들기","chapter":"3 R 벡터","heading":"3.1.1 c() 함수를 이용한 숫자 벡터 만들기","text":"","code":""},{"path":"ch-R-Vectors.html","id":"숫자-연결하여-벡터-만들기","chapter":"3 R 벡터","heading":"숫자 연결하여 벡터 만들기","text":"c() 함수는 여러 가지 기능을 하지만 가장 중요한 기능은 두개 이상의 벡터를 인수로 받아 이를 연결(concatenating)하여 새로운 벡터를 만드는 것이다.\n다음은 c() 함수로 숫자 2, 4, 6, 8, 10으로 이루어진 숫자 벡터를 만들어 y라는 변수에 할당하는 예이다.R 콘솔 상에 변수 y를 입력한 후 Enter를 치면 변수 y의 내용을 출력한다. 변수가 벡터인 경우에는 벡터의 요소들을 나열한다.앞의 예에서는 정수만으로 이루어진 벡터를 만들었는데 이번에는 실수가 들어간 숫자 벡터를 만들어 보자. 실수 하나가 벡터의 요소로 들어가자 나머지 숫자도 소수점을 가지는 실수로 표현됨을 볼 수 있다.","code":"\ny <- c(2, 4, 6, 8, 10)\ny#> [1]  2  4  6  8 10\nx <- c(1,3,5,7,9.2)\nx#> [1] 1.0 3.0 5.0 7.0 9.2"},{"path":"ch-R-Vectors.html","id":"길이가-2-이상인-벡터-연결하여-새-벡터-만들기","chapter":"3 R 벡터","heading":"길이가 2 이상인 벡터 연결하여 새 벡터 만들기","text":"지금까지는 숫자(길이가 1인 숫자 벡터)만을 연결하여 숫자 벡터를 만들었다. 이제 길이가 2 이상인 숫자 벡터 x와 y를 연결하여 새로운 숫자 벡터 z를 만들어 보도록 하자.위의 예에서 x와 y의 위치가 바뀌면 어떻게 될까? 아래 결과에서 볼 수 있듯이 새롭게 생긴 z 벡터의 요소의 순서가 바뀐다. y의 요소 다음에 x의 요소들이 차례대로 나열된다.","code":"\nz <- c(x, y)\nz#>  [1]  1.0  3.0  5.0  7.0  9.2  2.0  4.0  6.0  8.0 10.0\nz <- c(y, x)\nz#>  [1]  2.0  4.0  6.0  8.0 10.0  1.0  3.0  5.0  7.0  9.2"},{"path":"ch-R-Vectors.html","id":"여러-줄에-걸친-벡터-출력","chapter":"3 R 벡터","heading":"여러 줄에 걸친 벡터 출력","text":"c() 함수는 세 개 이상의 벡터를 연결시킬 수도 있다. 아래 결과에서 벡터 w는 x, y, z의 요소들이 차례로 나열되어 새 벡터가 되었음을 볼 수 있다. 이 때 벡터가 길어 여러 줄로 출력이 되었다. 출력 결과 중 [1]과 [11]은 첫째 줄은 벡터의 1번째 요소부터, 둘째 줄은 11번째 요소부터 출력되고 있음을 나타낸다. 이렇듯 벡터가 길어 여러 줄로 콘솔에 출력되면 각 줄의 맨 앞에 표시되는 요소가 벡터의 몇 번째 요소인지를 알려준다.","code":"\nw <- c(x, y, z)\nw#>  [1]  1.0  3.0  5.0  7.0  9.2  2.0  4.0  6.0  8.0 10.0\n#> [11]  2.0  4.0  6.0  8.0 10.0  1.0  3.0  5.0  7.0  9.2"},{"path":"ch-R-Vectors.html","id":"패턴을-이용한-숫자-벡터-만들기","chapter":"3 R 벡터","heading":"3.1.2 패턴을 이용한 숫자 벡터 만들기","text":"R의 데이터를 다루다 보면 어떤 패턴을 따르는 숫자 벡터가 필요한 경우가 있다. 예를 들어 50명의 학생에게 1부터 50까지 차례로 일련번호를 부여하려고 한다고 하자. c() 함수를 이용하여 1부터 50까지 숫자를 일일이 연결하여 이를 만드는 것은 매우 번거로운 일이다. 이러한 경우에는 n:m 명령을 사용하여, 숫자 n부터 시작하여 숫자 m까지 1씩 증가하거나 감소하는 수열로 된 벡터를 쉽게 만들 수 있다.","code":""},{"path":"ch-R-Vectors.html","id":"nm","chapter":"3 R 벡터","heading":"n:m","text":"위 결과에서 보듯이 m이 n보다 크면 1씩 증가하는 수열을, n이 m보다 크면 1씩 감소하는 수열이 생성된다. 위의 예는 자연수만을 사용하였는데, 사실 수열의 시작과 끝을 나타내는 숫자는 음의 정수나 실수 등 어떠한 숫자도 가능하다. n이 정수가 아닌 경우도 n부터 시작하여 1씩 증가 또는 감소하여 m을 넘지 않는 수열을 만든다는 사실은 변함이 없다.","code":"\n1:10#>  [1]  1  2  3  4  5  6  7  8  9 10\n10:1#>  [1] 10  9  8  7  6  5  4  3  2  1\n-4:8#>  [1] -4 -3 -2 -1  0  1  2  3  4  5  6  7  8\n0.7:8#> [1] 0.7 1.7 2.7 3.7 4.7 5.7 6.7 7.7\n2.3:-5#> [1]  2.3  1.3  0.3 -0.7 -1.7 -2.7 -3.7 -4.7"},{"path":"ch-R-Vectors.html","id":"seq","chapter":"3 R 벡터","heading":"seq()","text":"seq() 함수를 이용하면 1씩 증가하거나 감소하는 수열 벡터뿐 아니라 좀 더 복잡한 수열 벡터도 생성할 수 있다.seq() 함수는 입력 인수의 형태에 따라 생성하는 수열이 다르다. seq(n, m)으로 함수를 호출하면 n:m과 마찬가지로 1씩 증가하거나 감소하는 수열을 생성한다. seq(n, m, =k)로 호출하면 n부터 시작하여 k씩 증가하여 m을 넘지 않는 수열을 생성한다. seq(length=j, =n, =k)로 호출하면 n부터 시작하여 k씩 증가하는 길이가 j인 수열을 만든다.1부터 어떤 벡터의 길이까지 일련번호를 생성할 때 seq() 함수를 이용하면 편리하다. seq()의 along 인수에 벡터를 부여하면 1부터 그 벡터의 길이만큼의 일련번호가 생성된다.","code":"\nseq(n, m)\nseq(n, m, by=k)\nseq(length=j, from=n, by=k)\nseq(5, 15)#>  [1]  5  6  7  8  9 10 11 12 13 14 15\nseq(5, 15, by = 2)#> [1]  5  7  9 11 13 15\nseq(length=10, from = -3, by = 0.5)#>  [1] -3.0 -2.5 -2.0 -1.5 -1.0 -0.5  0.0  0.5  1.0  1.5\ny#> [1]  2  4  6  8 10\nseq(along=y)#> [1] 1 2 3 4 5"},{"path":"ch-R-Vectors.html","id":"rep","chapter":"3 R 벡터","heading":"rep()","text":"어떤 벡터를 반복시켜서 새로운 벡터를 만들고 싶을 때는 rep() 함수를 이용한다. 첫번째 인수에 반복할 벡터를, times 인수에 반복할 횟수를 부여한다. rep() 함수를 빈번하게 이용하는 경우가 숫자 하나를 여러번 반복하여 벡터를 만들 때이다.rep() 함수를 이용하면 벡터 전체를 차례로 반복시키는 것뿐 아니라, 요소별로 횟수만큼 반복시킨 후 이를 결합하여 새로운 벡터를 만들 수도 있다. 이 경우에는 times 인수 대신 인수에 반복할 회수를 부여한다.","code":"\ny <- c(1:5, 0:-5)\nrep(y, times = 2)#>  [1]  1  2  3  4  5  0 -1 -2 -3 -4 -5  1  2  3  4  5  0 -1 -2 -3 -4 -5\nrep(1, times = 10)#>  [1] 1 1 1 1 1 1 1 1 1 1\nrep(y, each = 2)#>  [1]  1  1  2  2  3  3  4  4  5  5  0  0 -1 -1 -2 -2 -3 -3 -4 -4 -5 -5"},{"path":"ch-R-Vectors.html","id":"숫자-벡터의-연산","chapter":"3 R 벡터","heading":"3.1.3 숫자 벡터의 연산","text":"","code":""},{"path":"ch-R-Vectors.html","id":"요소-단위-연산-elementwise-operation","chapter":"3 R 벡터","heading":"요소 단위 연산 (elementwise operation)","text":"R의 강점 중 하나가 벡터의 요소끼리 연산을 지원한다는 것이다. 이는 여타의 범용 프로그래밍 언어에서는 볼 수 없는 점이다. 길이가 동일한 두 벡터에 더하기나 곱하기 연산 등을 수행하면, 같은 위치에 있는 요소끼리 해당 연산이 이루어진다(그림 3.1 참조).다른 범용 프로그래밍 언어에 대한 지식이 있는 독자라면, 이를 해당 언어로 구현하려면 어떻게 해야 할지 잠시 생각해 보자. 반복문을 이용하여 이를 수행해야 할 것이다. 이러한 점을 고려하면 R이 벡터 연산을 얼마나 편리하게 수행하게 해 주는지 이해할 수 있을 것이다.\nFigure 3.1: 길이가 같은 벡터의 연산\n","code":"\nx <- seq(length=5, from=0, by=10)\nx#> [1]  0 10 20 30 40\ny <- 1:5\ny#> [1] 1 2 3 4 5\nx + y#> [1]  1 12 23 34 45\nx - y#> [1] -1  8 17 26 35\nx * y#> [1]   0  20  60 120 200\nx / y#> [1] 0.000000 5.000000 6.666667 7.500000 8.000000"},{"path":"ch-R-Vectors.html","id":"벡터-재사용-recycling","chapter":"3 R 벡터","heading":"벡터 재사용 (recycling)","text":"연산에 사용되는 두 벡터의 길이가 다르면 어떻게 될까? 이 경우 길이가 짧은 벡터의 요소들이 순환 반복되어 사용된다(그림 3.2 참조). 이러한 현상을 벡터의 재사용(recycling)이라고 부른다.다음 예는 길이가 10인 z 벡터와 길이가 5인 y 벡터를 더한 결과를 보여준다. 결과에서 보듯이 z의 10개 요소와의 더하기 위해, y의 요소가 차례대로 한번 사용된 후 다시 한번 더 반복되어 사용되었다. (더한 결과의 일의 자리를 살펴보면 이를 확인할 수 있다).다음은 길이가 11인 w 벡터와 길이가 5인 y 벡터를 더한 예이다. 이 경우에도 w의 11개 요소와 대응되기 위해서 y의 전 요소가 두 번 반복되어 이용되고 마지막으로 y의 첫째 요소가 다시 재사용되었음을 볼 수 있다(그림 3.2 참조). 이처럼 두 벡터의 길이가 서로 배수가 아닌 경우에는 혹시 사용자의 착각일 수도 있기 때문에 경고 메시지가 출력된다. 경고 메시지는 오류가 아니므로 계산 수행은 정상적으로 수행된다.\nFigure 3.2: 길이가 다른 벡터의 연산\n사실 길이가 다른 벡터 간의 연산이 가장 빈번히 사용되는 경우는 숫자 하나와 숫자 벡터간의 연산이다. 이 경우 숫자 하나가 벡터의 길이만큼 재사용되어 연산이 이루어진다.Table 3.1: 숫자 벡터를 인수로 하는 함수 예","code":"\nz <- rep(x, times=2)\nz#>  [1]  0 10 20 30 40  0 10 20 30 40\nz + y#>  [1]  1 12 23 34 45  1 12 23 34 45\nw <- c(z, 50)\nw#>  [1]  0 10 20 30 40  0 10 20 30 40 50\nw + y#> Warning in w + y: 두 객체의 길이가 서로 배수관계에 있지 않습니다#>  [1]  1 12 23 34 45  1 12 23 34 45 51\nx <- 1:5\n10 * x#> [1] 10 20 30 40 50\nx + 10#> [1] 11 12 13 14 15\n10/x#> [1] 10.000000  5.000000  3.333333  2.500000  2.000000\nx^2#> [1]  1  4  9 16 25"},{"path":"ch-R-Vectors.html","id":"숫자-벡터를-인수로-하는-함수","chapter":"3 R 벡터","heading":"숫자 벡터를 인수로 하는 함수","text":"숫자 벡터에 사칙연산 등의 수학 연산뿐 아니라, R에서 제공하는 다양한 함수도 적용할 수 있다. 숫자 벡터를 인수로 하는 함수들은 많이 있는데, 그 중 대표적인 함수들을 표 3.1에 제시하였다. 다음은 숫자 벡터에 함수를 적용한 예이다.","code":"\nx <- c(11, 3, 4, 20, 5)\nx#> [1] 11  3  4 20  5\nlength(x)#> [1] 5\nsum(x)#> [1] 43\nmean(x)#> [1] 8.6\nvar(x)#> [1] 50.3\nsd(x)#> [1] 7.092249\nsum( (x - mean(x))^2 ) / ( length(x) - 1 )#> [1] 50.3\nrange(x)#> [1]  3 20\nmin(x)#> [1] 3\nmax(x)#> [1] 20\nmedian(x)#> [1] 5\nwhich.max(x)#> [1] 4\nwhich.min(x)#> [1] 2\nwhich(x > 10 )#> [1] 1 4\nwhich(x > 10 & x < 15)#> [1] 1"},{"path":"ch-R-Vectors.html","id":"벡터의-순서-및-정렬-관련-함수","chapter":"3 R 벡터","heading":"벡터의 순서 및 정렬 관련 함수","text":"R은 벡터 요소들의 크기 순서, 정렬을 해주는 rank(), order(), sort() 함수가 있다. rank() 함수는 벡터 요소의 크기 등수를 작은 것에서 큰 것 순으로 1에서부터 등수를 매겨준다. 즉, rank() 함수 결과의 첫번째 요소는 원래 벡터의 첫번째 요소의 크기 등수이다.\n반면 order() 함수는 작은 것부터 큰 것 순으로 요소의 원래 벡터에서의 위치를 알려준다. 즉, order() 함수 결과의 첫번재 요소는 원래 벡터에서 가장 작은 요소가 어느 위치에 있는지를 알려준다.\n그림 3.3는 앞의 설명을 도식화하여 보여준다.\nFigure 3.3: rank() 함수와 order() 함수의 비교\n","code":"\nrank(x)#> [1] 4 1 2 5 3\nsort(x)#> [1]  3  4  5 11 20\norder(x)#> [1] 2 3 5 1 4"},{"path":"ch-R-Vectors.html","id":"논리-벡터","chapter":"3 R 벡터","heading":"3.2 논리 벡터","text":"R은 숫자뿐 아니라 논리값으로 구성된 벡터를 만들 수 있다. 논리 벡터의 요소들은 TRUE, FALSE, NA (available) 값을 가질 수 있다.","code":""},{"path":"ch-R-Vectors.html","id":"c로-논리-벡터-만들기","chapter":"3 R 벡터","heading":"c()로 논리 벡터 만들기","text":"논리 벡터도 숫자 벡터와 마찬가지로 논리값을 c() 함수로 연결하여 만들 수 있다. 아래 예에서 보듯이 TRUE와 FALSE 대신 혼동의 여지가 없는 경우에는 T와 F 만 입력하여도 TRUE와 FALSE로 인식함을 볼 수 있다.","code":"\na <- c(T, F, T); a#> [1]  TRUE FALSE  TRUE"},{"path":"ch-R-Vectors.html","id":"비교-연산으로-논리-벡터-만들기","chapter":"3 R 벡터","heading":"비교 연산으로 논리 벡터 만들기","text":"논리 벡터는 위의 예처럼 c() 함수로도 만들 수 있지만 많은 경우 벡터의 비교 연산의 결과로서 만들어진다. 다음은 비교 연산을 통해 논리 벡터를 생성한 예이다. ‘<’, ‘<=’, ‘>’, ‘>=’, ‘==’, ‘!=’ 등의 비교 연산이 벡터 요소별로 수행되어 논리 벡터가 생성되었다.","code":"\ny <- 1:5\ny > 3#> [1] FALSE FALSE FALSE  TRUE  TRUE\ny >= 3#> [1] FALSE FALSE  TRUE  TRUE  TRUE\ny < 5#> [1]  TRUE  TRUE  TRUE  TRUE FALSE\ny <= 5#> [1] TRUE TRUE TRUE TRUE TRUE\ny == 2#> [1] FALSE  TRUE FALSE FALSE FALSE\ny != 2#> [1]  TRUE FALSE  TRUE  TRUE  TRUE"},{"path":"ch-R-Vectors.html","id":"논리-연산으로-논리-벡터-만들기","chapter":"3 R 벡터","heading":"논리 연산으로 논리 벡터 만들기","text":"기존 논리 벡터들에 대해 논리 연산을 수행하여 새로운 논리 벡터를 만들 수도 있다. 다음은 ‘&’, ‘’, ‘!’ 등의 논리 연산자를 이용하여 논리 벡터에 대해 , , 연산을 수행한 예이다.","code":"\nb <- !a; b#> [1] FALSE  TRUE FALSE\na & b#> [1] FALSE FALSE FALSE\na | b#> [1] TRUE TRUE TRUE"},{"path":"ch-R-Vectors.html","id":"논리-벡터-함수-any와-all","chapter":"3 R 벡터","heading":"논리 벡터 함수: any()와 all()","text":"논리 연산은 아니지만 논리 벡터에 자주 사용되는 함수가 ()와 () 함수이다. 이 함수를 이용하면 논리 벡터의 논리값 중 하나라도 TRUE가 있는지 또는 모든 논리값이 TRUE인지를 확인할 수 있다.()와 ()을 비교 연산자와 함께 이용하면 어떤 조건을 만족하는 요소가 벡터에 하나라도 있는지 또는 모든 요소가 조건을 만족하는지를 쉽게 확인할 수 있다.\nFigure 3.4: ifelse() 함수 연산\n","code":"\nany( c(F, F, F) )#> [1] FALSE\nany( c(F, F, T) )#> [1] TRUE\nall( c(T, F, T) )#> [1] FALSE\nall( c(T, T, T) )#> [1] TRUE\ncars$dist#>  [1]   2  10   4  22  16  10  18  26  34  17  28  14  20  24  28  26  34  34  46\n#> [20]  26  36  60  80  20  26  54  32  40  32  40  50  42  56  76  84  36  46  68\n#> [39]  32  48  52  56  64  66  54  70  92  93 120  85\nany(cars$dist > 100)#> [1] TRUE\nany(cars$dist > 200)#> [1] FALSE\nall(cars$dist > 5)#> [1] FALSE\nall(cars$dist > 0) # for checking data errors#> [1] TRUE"},{"path":"ch-R-Vectors.html","id":"논리-벡터-함수-ifelse","chapter":"3 R 벡터","heading":"논리 벡터 함수: ifelse()","text":"ifelse() 함수는 논리 벡터를 이용하는 또 다른 벡터 연산 함수이다. ifelse(x, , b)로 호출되는데, x에는 논리 벡터, a와 b에는 (원칙적으로는) x의 길이와 동일한 벡터가 부여된다. ifelse() 함수는 x의 요소가 TRUE인 경우에는 벡터 a의 요소를, FALSE인 경우에는 벡터 b의 요소를 선택하여 x와 길이가 동일한 새로운 벡터를 만들어 낸다. 그림 3.4은 다음 예처럼 벡터가 1:5, b 벡터가 -1:-5일 때, x 벡터의 논리값에 따라 a와 b의 요소 중 어떤 요소가 선택되어 새로운 벡터가 만들어지는지를 보여준다.ifelse()의 첫번째 인수로 논리 벡터가 직접 부여되기보다는 비교 연산의 결과가 부여되는 경우가 많다. 다음은 벡터 y에서 양수인 요소는 그대로 두고, 0이하인 요소는 0이 되도록 하여 새로운 벡터를 만든 예이다.위의 결과가 나온 이유는 다음과 같다.\n첫번째 x 인수에 y와 0을 비교하는 연산이 들어갔다. 이 비교 연산은 다음과 같이 y보다 큰 요소에만 TRUE를 주는 논리값 벡터를 반환한다.두번째 인수에는 y가 부여되었으므로로 위의 비교 연산에서 TRUE가 된 위치에는 y 요소가 선택된다. 그리고 세번째 b 인수에는 0이 들어갔다. x 위치에 들어간 벡터의 요소가 5개인데, b 위치에 들어간 벡터는 요소가 1개이므로 숫자 벡터의 연산에서와 마찬가지로 0이 5번 재사용된다. 그러므로 x의 값이 FALSE인 위치에 0이 들어가게 된다 (그림 3.5 참조).\nFigure 3.5: ifelse() 함수 연산에서의 벡터 재사용\n","code":"\nx <- c(T, F, F, T, F)\na <- 1:5\nb <- -1:-5\ny <- ifelse(x, a, b); y#> [1]  1 -2 -3  4 -5\nifelse(y > 0, y, 0)#> [1] 1 0 0 4 0\ny > 0#> [1]  TRUE FALSE FALSE  TRUE FALSE"},{"path":"ch-R-Vectors.html","id":"문자-벡터","chapter":"3 R 벡터","heading":"3.3 문자 벡터","text":"문자 벡터는 문자를 요소로 하는 벡터이다. 범주형 데이터를 다루거나 데이터에 이름을 부여할 때 자주 이용된다.","code":""},{"path":"ch-R-Vectors.html","id":"문자-벡터-만들기","chapter":"3 R 벡터","heading":"문자 벡터 만들기","text":"문자 벡터의 생성은 숫자나 논리 벡터처럼 c() 함수를 이용하여 생성할 수 있다.숫자나 논리 벡터를 .character() 함수를 이용하여 문자 벡터로 변환할 수도 있다. 다음 예에서 n은 숫자 벡터로 따옴표 없이 값이 표시되고, num은 문자 벡터로 모든 요소가 따옴표로 둘러싸여 표시됨을 확인한다.","code":"\nstudents <- c(\"길동\", \"철수\", \"Tom\")\nstudents#> [1] \"길동\" \"철수\" \"Tom\"\nn <- 1:3\nn#> [1] 1 2 3\nnum <- as.character(n)\nnum#> [1] \"1\" \"2\" \"3\""},{"path":"ch-R-Vectors.html","id":"paste로-문자-벡터-연결하기","chapter":"3 R 벡터","heading":"paste()로 문자 벡터 연결하기","text":"문자 벡터에 많이 사용되는 연산 중 하나가 문자 벡터를 요소끼리 서로 연결시키는 연산이다. paste() 함수로 이러한 문자 벡터 연결을 수행할 수 있는데, 호출 시 sep 인수를 사용하지 않으면 연결되는 벡터의 요소는 공백으로 연결되고, sep 인수가 사용되면 sep 인수에 부여된 문자열이 연결되는 요소 사이에 구분자로 들어간다.마지막 예에서 문자 벡터의 길이가 다르면 숫자 벡터의 연산처럼 길이가 짧은 벡터의 요소가 재사용됨을 볼 수 있다. 또 paste() 적용시 숫자 벡터가 자동으로 문자 벡터로 변환되어 연결되었음을 볼 수 있다.paste() 함수는 세 개 이상의 문자 벡터를 연결하는 데에도 사용될 수 있다.","code":"\npaste(students, num)#> [1] \"길동 1\" \"철수 2\" \"Tom 3\"\npaste(students, num, sep=\"\")#> [1] \"길동1\" \"철수2\" \"Tom3\"\npaste(students, num, sep=\"-\")#> [1] \"길동-1\" \"철수-2\" \"Tom-3\"\npaste(students, 1:2)#> [1] \"길동 1\" \"철수 2\" \"Tom 1\"\npaste(students, num, c(\"A\", \"B\", \"C\"), \"!\")#> [1] \"길동 1 A !\" \"철수 2 B !\" \"Tom 3 C !\""},{"path":"ch-R-Vectors.html","id":"strsplit로-문자-벡터-분리하기","chapter":"3 R 벡터","heading":"strsplit()로 문자 벡터 분리하기","text":"paste()와 반대의 역할을 하는 함수가 strsplit()이다. strsplit()는 paste()와는 달리 문자열을 나눌 때 구분자로 사용할 문자열을 split 인수로 반드시 제공해야 한다. 마지막 예에서 x와 split의 요소가 같은 위치끼리 적용되어 문자열 분리가 수행되었음을 확인할 수 있다.","code":"\nx <- c(\"2015-3-15 10:12:12\", \"2016-10-11 11:12:13\", \n       \"2014-7-8 02:03:04\")\nstrsplit(x, split=\" \")#> [[1]]\n#> [1] \"2015-3-15\" \"10:12:12\" \n#> \n#> [[2]]\n#> [1] \"2016-10-11\" \"11:12:13\"  \n#> \n#> [[3]]\n#> [1] \"2014-7-8\" \"02:03:04\"\nstrsplit(x, split=\"-\")#> [[1]]\n#> [1] \"2015\"        \"3\"           \"15 10:12:12\"\n#> \n#> [[2]]\n#> [1] \"2016\"        \"10\"          \"11 11:12:13\"\n#> \n#> [[3]]\n#> [1] \"2014\"       \"7\"          \"8 02:03:04\"\nstrsplit(x, split=\":\")#> [[1]]\n#> [1] \"2015-3-15 10\" \"12\"           \"12\"          \n#> \n#> [[2]]\n#> [1] \"2016-10-11 11\" \"12\"            \"13\"           \n#> \n#> [[3]]\n#> [1] \"2014-7-8 02\" \"03\"          \"04\"\nstrsplit(x, split=c(\"-\", \":\", \" \"))#> [[1]]\n#> [1] \"2015\"        \"3\"           \"15 10:12:12\"\n#> \n#> [[2]]\n#> [1] \"2016-10-11 11\" \"12\"            \"13\"           \n#> \n#> [[3]]\n#> [1] \"2014-7-8\" \"02:03:04\""},{"path":"ch-R-Vectors.html","id":"nchar로-문자수-세기","chapter":"3 R 벡터","heading":"nchar()로 문자수 세기","text":"nchar() 함수는 문자 벡터의 각 요소의 문자 개수를 알려 준다. 공백도 문자이므로 문자 개수를 셀 때 포함이 된다는데 주의한다.Table 3.2: 문자 벡터를 인수로 하는 함수 예이외에도 다양한 문자 벡터 함수가 존재한다. 그 중 대표적인 함수를 표 3.2에 제시하였다.","code":"nchar(\"날짜\")#> [1] 2a <- c(\"날짜\", \"day\", \"date\", \"날짜와 시간\")\nnchar(a)#> [1] 2 3 4 6"},{"path":"ch-R-Vectors.html","id":"결측치-missing-values","chapter":"3 R 벡터","heading":"3.4 결측치 (Missing Values)","text":"","code":""},{"path":"ch-R-Vectors.html","id":"na","chapter":"3 R 벡터","heading":"NA","text":"R에서는 데이터에 결측치가 있을 때 이를 NA 값으로 표시한다. 예를 들어 5명의 학생의 키 데이터가 있는데 마지막 학생의 데이터를 얻지 못하였다면, 그 학생의 데이터는 NA로 값을 입력한다.","code":""},{"path":"ch-R-Vectors.html","id":"is.na와-na.omit","chapter":"3 R 벡터","heading":"is.na()와 na.omit()","text":".na() 함수를 이용하면 결측치의 포함 여부나 위치를 확인할 수 있다. .na()는 벡터에서 결측치가 있는 위치는 TRUE, 결측치가 아닌 위치는 FALSE로 하는 논리 벡터를 결과로 반환한다. na.omit() 함수를 이용하면 결측치를 제외한 벡터를 만들 수 있다. na.omit()에 대한 자세한 설명은 도움말을 참조하기 바란다.","code":"\nz <- c(11:13, NA)\nz#> [1] 11 12 13 NA\nis.na(z)#> [1] FALSE FALSE FALSE  TRUE\nna.omit(z)#> [1] 11 12 13\n#> attr(,\"na.action\")\n#> [1] 4\n#> attr(,\"class\")\n#> [1] \"omit\""},{"path":"ch-R-Vectors.html","id":"na.rm-인수","chapter":"3 R 벡터","heading":"na.rm 인수","text":"숫자 벡터에 결측치가 있으면 sum()이나 mean() 함수 등의 결과는 NA로 출력된다. 숫자 벡터에 결측치가 있기 때문에 합이나 평균을 알 수 없다는 의미이다. 만약 결측치를 제외하고 합이나 평균을 구하고 싶으면, 이들 함수를 호출할 때 na.rm=TRUE 인수를 추가하여야 한다. 그러면 결측치를 제외하고 해당 결과를 계산하게 할 수 있다.","code":"\nsum(z)#> [1] NA\nsum(z, na.rm=TRUE)#> [1] 36"},{"path":"ch-R-Vectors.html","id":"nan","chapter":"3 R 벡터","heading":"NaN","text":"결측치는 아니지만 데이터의 값을 결정할 수 없는 경우가 있다. 대표적인 경우가 0에서 0을 나누는 경우이다. 이 경우 숫자 연산의 결과를 결정할 수 없으므로 NaN(Number)로 결과를 표현된다. 주의할 점은 R은 무한대도 숫자로 간주하므로, 무한대의 결과가 나올 때는 Inf로 결과를 표현한다. 다음 예에서 앞의 두 계산은 무한대로, 뒤의 두 계산은 값을 결정할 수 없어 NaN로 결과를 반환함을 볼 수 있다.","code":"\n1/0#> [1] Inf\nInf * 5#> [1] Inf\n0/0#> [1] NaN\nInf - Inf#> [1] NaN"},{"path":"ch-R-Vectors.html","id":"is.nan","chapter":"3 R 벡터","heading":"is.nan()","text":"벡터에 NaN가 포함되어 있는지를 확인하려면 .nan() 함수를 사용하면 된다. .na()와 마찬가지로 NaN 요소가 있는 위치를 TRUE 값으로 하는 논리 벡터를 반환한다. 다음 예에서 보듯이 NaN가 포함되었는지를 정확히 알기 위해서는 .na()가 아니라 .nan() 함수를 실행하여야 한다. 왜냐하면 .na() 함수는 NaN뿐 아니라 NA도 TRUE로 반환하기 때문이다.통계 데이터에는 결측치가 자주 발생한다. 그리고 결측치 처리는 통계 분석에서 매우 중요한 문제 중 하나이다. R에서 결측치를 처리하는 다양한 기법에 대해서는 R Action2의 18장을 참조하기 바란다.","code":"\nz <- -1:1 / 0\nz#> [1] -Inf  NaN  Inf\nis.na(z)#> [1] FALSE  TRUE FALSE\nr <- c(z, NA)\nis.na(r)#> [1] FALSE  TRUE FALSE  TRUE\nis.nan(r)#> [1] FALSE  TRUE FALSE FALSE"},{"path":"ch-R-Vectors.html","id":"인덱스-벡터와-필터링","chapter":"3 R 벡터","heading":"3.5 인덱스 벡터와 필터링","text":"데이터를 분석하다 보면, 데이터의 특정 요소만 추출하여 분석해 보고 싶을 때가 있다. 40세 이상의 고객만 추출하여 분석한다든지, 남자 학생에 대해서만 별도의 분석을 하는 경우가 그러한 예라고 할 수 있다. 이렇게 데이터에서 특정 부분만 추출하여 새로운 데이터를 만드는 작업을 필터링(filtering)이라고 한다.벡터 필터링은 특정 벡터에서 특정 요소만을 추출하는 것을 의미한다. R에서 벡터 필터링은 인덱스 벡터를 이용하여 수행된다.\n여기서 인덱스란 벡터에서 특정 요소의 위치를 의미한다. 예를 들어 5개의 요소로 구성된 벡터에서 두번째 요소를 추출하려면 두번째라는 위치가 그 요소의 인덱스가 된다.\n그런데 어떤 벡터에서 추출하고자 하는 요소가 여러 개일 수도 있다. 이 경우 추출해야할 위치를 여러 개 나열해야 하고, 이렇게 나열한 요소의 위치 정보를 인덱스 벡터라고 한다.\n물론 하나의 요소만 추출하고자 한다면 인덱스 벡터는 길이가 1이 될 것이다.벡터 필터링을 하려면 다음처럼 벡터의 이름 다음에 인덱스 벡터를 대괄호 안에 기술하면 된다.인덱스 벡터는 자연수 벡터, 음의 정수 벡터, 논리 벡터, 이름 벡터의 네 가지 형태를 가질 수 있다. 이를 각각 살펴보도록 하자.","code":"\nvector[index_vector]"},{"path":"ch-R-Vectors.html","id":"자연수-인덱스-벡터","chapter":"3 R 벡터","heading":"3.5.1 자연수 인덱스 벡터","text":"자연수 인덱스는 추출할 요소의 위치를 자연수로 표현한다. 벡터의 첫번째 요소의 위치는 1로, 두번째 요소의 위치는 2로 하여, 요소의 위치를 차례대로 1부터 벡터 길이까지의 자연수로 표현한다. 아래 예는 10개의 요소로 이루어진 벡터 x에서 자연수 인덱스 벡터로 새로운 벡터를 추출한 예이다(그림 3.6 참조). 마지막 예처럼 인덱스 벡터에서 자연수가 반복되면 해당 위치에 있는 요소가 반복되어 추출됨을 볼 수 있다.\nFigure 3.6: 자연수 인덱스 벡터를 이용한 벡터 필터링\n인덱스 벡터를 사용하여 여러 요소를 뽑을 때 주의할 점이 있다. 벡터의 필터링에서 대괄호 안에는 오직 하나의 인덱스 벡터만 기술될 수 있다는 것이다. 만약 2개 이상의 요소를 뽑아야 한다면, c() 등으로 연결하여 하나의 인덱스 벡터로 만든 후 대괄호에 넣어야 한다. 만약 이를 실수하여 다음처럼 뽑을 요소를 각각 기술하게 되면 오류가 발생한다.앞의 예에서는 6이라는 요소를 하나만 가지는 벡터 하나와, 10이라는 요소 하나만 가지는 또 다른 벡터를 대괄호 안에 기술한 것이다. 벡터는 일차원 구조로 오직 한 개의 인덱스 벡터를 입력 받으므로, 위의 경우는 c(6, 10)으로 하나의 벡터로 결합하여 인덱스 벡터를 전달해야 한다. 행렬에서는 두 개의 인덱스 벡터를 입력받게 되는데, 이 형식과 벡터의 인덱스 벡터를 혼동하지 않아야 한다.추출해야 할 요소를 사용자가 직접 지정할 수도 있지만, 어떤 경우에는 함수를 이용하여 원하는 요소를 특정할 수도 있다. 예를 들어 .min() 함수는 숫자 벡터의 최소값의 위치를 자연수 인덱스 형식으로 반환한다. 따라서 .min() 결과를 인덱스 벡터로 이용하면 해당 벡터의 최소값을 추출할 수 있다. 자연수 인덱스 벡터로 많이 사용되는 함수 중 하나가 order() 함수이다. order() 함수는 크기 순으로 벡터 요소의 위치를 반환해 주는 함수이다. 이 함수의 결과를 인덱스 벡터로 사용하면 벡터의 요소를 크기로 정렬하는 효과가 발생한다.","code":"\nx <- 11:20\nx[6]#> [1] 16\nx[c(6, 10)]#> [1] 16 20\nx[seq(3, 9, by=2)]#> [1] 13 15 17 19\nx[rep(c(2,4), times=3)]#> [1] 12 14 12 14 12 14\nx[6, 10]#> Error in x[6, 10]: incorrect number of dimensions\nx <- c(7, 9, 4, 6, 13, 4, 1, 11)\nx[which.min(x)]  # You can use min() instead.#> [1] 1\nx[which.max(x)] # You can use max() instead.#> [1] 13\nx[which(x > 10)] # You can use a logical index vector instead.#> [1] 13 11\nx[order(x)] # You can use sort() instead.#> [1]  1  4  4  6  7  9 11 13"},{"path":"ch-R-Vectors.html","id":"음의-정수-인덱스-벡터","chapter":"3 R 벡터","heading":"3.5.2 음의 정수 인덱스 벡터","text":"자연수 인덱스가 추출한 요소의 위치를 표현한다면, 음의 정수 인덱스는 추출하지 않은 요소의 위치를 표현한다. 따라서 벡터 필터링에 음의 정수 인덱스 벡터가 사용되면, 데이터 벡터에서 해당 위치의 요소가 제외된 나머지 요소로 새로운 벡터를 만들어 반환한다. 예를 들어 인덱스 벡터가 -2라면 원래 벡터의 2번째 요소만 제외한 나머지 요소로 이루어진 벡터가 반환된다(그림 3.7 참조).\nFigure 3.7: 음의 정수 인덱스 벡터를 이용한 벡터 필터링\n","code":"\nx <- 11:20; x#>  [1] 11 12 13 14 15 16 17 18 19 20\nx[-2]#> [1] 11 13 14 15 16 17 18 19 20\nx[c(-2, -4)]#> [1] 11 13 15 16 17 18 19 20\nx[-(3:6)]#> [1] 11 12 17 18 19 20"},{"path":"ch-R-Vectors.html","id":"논리-인덱스-벡터","chapter":"3 R 벡터","heading":"3.5.3 논리 인덱스 벡터","text":"논리 인덱스는 추출할 요소는 TRUE, 추출하지 않을 요소는 FALSE로 표시한다.\n인덱스 벡터가 논리 벡터로 주어지면 데이터 벡터에서 TRUE 위치의 요소만 선택되어 새로운 벡터가 만들어진다. 다음 예와 그림 3.8은 논리 인덱스 벡터가 벡터 필터링에 어떻게 사용되는지를 보여준다.\nFigure 3.8: 논리값 인덱스 벡터를 이용한 벡터 필터링\n위의 예처럼 사용자가 직접 추출할 요소를 TRUE로 직접 기술하여 논리 인덱스 벡터를 제공할 수도 있지만, 더 많은 경우는 추출할 조건을 비교 연산 표현식으로 제공하는 경우가 더 많다(그림 3.8 참조).다음처럼 논리 인덱스 벡터가 데이터 벡터의 길이보다 작으면 인덱스 벡터가 재사용되어 벡터 필터링이 이루어진다.","code":"\nx <- 1:5\ny <- c(T, F, T, T, F)\nx[y]#> [1] 1 3 4\nx > 3#> [1] FALSE FALSE FALSE  TRUE  TRUE\nx[x>3]#> [1] 4 5\nx >3 & x <5#> [1] FALSE FALSE FALSE  TRUE FALSE\nx[x >3 & x <5]#> [1] 4\ny <- c(TRUE, FALSE)\nx[y]#> [1] 1 3 5"},{"path":"ch-R-Vectors.html","id":"이름-인덱스-벡터","chapter":"3 R 벡터","heading":"3.5.4 이름 인덱스 벡터","text":"R에선 벡터의 각 요소에 이름을 부여할 수 있다. 이름 인덱스 벡터는 추출할 요소의 위치를 벡터 요소의 이름으로 지정하는 방식이다.\n벡터 요소의 이름은 names() 함수로 확인하거나 할당할 수 있다. 벡터의 요소에 이름을 부여하면, 벡터가 출력될 때 데이터의 값뿐 아니라 요소의 이름도 함께 출력이 된다.\n다음은 names() 함수를 이용하여 animals라는 숫자 벡터의 각 요소에 이름을 부여한 후, 이름 인덱스 벡터로 요소들을 추출한 예이다.","code":"\nanimals <- c(5, 7, 3, 2)\nnames(animals) <- c(\"cats\", \"dogs\", \"camels\", \"donkeys\")\nanimals#>    cats    dogs  camels donkeys \n#>       5       7       3       2\nanimals[\"camels\"]#> camels \n#>      3\nanimals[c(\"dogs\",\"donkeys\")]#>    dogs donkeys \n#>       7       2"},{"path":"ch-R-Vectors.html","id":"인덱스-벡터를-이용해-벡터-요소에-값-할당하기","chapter":"3 R 벡터","heading":"3.5.5 인덱스 벡터를 이용해 벡터 요소에 값 할당하기","text":"지금까지는 인덱스 벡터를 이용하여 필요한 요소를 추출하는 방법에 대하여 살펴보았다. 그런데 인덱스 벡터를 이용하여 데이터 벡터의 특정 요소에만 값을 할당할 수도 있다. 다음은 숫자 인덱스 벡터를 이용하여 벡터의 특정 요소에 값을 할당한 예이다.다음은 논리 인덱스 벡터를 이용하여 결측치가 있는 데이터에 결측치 대신 0을 넣는 예이다. .na() 함수는 결측치가 있는 위치를 TRUE로 하는 논리값 벡터를 반환하므로, 이 결과를 인덱스 벡터로 하면 결측치가 있는 위치만 지정됨을 알 수 있다.다음은 논리 인덱스 벡터를 이용하여 숫자 벡터의 요소를 모두 양수로 바꾸는 예이다.","code":"\na <- 1:5; a#> [1] 1 2 3 4 5\na[2] <- 20; a#> [1]  1 20  3  4  5\na[c(3, 5)] <- c(100, 300); a#> [1]   1  20 100   4 300\na[c(1, 3, 5)] <- -5; a#> [1] -5 20 -5  4 -5\na[-1] <- 0; a#> [1] -5  0  0  0  0\nx <- c(NA, 2:4, NA)\nx#> [1] NA  2  3  4 NA\nx[is.na(x)] <- 0\nx#> [1] 0 2 3 4 0\ny <- c(-2, 0, 4, -7, 8)\ny[y<0] <- -y[y<0]\ny#> [1] 2 0 4 7 8"},{"path":"ch-R-Matrix.html","id":"ch-R-Matrix","chapter":"4 R 행렬","heading":"4 R 행렬","text":"벡터보다 조금 더 복잡한 데이터 구조가 행렬과 배열이다. 행렬과 배열은 벡터처럼 모든 요소가 동일한 데이터의 타입을 가져야 한다.","code":""},{"path":"ch-R-Matrix.html","id":"행렬과-배열은-다차원적-데이터-구조이다.","chapter":"4 R 행렬","heading":"행렬과 배열은 다차원적 데이터 구조이다.","text":"지금까지 배운 벡터는 일차원적인 데이터 구조였다. 벡터의 길이가 50이라면 벡터의 각 요소의 위치는 \\(1, 2, \\ldots, 50\\)까지 하나의 숫자로 특정할 수 있다. 반면 행렬과 배열은 다차원적인 데이터 구조이다. 행렬은 2차원적 데이터 구조로 행과 열로 구성된다. 행렬의 각 요소의 위치는 어떤 행과 어떤 열에 포함되는지를 나타내는 두 개의 숫자로 특정할 수 있다. 배열은 행렬을 일반화한 것으로 다차원적인 데이터 구조이다. 예로 3차원 배열은 세 개의 숫자에 의해 데이터의 위치를 특정할 수 있다.","code":""},{"path":"ch-R-Matrix.html","id":"행렬-만들기","chapter":"4 R 행렬","heading":"4.1 행렬 만들기","text":"","code":""},{"path":"ch-R-Matrix.html","id":"행렬의-필요성","chapter":"4 R 행렬","heading":"행렬의 필요성","text":"행렬의 예로 다음을 고려해 보자. 어떤 강의의 수강생을 성별, 학년의 두 가지 기준으로 분류한다고 해 보자. 그러면 표 4.1 같은 형식으로 데이터를 정리할 수 있을 것이다. 이와 같이 두 범주형 변수에 대해 관측도수를 요약한 표를 교차표(cross table) 또는 분할표라고 한다.Table 4.1: 어떤 과목의 수강생 분할표표 4.1 같은 데이터는 일차원적인 벡터 형태로 데이터를 저장하면 각 데이터 요소가 어떤 의미를 갖는지 파악하기가 쉽지 않다. 이러한 경우에는 2차원으로 구성된 행렬을 이용하는 것이 좋다.행렬을 만드는 방법은 (1) 벡터를 행렬로 변환시키는 방법과 (2) 벡터를 결합하여 행렬을 만드는 방법이 있다. 이 절에서는 벡터를 행렬로 변환시키는 방법부터 살펴보자.","code":""},{"path":"ch-R-Matrix.html","id":"matrix","chapter":"4 R 행렬","heading":"matrix()","text":"matrix() 함수를 이용하면 데이터 벡터를 데이터 행렬로 변환시킬 수 있다. 다음의 예를 보면서 설명해 보자.위 예에서 n은 1부터 10까지 숫자를 가진 벡터이다. matrix() 함수의 첫 인수로 행렬로 바꿀 벡터를 주고, nrow 인수에 새로 만들 행렬의 행 수를 주면 행렬이 만들어짐을 볼 수 있다. 이렇게 만들어진 행렬 m은 크기가 \\(2 \\times 5\\) 인 행렬이 된다. 왜냐하면 전체 데이터의 수는 10개인데 2 개의 행이 지정되었으므로 모두 5개의 열이 있어야 모든 데이터를 수용할 수 있기 때문이다.","code":"\nn <- 1:10\nn#>  [1]  1  2  3  4  5  6  7  8  9 10\nm <- matrix(n, nrow=2, ncol=5)\nm#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    3    5    7    9\n#> [2,]    2    4    6    8   10\nm <- matrix(n, nrow=2)"},{"path":"ch-R-Matrix.html","id":"matrix는-열을-순서대로-채워나간다.","chapter":"4 R 행렬","heading":"matrix()는 열을 순서대로 채워나간다.","text":"벡터의 요소는 차례대로 1열의 1행을 채우고 2행을 채운다. 그리고 난 후 2열의 모든 행을 순서대로 채운다. 이러한 방식으로 차례차례 모든 열의 데이터를 채워 나감을 볼 수 있다. 만약 열이 아니라 행을 차례대로 채워나가면서 행렬을 만드고 싶으면 byrow=TRUE 인수를 사용하면 된다.","code":"\nmatrix(n, nrow=2, ncol=5, byrow=T)#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    2    3    4    5\n#> [2,]    6    7    8    9   10"},{"path":"ch-R-Matrix.html","id":"행렬과-dim-속성","chapter":"4 R 행렬","heading":"행렬과 dim 속성","text":"원래의 벡터 n과 벡터로 만들어진 행렬 m의 속성을 보기 위해 attributes() 함수를 이용하자. 벡터 n에는 아무 속성도 부여되지 않았지만 행렬 m은 차원을 의미하는 dim 속성이 부여되었음을 볼 수 있다. dim 속성에는 길이가 2인 숫자 벡터가 부여되어 있는데, 첫번째 요소는 행의 개수, 두번째 요소는 열의 개수를 나타낸다.matrix()로 벡터를 행렬로 변환시킬 때 행의 개수 대신 열의 개수를 지정할 수도 있다. 이 경우 nrow 대신 ncol 인수를 사용하면 된다. 아래 예에서는 열의 개수를 2로 지정하였으므로 행렬 m은 크기가 \\(5 \\times 2\\)인 행렬이 되었음을 볼 수 있다. 이는 dim 속성에서도 확인할 수 있다.","code":"\nattributes(n)#> NULL\nattributes(m)#> $dim\n#> [1] 2 5\nm <- matrix(n, nrow=5, ncol=2)\nm#>      [,1] [,2]\n#> [1,]    1    6\n#> [2,]    2    7\n#> [3,]    3    8\n#> [4,]    4    9\n#> [5,]    5   10\nattributes(m)#> $dim\n#> [1] 5 2"},{"path":"ch-R-Matrix.html","id":"벡터-출력-vs.-행렬-출력","chapter":"4 R 행렬","heading":"벡터 출력 vs. 행렬 출력","text":"행렬 m을 출력한 내용을 보면 벡터와는 다름을 볼 수 있다. 먼저 벡터는 데이터를 R 콘솔의 모든 줄을 차례대로 채우면서 출력하고, 줄이 바뀔 때마다 각 줄의 첫 요소가 벡터의 몇 번째 데이터인지를 [] 형태로 보여준다. 반면 행렬은 행과 열의 개수에 맞추어 출력시킬 뿐 아니라 [,j] 형태로 데이터의 위치를 보여준다.","code":""},{"path":"ch-R-Matrix.html","id":"matrix에서-벡터-재사용","chapter":"4 R 행렬","heading":"matrix()에서 벡터 재사용","text":"matrix() 함수를 이용하여 행렬을 만들 때 행과 열의 크기를 모두 지정할 수 있다. 만약 벡터의 크기가 행렬의 요소 개수보다 적으면 벡터가 재사용된다. 반대로 벡터의 크기가 행렬의 요소 개수보다 크거나 배수가 되지 않으면 경고 메시지가 출력되고 행렬을 만드는 데는 앞에 있는 벡터 요소들만 사용된다.","code":"\nm <- matrix(1:9, nrow=3, ncol=3)\nm#>      [,1] [,2] [,3]\n#> [1,]    1    4    7\n#> [2,]    2    5    8\n#> [3,]    3    6    9\nm <- matrix(1, nrow=3, ncol=3)\nm#>      [,1] [,2] [,3]\n#> [1,]    1    1    1\n#> [2,]    1    1    1\n#> [3,]    1    1    1\nm <- matrix(1:3, nrow=3, ncol=3)\nm#>      [,1] [,2] [,3]\n#> [1,]    1    1    1\n#> [2,]    2    2    2\n#> [3,]    3    3    3\nm <- matrix(11:30, nrow=3, ncol=3)#> Warning in matrix(11:30, nrow = 3, ncol = 3): 데이터의 길이[20]가 행의 개수[3]의\n#> 배수가 되지 않습니다\nm#>      [,1] [,2] [,3]\n#> [1,]   11   14   17\n#> [2,]   12   15   18\n#> [3,]   13   16   19"},{"path":"ch-R-Matrix.html","id":"벡터를-결합하여-행렬-만들기","chapter":"4 R 행렬","heading":"4.2 벡터를 결합하여 행렬 만들기","text":"","code":""},{"path":"ch-R-Matrix.html","id":"cbind와-rbind","chapter":"4 R 행렬","heading":"cbind()와 rbind()","text":"기존의 벡터나 행렬을 열이나 행으로 묶어서 새로운 행렬을 만들 수 있다. 아래 예는 벡터를 cbind()와 rbind() 함수를 이용하여 열 또는 행으로 묶은 경우이다.","code":"\ncbind(1:5, 10:6)#>      [,1] [,2]\n#> [1,]    1   10\n#> [2,]    2    9\n#> [3,]    3    8\n#> [4,]    4    7\n#> [5,]    5    6\nrbind(1:5, 10:6, 11:15)#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    2    3    4    5\n#> [2,]   10    9    8    7    6\n#> [3,]   11   12   13   14   15"},{"path":"ch-R-Matrix.html","id":"벡터벡터-벡터행렬-행렬행렬-결합","chapter":"4 R 행렬","heading":"벡터+벡터, 벡터+행렬, 행렬+행렬 결합","text":"벡터들만 연결하여 행렬을 만드는 것이 아니라, 행렬과 벡터 또는 행렬과 행렬을 행 또는 열로 묶어 새로운 행렬을 만들 수 있다.","code":"\nA <- matrix(1:9, nrow=3, ncol=3)\ncbind(A, 10:12)#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    4    7   10\n#> [2,]    2    5    8   11\n#> [3,]    3    6    9   12\nrbind(10:12, A)#>      [,1] [,2] [,3]\n#> [1,]   10   11   12\n#> [2,]    1    4    7\n#> [3,]    2    5    8\n#> [4,]    3    6    9\ncbind(A, A)#>      [,1] [,2] [,3] [,4] [,5] [,6]\n#> [1,]    1    4    7    1    4    7\n#> [2,]    2    5    8    2    5    8\n#> [3,]    3    6    9    3    6    9\nt <- rbind(A, 10:12)\nt#>      [,1] [,2] [,3]\n#> [1,]    1    4    7\n#> [2,]    2    5    8\n#> [3,]    3    6    9\n#> [4,]   10   11   12\nrbind(A, t)#>      [,1] [,2] [,3]\n#> [1,]    1    4    7\n#> [2,]    2    5    8\n#> [3,]    3    6    9\n#> [4,]    1    4    7\n#> [5,]    2    5    8\n#> [6,]    3    6    9\n#> [7,]   10   11   12\ncbind(A, t)#> Error in cbind(A, t): 각각의 행렬이 가진 행의 개수는 반드시 서로 일치해야 합니다 (인자 2를 참고하세요)"},{"path":"ch-R-Matrix.html","id":"행렬행렬-연결은-행-또는-열의-수가-같아야-한다.","chapter":"4 R 행렬","heading":"행렬+행렬 연결은 행 또는 열의 수가 같아야 한다.","text":"마지막 예에서 볼 수 있듯이 행렬을 cbind 할 때는 행의 수가 같아야 하며, rbind를 할 때에는 열의 수가 일치하여야 한다. 하지만 벡터의 경우에는 가장 긴 길이에 맞추어 요소가 재사용된다.","code":"\nA <- cbind(1:6, 7:9)\nA#>      [,1] [,2]\n#> [1,]    1    7\n#> [2,]    2    8\n#> [3,]    3    9\n#> [4,]    4    7\n#> [5,]    5    8\n#> [6,]    6    9\ncbind(A, 10:11)#>      [,1] [,2] [,3]\n#> [1,]    1    7   10\n#> [2,]    2    8   11\n#> [3,]    3    9   10\n#> [4,]    4    7   11\n#> [5,]    5    8   10\n#> [6,]    6    9   11\nrbind(1, 1:5)#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    1    1    1    1\n#> [2,]    1    2    3    4    5"},{"path":"ch-R-Matrix.html","id":"행렬의-필터링","chapter":"4 R 행렬","heading":"4.3 행렬의 필터링","text":"","code":""},{"path":"ch-R-Matrix.html","id":"행과-열-인덱스-벡터","chapter":"4 R 행렬","heading":"행과 열 인덱스 벡터","text":"벡터와 마찬가지로 행렬도 인덱스 벡터에 의해 필터링을 할 수 있다. 벡터는 오직 한 개의 인덱스 벡터를 가지는데, 행렬은 2차원인 만큼 각 차원을 지정할 수 있도록 2개의 인덱스 벡터를 가진다. 첫번째 인덱스 벡터는 추출할 행의 위치를, 두번째 인덱스 벡터는 추출할 열의 위치를 지정하게 된다. 벡터와 마찬가지로 행렬도 자연수, 음의 정수, 논리, 이름 인덱스 벡터를 가질 수 있다.","code":""},{"path":"ch-R-Matrix.html","id":"자연수-인덱스-벡터-1","chapter":"4 R 행렬","heading":"자연수 인덱스 벡터","text":"아래는 1부터 25까지의 숫자를 크기 \\(5 \\times 5\\)인 행렬로 만든 후 인덱스 벡터로 각 데이터 요소를 특정하는 예를 보여주고 있다.다음 예처럼 인덱스 벡터 위치가 비어 있으면 그 인덱스는 전체 범위를 취한다. 인덱스 벡터가 모두 비어 있으면 행렬 그 자체가 된다. 즉 z[ , ]은 z와 같다.","code":"\nz <- matrix(1:25, nrow=5, ncol=5)\nz#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    6   11   16   21\n#> [2,]    2    7   12   17   22\n#> [3,]    3    8   13   18   23\n#> [4,]    4    9   14   19   24\n#> [5,]    5   10   15   20   25\nz[1,1]#> [1] 1\nz[5,5]#> [1] 25\nz[1:3,1]#> [1] 1 2 3\nz[2, 1:3]#> [1]  2  7 12\nz[c(3, 5), c(2, 4)]#>      [,1] [,2]\n#> [1,]    8   18\n#> [2,]   10   20\nz[,2]#> [1]  6  7  8  9 10\nz[3,]#> [1]  3  8 13 18 23\nz[,c(3,5)]#>      [,1] [,2]\n#> [1,]   11   21\n#> [2,]   12   22\n#> [3,]   13   23\n#> [4,]   14   24\n#> [5,]   15   25\nz[ , ]#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    6   11   16   21\n#> [2,]    2    7   12   17   22\n#> [3,]    3    8   13   18   23\n#> [4,]    4    9   14   19   24\n#> [5,]    5   10   15   20   25"},{"path":"ch-R-Matrix.html","id":"음의-정수-인덱스-벡터-1","chapter":"4 R 행렬","heading":"음의 정수 인덱스 벡터","text":"벡터와 마찬가지로 음의 정수를 이용하면 해당 행과 열을 제외한 행렬을 구할 수 있다.","code":"\nz[,-2]#>      [,1] [,2] [,3] [,4]\n#> [1,]    1   11   16   21\n#> [2,]    2   12   17   22\n#> [3,]    3   13   18   23\n#> [4,]    4   14   19   24\n#> [5,]    5   15   20   25\nz[-3,]#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    6   11   16   21\n#> [2,]    2    7   12   17   22\n#> [3,]    4    9   14   19   24\n#> [4,]    5   10   15   20   25\nz[,-c(2,4)]#>      [,1] [,2] [,3]\n#> [1,]    1   11   21\n#> [2,]    2   12   22\n#> [3,]    3   13   23\n#> [4,]    4   14   24\n#> [5,]    5   15   25\nz[-3,-2]#>      [,1] [,2] [,3] [,4]\n#> [1,]    1   11   16   21\n#> [2,]    2   12   17   22\n#> [3,]    4   14   19   24\n#> [4,]    5   15   20   25"},{"path":"ch-R-Matrix.html","id":"인덱스-벡터로-행과-열-재배치-하기","chapter":"4 R 행렬","heading":"인덱스 벡터로 행과 열 재배치 하기","text":"행렬의 인덱스 벡터를 이용하여 행 단위 재배치나 열 단위 재배치가 가능하다.아울러 인덱스 벡터를 사용하여 행과 열에 대한 정렬도 가능하다. 다음은 행렬의 첫번째 열을 기준으로 행을 큰 순에서 작은 순으로 정렬한 예이다.","code":"\nz[5:1, ]#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    5   10   15   20   25\n#> [2,]    4    9   14   19   24\n#> [3,]    3    8   13   18   23\n#> [4,]    2    7   12   17   22\n#> [5,]    1    6   11   16   21\nz[ , c(3:5, 1:2)]#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]   11   16   21    1    6\n#> [2,]   12   17   22    2    7\n#> [3,]   13   18   23    3    8\n#> [4,]   14   19   24    4    9\n#> [5,]   15   20   25    5   10\na <- matrix(sample(1:16), nrow=4, ncol=4)\na#>      [,1] [,2] [,3] [,4]\n#> [1,]    5    8    2   12\n#> [2,]   15    1    3    4\n#> [3,]    6   11   10   13\n#> [4,]   14    9    7   16\na[,1]#> [1]  5 15  6 14\norder(a[,1])#> [1] 1 3 4 2\na[order(a[,1]), ]#>      [,1] [,2] [,3] [,4]\n#> [1,]    5    8    2   12\n#> [2,]    6   11   10   13\n#> [3,]   14    9    7   16\n#> [4,]   15    1    3    4"},{"path":"ch-R-Matrix.html","id":"논리-인덱스-벡터-1","chapter":"4 R 행렬","heading":"논리 인덱스 벡터","text":"벡터와 마찬가지로 논리 인덱스 벡터를 사용할 수 있다. 다음의 예에서 보듯이 행과 열의 인덱스 벡터에서 TRUE가 되는 행과 열만 선택된다.","code":"\nheight <- c(180, 172, 167, 175, 182)\nweight <- c(72, 78, 58, 64, 68)\nyear <- c(1, 3, 2, 4, 2)\nA <- cbind(height, weight, year)\nA[ , c(F, T, T)]#>      weight year\n#> [1,]     72    1\n#> [2,]     78    3\n#> [3,]     58    2\n#> [4,]     64    4\n#> [5,]     68    2\nA[ , c(T, F, T)]#>      height year\n#> [1,]    180    1\n#> [2,]    172    3\n#> [3,]    167    2\n#> [4,]    175    4\n#> [5,]    182    2\nA[ A[,1] > 180,  ]#> height weight   year \n#>    182     68      2\nA[ A[,2] < 70,  ]#>      height weight year\n#> [1,]    167     58    2\n#> [2,]    175     64    4\n#> [3,]    182     68    2"},{"path":"ch-R-Matrix.html","id":"행과-열-이름-부여하기-rownames와-colnames","chapter":"4 R 행렬","heading":"행과 열 이름 부여하기: rownames()와 colnames()","text":"벡터와 마찬가지로 행과 열의 이름을 인덱스로 하여 행렬의 부분을 참조할 수 있다. 행렬의 행과 열 이름의 확인과 할당은 rownames()와 colnames() 함수를 이용하여 이루어진다. rbind()나 cbind()에 의해 벡터 변수가 결합되면 변수의 이름이 자동적으로 행이나 열의 이름으로 부여된다.","code":"\ncolnames(A)#> [1] \"height\" \"weight\" \"year\"\nrownames(A)#> NULL\nrownames(A) <- paste(\"student\", 1:5, sep=\"\")\nA#>          height weight year\n#> student1    180     72    1\n#> student2    172     78    3\n#> student3    167     58    2\n#> student4    175     64    4\n#> student5    182     68    2\nA[, \"year\"]#> student1 student2 student3 student4 student5 \n#>        1        3        2        4        2\nA[\"student1\",]#> height weight   year \n#>    180     72      1\nA[\"student2\", \"weight\"]#> [1] 78\nA[\"student2\", 2]  # 행과 열의 인덱스 벡터의 종류가 달라도 된다.#> [1] 78"},{"path":"ch-R-Matrix.html","id":"벡터로서-필터링-하기","chapter":"4 R 행렬","heading":"벡터로서 필터링 하기","text":"만약 행렬 이름 뒤에 인덱스 벡터가 하나밖에 주어지지 않으면, 행렬은 벡터로서 처리되어 필터링되고 행렬의 차원 정보는 무시된다","code":"\nz#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    6   11   16   21\n#> [2,]    2    7   12   17   22\n#> [3,]    3    8   13   18   23\n#> [4,]    4    9   14   19   24\n#> [5,]    5   10   15   20   25\nz[10]#> [1] 10\nz[z>15]#>  [1] 16 17 18 19 20 21 22 23 24 25"},{"path":"ch-R-Matrix.html","id":"행렬의-연산","chapter":"4 R 행렬","heading":"4.4 행렬의 연산","text":"","code":""},{"path":"ch-R-Matrix.html","id":"행렬의-요소-단위-연산","chapter":"4 R 행렬","heading":"행렬의 요소 단위 연산","text":"행과 열의 수가 같은 행렬은 산술 연산을 할 수 있다. 이 경우 벡터와 마찬가지로 산술 연산은 같은 위치의 요소 단위(element--element)로 이루어진다.","code":"\nA <- matrix(1:9, nrow=3, ncol=3)\nA#>      [,1] [,2] [,3]\n#> [1,]    1    4    7\n#> [2,]    2    5    8\n#> [3,]    3    6    9\nB <- matrix(seq(from=10, length=9, by=10), nrow=3, ncol=3)\nB#>      [,1] [,2] [,3]\n#> [1,]   10   40   70\n#> [2,]   20   50   80\n#> [3,]   30   60   90\nA + B#>      [,1] [,2] [,3]\n#> [1,]   11   44   77\n#> [2,]   22   55   88\n#> [3,]   33   66   99\nB - A#>      [,1] [,2] [,3]\n#> [1,]    9   36   63\n#> [2,]   18   45   72\n#> [3,]   27   54   81\nA * B#>      [,1] [,2] [,3]\n#> [1,]   10  160  490\n#> [2,]   40  250  640\n#> [3,]   90  360  810\nB / A#>      [,1] [,2] [,3]\n#> [1,]   10   10   10\n#> [2,]   10   10   10\n#> [3,]   10   10   10"},{"path":"ch-R-Matrix.html","id":"행렬은-재사용되지-않는다","chapter":"4 R 행렬","heading":"행렬은 재사용되지 않는다","text":"행과 열의 개수가 다른 행렬의 산술연산은 오류를 발생시킨다. 그 이유는 행렬은 벡터와 달리 요소의 재사용(recycling)이 일어나지 않기 때문이다. 그렇기 때문에 행렬과 행렬의 연산에서는 행과 열이 같은 크기이어야 한다.","code":"\nC <- cbind(A, 10:12)\nC#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    4    7   10\n#> [2,]    2    5    8   11\n#> [3,]    3    6    9   12\nB + C#> Error in B + C: 배열의 크기가 올바르지 않습니다\nC <- rbind(A, 1:3)\nC#>      [,1] [,2] [,3]\n#> [1,]    1    4    7\n#> [2,]    2    5    8\n#> [3,]    3    6    9\n#> [4,]    1    2    3\nB * C#> Error in B * C: 배열의 크기가 올바르지 않습니다"},{"path":"ch-R-Matrix.html","id":"벡터와-행렬의-연산-벡터는-재사용된다","chapter":"4 R 행렬","heading":"벡터와 행렬의 연산: 벡터는 재사용된다","text":"벡터와 행렬의 산술연산도 같은 위치의 요소 단위로 이루어진다. 벡터 a와 행렬 A의 연산시 벡터 a는 먼저 행렬 A와 같은 차원의 행렬로 변환되어 연산이 수행된다. 만약 벡터의 길이가 행렬의 길이보다 작으면 벡터의 데이터는 행렬의 길이만큼 순환 재사용된다. 연산을 위해 벡터가 행렬로 변환될 때도 matrix()로 행렬이 만들어질 때와 마찬가지로 열 별로 데이터를 채워나간다.숫자와 행렬이 연산은 길이가 1인 벡터와 행렬이 연산되는 것이므로 모든 행렬의 요소와 숫자간에 연산이 이루어진다. 다음 예에서 숫자 10이 A의 모든 요소에 대응하여 계산되었음을 볼 수 있다.그러나 벡터의 길이가 배열의 길이보다 길면 오류가 발생한다.현재까지는 행렬의 연산 중 요소 단위의 연산만을 설명하였다. R은 이 외에도 행렬의 외적, 행렬의 곱, 역행렬 구하기 등 다양한 행렬 연산을 지원한다. 관심 있는 독자는 4.7 절을 참조한다.","code":"\na <- 9:1\na + A#>      [,1] [,2] [,3]\n#> [1,]   10   10   10\n#> [2,]   10   10   10\n#> [3,]   10   10   10\na <- c(0, 10, 100)\na + A#>      [,1] [,2] [,3]\n#> [1,]    1    4    7\n#> [2,]   12   15   18\n#> [3,]  103  106  109\nA * a#>      [,1] [,2] [,3]\n#> [1,]    0    0    0\n#> [2,]   20   50   80\n#> [3,]  300  600  900\n10 * A#>      [,1] [,2] [,3]\n#> [1,]   10   40   70\n#> [2,]   20   50   80\n#> [3,]   30   60   90\nb <- 1:10\nb * A#> Warning in b * A: 두 객체의 길이가 서로 배수관계에 있지 않습니다#> Error in eval(expr, envir, enclos): dims [product 9]가 객체 [10]의 길이와 일치하지 않습니다"},{"path":"ch-R-Matrix.html","id":"행렬과-함수","chapter":"4 R 행렬","heading":"4.5 행렬과 함수","text":"","code":""},{"path":"ch-R-Matrix.html","id":"행렬을-인수로-하는-함수들","chapter":"4 R 행렬","heading":"4.5.1 행렬을 인수로 하는 함수들","text":"이 절에서는 행렬을 인수로 하는 R 함수를 살펴본다.","code":""},{"path":"ch-R-Matrix.html","id":"t","chapter":"4 R 행렬","heading":"t()","text":"어떤 행렬에서 행과 열이 바뀐 행렬을 전치행렬(transposed matrix)이라 한다. t() 함수를 이용하면 전치행렬을 구할 수 있다.","code":"\nA <- matrix(1:4, nrow=2, ncol=2)\nA#>      [,1] [,2]\n#> [1,]    1    3\n#> [2,]    2    4\nt(A)#>      [,1] [,2]\n#> [1,]    1    2\n#> [2,]    3    4"},{"path":"ch-R-Matrix.html","id":"행렬의-차원-정보를-주는-함수-nrow-ncol-dim","chapter":"4 R 행렬","heading":"행렬의 차원 정보를 주는 함수: nrow(), ncol(), dim()","text":"행렬의 행 수와 열 수를 구할 때는 nrow(), ncol() 함수를 이용한다. 행과 열의 차원 전체를 얻고자 하면 dim() 함수를 이용한다.","code":"\nnrow(A)#> [1] 2\nncol(A)#> [1] 2\ndim(A)#> [1] 2 2\nattributes(A)#> $dim\n#> [1] 2 2"},{"path":"ch-R-Matrix.html","id":"행과-열에-이름-함수-rownames-colnames","chapter":"4 R 행렬","heading":"행과 열에 이름 함수: rownames(), colnames()","text":"행과 열 이름을 확인하거나, 새로 할당할 때는 rownames()와 colnames() 함수를 이용한다.","code":"\nrownames(A)#> NULL\ncolnames(A)#> NULL\nrownames(A) <- c(\"upper\", \"lower\")\ncolnames(A) <- c(\"left\", \"right\")\nA#>       left right\n#> upper    1     3\n#> lower    2     4\nattributes(A)#> $dim\n#> [1] 2 2\n#> \n#> $dimnames\n#> $dimnames[[1]]\n#> [1] \"upper\" \"lower\"\n#> \n#> $dimnames[[2]]\n#> [1] \"left\"  \"right\""},{"path":"ch-R-Matrix.html","id":"벡터로-변환-as.vector-c","chapter":"4 R 행렬","heading":"벡터로 변환: as.vector(), c()","text":".vector()나 c() 함수를 이용하면 행렬을 벡터로 변경할 수 있다. 배열을 벡터로 바꾸는 공식적인 방법은 .vector() 함수를 이용하는 것이다. 다음 예를 살펴보자. (R이 대소문자를 구분하는 것에 주의.)하지만 c() 함수도 이와 유사한 효과를 나타낸다. cbind()와 rbind()는 행렬과 벡터의 차원 속성을 유지하며 데이터를 연결한다. 그러나 c() 함수는 dim과 dimnames 속성을 지운다.","code":"\nX <- rbind(1:5, 5:1)\nX#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    2    3    4    5\n#> [2,]    5    4    3    2    1\nx <- as.vector(X)\nx#>  [1] 1 5 2 4 3 3 4 2 5 1\nattributes(x)#> NULL\ny <- c(X)\ny#>  [1] 1 5 2 4 3 3 4 2 5 1\nattributes(y)#> NULL"},{"path":"ch-R-Matrix.html","id":"행렬에-벡터-함수-적용하기","chapter":"4 R 행렬","heading":"행렬에 벡터 함수 적용하기","text":"사실 행렬은 벡터에 dim 속성이 부여된 것뿐이므로, 벡터에 적용되는 함수를 행렬에 적용하면 행렬을 벡터로 간주하여 잘 동작한다.","code":"\nsum(X)#> [1] 30\nmean(X)#> [1] 3\nsd(X)#> [1] 1.490712\nrange(X)#> [1] 1 5"},{"path":"ch-R-Matrix.html","id":"행렬의-행별-또는-열별로-함수를-적용하는-방법","chapter":"4 R 행렬","heading":"4.5.2 행렬의 행별 또는 열별로 함수를 적용하는 방법","text":"apply() 함수를 이용하면 행렬의 행별 또는 열별로 함수를 적용할 수 있다.","code":""},{"path":"ch-R-Matrix.html","id":"apply","chapter":"4 R 행렬","heading":"apply()","text":"apply() 함수의 X 인수에는 행별 또는 열별로 함수를 적용할 행렬을, MARGIN 인수에는 함수를 적용할 방향을 지정한다. MARGIN 인수가 1이면 행별로, 2이면 열별로 함수가 적용된다. apply() 함수의 FUN 인수에는 행이나 열별로 적용할 함수를 전달한다.다음은 행렬 A에 대해 행별 합과 열별 합을 구한 예이다. 행렬 전체를 sum()한 결과와의 차이를 비교해 보라.apply() 함수가 적용되는 행렬의 행과 열에 이름이 있으면 apply()의 결과 벡터에도 해당 이름이 적용되어 출력된다.","code":"\napply(X, MARGIN, FUN, ...)\nset.seed(123)\na <- sample(1:25)\na#>  [1] 15 19 14  3 10 18 11  5 23  6  9 21 24 20 22 25 17  1 12 13  2 16  7  8  4\nA <- matrix(a, nrow=5, ncol=5)\nA#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]   15   18    9   25    2\n#> [2,]   19   11   21   17   16\n#> [3,]   14    5   24    1    7\n#> [4,]    3   23   20   12    8\n#> [5,]   10    6   22   13    4\napply(A, 1, sum)#> [1] 69 84 51 66 55\napply(A, 2, sum)#> [1] 61 63 96 68 37\nsum(A)#> [1] 325\ncolnames(A) <- LETTERS[1:5]\nrownames(A) <- paste(\"X\", 1:5, sep=\"\")\nA#>     A  B  C  D  E\n#> X1 15 18  9 25  2\n#> X2 19 11 21 17 16\n#> X3 14  5 24  1  7\n#> X4  3 23 20 12  8\n#> X5 10  6 22 13  4\napply(A, 1, min)#> X1 X2 X3 X4 X5 \n#>  2 11  1  3  4\napply(A, 2, max)#>  A  B  C  D  E \n#> 19 23 24 25 16"},{"path":"ch-R-Matrix.html","id":"함수의-결과가-벡터이면-열로서-결합하여-출력한다.","chapter":"4 R 행렬","heading":"함수의 결과가 벡터이면 열로서 결합하여 출력한다.","text":"지금까지 apply()의 FUN 인수에 부여된 함수는 sum()처럼 오직 하나의 값만을 반환하는 함수였다. 그렇기 때문에 apply() 함수로 행 또는 열별 합을 구하면 행 또는 열의 수만큼의 길이를 가지는 벡터로서 결과값이 반환되었다. 그러면 range()나 summary()처럼 길이가 2 이상인 벡터로서 결과를 주는 함수를 FUN 인수에 적용하면 어떻게 될까? 이 경우에는 함수가 적용되어 나온 결과 벡터를 cbind()처럼 열로서 결합하여 최종 결과를 출력한다.range() 함수는 최소값과 최대값이라는 두 요소로 이루어진 벡터를 결과로서 반환하는 함수이다. 따라서 첫번째 예는 A의 열별 최소값과 최대값을 열로 하는 행렬을, 두번째 예는 A의 행별 최대값과 최소값을 열로 하는 행렬을 반환하였다. 마지막 예에서는, summary() 함수가 최소값, 사분위수, 최대값, 평균 등의 통계치를 벡터로 반환하기 때문에, apply() 결과는 A의 행별 통계치를 열로 하는 행렬로서 반환되었다.","code":"\napply(A, 2, range)#>       A  B  C  D  E\n#> [1,]  3  5  9  1  2\n#> [2,] 19 23 24 25 16\napply(A, 1, range)#>      X1 X2 X3 X4 X5\n#> [1,]  2 11  1  3  4\n#> [2,] 25 21 24 23 22\napply(A, 1, summary)#>           X1   X2   X3   X4 X5\n#> Min.     2.0 11.0  1.0  3.0  4\n#> 1st Qu.  9.0 16.0  5.0  8.0  6\n#> Median  15.0 17.0  7.0 12.0 10\n#> Mean    13.8 16.8 10.2 13.2 11\n#> 3rd Qu. 18.0 19.0 14.0 20.0 13\n#> Max.    25.0 21.0 24.0 23.0 22"},{"path":"ch-R-Matrix.html","id":"sec-RMatrix-array","chapter":"4 R 행렬","heading":"4.6 배열 *","text":"","code":""},{"path":"ch-R-Matrix.html","id":"배열의-생성","chapter":"4 R 행렬","heading":"4.6.1 배열의 생성","text":"벡터는 일차원 데이터 구조로 하나의 인덱스 벡터로 요소의 위치를 지정한다.행렬은 2차원의 데이터 구조로 두 개의 인덱스 벡터로 요소의 위치를 지정한다. 첫번째 인덱스 벡터가 행의 위치를 지정하고, 두번째 인덱스 벡터가 열 위치를 지정한다.배열은 행렬을 일반화한 것으로 2차원 이상의 차원을 가지는 데이터 구조이다.\n사실 행렬은 2차인 구조를 가지는 배열의 특수한 예이다.\n배열은 벡터, 행렬과 마찬가지로 동일한 형식의 데이터만 그 요소로 가질 수 있으므로, 따라서 숫자 배열, 문자 배열, 논리값 배열 등이 만들어질 수 있다.","code":"\nx <- 11:20; x#>  [1] 11 12 13 14 15 16 17 18 19 20\nx[1]#> [1] 11\nx[6:7]#> [1] 16 17\nx <- matrix(11:19, nrow=3, ncol=3); x#>      [,1] [,2] [,3]\n#> [1,]   11   14   17\n#> [2,]   12   15   18\n#> [3,]   13   16   19\nx[1, 2]#> [1] 14\nx[2:3, 1]#> [1] 12 13"},{"path":"ch-R-Matrix.html","id":"array","chapter":"4 R 행렬","heading":"array()","text":"배열은 array() 함수를 이용하여 행렬과 비슷한 방법으로 만들수 있다.","code":"\nmatrix(data, nrow, ncol)\narray(data, dim)"},{"path":"ch-R-Matrix.html","id":"dim-인수","chapter":"4 R 행렬","heading":"dim 인수","text":"matrix() 함수와 마찬가지로 데이터 요소를 가지고 있는 벡터가 array()의 첫번째 인수로 제공된다. matrix() 함수와 다른 점은 차원의 크기가 dim 인수에 벡터 형식으로 제공된다는 것이다.\n행렬은 2차원으로 차원이 정해져 있으므로 첫번째 차원인 행의 크기는 nrow 인수에 두번째 차원인 열의 크기는 ncol 인수에 숫자 하나로 제공된다.\n그러나 배열은 2차원 이상의 다양한 차원을 가질 수 있으므로, 원하는 차원의 수만큼 각 차원의 크기를 결정해야 한다.\n따라서 차원의 개수만큼의 요소를 가지는 벡터가 dim 인수에 제공된다. 따라서 어떤 배열의 차원 벡터의 길이가 k이면 그 배열은 k차원 배열이라고 한다. 다음은 3차원 배열을 생성한 예이다.","code":"\nx <- array(11:28, dim=c(3, 3, 2))\nx#> , , 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]   11   14   17\n#> [2,]   12   15   18\n#> [3,]   13   16   19\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]   20   23   26\n#> [2,]   21   24   27\n#> [3,]   22   25   28"},{"path":"ch-R-Matrix.html","id":"차원-배열의-출력-방식","chapter":"4 R 행렬","heading":"3차원 배열의 출력 방식","text":"행렬과 마찬가지로 3차원 배열의 첫번째 차원은 행(rows)을, 두번째 차원은 열(columns)을, 세번째 차원은 층(layers)을 나타낸다. 3차원 큐브를 생각하면 이해하기 쉽다. 앞의 예에서는 행은 3개, 열도 3개, 층은 2개로 데이터 요소가 배열되었다.\n3차원 배열의 경우 컴퓨터 화면은 2차원이기 때문이 각 층을 차례로 보여주는 방식으로 배열의 요소를 출력한다. 따라서 각 층의 데이터는 2차원의 행렬의 형태로 출력된다. 출력된 행렬이 어떤 층의 데이터인지 보여주기 위해서 ’ , , (층 번호)’가 각 행렬의 위에 같이 출력되었다.","code":""},{"path":"ch-R-Matrix.html","id":"차원-배열에서-데이터가-채워지는-순서","chapter":"4 R 행렬","heading":"3차원 배열에서 데이터가 채워지는 순서","text":"예에서 보듯이 행렬과 마찬가지로 앞 차원의 인덱스들이 먼저 변하며 데이터가 채워진다. 1층의 데이터가 다 채워진 후 2 층의 데이터가 채워지고, 동일 층에서는 앞의 열이 먼저 채워지고 뒤의 열이 다음에 채워진다. 동일 층의 동일 열에서는 앞의 행이 먼저 채워지고 뒤의 행이 다음에 채워진다. 즉, [행, 열, 층]의 인덱스가 [1, 1, 1]에서 시작하여 [2, 1, 1]로 진행하며 1층-1열의 모든 행을 다 채우고 나서, 다시 [1, 2, 1]부터 1층-2열의 데이터를 채운다. 그리고 1층의 데이터가 모두 채워지면 다시 2층의 1열의 1행, 즉 [1, 1, 2]부터 차례대로 1층과 같은 방식으로 데이터를 채워나간다. 비유적으로 설명하자면 숫자의 자리수가 일의 자리가 채워지면 십의 자리, 그리고 그 다음 백의 자리가 채워지듯이, 첫번째 차원의 인덱스가 모두 채워지면 두번째 차원의 인덱스가 하나 증가하고, 두번째 차원의 인덱스가 모두 채워지면 세번째 차원이 인덱스가 하나 증가하며 데이터가 채워진다고 할 수 있다. 다만 십진법에서는 숫자의 자리수는 모두 10으로 크기가 같고, 0부터 시작하며, 숫자 표기상 뒷쪽 자릿수가 먼저 채워지는데, R의 배열에서는 차원의 크기가 서로 다를 수 있고, 1부터 시작하고, 앞 쪽의 차원이 먼저 채워지는 것에 차이가 있다.","code":""},{"path":"ch-R-Matrix.html","id":"k차원-배열은-k개의-인덱스-벡터로-요소의-위치를-지정한다.","chapter":"4 R 행렬","heading":"k차원 배열은 k개의 인덱스 벡터로 요소의 위치를 지정한다.","text":"3차원 배열에서 요소의 위치를 지정하기 위해서는 3개의 인덱스 벡터가 필요하다. 마찬가지로 k-차원의 배열에서 요소의 위치를 지정하기 위해서는 k개의 인덱스 벡터가 필요하다.행렬은 2차원 배열이므로 array() 함수를 이용해서도 행렬을 만들 수 있다.","code":"\nx[2, 1, 1]#> [1] 12\nx[2, 1, 2]#> [1] 21\nx[1, 2:3, 2]#> [1] 23 26\nx <- array(11:19, c(3,3))\nx#>      [,1] [,2] [,3]\n#> [1,]   11   14   17\n#> [2,]   12   15   18\n#> [3,]   13   16   19"},{"path":"ch-R-Matrix.html","id":"벡터를-재사용하여-배열-만들기","chapter":"4 R 행렬","heading":"벡터를 재사용하여 배열 만들기","text":"행렬을 만들 때와 마찬가지로 데이터로 제공된 벡터가 배열의 모든 공간을 채울 수 없으면 벡터가 재사용된다.참고로 벡터를 재사용하여 배열을 채울 때, 벡터의 길이가 배열의 길이의 배수가 아니어도 경고 메시지가 나오지 않는다. 이는 행렬의 경우와 다른데 차원이 커지면 벡터의 길이와 배열의 길이를 배수로 맞추는 것이 쉽지 않기 때문에 생략한 것으로 보인다.마찬가지로 벡터의 길이가 배열의 길이보다 길어도 아무 경고 메시지 없이 배열을 잘 생성한다.","code":"\nx <- array(1, dim=c(2, 3, 2))\nx#> , , 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    1    1    1\n#> [2,]    1    1    1\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    1    1    1\n#> [2,]    1    1    1\nx <- array(1:6, dim=c(3, 3, 2))\nx#> , , 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    1    4    1\n#> [2,]    2    5    2\n#> [3,]    3    6    3\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    4    1    4\n#> [2,]    5    2    5\n#> [3,]    6    3    6\nx <- array(1:5, dim=c(3, 3, 2))\nx#> , , 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    1    4    2\n#> [2,]    2    5    3\n#> [3,]    3    1    4\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    5    3    1\n#> [2,]    1    4    2\n#> [3,]    2    5    3\nx <- array(1:30, dim=c(3, 3, 2))\nx#> , , 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    1    4    7\n#> [2,]    2    5    8\n#> [3,]    3    6    9\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]   10   13   16\n#> [2,]   11   14   17\n#> [3,]   12   15   18"},{"path":"ch-R-Matrix.html","id":"차원-배열-예","chapter":"4 R 행렬","heading":"4차원 배열 예","text":"마지막으로 4차원 배열을 만들어 보자. 컴퓨터 화면은 2차원이므로 4차원 배열을 표현하기 위해, 세번째와 네번째 차원의 인덱스가 정해져 있을 때의 데이터를 2차원 행렬로 출력해 주는 것을 볼 수 있다. 3차원 배열 때와 마찬가지로 앞의 차원의 인덱스가 먼저 변하면서 데이터가 차례로 배정됨을 볼 수 있다.","code":"\ny <- array(1:30, dim=c(2, 3, 2, 2))\ny#> , , 1, 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\n#> \n#> , , 2, 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    7    9   11\n#> [2,]    8   10   12\n#> \n#> , , 1, 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]   13   15   17\n#> [2,]   14   16   18\n#> \n#> , , 2, 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]   19   21   23\n#> [2,]   20   22   24"},{"path":"ch-R-Matrix.html","id":"배열도-결국-벡터","chapter":"4 R 행렬","heading":"4.6.2 배열도 결국 벡터","text":"","code":""},{"path":"ch-R-Matrix.html","id":"배열은-dim-속성을-가진-벡터이다.","chapter":"4 R 행렬","heading":"배열은 dim 속성을 가진 벡터이다.","text":"행렬과 마찬가지로 배열도 사실 벡터이다. 그러므로 typeof() 함수를 이용하여 생성된 배열의 타입을 확인해 보면 숫자 벡터임을 보여준다. 그러나 class() 함수로 배열의 클래스를 확인하면 array 클래스로 처리됨을 볼 수 있다. 앞의 예에서도 벡터가 array 클래스로 처리되기 때문에 행, 열, 층 등으로 잘 구분되어 출력될 수 있었던 것이다. Array 클래스의 데이터는 본질적으로 벡터가 dim 속성을 가지고 있는 것 뿐이다. Dim 속성은 해당 배열의 각 차원의 크기를 나타내 준다. R은 dim 속성에 저장된 차원 정보를 이용하여 데이터 요소를 각 차원에 맞게 출력해 준다.","code":"\ntypeof(x)#> [1] \"integer\"\nclass(x)#> [1] \"array\"\nattributes(x)#> $dim\n#> [1] 3 3 2"},{"path":"ch-R-Matrix.html","id":"벡터에-dim-속성을-부여하여-배열-만들기","chapter":"4 R 행렬","heading":"벡터에 dim 속성을 부여하여 배열 만들기","text":"배열은 결국 벡터가 dim 속성을 가지고 있는 것이므로 벡터에 dim 속성을 부여하여 배열을 만들 수도 있다. 다음 예에서도 보듯이 데이터는 변함이 없고 dim 속성에 따라 데이터가 보여지는 형식이 달라짐을 볼 수 있다.","code":"\nx <- 1:12\ndim(x)#> NULL\nx#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12\ndim(x) <- c(3, 4)\nx#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    4    7   10\n#> [2,]    2    5    8   11\n#> [3,]    3    6    9   12\ndim(x) <- c(2, 3, 2)\nx#> , , 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    7    9   11\n#> [2,]    8   10   12\ndim(x) <- NULL\nx#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12"},{"path":"ch-R-Matrix.html","id":"dimnames-속성과-dimnames-함수","chapter":"4 R 행렬","heading":"dimnames 속성과 dimnames() 함수","text":"배열도 행렬과 마찬가지로 각 차원에 이름을 부여할 수 있다. 배열의 dimnames 속성에 차원의 이름 벡터를 리스트 객체로 만들어 부여하면 된다. (리스트 객체에 대한 설명은 5장을 살펴보기 바란다.) 배열에 dimnames 속성을 부여하려면 array() 함수의 dimnames 인수를 이용하거나, 다음처럼 dimnames() 함수를 사용한다.","code":"\ndim(x) <- c(2, 3, 2)\ndimnames(x) <- list(c(\"A\", \"B\"), \n                    paste(\"group\",1:3,sep=\"-\"), \n                    c(\"Male\", \"Female\"))\nx#> , , Male\n#> \n#>   group-1 group-2 group-3\n#> A       1       3       5\n#> B       2       4       6\n#> \n#> , , Female\n#> \n#>   group-1 group-2 group-3\n#> A       7       9      11\n#> B       8      10      12\nattributes(x)#> $dim\n#> [1] 2 3 2\n#> \n#> $dimnames\n#> $dimnames[[1]]\n#> [1] \"A\" \"B\"\n#> \n#> $dimnames[[2]]\n#> [1] \"group-1\" \"group-2\" \"group-3\"\n#> \n#> $dimnames[[3]]\n#> [1] \"Male\"   \"Female\""},{"path":"ch-R-Matrix.html","id":"배열의-연산과-필터링","chapter":"4 R 행렬","heading":"4.6.3 배열의 연산과 필터링","text":"","code":""},{"path":"ch-R-Matrix.html","id":"배열의-요소-단위-연산","chapter":"4 R 행렬","heading":"배열의 요소 단위 연산","text":"배열 연산과 필터링은 행렬 연산과 필터링의 경우와 동일한 원리로 작동한다. 다른 점은 행렬보다 더 많은 차원의 데이터를 다룬다는 것이다. 행렬 연산과 마찬가지로 배열 연산도 동일한 차원 벡터를 갖는 배열들이 요소 단위로 연산이 이루어진다.행렬 연산과 마찬가지로 차원 벡터가 다른 배열과 연산을 시도하면 오류가 발생한다.벡터와 배열이 연산되면 벡터는 배열의 길이만큼 재사용되어 연산이 수행된다.","code":"\na <- array(1:8, c(2, 2, 2)); a#> , , 1\n#> \n#>      [,1] [,2]\n#> [1,]    1    3\n#> [2,]    2    4\n#> \n#> , , 2\n#> \n#>      [,1] [,2]\n#> [1,]    5    7\n#> [2,]    6    8\nb <- array(10^(0:7), c(2, 2, 2)); b#> , , 1\n#> \n#>      [,1] [,2]\n#> [1,]    1  100\n#> [2,]   10 1000\n#> \n#> , , 2\n#> \n#>       [,1]  [,2]\n#> [1,] 1e+04 1e+06\n#> [2,] 1e+05 1e+07\na + b#> , , 1\n#> \n#>      [,1] [,2]\n#> [1,]    2  103\n#> [2,]   12 1004\n#> \n#> , , 2\n#> \n#>        [,1]     [,2]\n#> [1,]  10005  1000007\n#> [2,] 100006 10000008\na * b#> , , 1\n#> \n#>      [,1] [,2]\n#> [1,]    1  300\n#> [2,]   20 4000\n#> \n#> , , 2\n#> \n#>       [,1]  [,2]\n#> [1,] 5e+04 7e+06\n#> [2,] 6e+05 8e+07\nd <- array(11:30, c(2, 3, 2)); d#> , , 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]   11   13   15\n#> [2,]   12   14   16\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]   17   19   21\n#> [2,]   18   20   22\na + d#> Error in a + d: 배열의 크기가 올바르지 않습니다\n2 * a#> , , 1\n#> \n#>      [,1] [,2]\n#> [1,]    2    6\n#> [2,]    4    8\n#> \n#> , , 2\n#> \n#>      [,1] [,2]\n#> [1,]   10   14\n#> [2,]   12   16\n1:2 * a#> , , 1\n#> \n#>      [,1] [,2]\n#> [1,]    1    3\n#> [2,]    4    8\n#> \n#> , , 2\n#> \n#>      [,1] [,2]\n#> [1,]    5    7\n#> [2,]   12   16"},{"path":"ch-R-Matrix.html","id":"차원-축소와-drop-인수","chapter":"4 R 행렬","heading":"차원 축소와 drop 인수","text":"배열도 행렬과 마찬가지로 차원의 수만큼의 자연수, 음의 정수, 논리, 이름 인덱스 벡터로 필터링을 수행할 수 있다. 필터링의 결과로 어떤 차원의 크기가 1로 줄어들게 되면, 더 낮은 차원의 데이터 구조로 차원이 축소된다. 예를 들어 3차원 배열을 필터링한 결과가 1차원 벡터나 2차원 행렬이 될 수 있다. 이러한 차원 축소를 원하지 않으면 drop=FALSE 인수를 사용하여 필터링을 하면 된다.3","code":"\nx#> , , Male\n#> \n#>   group-1 group-2 group-3\n#> A       1       3       5\n#> B       2       4       6\n#> \n#> , , Female\n#> \n#>   group-1 group-2 group-3\n#> A       7       9      11\n#> B       8      10      12\nx[ , , 2]#>   group-1 group-2 group-3\n#> A       7       9      11\n#> B       8      10      12\nx[ ,2, 2]#>  A  B \n#>  9 10\nx[1, 2:3, 2]#> group-2 group-3 \n#>       9      11\nx[1, 2:3, 1:2]#>         Male Female\n#> group-2    3      9\n#> group-3    5     11\nx[1, 2:3, 1:2, drop=F]#> , , Male\n#> \n#>   group-2 group-3\n#> A       3       5\n#> \n#> , , Female\n#> \n#>   group-2 group-3\n#> A       9      11\nx[,-2,c(T, F)]#>   group-1 group-3\n#> A       1       5\n#> B       2       6\nx[\"A\", \"group-2\", \"Female\"]#> [1] 9"},{"path":"ch-R-Matrix.html","id":"sec-RMatrix-operation-advanced","chapter":"4 R 행렬","heading":"4.7 행렬과 배열의 고급 연산 *","text":"행렬은 배열의 매우 중요하고 특수한 경우이다. 따라서 R에서는 행렬에만 가능한 여러 연산과 기능들이 있다.","code":""},{"path":"ch-R-Matrix.html","id":"행렬의-곱","chapter":"4 R 행렬","heading":"4.7.1 행렬의 곱","text":"지금까지 행렬의 연산은 요소 단위로 이루어졌다. 따라서 행렬에 곱하기 연산자 *를 사용하면 같은 위치의 요소끼리 곱해졌다. 그러나 수학에서 일반적으로 정의하는 행렬의 곱은 다음과 같은 형식으로 수행된다.\\[\\begin{equation*}\n\\begin{pmatrix}\n  & b \\\\\n  c & d\n\\end{pmatrix} \\times\n\\begin{pmatrix}\n  e & f \\\\\n  g & h\n\\end{pmatrix}\n=\n\\begin{pmatrix}b\\,g+\\,e & b\\,h+\\,f \\\\\n  d\\,g+c\\,e & d\\,h+c\\,f\n\\end{pmatrix}\n\\end{equation*}\\]연산자 %*%는 행렬의 곱 연산을 수행한다. 다음의 예는 요소별로 곱이 이루어지는 * 연산자와 행렬의 곱 연산자 %*%이 어떻게 다른지 보여준다. 결과에서 알 수 있듯이 행렬 곱은 교환법칙이 성립하지 않는다. 반면 요소 단위의 곱은 교환법칙이 성립한다.벡터가 행렬의 곱 수식에 나타나면 자동적으로 열 벡터나 행 벡터로 변환이 이루어진다. 그리고 행렬의 곱의 결과과 행이나 열 벡터로 표현되더라도 차원 축소는 일어나지 않는다.","code":"\nA <- array(1:4, c(2,2)); A#>      [,1] [,2]\n#> [1,]    1    3\n#> [2,]    2    4\nB <- array(10^(0:3), c(2,2)); B#>      [,1] [,2]\n#> [1,]    1  100\n#> [2,]   10 1000\nA * B#>      [,1] [,2]\n#> [1,]    1  300\n#> [2,]   20 4000\nB * A#>      [,1] [,2]\n#> [1,]    1  300\n#> [2,]   20 4000\nA %*% B#>      [,1] [,2]\n#> [1,]   31 3100\n#> [2,]   42 4200\nB %*% A#>      [,1] [,2]\n#> [1,]  201  403\n#> [2,] 2010 4030\nx <- c(1,1)\nx %*% A#>      [,1] [,2]\n#> [1,]    3    7\nA %*% x#>      [,1]\n#> [1,]    4\n#> [2,]    6\nx %*% A %*% x#>      [,1]\n#> [1,]   10"},{"path":"ch-R-Matrix.html","id":"행렬의-주대각선-요소와-대각행렬","chapter":"4 R 행렬","heading":"4.7.2 행렬의 주대각선 요소와 대각행렬","text":"행렬을 이용한 수학적 연산에서 행렬의 주대각선 요소나 대각행렬은 매우 중요한 역할을 수행한다. R은 diag() 함수를 이용하여 행렬에서 주대각선 요소를 추출하거나, 대각행렬을 만든다. diag() 함수는 첫번째 인수 x에 어떤 형식의 데이타가 오는지에 따라 다른 연산을 수행한다.인수 x가 행렬이면, 그 행렬의 주대각선 요소를 벡터로 반환한다.인수 x가 벡터이고 벡터의 길이가 1보다 크면, 그 벡터를 주대각선 요소로 하는 대각행렬(diagonal matrix)를 반환한다. 이 경우 nrow나 ncol이 주어지면 벡터가 재사용되어 대각행렬을 만들 수 있다.인수 x가 숫자 하나이고 그 값이 k이면, \\(k \\times k\\) 단위 행렬(identity matrix)을 반환한다. 만약 nrow나 ncol 등이 주어지면 k가 주대각선 요소인 대각행렬이 생성된다.","code":"\ndiag(A)#> [1] 1 4\ndiag(1:4)#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    0    0    0\n#> [2,]    0    2    0    0\n#> [3,]    0    0    3    0\n#> [4,]    0    0    0    4\ndiag(3)#>      [,1] [,2] [,3]\n#> [1,]    1    0    0\n#> [2,]    0    1    0\n#> [3,]    0    0    1\ndiag(3, nrow=2)#>      [,1] [,2]\n#> [1,]    3    0\n#> [2,]    0    3"},{"path":"ch-R-Matrix.html","id":"연립-일차-방정식과-역행렬","chapter":"4 R 행렬","heading":"4.7.3 연립 일차 방정식과 역행렬","text":"다음과 같은 연립 일차 방정식이 있다고 하자.\\[\\begin{align*}\n2 x - 3 y &= 5 \\\\\n-2 x + 4 y &= -4\n\\end{align*}\\]위의 연립 일차 방정식은 행렬과 벡터를 이용하여 나타내면 다음처럼 표현된다.\\[\\begin{equation*}\n\\mathbf{} \\mathbf{x} = \\mathbf{b}\n\\end{equation*}\\]단,\\[\\begin{equation*}\n\\mathbf{} = \\begin{pmatrix} 2 & -3 \\\\ -2 & 4 \\end{pmatrix}, \\,\n\\mathbf{x} = \\begin{pmatrix} x \\\\ y \\end{pmatrix}, \\,\n\\mathbf{b} = \\begin{pmatrix} 5 \\\\ -4 \\end{pmatrix}.\n\\end{equation*}\\]위의 식의 해를 구하기 위해서는 앙변에 \\(\\mathbf{}\\)의 역행렬 \\(\\mathbf{}^{-1}\\)을 곱하면 된다.\\[\\begin{equation*}\n\\mathbf{x} = \\mathbf{}^{-1} \\mathbf{b}\n\\end{equation*}\\]R에서는 solve() 함수를 이용하여 해를 구한다. solve(, b) 함수의 첫번째 인수 a에는 연립 일차 방정식의 좌변의 계수를 나타내는 정방행렬이, 두번째 인수 b에는 우변의 상수항을 나타내는 벡터가 제공된다.위의 문제의 답은 \\(x = 4\\)이고 \\(y = 1\\)임을 알 수 있다. 행렬 A와 해 x를 곱하면 우변항의 b와 같아짐을 확인할 수 있다.solve() 함수의 두번째 인수 b가 주어지지 않으면 b를 단위 행렬로 하여 해를 구한다. 그러면 해는 좌변 행렬의 역행렬이 된다.\\[\\begin{align*}\n& \\mathbf{} \\mathbf{x} = \\mathbf{} \\\\\n& \\mathbf{x} = \\mathbf{}^{-1}\n\\end{align*}\\]단, \\(\\mathbf{}\\)는 \\(\\mathbf{}\\)와 차원이 같은 단위 행렬이다. 따라서 다음은 행렬 \\(\\mathbf{}\\)의 역행렬 \\(\\mathbf{}^{-1}\\)을 구해준다. 결과에서 solve()의 해를 원래의 행렬로 곱하면 단위 행렬이 됨을 확인할 수 있다.\\(\\mathbf{}^{-1}\\)을 구하였으므로 \\(\\mathbf{x} = \\mathbf{}^{-1} \\mathbf{b}\\) 관계를 이용하여 앞의 방정식의 해를 구할 수도 있다.하지만 이러한 방법은 수치 계산적인 측면에서 비효율적이고 불안정한 결과를 만들 수 있다. 따라서 \\(\\mathbf{}\\)의 역행렬을 직접 구하기보다는 solve(, b)를 이용하여 해를 구하는 것이 좋다. \\(\\mathbf{x}^{t} \\mathbf{}^{-1} \\mathbf{x}\\) 처럼 이차형식(quadratic form)을 구할 때도 역행렬을 직접 구하기보다는 x %*% solve(, x)로 계산하는 것이 더 좋다.","code":"\nA <- matrix(c(2, -2, -3, 4), nrow=2, ncol=2); A#>      [,1] [,2]\n#> [1,]    2   -3\n#> [2,]   -2    4\nb <- c(5, -4); b#> [1]  5 -4\nx <- solve(A, b); x#> [1] 4 1\nA %*% x#>      [,1]\n#> [1,]    5\n#> [2,]   -4\nA.inverse <- solve(A); A.inverse#>      [,1] [,2]\n#> [1,]    2  1.5\n#> [2,]    1  1.0\nA %*% A.inverse#>      [,1] [,2]\n#> [1,]    1    0\n#> [2,]    0    1\nA.inverse %*% b#>      [,1]\n#> [1,]    4\n#> [2,]    1"},{"path":"ch-R-Matrix.html","id":"고유치eigenvalues와-고유벡터eigenvectors","chapter":"4 R 행렬","heading":"4.7.4 고유치(eigenvalues)와 고유벡터(eigenvectors)","text":"행렬의 고유치와 고유벡터를 구하기 위해서는 eigen() 함수를 이용한다. eigen() 함수의 결과는 values와 vectors라는 이름을 가진 두 요소를 가지는 리스트이다. (리스트에 대해서는 5 장을 참조하라.) 고유치 또는 고유벡터를 확인하려면 values 또는 vectors로 리스트 요소를 지정하면 된다.매우 큰 행렬의 경우 고유벡터가 필요하지 않다면 계산하지 않는 것이 효율적이다. eigen() 함수의 .values 옵션을 TRUE로 설정하면 고유벡터는 계산하지 않고 고유치만 계산한다.","code":"\nA#>      [,1] [,2]\n#> [1,]    2   -3\n#> [2,]   -2    4\nev <- eigen(A)\nev$values#> [1] 5.6457513 0.3542487\nev$vectors#>            [,1]       [,2]\n#> [1,]  0.6354064 -0.8767397\n#> [2,] -0.7721779 -0.4809652\neigen(A, only.values = TRUE)#> $values\n#> [1] 5.6457513 0.3542487\n#> \n#> $vectors\n#> NULL"},{"path":"ch-R-List.html","id":"ch-R-List","chapter":"5 R 리스트","heading":"5 R 리스트","text":"지금까지는 객체에 포함되는 요소가 모두 같은 타입인 벡터나 행렬을 살펴보았다. 이 장에서는 숫자와 문자 등 다른 타입의 데이터를 결합시킬 수 있는 리스트라는 데이터 구조를 살펴본다.실제 데이터 분석을 수행할 때 사용자가 리스트를 직접적으로 생성하는 경우는 그리 많지 않다. 그러나 리스트를 이해하는 것은 매우 중요한데 그 이유는 다음과 같다.","code":""},{"path":"ch-R-List.html","id":"리스트-이해의-중요성","chapter":"5 R 리스트","heading":"리스트 이해의 중요성","text":"첫째, 6 장에서 보겠지만 데이터 분석에서 가장 중요한 데이터 구조는 데이터 프레임이다. 그리고 데이터 프레임은 리스트를 기반으로 하고 있다. 따라서 데이터 프레임의 근간이 되는 리스트에 대해 명확하게 이해하는 것이 데이터를 효율적으로 조작하는 데 도움이 된다.둘째, 통계 및 데이터 마이닝을 위해 사용하는 다양한 R의 함수는 복잡한 분석의 결과를 리스트 타입으로 제공하는 경우가 많다. 따라서 데이터 분석의 결과를 효과적으로 이용하기 위해서는 리스트 구조를 이해할 필요가 있다.앞서 리스트란 타입이 다른 데이터를 결합시킬 수 있는 데이터 구조라고 했으므로, 본격적으로 리스트를 논하기 전에 R에서 사용하는 다양한 데이터 타입을 먼저 살펴보자.","code":""},{"path":"ch-R-List.html","id":"객체-객체의-타입-객체의-속성","chapter":"5 R 리스트","heading":"5.1 객체, 객체의 타입, 객체의 속성 *","text":"","code":""},{"path":"ch-R-List.html","id":"객체","chapter":"5 R 리스트","heading":"객체","text":"R에서는 메모리에 저장하거나 메모리에서 읽어 올 수 있는 모든 데이터 단위를 객체(objects)라고 부른다. 앞에서 살펴본 숫자 벡터, 논리 벡터, 문자 벡터들은 모두 객체이다. 또한 행렬, 배열, 그리고 앞으로 살펴볼 리스트, 데이터 프레임뿐 아니라, 함수, 그래프 등도 모두 객체여서 변수에 할당하여 메모리에 저장하거나 필요시 메모리에서 읽어들일 수 있다.","code":""},{"path":"ch-R-List.html","id":"객체의-타입","chapter":"5 R 리스트","heading":"객체의 타입","text":"객체는 하나의 데이터 타입(type)을 갖는다. (모드(mode)라고도 한다.) 데이터 타입이 다른 객체는 다른 방식으로 메모리에 저장되고 읽어들여진다. 예를 들어 논리 벡터의 경우 논리값 타입을 가지며, 논리값 타입을 갖는 데이터는 논리값이 효율적으로 저장되고 연산될 수 있는 형식으로 메모리에 저장되어진다.R에서는 함수를 나타내는 closure 타입, R의 표현식을 의미하는 expression 타입 등 다양한 타입이 존재한다. 그러나 데이터의 관점에서 보면 크게 두 가지 종류의 근본적인 데이터 타입이 존재한다. 하나는 원자적 벡터(atomic vectors)이고, 다른 하나는 일반적 벡터(generic vectors) 또는 리스트라고 불리는 데이터 타입이다.","code":""},{"path":"ch-R-List.html","id":"원자적-벡터-atomic-vector","chapter":"5 R 리스트","heading":"원자적 벡터 atomic vector","text":"원자적 벡터는 숫자 벡터, 논리 벡터, 문자 벡터처럼 하나의 데이터 형식으로 저장되는 데이터 타입을 의미한다. 반면 리스트는 숫자와 문자 등 서로 다른 데이터 형식으로 저장되는 요소를 가지는 데이터 타입이다.\n원자적 벡터의 대표적인 타입은 논리값(logical), 정수(integer), 실수(double), 복소수(complex), 문자(chracter), 바이트(raw) 등이 있다.","code":""},{"path":"ch-R-List.html","id":"typeof","chapter":"5 R 리스트","heading":"typeof()","text":"객체가 어떤 데이터 타입으로 저장되어 있는지를 확인하기 위해서 typeof() 함수를 이용할 수 있다.","code":"\na <- c(T, F, F, T); typeof(a)#> [1] \"logical\"\nb <- 1:4; typeof(b)#> [1] \"integer\"\nd <- c(1.5, 2.7, 3.3, 4.7); typeof(d)#> [1] \"double\"\ne <- c(\"car\", \"bus\", \"train\", \"plane\"); typeof(e)#> [1] \"character\""},{"path":"ch-R-List.html","id":"데이터-자동-형변환","chapter":"5 R 리스트","heading":"데이터 자동 형변환","text":"논리값, 정수, 실수, 문자 데이터 형식은 제시된 순서대로 데이터가 자동 형변환 된다. 논리값과 정수가 하나의 벡터에 같이 사용되면, 벡터는 하나의 데이터 형식으로 저장되어야 하므로 논리값보다 더 표현 범위가 넓은 정수 형식으로 데이터가 변환된다. 논리값의 FALSE는 0으로, TRUE는 1로 변환된다.\n정수와 실수가 같이 사용되면 모두 실수 형식으로 변환된다.\n실수와 문자 데이터가 같이 사용되면 모두 문자 형식으로 자동 변환된다.물론 숫자 형식의 데이터가 문자로 변환되면 더이상 숫자로서의 연산을 지원되지 않는다.","code":"\nf <- c(a, b); f; typeof(f)#> [1] 1 0 0 1 1 2 3 4#> [1] \"integer\"\ng <- c(b, d); g; typeof(g)#> [1] 1.0 2.0 3.0 4.0 1.5 2.7 3.3 4.7#> [1] \"double\"\nh <- c(d, e); h; typeof(h)#> [1] \"1.5\"   \"2.7\"   \"3.3\"   \"4.7\"   \"car\"   \"bus\"   \"train\" \"plane\"#> [1] \"character\"\ng * 2#> [1] 2.0 4.0 6.0 8.0 3.0 5.4 6.6 9.4\nh * 2#> Error in h * 2: 이항연산자에 수치가 아닌 인수입니다"},{"path":"ch-R-List.html","id":"내재적-속성","chapter":"5 R 리스트","heading":"내재적 속성","text":"객체의 데이터 타입은 모든 객체의 내재적 속성 중 하나이다. 모든 객체가 가지는 또 다른 내재적 속성은 길이이다. 길이 속성은 해당 객체의 데이터 요소가 몇 개인지를 알려준다. typeof(objects)와 length(objects) 함수를 이용하면 객체의 데이터 타입과 길이를 알아낼 수 있다.","code":"\nlength(a)#> [1] 4\nlength(b)#> [1] 4"},{"path":"ch-R-List.html","id":"행렬의-타입","chapter":"5 R 리스트","heading":"행렬의 타입","text":"행렬도 결국은 모두 같은 데이터 형식을 가지는 데이터 요소로 구성되어 있으므로, 원자적 벡터 형식의 데이터라고 할 수 있다. 따라서 행렬의 데이터 타입도 결국 벡터가 가지는 데이터 타입과 동일함을 확인할 수 있다.즉 벡터 b와 행렬 bb는 동일한 형식으로 정수가 4개 메모리에 저장되어 있는 데이터이다. 그러므로 데이터 타입도 integer로 동일하고 요소의 길이도 동일하다. 그러나 b와 bb를 출력해 보면 서로 다른 방식으로 처리되어 출력됨을 볼 수 있다. b는 일련의 숫자로 출력되고, bb는 행과 열이 2인 행렬의 형식으로 출력된다. R은 똑같이 저장되어 있는 데이터에서 이를 어떻게 구분하여 처리하는 것일까?","code":"\naa <- matrix(a, nrow=2); typeof(aa); length(aa)#> [1] \"logical\"#> [1] 4\nbb <- matrix(b, nrow=2); typeof(bb); length(bb)#> [1] \"integer\"#> [1] 4\ndd <- matrix(d, nrow=2); typeof(dd); length(dd)#> [1] \"double\"#> [1] 4\nee <- matrix(e, nrow=2); typeof(ee); length(ee)#> [1] \"character\"#> [1] 4\nb#> [1] 1 2 3 4\nbb#>      [,1] [,2]\n#> [1,]    1    3\n#> [2,]    2    4\nclass(b)#> [1] \"integer\"\nclass(bb)#> [1] \"matrix\" \"array\""},{"path":"ch-R-List.html","id":"클래스-class","chapter":"5 R 리스트","heading":"클래스 class()","text":"R은 객체에 데이터 타입 말고 클래스라는 속성을 부여할 수 있다. 데이터 타입은 내재적 속성으로 모든 객체에게 부여된다. 반면 클래스는 객체에 따라 부여되지 않을 수도 있고 여러 개가 부여될 수 있는 속성으로, 객체가 R 함수에 의해 처리될 때 어떤 방식으로 처리되어야 하는지를 알려준다.\n위의 예에서 숫자 벡터 b는 아무 클래스도 부여되지 않았으므로 데이터 타입인 integer가 클래스로 지정되어 있고, 행렬 bb의 데이터 타입은 integer이지만 클래스로 matrix가 부여되어 있음을 확인할 수 있다. 따라서 R은 b와 bb의 클래스가 다르므로 print() 출력 함수로 데이터를 출력할 때 다른 방식으로 처리를 수행하였다.","code":""},{"path":"ch-R-List.html","id":"attributes","chapter":"5 R 리스트","heading":"attributes()","text":"그러면 R은 4개의 정수가 차례로 저장되어 있는 bb에 대해 2개의 행과 2개의 열을 가진 행렬로 표현해야 한다는 것을 어떻게 알았을까?\nR은 객체의 데이터를 데이터 타입에 맞추어 저장하고 있을 뿐만 아니라, 그 객체의 부가 정보(메타 정보)를 속성이라는 형태로 저장하고 있다. 각 객체가 가진 내재적 속성인 데이터 타입과 길이를 제외한 모든 속성은 attributes(objects) 함수에 의해 확인할 수 있다.위의 예에서 벡터 b는 다른 속성 정보가 없지만, bb는 dim 속성에 행과 열의 길이 정보가 부여되어 있음을 알 수 있다. 사실 R은 벡터에 부여된 dim 속성을 보고 이 벡터가 행렬로 또는 배열로 처리되어야 하는지를 인식하고, 행과 열의 길에에 맞게 출력과 연산 등을 수행한다.","code":"\nattributes(b)#> NULL\nattributes(bb)#> $dim\n#> [1] 2 2"},{"path":"ch-R-List.html","id":"attr","chapter":"5 R 리스트","heading":"attr()","text":"attributes(objects) 함수는 객체에 내재된 속성을 제외한 모든 속성을 보여주거나 모든 속성에 데이터를 할당할 때 이용되는 반면, attr(object, name) 함수는 객체에서 특정 이름을 가진 속성을 보여주거나 해당 속성에 데이터를 할당하기 위해 이용된다. 이러한 함수가 자주 사용되지는 않지만 속성에 대한 개념을 이해하는 것은 매우 중요하다. R의 객체 시스템과 각 속성들은 통합되어 있으므로 객체의 속성을 할당하거나 삭제할 때 주의할 필요가 있기 때문이다.\n객체의 속성은 할당문의 좌변에 사용되어서 객체에 새로운 속성을 부여하거나 기존의 속성 값을 변경할 수 있다. 예를 들어 다음과 같이 z 객체에 dim 속성을 부여하여 R이 z를 3ⅹ3의 행렬인 것처럼 다루도록 할 수 있다.아래 예는 dimnames 속성에 행과 열의 이름을 할당하여 행렬이 출력될 때 행과 열의 이름이 같이 출력되도록 한 경우이다. 이 경우도 R은 저장되어 있는 9개의 정수뿐 아니라 객체의 부가적인 속성 정보를 이용하여 어떤 식으로 처리할 것인지를 결정하게 된다.","code":"\nz <- 1:9\nz#> [1] 1 2 3 4 5 6 7 8 9\nclass(z)#> [1] \"integer\"\nattr(z, \"dim\")#> NULL\nattr(z, \"dim\") <- c(3,3)\nattributes(z)#> $dim\n#> [1] 3 3\nz#>      [,1] [,2] [,3]\n#> [1,]    1    4    7\n#> [2,]    2    5    8\n#> [3,]    3    6    9\nattr(z, \"dimnames\") <- list(c(\"A\", \"B\", \"C\"), 1:3)\nattributes(z)#> $dim\n#> [1] 3 3\n#> \n#> $dimnames\n#> $dimnames[[1]]\n#> [1] \"A\" \"B\" \"C\"\n#> \n#> $dimnames[[2]]\n#> [1] \"1\" \"2\" \"3\"\nz#>   1 2 3\n#> A 1 4 7\n#> B 2 5 8\n#> C 3 6 9"},{"path":"ch-R-List.html","id":"객체-속성-함수","chapter":"5 R 리스트","heading":"객체 속성 함수","text":"attr() 함수를 이용하여 다양한 속성을 객체에 부가할 수 있다. 그러나 보통 속성 이름을 잘못 부여하여 오작동하는 것을 방지하고, 사용자의 편의를 도모하기 위해 자주 사용되는 속성을 확인하거나 할당하는 dim(), dimnames(), names(), row.names(), class() 등의 각 속성 전용의 함수들이 정의되어 있다. 각 함수의 사용법은 이 책의 관련 부분이나 R의 도움말을 참고하기 바란다.\n객체 속성을 변경할 때는 이러한 attr()보다는 객체 속성 함수를 이용하는 것이 좋다. 왜냐하면 attr() 함수는 속성 이름이 잘 못되더라도 새로운 속성을 설정하는 것으로 생각하여 오류가 발생하지 않는다. 객체 속성 함수를 사용하면 해당 속성을 위한 함수를 잘 못 지정하면 오류가 발생하기 때문에 입력 오류를 바로 확인할 수 있다.","code":""},{"path":"ch-R-List.html","id":"모드와-타입의-차이","chapter":"5 R 리스트","heading":"모드와 타입의 차이","text":"마지막으로 모드와 타입의 차이를 설명하고자 한다. 많은 R 문서나 책을 보면 앞에서 이야기한 데이터 타입을 모드라는 이름으로 설명하는 경우가 많다. 사실 모드와 타입은 비슷한 개념으로 생각하면 된다. 타입이 R에서 이용되는 개념이라고 한다면, 모드는 R의 전신인 S 언어에서 데이터의 기본 형식을 지정하기 위해서 사용한 개념이다. R은 S 언어에 대한 호환성을 보장하기 위해 모드라는 개념을 같이 혼용하여 사용하고 있다. 객체의 모드를 확인하기 위해서는 mode() 함수를 이용한다.대부분의 경우 타입과 모드는 비슷한 결과를 주지만, 숫자 벡터의 경우 R의 타입은 integer와 double로 저장 형식이 정수인지 실수인지 구분하고, S 언어의 모드는 모두 numeric으로 표시한다. 그러나 S도 storage.mode()라는 함수를 이용하면 내부적으로 저장하는 형식을 확인할 수 있다.그러나 R에서는 mode()나 storage.mode() 함수 모두 typeof() 함수의 결과에 기반을 하고 있으므로, S 언어와의 하위 호환성 때문이 아니라면 타입이라는 개념과 typeof() 함수를 사용하는 것이 좋다.","code":"\ntypeof(a); mode(a)#> [1] \"logical\"#> [1] \"logical\"\ntypeof(b); mode(b)#> [1] \"integer\"#> [1] \"numeric\"\ntypeof(d); mode(d)#> [1] \"double\"#> [1] \"numeric\"\ntypeof(e); mode(e)#> [1] \"character\"#> [1] \"character\"\nstorage.mode(b)#> [1] \"integer\"\nstorage.mode(d)#> [1] \"double\""},{"path":"ch-R-List.html","id":"리스트의-생성-및-필터링","chapter":"5 R 리스트","heading":"5.2 리스트의 생성 및 필터링","text":"R의 리스트는 요소(component)라고 불리는 객체들을 순서대로 모은 데이터 구조이다. 리스트의 요소들은 서로 다른 데이터 형식일 수 있다. 이론적으로 말하자면 리스트는 서로 다른 타입을 가지는 요소에 대한 주소 정보를 가지고 있는 데이터 형식이다.","code":""},{"path":"ch-R-List.html","id":"list","chapter":"5 R 리스트","heading":"list()","text":"리스트 객체는 list() 함수를 이용하여 만드는데, 아래처럼 리스트 요소에 이름 없이 만드는 방법과 리스트 요소에 이름을 붙여서 만드는 방법이 있다.다음은 list() 함수를 이용하여 리스트를 만드는 예를 보여주고 있다.a의 요소로 문자, 숫자, 논리값을 모두 포함할 수 있음을 볼 수 있다. 뒤에서 살펴보겠지만 리스트는 요소로 다른 리스트를 포함할 수도 있고, 함수 등의 다른 타입의 객체도 포함할 수 있다.위의 예에서 list() 함수의 인수로 리스트에 포함될 요소를 ’이름=요소’의 형식으로 기술하였다. 객체를 출력해 보면 각 요소의 이름이 $를 앞에 붙여 출력되고 그 다음에 요소의 내용이 출력된다.","code":"\nlist(요소1, 요소2, ...)\nlist(이름1=요소1, 이름2=요소2, ...)\na <- list(name=\"Fred\", age=43, wife=\"Mary\", \n            no.children= 3, child.ages=c(4, 7, 9), \n          is.house.owner=T)\na#> $name\n#> [1] \"Fred\"\n#> \n#> $age\n#> [1] 43\n#> \n#> $wife\n#> [1] \"Mary\"\n#> \n#> $no.children\n#> [1] 3\n#> \n#> $child.ages\n#> [1] 4 7 9\n#> \n#> $is.house.owner\n#> [1] TRUE"},{"path":"ch-R-List.html","id":"리스트-객체의-타입-길이-속성-및-names","chapter":"5 R 리스트","heading":"리스트 객체의 타입, 길이, 속성 및 names()","text":"typeof()와 length() 함수를 이용하면 객체의 내재적 속성인 타입과 요소의 길이를 확인할 수 있다.\nattributes() 함수를 이용하면 그 밖의 속성을 확인할 수 있는데, names 속성이 부여되어 있음을 볼 수 있다. 사실 attributes()에 의해 반환되는 결과는 속성을 요소로 갖는 리스트 객체이다.list() 함수를 이용하여 객체를 정의할 때 요소에 이름을 부여하지 않으면, 특별한 이름 없이 각 요소가 순서대로 1부터 숫자가 매겨진다. 앞서와 달리 요소의 이름 대신 요소의 번호가 [[ ]] 안에 표시된 후 요소의 내용이 출력됨을 볼 수 있다.","code":"\ntypeof(a)#> [1] \"list\"\nlength(a)#> [1] 6\nattributes(a)#> $names\n#> [1] \"name\"           \"age\"            \"wife\"           \"no.children\"   \n#> [5] \"child.ages\"     \"is.house.owner\"\nnames(a)#> [1] \"name\"           \"age\"            \"wife\"           \"no.children\"   \n#> [5] \"child.ages\"     \"is.house.owner\"\na2 <- list(1:5, letters[1:8], LETTERS[1:3])\na2#> [[1]]\n#> [1] 1 2 3 4 5\n#> \n#> [[2]]\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"\n#> \n#> [[3]]\n#> [1] \"A\" \"B\" \"C\""},{"path":"ch-R-List.html","id":"리스트-요소의-이름-자동으로-부여되지-않는다.","chapter":"5 R 리스트","heading":"5.2.0.1 리스트 요소의 이름 자동으로 부여되지 않는다.","text":"2차원 데이터 구조인 행렬을 만드는 cbind() 함수나, 또 다른 2차원 데이터 구조인 데이터프레임을 만드는 data.frame() 함수는 변수를 사용하여 행렬과 데이터프레임을 만들면 변수명을 열 이름으로 자동적으로 부여한다. (data.frame() 함수에 대해서는 6 장을 참조한다.)반면 list() 함수는 변수를 요소로 사용해도 변수명을 요소의 이름으로 자동으로 부여하지 않는다.그러므로 리스트 생성 시 요소에 이름을 부여하려면 앞서 본 것과 같이 요소이름=요소 형식으로 리스트를 생성하여야 한다.","code":"\nvar1 <- 1:3\nvar2 <- 4:6\ncbind(var1, var2)#>      var1 var2\n#> [1,]    1    4\n#> [2,]    2    5\n#> [3,]    3    6\ndata.frame(var1, var2)#>   var1 var2\n#> 1    1    4\n#> 2    2    5\n#> 3    3    6\nlist(var1, var2)#> [[1]]\n#> [1] 1 2 3\n#> \n#> [[2]]\n#> [1] 4 5 6\nlist(var1=var1, var2=var2)#> $var1\n#> [1] 1 2 3\n#> \n#> $var2\n#> [1] 4 5 6"},{"path":"ch-R-List.html","id":"리스트-요소-지정","chapter":"5 R 리스트","heading":"리스트 요소 지정","text":"리스트에서 요소 하나를 지정할 때는 주로 다음의 세가지 방법을 사용한다.첫번째 방법은, [[ ]] 연산자와 요소의 번호로 지정하는 것이다.두번째 방법은 list_name$component_name의 형태로 $ 뒤에 리스트 요소의 이름을 이용하여 지정하는 것이다.세번째 방법은, [[ ]] 연산자 안에 숫자 대신 요소의 이름을 나타내는 문자열을 제시하여 지정하는 것이다. 이 때 두번째와 세번째 방법은 요소의 이름을 사용하는 것은 모두 동일하나, 두번째 방법에서는 $ 뒤에 사용되는 요소의 이름이 변수처럼 따옴표 없이 그대로 이용되는 반면, 세번째 방법에서는 요소의 이름이 문자열로 따옴표로 표현되는 차이가 있다. 숫자 대신 이름을 이용하는 것은 숫자를 기억하지 않아도 되므로 편리하다.","code":"\na[[3]]#> [1] \"Mary\"\na$wife#> [1] \"Mary\"\na[[\"wife\"]]#> [1] \"Mary\""},{"path":"ch-R-List.html","id":"단계적으로-요소-지정","chapter":"5 R 리스트","heading":"단계적으로 요소 지정","text":"리스트 요소가 벡터나 행렬인 경우에는 지정된 요소에 다시 인덱스 벡터를 이용하여 부분을 선택할 수 있다.","code":"\na[[5]]#> [1] 4 7 9\na[[5]][2:3]#> [1] 7 9\na$child.ages[2:3]#> [1] 7 9"},{"path":"ch-R-List.html","id":"요소-이름의-단축","chapter":"5 R 리스트","heading":"요소 이름의 단축","text":"요소의 이름이 다른 요소들의 이름과 충분히 구별 가능하면 축약된 형태로 적을 수도 있다. 그러나 되도록 이름의 단축 기능은 사용하지 말 것을 권장한다. 최근의 R 관련 프로그램은 대부분 코드 자동 완성 기능이 있으므로 긴 이름도 쉽게 작성할 수 있으므로, 이름의 단축으로 얻는 입력 타수 절약이라는 장점보다는 명령문의 가독성이 줄어드는 단점이 더 크기 때문이다.","code":"\na$no#> [1] 3\na$child#> [1] 4 7 9"},{"path":"ch-R-List.html","id":"부분-리스트로-필터링","chapter":"5 R 리스트","heading":"부분 리스트로 필터링","text":"지금까지는 리스트의 한 요소를 지정하는 방법에 대하여 설명하였다. 어떤 경우에는 리스트의 여러 요소를 지정할 필요가 있다. 이러한 경우에는 [[ ]] 연산자가 아니라 벡터의 필터링에 사용한 [ ]를 동일하게 이용한다.벡터의 필터링과 마찬가지로 자연수를 이용하여 해당 위치의 요소를 뽑을 수도 있고, 음의 정수를 이용하여 해당 위치의 요소를 빼고 필터링을 수행할 수도 있다. 문자열 벡터를 이용하여 요소의 이름으로 필터링이 가능하다.","code":"\na[1:3]#> $name\n#> [1] \"Fred\"\n#> \n#> $age\n#> [1] 43\n#> \n#> $wife\n#> [1] \"Mary\"\na[c(2, 5)]#> $age\n#> [1] 43\n#> \n#> $child.ages\n#> [1] 4 7 9\na[-(4:5)]#> $name\n#> [1] \"Fred\"\n#> \n#> $age\n#> [1] 43\n#> \n#> $wife\n#> [1] \"Mary\"\n#> \n#> $is.house.owner\n#> [1] TRUE\na[c(\"wife\", \"child.ages\")]#> $wife\n#> [1] \"Mary\"\n#> \n#> $child.ages\n#> [1] 4 7 9\na[c(T, F, F)]#> $name\n#> [1] \"Fred\"\n#> \n#> $no.children\n#> [1] 3"},{"path":"ch-R-List.html","id":"리스트-요소-지정-vs.-부분-리스트-필터링","chapter":"5 R 리스트","heading":"리스트 요소 지정 vs. 부분 리스트 필터링","text":"여기서 주목해야 할 것은 벡터의 필터링의 결과는 원래 벡터의 부분으로 구성된 벡터인 것과 마찬가지로, 리스트의 [ ] 필터링의 결과는 리스트의 부분으로 구성된 또 다른 리스트가 된다. 반면 [[ ]]나 $ 연산자를 이용하여 요소를 지정하는 것은 리스트의 요소 그 자체가 된다. 즉, 또 다른 리스트가 되는 것이 아니라 리스트의 요소가 벡터이면 벡터 그 자체가 된다. 다음의 예는 [ ]와 [[ ]] 연산자를 이용하여 a의 5번째 요소를 뽑아낸 예이다.전자는 벡터로 출력되고 후자는 다시 요소가 하나짜리 리스트로 표현됨을 볼 수 있다. 내용적으로 두 결과의 차이가 크지 않지만 형식적으로는 두 결과는 큰 차이를 가진다. 전자의 경우는 요소 그 자체인 벡터가 되므로 벡터 필터링이나 벡터와 관련된 연산이 가능하지만, 후자는 불가능하다. 대신 리스트와 관련된 연산이나 필터링을 수행해야 한다.위의 예에서 [[ ]]로 지정된 결과는 요소 그 자체가 되므로, 결과가 숫자 벡터가 된다. 따라서 벡터와 관련된 모든 연산이 가능하다. 반면 [ ]로 필터링된 결과는 리스트라는 형식이 유지되어 요소가 하나인 리스트가 된다. 따라서 2번째와 3번째 요소를 필터링하자, 해당 요소가 없으므로 모두 NULL로 표시된다. 리스트이므로 수식 벡터의 연산도 수행되지 않음을 알 수 있다.","code":"\na[[5]]#> [1] 4 7 9\na[5]#> $child.ages\n#> [1] 4 7 9\na[[5]][2:3]#> [1] 7 9\na[[5]] * 7#> [1] 28 49 63\na[5][2:3]#> $<NA>\n#> NULL\n#> \n#> $<NA>\n#> NULL\na[5] * 7#> Error in a[5] * 7: 이항연산자에 수치가 아닌 인수입니다"},{"path":"ch-R-List.html","id":"리스트의-변경-및-연결","chapter":"5 R 리스트","heading":"5.3 리스트의 변경 및 연결","text":"","code":""},{"path":"ch-R-List.html","id":"리스트-요소의-추가","chapter":"5 R 리스트","heading":"리스트 요소의 추가","text":"이미 생성된 리스트는 새로운 요소를 추가함으로써 확장될 수 있다.\n새로운 요소를 추가하거나 변경하는 방법은 여러 가지가 있을 수 있는데, 첫번째로 생각할 수 있는 방법은 [[ ]] 연산자나 $ 연산자를 이용하여 요소를 추가하거나 변경하는 방법이다. 다음은 새로운 요소를 리스트에 추가한 예이다.","code":"\nlength(a)#> [1] 6\na[[7]] <- 1:5\na[[\"address\"]] <- \"Cheonan\"\na$years.since.marrage <- 15\na#> $name\n#> [1] \"Fred\"\n#> \n#> $age\n#> [1] 43\n#> \n#> $wife\n#> [1] \"Mary\"\n#> \n#> $no.children\n#> [1] 3\n#> \n#> $child.ages\n#> [1] 4 7 9\n#> \n#> $is.house.owner\n#> [1] TRUE\n#> \n#> [[7]]\n#> [1] 1 2 3 4 5\n#> \n#> $address\n#> [1] \"Cheonan\"\n#> \n#> $years.since.marrage\n#> [1] 15"},{"path":"ch-R-List.html","id":"리스트-요소의-변경","chapter":"5 R 리스트","heading":"리스트 요소의 변경","text":"벡터와 마찬가지로 기존 요소를 지정한 후 할당을 하면 기존 요소가 변경된다.","code":"\na[[7]] <- 10:18\na$address <- \"Daejeon\"\na[[9]] <- 16\na#> $name\n#> [1] \"Fred\"\n#> \n#> $age\n#> [1] 43\n#> \n#> $wife\n#> [1] \"Mary\"\n#> \n#> $no.children\n#> [1] 3\n#> \n#> $child.ages\n#> [1] 4 7 9\n#> \n#> $is.house.owner\n#> [1] TRUE\n#> \n#> [[7]]\n#> [1] 10 11 12 13 14 15 16 17 18\n#> \n#> $address\n#> [1] \"Daejeon\"\n#> \n#> $years.since.marrage\n#> [1] 16"},{"path":"ch-R-List.html","id":"자연수-인덱스를-이용한-리스트-요소의-추가와-빈-요소의-생성","chapter":"5 R 리스트","heading":"자연수 인덱스를 이용한 리스트 요소의 추가와 빈 요소의 생성","text":"위의 예에서 새로운 요소를 추가할 때 요소의 이름을 이용하면 현재까지 있는 요소의 다음 위치에 차례로 해당 이름을 갖는 요소가 추가된다. 그러나 숫자를 이용하여 위치를 지정하여 새로운 요소를 추가하면 해당 위치에 요소가 생성된다. 위의 예처럼 이미 해당 위치에 다른 요소가 있다면 새로운 값으로 변경이 될 것이며, 아무 것도 없었다면 해당 위치에 새로운 데이터가 추가된다. 그러면 기존 리스트의 마지막 요소의 다음 위치가 아니라 더 먼 위치에 새로운 요소를 추가하면 어떻게 될까?위의 예에서 보듯이 비어 있는 요소는 아무 것도 없다는 뜻의 NULL로 표현되어 출력되고 마지막 위치에 있는 요소까지 모두 출력된다.","code":"\na2#> [[1]]\n#> [1] 1 2 3 4 5\n#> \n#> [[2]]\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"\n#> \n#> [[3]]\n#> [1] \"A\" \"B\" \"C\"\na2[[5]] <- \"New items\"\na2#> [[1]]\n#> [1] 1 2 3 4 5\n#> \n#> [[2]]\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"\n#> \n#> [[3]]\n#> [1] \"A\" \"B\" \"C\"\n#> \n#> [[4]]\n#> NULL\n#> \n#> [[5]]\n#> [1] \"New items\""},{"path":"ch-R-List.html","id":"리스트-요소의-삭제","chapter":"5 R 리스트","heading":"리스트 요소의 삭제","text":"리스트의 요소를 삭제하기 위해서는 해당 요소를 [[ ]]나 $ 연산자를 이용하여 지정한 후 해당 요소에 NULL을 할당하면 된다.","code":"\na2[[5]] <- NULL\na2#> [[1]]\n#> [1] 1 2 3 4 5\n#> \n#> [[2]]\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"\n#> \n#> [[3]]\n#> [1] \"A\" \"B\" \"C\"\n#> \n#> [[4]]\n#> NULL\na2[[4]] <- NULL\na2#> [[1]]\n#> [1] 1 2 3 4 5\n#> \n#> [[2]]\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"\n#> \n#> [[3]]\n#> [1] \"A\" \"B\" \"C\"\nnames(a2) <- c(\"num\", \"lower.case\", \"upper.case\")\na2#> $num\n#> [1] 1 2 3 4 5\n#> \n#> $lower.case\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"\n#> \n#> $upper.case\n#> [1] \"A\" \"B\" \"C\"\na2$num <- NULL\na2#> $lower.case\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"\n#> \n#> $upper.case\n#> [1] \"A\" \"B\" \"C\""},{"path":"ch-R-List.html","id":"부분-리스트를-이용한-리스트-변경","chapter":"5 R 리스트","heading":"부분 리스트를 이용한 리스트 변경 *","text":"지금까지는 [[ ]]나 $ 연산자를 이용하여 요소 하나를 추가, 변경, 삭제하는 것을 보여주었다. [ ] 연산자를 이용하면 리스트의 여러 요소를 추가 또는 변경할 수 있다. 이 때 할당문의 오른쪽에 있는 객체는 리스트 객체여야 한다. 왜냐하면 [ ] 연산자를 이용한 필터링의 결과는 원래 리스트의 부분 리스트이기 때문이다.","code":"\na2[3:4] <- list(1:5, month.name)\na2#> $lower.case\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"\n#> \n#> $upper.case\n#> [1] \"A\" \"B\" \"C\"\n#> \n#> [[3]]\n#> [1] 1 2 3 4 5\n#> \n#> [[4]]\n#>  [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n#>  [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\""},{"path":"ch-R-List.html","id":"리스트의-recycling","chapter":"5 R 리스트","heading":"리스트의 recycling *","text":"만약 오른쪽 항의 리스트가 할당될 부분 리스트보다 요소 수가 적으면 오른쪽 항의 리스트가 재사용된다.","code":"\na2[3:6] <- list(11:15, month.abb)\na2#> $lower.case\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"\n#> \n#> $upper.case\n#> [1] \"A\" \"B\" \"C\"\n#> \n#> [[3]]\n#> [1] 11 12 13 14 15\n#> \n#> [[4]]\n#>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"\n#> \n#> [[5]]\n#> [1] 11 12 13 14 15\n#> \n#> [[6]]\n#>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\""},{"path":"ch-R-List.html","id":"벡터의-리스트로의-형변환","chapter":"5 R 리스트","heading":"벡터의 리스트로의 형변환 *","text":"또한 부분 리스트를 지정한 후 할당하는 예에서, 오른쪽에 리스트가 아니라 벡터가 주어지면 벡터의 각 요소가 리스트의 요소로 변환된 후 할당이 이루어진다. 이는 R 등의 고급 언어들의 특징인데 할당해야 할 내용이 할당받을 객체의 타입과 다른 경우, 가능하면 할당문의 왼쪽에 있는 객체의 타입으로 변환하려고 노력한다. .list() 함수를 이용하여 벡터를 리스트로 사용자가 명시적으로 변환할 수도 있다.위의 예에서 부분리스트에 NULL을 할당하면 부분 리스트에 해당되는 모든 요소가 삭제됨을 볼 수 있다. 이 때도 역시 NULL이 재사용되어 4개의 요소에 모두 NULL이 할당되었다.","code":"\na2[3:6] <- c(\"X\", \"Y\", \"Z\", \"W\")\na2#> $lower.case\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"\n#> \n#> $upper.case\n#> [1] \"A\" \"B\" \"C\"\n#> \n#> [[3]]\n#> [1] \"X\"\n#> \n#> [[4]]\n#> [1] \"Y\"\n#> \n#> [[5]]\n#> [1] \"Z\"\n#> \n#> [[6]]\n#> [1] \"W\"\nc(\"X\", \"Y\", \"Z\", \"W\")#> [1] \"X\" \"Y\" \"Z\" \"W\"\nas.list(c(\"X\", \"Y\", \"Z\", \"W\"))#> [[1]]\n#> [1] \"X\"\n#> \n#> [[2]]\n#> [1] \"Y\"\n#> \n#> [[3]]\n#> [1] \"Z\"\n#> \n#> [[4]]\n#> [1] \"W\"\na2[3:6] <- NULL\na2#> $lower.case\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"\n#> \n#> $upper.case\n#> [1] \"A\" \"B\" \"C\""},{"path":"ch-R-List.html","id":"c를-이용한-리스트-연결하기","chapter":"5 R 리스트","heading":"c()를 이용한 리스트 연결하기","text":"리스트는 벡터와 같이 c() 함수를 이용하여 리스트들을 연결하여 하나의 리스트로 만들 수 있다.","code":"\na3 <- list(first=1:3, second=4:6)\na3#> $first\n#> [1] 1 2 3\n#> \n#> $second\n#> [1] 4 5 6\na4 <- c(a2, a3)\na4#> $lower.case\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"\n#> \n#> $upper.case\n#> [1] \"A\" \"B\" \"C\"\n#> \n#> $first\n#> [1] 1 2 3\n#> \n#> $second\n#> [1] 4 5 6\nlength(a4)#> [1] 4"},{"path":"ch-R-List.html","id":"계층적인-리스트-만들기","chapter":"5 R 리스트","heading":"계층적인 리스트 만들기","text":"위의 예에서 c()로 연결된 리스트들은 모든 요소가 평평하게 하나의 계층으로 연결되었음을 볼 수 있다. 그런데 리스트는 모든 타입의 요소를 포함할 수 있기 때문에 리스트의 요소에 리스트가 할당될 수 있다. 이 경우 리스트는 계층적인 구조를 갖게 된다.c()로 같은 계층으로 연결한 앞의 a4의 결과와 a5의 출력 결과를 비교해 보라.\na4에서 upper.case 요소를 뽑기 위해서는 2번째 요소를 뽑으면 된다. 그러나 a5에서는 2번째 요소를 뽑으면 2번째 리스트 전체가 뽑혀져서 나오는 것을 볼 수 있다. a5에서 upper.case를 뽑으려면 첫번째 요소를 뽑은 후, 거기서 다시 2번째 요소를 뽑아야 한다.계층적인 구조의 리스트를 c()로 연결하면 첫 층위에서만 하나의 리스트로 합쳐진다. 모든 층위의 요소를 재귀적으로 하나로 합치려면 recursive=TRUE 인수를 설정한다. 그러면 모든 요소들이 하나로 합쳐져 벡터로 변환된다. 다음 예에서는 문자 요소가 있으므로 모두 문자로 자동 형변환되어 합쳐졌다.","code":"\na5 <- list(a2, a3)\na5#> [[1]]\n#> [[1]]$lower.case\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"\n#> \n#> [[1]]$upper.case\n#> [1] \"A\" \"B\" \"C\"\n#> \n#> \n#> [[2]]\n#> [[2]]$first\n#> [1] 1 2 3\n#> \n#> [[2]]$second\n#> [1] 4 5 6\nlength(a5)#> [1] 2\na4[[2]]#> [1] \"A\" \"B\" \"C\"\na5[[2]]#> $first\n#> [1] 1 2 3\n#> \n#> $second\n#> [1] 4 5 6\na5[[1]][[2]]#> [1] \"A\" \"B\" \"C\"\na5[[2]]$second#> [1] 4 5 6\na4$second#> [1] 4 5 6\nc(a4, a5)#> $lower.case\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"\n#> \n#> $upper.case\n#> [1] \"A\" \"B\" \"C\"\n#> \n#> $first\n#> [1] 1 2 3\n#> \n#> $second\n#> [1] 4 5 6\n#> \n#> [[5]]\n#> [[5]]$lower.case\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"\n#> \n#> [[5]]$upper.case\n#> [1] \"A\" \"B\" \"C\"\n#> \n#> \n#> [[6]]\n#> [[6]]$first\n#> [1] 1 2 3\n#> \n#> [[6]]$second\n#> [1] 4 5 6\nc(a4, a5, recursive = TRUE)#> lower.case1 lower.case2 lower.case3 lower.case4 lower.case5 lower.case6 \n#>         \"a\"         \"b\"         \"c\"         \"d\"         \"e\"         \"f\" \n#> lower.case7 lower.case8 upper.case1 upper.case2 upper.case3      first1 \n#>         \"g\"         \"h\"         \"A\"         \"B\"         \"C\"         \"1\" \n#>      first2      first3     second1     second2     second3 lower.case1 \n#>         \"2\"         \"3\"         \"4\"         \"5\"         \"6\"         \"a\" \n#> lower.case2 lower.case3 lower.case4 lower.case5 lower.case6 lower.case7 \n#>         \"b\"         \"c\"         \"d\"         \"e\"         \"f\"         \"g\" \n#> lower.case8 upper.case1 upper.case2 upper.case3      first1      first2 \n#>         \"h\"         \"A\"         \"B\"         \"C\"         \"1\"         \"2\" \n#>      first3     second1     second2     second3 \n#>         \"3\"         \"4\"         \"5\"         \"6\""},{"path":"ch-R-List.html","id":"unlist로-리스트를-벡터로-형-변환하기","chapter":"5 R 리스트","heading":"unlist()로 리스트를 벡터로 형 변환하기","text":"앞서 .list()를 이용하여 벡터를 리스트로 변환한 예를 보았다. 어떤 경우에는 리스트의 모든 요소를 벡터로 변환할 필요가 있다. 앞의 예처럼 c( , recursive = TRUE)를 사용할 수도 있지만, 이 때 사용하는 전용 함수인 unlist()를 사용하는 것이 더 일반적이다.예에서 보듯이 리스트의 요소가 모두 숫자로 표시가 가능하면 숫자 벡터로 변환하지만, 하나라도 문자 등이 있으면 모두 문자 벡터로 변환한다. 그리고 벡터의 각 요소에 리스트 요소의 이름과 벡터의 위치에 따라 자동으로 이름이 부여되었음을 확인할 수 있다.\nunlist() 함수는 strsplit() 결과를 하나의 문자 벡터로 만들 때 자주 사용된다.","code":"\nunlist(a3)#>  first1  first2  first3 second1 second2 second3 \n#>       1       2       3       4       5       6\nunlist(a4)#> lower.case1 lower.case2 lower.case3 lower.case4 lower.case5 lower.case6 \n#>         \"a\"         \"b\"         \"c\"         \"d\"         \"e\"         \"f\" \n#> lower.case7 lower.case8 upper.case1 upper.case2 upper.case3      first1 \n#>         \"g\"         \"h\"         \"A\"         \"B\"         \"C\"         \"1\" \n#>      first2      first3     second1     second2     second3 \n#>         \"2\"         \"3\"         \"4\"         \"5\"         \"6\"\na <- c(\"R은 통계분석을 위해 특화된 프로그램 언어입니다.\", \"다양한 데이터 분석 함수가 내장되어 있습니다.\")\nb <- strsplit(a, split = \" \")\nb#> [[1]]\n#> [1] \"R은\"         \"통계분석을\"  \"위해\"        \"특화된\"      \"프로그램\"   \n#> [6] \"언어입니다.\"\n#> \n#> [[2]]\n#> [1] \"다양한\"    \"데이터\"    \"분석\"      \"함수가\"    \"내장되어\"  \"있습니다.\"\nunlist(b)#>  [1] \"R은\"         \"통계분석을\"  \"위해\"        \"특화된\"      \"프로그램\"   \n#>  [6] \"언어입니다.\" \"다양한\"      \"데이터\"      \"분석\"        \"함수가\"     \n#> [11] \"내장되어\"    \"있습니다.\""},{"path":"ch-R-List.html","id":"리스트에-함수-적용하기","chapter":"5 R 리스트","heading":"5.4 리스트에 함수 적용하기","text":"행렬을 공부할 때 apply() 함수를 이용하여 행렬의 각 행 또는 각 열에 함수를 적용하는 방법을 공부하였다. 리스트에도 리스트의 각 요소에 함수를 적용하는 lapply()와 sapply() 함수가 있다.","code":""},{"path":"ch-R-List.html","id":"lapply-함수","chapter":"5 R 리스트","heading":"5.4.1 lapply() 함수","text":"","code":""},{"path":"ch-R-List.html","id":"lapply","chapter":"5 R 리스트","heading":"lapply()","text":"lapply() 함수는 다음의 문법 구조를 가진다.다음 예는 lapply()를 이용하여 숫자 벡터로 이루어진 리스트의 각 요소에 mean() 함수를 적용한 예이다. 어떤 객체에 함수를 적용할 때는 function(object) 형식으로 함수의 인수로 객체를 제공한다. 그러나 lapply()에서는 첫번째 인수로 리스트를 제공하고, 두번째 인수로 함수 객체를 제공한다.위의 예에서 보듯이 lapply()는 리스트의 각 요소에 함수를 적용한 후 그 결과를 동일한 형식의 리스트 객체로 제공한다.","code":"\nlapply(리스트, 함수)\nb <- list(1:5, 21:29, seq(2, 20, by=2))\nb#> [[1]]\n#> [1] 1 2 3 4 5\n#> \n#> [[2]]\n#> [1] 21 22 23 24 25 26 27 28 29\n#> \n#> [[3]]\n#>  [1]  2  4  6  8 10 12 14 16 18 20\nmean(b[[1]])#> [1] 3\nmean(b[[2]])#> [1] 25\nmean(b[[3]])#> [1] 11\nlapply(b, mean)#> [[1]]\n#> [1] 3\n#> \n#> [[2]]\n#> [1] 25\n#> \n#> [[3]]\n#> [1] 11"},{"path":"ch-R-List.html","id":"lapply-결과-리스트의-요소-이름","chapter":"5 R 리스트","heading":"lapply() 결과 리스트의 요소 이름","text":"아래 예는 리스트에 여러 함수들을 적용한 예이다. 리스트에 이름을 제공하면 결과에도 동일한 이름이 요소에 붙여짐을 확인할 수 있다.","code":"\nlapply(b, max)#> [[1]]\n#> [1] 5\n#> \n#> [[2]]\n#> [1] 29\n#> \n#> [[3]]\n#> [1] 20\nnames(b) <- c(\"A\", \"B\", \"C\")\nlapply(b, range)#> $A\n#> [1] 1 5\n#> \n#> $B\n#> [1] 21 29\n#> \n#> $C\n#> [1]  2 20"},{"path":"ch-R-List.html","id":"sapply-함수","chapter":"5 R 리스트","heading":"5.4.2 sapply() 함수","text":"","code":""},{"path":"ch-R-List.html","id":"sapply","chapter":"5 R 리스트","heading":"sapply()","text":"많은 경우에 최종 결과가 리스트보다는 벡터나 행렬 등의 간단한 형태로 제공되는 것이 편리하다. 이런 경우에는 sapply()를 사용한다. (simplified lapply로 기억하면 편리하다.) sapply()도 lapply()와 문법적 구조가 동일하다. 다른 점은 최종 결과를 리스트가 아니라 가능하면 벡터나 행렬처럼 간단한 형식으로 반환한다는 점이다.\nsapply()도 apply() 함수처럼 벡터로 결과를 반환하거나, 요소 하나에 함수를 적용한 결과가 길이가 2 이상인 벡터이면 열로 결과를 붙여서 행렬 형식으로 결과를 반환한다.","code":"\nsapply(b, length)#>  A  B  C \n#>  5  9 10\nsapply(b, range)#>      A  B  C\n#> [1,] 1 21  2\n#> [2,] 5 29 20\nlb <- lapply(b, length)\ntypeof(lb)#> [1] \"list\"\nsb <- sapply(b, length)\ntypeof(sb)#> [1] \"integer\""},{"path":"ch-R-List.html","id":"사용자-정의-함수의-적용","chapter":"5 R 리스트","heading":"사용자 정의 함수의 적용","text":"lapply()와 sapply(), 또는 apply() 등을 이용하여 객체의 각 요소나 부분에 함수를 적용할 때 기존의 함수뿐 아니라 사용자가 정의한 함수를 적용할 수도 있다. (함수를 정의하는 법은 10 장의 함수와 관련된 내용을 참조하기 바란다.) 다음은 리스트의 각 요소에서 10보다 큰 수의 개수를 세는 예이다.","code":"\nsapply(b, function(x){\n  sum(x > 10)\n})#> A B C \n#> 0 9 5"},{"path":"ch-R-List.html","id":"mapply-함수","chapter":"5 R 리스트","heading":"5.4.3 mapply() 함수","text":"lapply()와 sapply()가 하나의 리스트에 대해 각 요소에 함수를 적용한다면, mapply()는 다수의 리스트에 대해 같은 위치의 요소들에 함수를 적용하기 위한 함수이다. mapply()는 sapply()처럼 결과를 벡터나 행렬 등의 단순한 형태로 제공할 수 있으면 리스트가 아니라 단순한 형태로 결과를 제공한다.mapply()는 다음과 같은 문법 구조를 가진다. 먼저 리스트의 요소에 적용할 함수를 첫번째 FUN 인수로 제공한다. 그리고는 함수를 동시에 같이 적용할 리스트의 목록을 기술한다. 그러면 이 리스트의 같은 위치의 요소들이 함수의 인수로 제공된다. 리스트 외에도 별도의 인수를 함수에 제공할 필요가 있으면 MoreArgs 인수에 리스트 형태로 제공한다.다음과 같은 2 개의 리스트가 존재한다고 하자.다음은 리스트의 같은 위치에 있는 요소를 c() 함수를 이용하여 각각 연결한 예이다.또한 mapply()에 리스트를 인수로 제공할 때 이름=리스트 형태로 인수를 제공하면 FUN 인수에 부여된 함수에 해당 이름으로 인수가 제공된다. 다음은 rep() 함수에 반복할 벡터 x와 반복 횟수를 times을 리스트로 제공한 예이다.위의 결과에서 x 리스트의 각 요소와 times 벡터의 각 요소가 차례로 결합되어 rep() 함수가 적용되었음을 볼 수 있다.","code":"\nmapply(FUN, list_1(vector_1), ..., list_n(vector_n), \n       MoreArgs=NULL)\na <- list(1:5, 10:5, letters[1:4])\nb <- list(6:4, 4:7, LETTERS[5:1])\nmapply(c, a, b)#> [[1]]\n#> [1] 1 2 3 4 5 6 5 4\n#> \n#> [[2]]\n#>  [1] 10  9  8  7  6  5  4  5  6  7\n#> \n#> [[3]]\n#> [1] \"a\" \"b\" \"c\" \"d\" \"E\" \"D\" \"C\" \"B\" \"A\"\nmapply(rep, times=2:4, x=list(1:2, 11:12, 21:22))#> [[1]]\n#> [1] 1 2 1 2\n#> \n#> [[2]]\n#> [1] 11 12 11 12 11 12\n#> \n#> [[3]]\n#> [1] 21 22 21 22 21 22 21 22"},{"path":"ch-R-List.html","id":"리스트-활용-분야","chapter":"5 R 리스트","heading":"5.5 리스트 활용 분야","text":"","code":""},{"path":"ch-R-List.html","id":"리스트로-결과를-반환하는-함수의-예","chapter":"5 R 리스트","heading":"리스트로 결과를 반환하는 함수의 예","text":"이 장의 시작부분에서 리스트가 중요한 이유를 설명할 때, 많은 데이터 분석 함수들이 결과를 리스트 형태로 제공한다고 하였다. 실제 그러한지 예를 통해 살펴보도록 하자. 다음은 선형회귀분석을 수행하는 lm() 함수의 결과가 리스트 객체라는 것을 보여준다. 리스트 객체의 각 요소는 수행된 선형회귀분석에 대한 자세한 결과를 저장하고 있다.lm() 함수의 결과의 타입은 list이고, 클래스는 함수의 이름과 동일한 lm임을 볼 수 있다. (R에서는 사용자의 기억을 돕기 위해서 일반적으로 함수의 결과가 복잡한 경우 함수의 이름과 동일한 클래스 이름으로 결과를 반환한다. 클래스에 대해서는 11 장을 참조한다.) lm 클래스의 객체이긴 하지만 타입이 리스트이므로 names() 함수를 이용하여 요소의 이름을 확인하고, $ 연산자를 이용하여 요소에 접근하여 요소의 내용을 확인할 수 있다.","code":"\nx <- lm(dist~speed, data=cars)\nx#> \n#> Call:\n#> lm(formula = dist ~ speed, data = cars)\n#> \n#> Coefficients:\n#> (Intercept)        speed  \n#>     -17.579        3.932\ntypeof(x)#> [1] \"list\"\nclass(x)#> [1] \"lm\"\nnames(x)#>  [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n#>  [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n#>  [9] \"xlevels\"       \"call\"          \"terms\"         \"model\"\nx$residuals#>          1          2          3          4          5          6          7 \n#>   3.849460  11.849460  -5.947766  12.052234   2.119825  -7.812584  -3.744993 \n#>          8          9         10         11         12         13         14 \n#>   4.255007  12.255007  -8.677401   2.322599 -15.609810  -9.609810  -5.609810 \n#>         15         16         17         18         19         20         21 \n#>  -1.609810  -7.542219   0.457781   0.457781  12.457781 -11.474628  -1.474628 \n#>         22         23         24         25         26         27         28 \n#>  22.525372  42.525372 -21.407036 -15.407036  12.592964 -13.339445  -5.339445 \n#>         29         30         31         32         33         34         35 \n#> -17.271854  -9.271854   0.728146 -11.204263   2.795737  22.795737  30.795737 \n#>         36         37         38         39         40         41         42 \n#> -21.136672 -11.136672  10.863328 -29.069080 -13.069080  -9.069080  -5.069080 \n#>         43         44         45         46         47         48         49 \n#>   2.930920  -2.933898 -18.866307  -6.798715  15.201285  16.201285  43.201285 \n#>         50 \n#>   4.268876\nx$terms#> dist ~ speed\n#> attr(,\"variables\")\n#> list(dist, speed)\n#> attr(,\"factors\")\n#>       speed\n#> dist      0\n#> speed     1\n#> attr(,\"term.labels\")\n#> [1] \"speed\"\n#> attr(,\"order\")\n#> [1] 1\n#> attr(,\"intercept\")\n#> [1] 1\n#> attr(,\"response\")\n#> [1] 1\n#> attr(,\".Environment\")\n#> <environment: R_GlobalEnv>\n#> attr(,\"predvars\")\n#> list(dist, speed)\n#> attr(,\"dataClasses\")\n#>      dist     speed \n#> \"numeric\" \"numeric\""},{"path":"ch-R-List.html","id":"unclass","chapter":"5 R 리스트","heading":"unclass()","text":"주의할 점은 리스트이긴 하지만 lm 클래스이므로 출력을 해 보면 리스트의 모든 요소가 출력되는 것이 아니라 lm 클래스에 맞추어 회귀분석의 주요 결과만 간략하게 출력됨을 볼 수 있다. 만약 리스트로서 모든 요소를 확인하고 싶으면 unclass() 함수를 이용하여 객체에 부여된 클래스 속성을 제거한다. 그러면 단순한 리스트 객체가 되어서 모든 요소가 출력된다. 출력이 매우 길므로 출력 결과는 생략하였다.","code":"\nunclass(x)"},{"path":"ch-R-List.html","id":"데이터-프레임","chapter":"5 R 리스트","heading":"데이터 프레임","text":"리스트가 중요한 또 다른 이유는 R에서 데이터를 저장할 때 빈번하게 이용하는 데이터 프레임이라는 형식이 리스트를 기반으로 하고 있기 때문이다. 정확히 이야기하면, 데이터 프레임은 data.frame이라는 클래스 속성을 갖는 리스트이다.이번에도 cars 객체는 리스트로 데이터를 저장하지만, 클래스가 data.frame이므로 출력해 보면 일반적인 리스트의 형식으로 출력되지 않고 행렬 형태로 출력된다. unclass()를 이용하면 클래스가 없어져서 이 데이터가 리스트 형식으로 저장되어 있음을 확인할 수 있다.결과에서 speed와 dist로 이름이 붙여진 숫자 벡터로 구성된 리스트임을 확인할 수 있다. 그리고 row.names라는 속성이 부여되어 있음을 확인할 수 있다.데이터 프레임은 보통 다른 통계 소프트웨어에서 데이터 집합 또는 데이터 행렬이라고 불리는 것이다. R에서는 본질적으로 데이터 프레임은 data.frame 클래스인 리스트인데, 요소의 길이가 모두 같은 리스트이다. 그러므로 데이터를 행렬 형태로 표현할 수 있다. 리스트의 각 요소가 각 열로 표현된다.\n리스트를 데이터 프레임으로 변환시키기 위해서는 .data.frame()을 이용하면 된다.","code":"\nhead(cars)#>   speed dist\n#> 1     4    2\n#> 2     4   10\n#> 3     7    4\n#> 4     7   22\n#> 5     8   16\n#> 6     9   10\ntypeof(cars)#> [1] \"list\"\nclass(cars)#> [1] \"data.frame\"\nunclass(cars)#> $speed\n#>  [1]  4  4  7  7  8  9 10 10 10 11 11 12 12 12 12 13 13 13 13 14 14 14 14 15 15\n#> [26] 15 16 16 17 17 17 18 18 18 18 19 19 19 20 20 20 20 20 22 23 24 24 24 24 25\n#> \n#> $dist\n#>  [1]   2  10   4  22  16  10  18  26  34  17  28  14  20  24  28  26  34  34  46\n#> [20]  26  36  60  80  20  26  54  32  40  32  40  50  42  56  76  84  36  46  68\n#> [39]  32  48  52  56  64  66  54  70  92  93 120  85\n#> \n#> attr(,\"row.names\")\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n#> [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\ny <- list(a=11:15, b=letters[11:15])\ny#> $a\n#> [1] 11 12 13 14 15\n#> \n#> $b\n#> [1] \"k\" \"l\" \"m\" \"n\" \"o\"\ntypeof(y); class(y)#> [1] \"list\"#> [1] \"list\"\nz <- as.data.frame(y)\nz#>    a b\n#> 1 11 k\n#> 2 12 l\n#> 3 13 m\n#> 4 14 n\n#> 5 15 o\ntypeof(z); class(z)#> [1] \"list\"#> [1] \"data.frame\""},{"path":"ch-R-Data-Frame.html","id":"ch-R-Data-Frame","chapter":"6 R 데이터 프레임","heading":"6 R 데이터 프레임","text":"이 장에서는 여러 타입의 데이터가 혼재된 데이터 프레임이란 데이터 구조를 다룬다. 보통 다른 통계 소프트웨어에서 데이터 분석의 기본 단위인 데이터 집합 또는 데이터 행렬이라고 불리는 것이다.","code":""},{"path":"ch-R-Data-Frame.html","id":"데이터-프레임의-두-측면-리스트적-측면-행렬적-측면","chapter":"6 R 데이터 프레임","heading":"데이터 프레임의 두 측면: 리스트적 측면 행렬적 측면","text":"데이터 프레임은 행렬을 일반화한 것으로 생각하면 이해하기 쉽다. 행렬에 속한 데이터는 모두 같은 타입인데 반해, 데이터 프레임은 각 열마다 각기 다른 타입의 데이터를 가질 수 있다. 데이터 프레임에는 한 열은 숫자 타입의 데이터가, 다른 한 열은 문자 타입의 데이터가 각각 들어갈 수 있다.한 강의를 듣는 학생에 대한 표 6.1 같은 데이터가 있다고 하자. 이 데이터에는 중간고사, 기말고사 같이 숫자 데이터도 있지만, 학생 이름과 성별처럼 문자 데이터도 있다. 그리고 재수강 여부처럼 논리 값 데이터도 있다. 데이터의 형태는 다르지만 한 학생에 대한 정보를 얻기 위해서는 숫자, 문자, 논리 값을 포함한 데이터를 다룰 수 있어야 한다. 이 경우에 사용할 수 있는 데이터 구조가 데이터 프레임이다.본질적으로 데이터 프레임은 ‘data.frame’ 클래스인 리스트이다. 리스트가 특정 조건을 만족하면 데이터 프레임이 될 수 있다. 리스트와 데이터 프레임의 관계에 대한 자세한 내용은 5 장을 참조하라.Table 6.1: 한 과목의 수강생 데이터","code":""},{"path":"ch-R-Data-Frame.html","id":"범주형-데이터와-요인-factors","chapter":"6 R 데이터 프레임","heading":"6.1 범주형 데이터와 요인 (Factors)","text":"R 데이터 프레임의 각 열은 숫자, 문자, 논리 값 벡터 또는 요인으로 구성된다. 숫자, 문자, 논리 값 벡터에 대해서는 3 장에서 다루었다. 본 절에서는 R 데이터 프레임에 대하여 설명하기에 앞서 요인에 대하여 살펴보도록 한다.","code":""},{"path":"ch-R-Data-Frame.html","id":"명목형-변수와-요인","chapter":"6 R 데이터 프레임","heading":"6.1.1 명목형 변수와 요인","text":"전국 유권자 대상으로 지지하는 정당에 대해 다음 설문조사를 하였다고 하자.다음 중 지지하는 정당은? ( )정당B 정당C 정당지지하는 정당 없음","code":""},{"path":"ch-R-Data-Frame.html","id":"범주-데이터의-숫자-코딩","chapter":"6 R 데이터 프레임","heading":"범주 데이터의 숫자 코딩","text":"10 명의 유권자에게 응답을 얻었다면 아마도 1부터 4까지의 숫자를 이용하여 다음과 같이 설문 결과를 입력하게 될 것이다.여기서 숫자로 코딩된 설문 결과는 1부터 4까지의 수량적 의미를 가지기보다는 4가지 범주(정당, B 정당, C 정당, 없음)의 차이를 숫자로 표현한 것 뿐이다. 그런데 이렇게 범주형 데이터를 숫자 벡터로 표현하는 것은 범주형 데이터를 편리하게 코딩할 수 있는 장점이 있는 반면 다음과 같은 단점을 가진다.","code":"\nresults <- c(1, 3, 2, 4, 3, 2, 1, 3, 2, 2)\nresults#>  [1] 1 3 2 4 3 2 1 3 2 2"},{"path":"ch-R-Data-Frame.html","id":"숫자-코딩의-문제점","chapter":"6 R 데이터 프레임","heading":"숫자 코딩의 문제점","text":"결과가 숫자 벡터로 입력되었으므로 다음처럼 어떤 범주에도 대응되지 않는 잘못된 숫자가 입력될 수도 있다.결과를 숫자형 데이터로 오인하여 잘못된 처리를 수행할 수 있다. 입력하는 시점에는 오인을 할 가능성이 적지만 데이터를 분석하는 과정에서 주의를 기울이지 않으면 범주형 데이터를 숫자 데이터로 오인하여 잘못된 분석을 수행할 수 있다. 다음은 범주형 데이터를 나타내는 벡터를 수량 데이터로 오인하여 평균을 분석한 예이다.데이터 입력 후 제대로 기록해 두지 않으면 각 숫자의 의미가 무엇인지 파악하기 어렵게 된다.","code":"\nresults[1] <- 5\nresults#>  [1] 5 3 2 4 3 2 1 3 2 2\nmean(results)#> [1] 2.7"},{"path":"ch-R-Data-Frame.html","id":"factor","chapter":"6 R 데이터 프레임","heading":"factor()","text":"이러한 문제를 해결하기 위해 R은 범주형 데이터를 처리할 때 이용할 수 있는 요인(factor)이라는 데이터 형태를 제공한다. 요인을 생성하기 위해서 factor() 함수를 이용한다.","code":""},{"path":"ch-R-Data-Frame.html","id":"수준-levels","chapter":"6 R 데이터 프레임","heading":"수준 levels","text":"다음은 숫자로 코딩된 결과(results)를 이용하여 1, 2, 3, 4 수준(level)을 가진 요인을 생성한 예이다. 요인에서 수준은 요인 데이터가 가질 수 있는 차별적 값을 나타낸다.결과에서 보듯이 수준에 포함되지 않은 5의 값은 NA로 변환된다. 요인으로 변경된 데이터의 클래스는 factor가 되고, levels 속성이 지정되어 있음을 볼 수 있다. results의 첫 번째 데이터를 제대로 된 값인 1로 변경한 후 다시 한번 요인으로 변경해 보자.만약 요인 데이터에 이미 정의된 수준을 제외한 다른 값을 입력하면 다음과 같이 경고가 출력되고 입력된 데이터는 NA로 입력됨을 볼 수 있다.만약 요인 데이터를 숫자 벡터로 착각하여 평균을 구하려고 해 보자. 먼저 fResults의 데이터를 원래대로 돌려놓은 후 mean() 함수로 평균을 구해보자. 그러면 숫자 데이터가 아니므로 평균을 구할 수 없음을 알 수 있다.","code":"\nresults#>  [1] 5 3 2 4 3 2 1 3 2 2\nattributes(results)#> NULL\nfResults <- factor(results, levels=1:4)\nfResults#>  [1] <NA> 3    2    4    3    2    1    3    2    2   \n#> Levels: 1 2 3 4\nattributes(fResults)#> $levels\n#> [1] \"1\" \"2\" \"3\" \"4\"\n#> \n#> $class\n#> [1] \"factor\"\nresults[1] <- 1\nfResults <- factor(results, levels=1:4)\nfResults#>  [1] 1 3 2 4 3 2 1 3 2 2\n#> Levels: 1 2 3 4\nfResults[11] <- 4\nfResults#>  [1] 1 3 2 4 3 2 1 3 2 2 4\n#> Levels: 1 2 3 4\nfResults[12] <- 5#> Warning in `[<-.factor`(`*tmp*`, 12, value = 5): 요인의 수준(factor level)이\n#> 올바르지 않아 NA가 생성되었습니다.\nfResults#>  [1] 1    3    2    4    3    2    1    3    2    2    4    <NA>\n#> Levels: 1 2 3 4\nfResults[12] <- 2\nfResults#>  [1] 1 3 2 4 3 2 1 3 2 2 4 2\n#> Levels: 1 2 3 4\nmean(fResults)#> Warning in mean.default(fResults): 인자가 수치형 또는 논리형이 아니므로 NA를\n#> 반환합니다#> [1] NA"},{"path":"ch-R-Data-Frame.html","id":"levels","chapter":"6 R 데이터 프레임","heading":"levels()","text":"요인의 수준을 좀 더 의미있는 형태로 바꾸어 보자. 그러면 요인에 입력된 숫자가 각각 어떤 범주에 대응하는지를 쉽게 파악할 수 있다.이제 fResults 요인을 출력해 보면 각 데이터가 수준에 정의된 문자로 표현됨을 볼 수 있다. 그러면 fResults는 문자 데이터로 변환된 것일까? 그렇지 않다. 요인은 내부적으로 데이터를 각각의 범주를 1부터 시작하는 자연수로 관리한다. 이 예에서는 4가지 서로 다른 범주(수준)이 있으므로 1부터 4까지의 자연수로 데이터를 표현한다. 단지 입출력될 때 요인에 부여된 수준으로 처리를 할 뿐이다. 이를 확인하기 위해서 typeof() 함수로 요인의 근원적 타입을 확인하고, unclass() 함수를 이용하여 요인이 내부적으로 어떤 정보를 가지고 있는지 확인해 보자.요인이 내부적으로 숫자로 데이터를 표현하고 있다고 하더라도, 수준에 정의되지 않은 숫자로 데이터를 입력할 수는 없다. 요인은 항상 수준에 정의되어 있는 데이터 값만으로 입력되거나 출력될 수 있다.","code":"\nlevels(fResults)#> [1] \"1\" \"2\" \"3\" \"4\"\nlevels(fResults) <- c(\"A\", \"B\", \"C\", \"None\")\nfResults#>  [1] A    C    B    None C    B    A    C    B    B    None B   \n#> Levels: A B C None\ntypeof(fResults)#> [1] \"integer\"\nclass(fResults)#> [1] \"factor\"\nunclass(fResults)#>  [1] 1 3 2 4 3 2 1 3 2 2 4 2\n#> attr(,\"levels\")\n#> [1] \"A\"    \"B\"    \"C\"    \"None\"\nlevels(fResults)#> [1] \"A\"    \"B\"    \"C\"    \"None\"\nfResults[11] <- 4#> Warning in `[<-.factor`(`*tmp*`, 11, value = 4): 요인의 수준(factor level)이\n#> 올바르지 않아 NA가 생성되었습니다.\nfResults[12] <- \"None\"\nfResults#>  [1] A    C    B    None C    B    A    C    B    B    <NA> None\n#> Levels: A B C None"},{"path":"ch-R-Data-Frame.html","id":"순서형-변수와-요인","chapter":"6 R 데이터 프레임","heading":"6.1.2 순서형 변수와 요인","text":"범주형 데이터는 앞의 예처럼 범주 간에 순서가 없는 명목형 데이터도 있지만, 범주 간에 순서가 있는 순서형 데이터도 있다. 전국 유권자 대상으로 현 정권에 대한 만족도에 대해 다음 설문조사를 하였다고 하자.현 정권의 국정 수행에 대해 만족하고 계십니까? ( )매우 불만불만보통만족매우 만족설문 결과를 다음과 같이 요인을 가지고 결과를 코딩할 수 있을 것이다. 그러나 요인은 디폴트로 수준 간에 순서가 없는 명목형 변수로 데이터를 처리한다. 그러므로 순서를 비교하는 비교 연산을 적용할 수 없다.","code":"\nsatisfaction <- c(\"매우 불만\", \"매우 만족\", \"불만\", \"만족\", \"보통\", \n                  \"불만\", \"매우 불만\", \"보통\", \"매우 만족\", \"불만\")\nfSatisfaction <- factor(satisfaction, \n        levels=c(\"매우 불만\", \"불만\", \"보통\", \"만족\", \"매우 만족\"))\nfSatisfaction#>  [1] 매우 불만 매우 만족 불만      만족      보통      불만      매우 불만\n#>  [8] 보통      매우 만족 불만     \n#> Levels: 매우 불만 불만 보통 만족 매우 만족\nfSatisfaction >= \"만족\"#> Warning in Ops.factor(fSatisfaction, \"만족\"): 요인(factors)에 대하여 의미있는\n#> '>='가 아닙니다.#>  [1] NA NA NA NA NA NA NA NA NA NA"},{"path":"ch-R-Data-Frame.html","id":"ordered-인수로-순서형-변수-만들기","chapter":"6 R 데이터 프레임","heading":"ordered 인수로 순서형 변수 만들기","text":"명목형 데이터를 나타내는 요인의 숫자는 각 범주를 표현하는 의미를 가지므로 앞의 맨 마지막 예처럼 순서를 비교하는 연산을 수행할 수 없다. 그런데 이 경우에는 범주 간에 순서적 의미가 있으므로 factor() 함수의 ordered 인수를 설정하여 범주 간의 순서 관계를 명확히 할 수 있다. 다음 예에서 볼 수 있듯이 범주 간의 순서가 수준이 출력될 때 명시됨을 볼 수 있고, 순서 비교가 가능함을 볼 수 있다. 심지어는 order() 함수로 순서를 파악할 수 있다.R은 범주형 변수인 ’불만’과 ’만족’의 순서를 알 수 없다. ordered() 함수로 순서형 범주를 만들 때 levels에 나열된 순서로 크기가 주어진다고 가정한다. 만약 위의 예에서 levels의 순서가 다르면 다른 결과가 나올 것이다.","code":"\noSatisfaction <- factor(satisfaction, ordered = TRUE,\n        levels=c(\"매우 불만\", \"불만\", \"보통\", \"만족\", \"매우 만족\"))\noSatisfaction#>  [1] 매우 불만 매우 만족 불만      만족      보통      불만      매우 불만\n#>  [8] 보통      매우 만족 불만     \n#> Levels: 매우 불만 < 불만 < 보통 < 만족 < 매우 만족\noSatisfaction >= \"만족\" #>  [1] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE\nsum(oSatisfaction >= \"만족\")#> [1] 3\nmean(oSatisfaction >= \"만족\")#> [1] 0.3\norder(oSatisfaction)#>  [1]  1  7  3  6 10  5  8  4  2  9\noSatisfaction <- factor(satisfaction, ordered = TRUE,\n        levels=c(\"매우 만족\", \"만족\", \"보통\", \"불만\", \"매우 불만\"))\noSatisfaction#>  [1] 매우 불만 매우 만족 불만      만족      보통      불만      매우 불만\n#>  [8] 보통      매우 만족 불만     \n#> Levels: 매우 만족 < 만족 < 보통 < 불만 < 매우 불만\noSatisfaction >= \"만족\" #>  [1]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\nsum(oSatisfaction >= \"만족\")#> [1] 8\nmean(oSatisfaction >= \"만족\")#> [1] 0.8\norder(oSatisfaction)#>  [1]  2  9  4  5  8  3  6 10  1  7"},{"path":"ch-R-Data-Frame.html","id":"수준의-순서","chapter":"6 R 데이터 프레임","heading":"수준의 순서","text":"순서형이 아닌 명목형 범주 데이터는 factor()로 만들어지고 이 때도 levels에 주어진 순서로, 범주(수준)가 내부적으로 저장되는 숫자가 결정된다. levels에 언급된 수준의 순서대로 1번부터 차례로 숫자가 부여된다. 순서형 범주 데이터처럼 순서가 데이터 분석에 핵심적인 역할을 하지는 않지만, 그래프나 표가 표현될 때 이 범주(수준)의 순서대로 출력되므로, 범주를 원하는 순서대로 출력하고자 하면 levels 인수에 수준의 순서를 명시하는 것이 좋다. 그렇지 않으면 단어의 사전적 순서 등에 의해 순서가 부여된다.","code":"\na <- c(\"F\", \"M\", \"F\", \"M\", \"F\")\nfa1 <- factor(a)\nfa1#> [1] F M F M F\n#> Levels: F M\nunclass(fa1)#> [1] 1 2 1 2 1\n#> attr(,\"levels\")\n#> [1] \"F\" \"M\"\ntable(fa1)#> fa1\n#> F M \n#> 3 2\nfa2 <- factor(a, levels=c(\"M\", \"F\"))\nfa2#> [1] F M F M F\n#> Levels: M F\nunclass(fa2)#> [1] 2 1 2 1 2\n#> attr(,\"levels\")\n#> [1] \"M\" \"F\"\ntable(fa2)#> fa2\n#> M F \n#> 2 3"},{"path":"ch-R-Data-Frame.html","id":"relevel과-reorder를-이용한-수준의-순서-변경","chapter":"6 R 데이터 프레임","heading":"relevel()과 reorder()를 이용한 수준의 순서 변경","text":"앞의 예에서는 factor() 함수의 levels 인수를 사용하여 수준의 순서를 바꾸는 방법을 보았다.\n이러한 방법은 수준의 수가 적을 때는 편리한 방법이지만, 수준의 수가 많으면 모든 수준을 levels 인수에 나열하여야 하기 때문에 불편하다.\n예를 들어, 분석의 주안점이 되는 수준이 있고, 나머지 수준의 순서는 중요하지 않은 경우, 관심의 대상이 되는 수준이 맨 앞에 오도록 순서를 변경하려면 factor() 함수의 levels 인수에 모든 수준을 다시 나열해 주어야 하므로 불편하다.\n이러한 경우에는 relevel() 함수를 사용하면 원하는 결과를 쉽게 얻을 수 있다.다음의 fResult 요인에서 \"None\"이라는 수준이 맨 앞에 나타나도록 변경하고자 한다.relevel() 함수의 ref 인수에 맨 앞에 나타날 수준을 지정하면 나머지 수준의 순서는 변하지 않고 지정된 수준만 앞으로 이동하게 된다.InsectSprays는 살충제의 종류(spray)와 농작물에 있는 해충의 수(count)를 보여주는 데이터이다.\n살충제의 종류는 6 개의 수준을 가지는 요인이다.다음은 살충제 종류에 따른 해충의 수의 분포를 상자 그래프로 나타낸 것이다.그런데 이런 데이터는 살충력이 높은 것에서 낮은 것 순으로 배열되는 것이 더 이해하기가 쉽다.\n그러한 형태로 그래프를 그리려면 요인이 spray 열의 수준이 count의 중위수가 낮은 것부터 높은 것 순으로 정렬되어야 한다.\nreorder() 함수를 사용하면 이러한 수준의 변경을 손 쉽게 할 수 있다.\nreorder()는 첫 번째 인수로 요인을, 두 번째 인수로 요인의 수준을 결정할 다른 수치 벡터를, 세 번째 인수로 수치 벡터에 적용할 통계 함수를 지정한다. 그러면 수치 벡터를 요인의 수준 별로 나누어 통계 함수를 적용한 후, 가장 낮은 값에서 큰 값으로 수준의 순서를 재정렬한다.","code":"\nfResults#>  [1] A    C    B    None C    B    A    C    B    B    <NA> None\n#> Levels: A B C None\nfResults2 <- relevel(fResults, ref = \"None\")\nfResults2#>  [1] A    C    B    None C    B    A    C    B    B    <NA> None\n#> Levels: None A B C\ntable(fResults2)#> fResults2\n#> None    A    B    C \n#>    2    2    4    3\nhead(InsectSprays)#>   count spray\n#> 1    10     A\n#> 2     7     A\n#> 3    20     A\n#> 4    14     A\n#> 5    14     A\n#> 6    12     A\nInsectSprays$spray#>  [1] A A A A A A A A A A A A B B B B B B B B B B B B C C C C C C C C C C C C D D\n#> [39] D D D D D D D D D D E E E E E E E E E E E E F F F F F F F F F F F F\n#> Levels: A B C D E F\nboxplot(count ~ spray, data=InsectSprays)\nboxplot(count ~ reorder(spray, count, median), data=InsectSprays)"},{"path":"ch-R-Data-Frame.html","id":"labels-인수","chapter":"6 R 데이터 프레임","heading":"labels 인수","text":"요인을 만든 후 기존의 수준을 변경하고 싶으면 levels() 함수를 이용하여 새로운 수준을 할당한다고 설명하였다. 그러나 요인을 만들 때 기존에 코딩된 수준을 바로 변경하고 싶을 수가 있다. 이 경우에는 factor() 함수에 labels 인수를 이용하면 기존의 수준이 labels 인수에 주어진 형태로 변경된다. 이 때 주의할 점은 levels 인수는 원래 데이터가 코딩된 형태로 정의되어야 하고, labels 인수는 바꿀 코딩 형태로 정의되어야 한다.","code":"\nfa3 <- factor(a, levels=c(\"M\", \"F\"), labels=c(\"Male\", \"Female\"))\nfa3#> [1] Female Male   Female Male   Female\n#> Levels: Male Female\nunclass(fa3)#> [1] 2 1 2 1 2\n#> attr(,\"levels\")\n#> [1] \"Male\"   \"Female\"\ntable(fa3)#> fa3\n#>   Male Female \n#>      2      3\nfa3[6] <- \"M\"#> Warning in `[<-.factor`(`*tmp*`, 6, value = \"M\"): 요인의 수준(factor level)이\n#> 올바르지 않아 NA가 생성되었습니다.\nfa3[6] <- \"Male\""},{"path":"ch-R-Data-Frame.html","id":"데이터-프레임-만들기","chapter":"6 R 데이터 프레임","heading":"6.2 데이터 프레임 만들기","text":"","code":""},{"path":"ch-R-Data-Frame.html","id":"data.frame","chapter":"6 R 데이터 프레임","heading":"data.frame()","text":"data.frame() 함수를 이용하면 벡터, 행렬, 요인, 심지어 다른 데이터 프레임을 묶어서 새로운 데이터 프레임을 만들 수 있다. 이 때 다음과 같은 제한 조건이 있다.첫째, 벡터는 모두 같은 길이를 가져야 하며 행렬과 데이터 프레임은 모두 같은 행 수를 가져야 한다. 벡터의 같은 위치의 데이터와 행렬 및 데이터 프레임의 같은 행에 있는 데이터가 연결되어 하나의 데이터 단위가 된다.둘째, 벡터는 하나의 벡터가 데이터 프레임의 하나의 열이 되지만, 행렬, 데이터 프레임은 각 열이 데이터 프레임의 하나의 열이 된다.이러한 사실을 염두하면서 표 6.1의 데이터를 데이터 프레임으로 만들어 본다. 먼저 학생이름, 학년, 성별로만 이루어진 데이터 프레임을 만들어 보자.위의 예에서는 길이가 같은 벡터와 요인을 인수로 해서 데이터 프레임을 만들었다. 데이터 프레임을 출력해 보면 자동으로 행 번호가 부여되어 있음을 볼 수 있다. 열의 이름으로 각각 벡터와 요인을 저장한 변수명이 부여되었음을 볼 수 있다.이번에는 만들어진 데이터 프레임에 중간, 기말 고사 점수와 재수강 여부를 포함시켜 새로운 데이터 프레임을 만들어 보자. 아래 예에서는 중간, 기말 고사 점수를 행렬로 먼저 만든 후 데이터 프레임에 포함시켜 보았다.위에서 새로운 데이터 프레임의 각 열의 이름은 기존 데이터 프레임의 각 열의 이름, 행렬의 열 이름이 자동으로 부여되고 있음을 볼 수 있다. 재수강 여부 데이터벡터 rt는 data.frame()이 호출될 때, retake = rt 형태로 인수를 전달하여 새로운 데이터 프레임에서는 이름이 retake로 변경되었다. 데이터 프레임을 생성할 때 각 열에 이름을 부여하고 싶으면 이와 같은 방식으로 이름을 부여하면 된다.","code":"\nname <- c(\"김철수\", \"김영희\", \"이철수\", \"이영희\", \"홍길동\")\ngrade <- c(1, 4, 3, 2, 1)\ngender <- c(\" M\", \"F\", \"M\", \"F\", \"M\")\nstudent <- data.frame(name, grade, gender)\nstudent#>     name grade gender\n#> 1 김철수     1      M\n#> 2 김영희     4      F\n#> 3 이철수     3      M\n#> 4 이영희     2      F\n#> 5 홍길동     1      M\nmidterm = c(74, 82, 67, 89, 92)\nfinal = c(91, 77, 88, 78, 86)\nscores = cbind(midterm, final)\nscores#>      midterm final\n#> [1,]      74    91\n#> [2,]      82    77\n#> [3,]      67    88\n#> [4,]      89    78\n#> [5,]      92    86\nrt <- c(TRUE, FALSE, FALSE, TRUE, FALSE)\nstudents <- data.frame(student, scores, retake = rt)\nstudents#>     name grade gender midterm final retake\n#> 1 김철수     1      M      74    91   TRUE\n#> 2 김영희     4      F      82    77  FALSE\n#> 3 이철수     3      M      67    88  FALSE\n#> 4 이영희     2      F      89    78   TRUE\n#> 5 홍길동     1      M      92    86  FALSE"},{"path":"ch-R-Data-Frame.html","id":"cbind","chapter":"6 R 데이터 프레임","heading":"cbind()","text":"앞서 설명하였듯이 데이터 프레임은 행렬적인 외양을 가지고 있으므로 행렬처럼 cbind()나 rbind()를 이용하여 행과 열을 추가할 수 있다. 다음 예는 cbind를 이용하여 중간과 기말의 총점 열을 추가한 예이다.","code":"\ntotal.scores <- midterm + final\ncbind(students, total.scores)#>     name grade gender midterm final retake total.scores\n#> 1 김철수     1      M      74    91   TRUE          165\n#> 2 김영희     4      F      82    77  FALSE          159\n#> 3 이철수     3      M      67    88  FALSE          155\n#> 4 이영희     2      F      89    78   TRUE          167\n#> 5 홍길동     1      M      92    86  FALSE          178"},{"path":"ch-R-Data-Frame.html","id":"rbind","chapter":"6 R 데이터 프레임","heading":"rbind()","text":"다음 예는 rbind()로 새로운 데이터 행을 추가한 예이다. 이 때 주의할 점은 추가할 데이터의 각 항목의 이름과 형식이 일치해야 한다는 것이다.","code":"\na <- data.frame(name=\"Jane Eyre\", grade=4, gender=\"F\", \n                midterm=90, final=85, retake=F)\na#>        name grade gender midterm final retake\n#> 1 Jane Eyre     4      F      90    85  FALSE\nrbind(students, a)#>        name grade gender midterm final retake\n#> 1    김철수     1      M      74    91   TRUE\n#> 2    김영희     4      F      82    77  FALSE\n#> 3    이철수     3      M      67    88  FALSE\n#> 4    이영희     2      F      89    78   TRUE\n#> 5    홍길동     1      M      92    86  FALSE\n#> 6 Jane Eyre     4      F      90    85  FALSE"},{"path":"ch-R-Data-Frame.html","id":"데이터-프레임-각-열의-지정","chapter":"6 R 데이터 프레임","heading":"6.3 데이터 프레임 각 열의 지정","text":"","code":""},{"path":"ch-R-Data-Frame.html","id":"데이터-프레임은-리스트-타입","chapter":"6 R 데이터 프레임","heading":"데이터 프레임은 리스트 타입","text":"생성된 데이터 프레임에 대해 typeof() 함수와 attributes() 함수를 이용하여 타입과 속성을 알아보자. 다음 결과에서 데이터 프레임은 리스트 타입이며, names 속성에 데이터 프레임의 각 열의 이름이 나열되어 있음을 볼 수 있다.","code":"\ntypeof(students)#> [1] \"list\"\nattributes(students)#> $names\n#> [1] \"name\"    \"grade\"   \"gender\"  \"midterm\" \"final\"   \"retake\" \n#> \n#> $class\n#> [1] \"data.frame\"\n#> \n#> $row.names\n#> [1] 1 2 3 4 5"},{"path":"ch-R-Data-Frame.html","id":"리스트-형식으로-데이터-프레임의-열-지정","chapter":"6 R 데이터 프레임","heading":"리스트 형식으로 데이터 프레임의 열 지정","text":"데이터 프레임은 본질적으로 리스트 타입이므로 데이터 프레임의 각 열은 리스트의 요소가 된다. 따라서 데이터 프레임의 각 열을 지정할 때는 리스트의 각 요소를 지정할 때와 마찬가지로, $ 기호 또는 [[ ]]를 이용하여 다음과 같은 형태로 지정하면 된다. 이는 데이터 프레임이 리스트 타입이기 때문에 리스트와 같은 방식으로 요소들에 접근할 수 있기 때문이다. 리스트에 대한 자세한 설명은 5 장을 확인하기 바란다.다음은 위에서 생성한 students의 각 열을 이름으로 지정하여, 학생의 성별 데이터, 중간, 기말고사를 출력한 예이다.","code":"\ndata_frame_name$column_name\ndata_frame_name[[column_number]]\ndata_frame_name[[column_name]]\nstudents$gender#> [1] \" M\" \"F\"  \"M\"  \"F\"  \"M\"\nstudents[[\"midterm\"]]#> [1] 74 82 67 89 92\nstudents[[5]]#> [1] 91 77 88 78 86\nstudents$name#> [1] \"김철수\" \"김영희\" \"이철수\" \"이영희\" \"홍길동\"\ntypeof(students$name)#> [1] \"character\""},{"path":"ch-R-Data-Frame.html","id":"데이터-프레임의-각-열은-벡터","chapter":"6 R 데이터 프레임","heading":"데이터 프레임의 각 열은 벡터","text":"데이터 프레임의 각 열은 벡터이므로 데이터 프레임의 특정 열을 리스트 필터링과 같은 방식으로 지정한 후, 벡터 연산이나 벡터 인덱스를 이용하여 각 요소의 값을 출력하거나 변경할 수 있다.또한 리스트에 새로운 요소를 추가할 때와 마찬가지 방법으로 열을 추가할 수도 있다. 다음 예는 hw이라는 이름으로 숙제 점수 열을 추가하는 예이다.","code":"\nstudents$midterm * 2#> [1] 148 164 134 178 184\nsum(students$midterm)#> [1] 404\nstudents$midterm[5]#> [1] 92\nstudents$midterm[5] <- 50\nstudents[[4]][3:5]#> [1] 67 89 50\nstudents$hw <- c(8, 9, 7, 8, 10)\nstudents#>     name grade gender midterm final retake hw\n#> 1 김철수     1      M      74    91   TRUE  8\n#> 2 김영희     4      F      82    77  FALSE  9\n#> 3 이철수     3      M      67    88  FALSE  7\n#> 4 이영희     2      F      89    78   TRUE  8\n#> 5 홍길동     1      M      50    86  FALSE 10"},{"path":"ch-R-Data-Frame.html","id":"데이터-프레임의-필터링","chapter":"6 R 데이터 프레임","heading":"6.4 데이터 프레임의 필터링","text":"데이터를 분석하다 보면 작업 중인 데이터 프레임의 일부만을 선택하여 작업을 할필요가 있다. 어떤 경우에는 데이터의 일부분만 변경할 필요가 있다. 필요 없는 열을 제거하거나 새로운 열을 추가하기 위해서는 여러 열을 한번에 지정할 수도 있어야 한다.이러한 작업을 수행하기 위해서는 데이터 프레임의 일부분을 지정하는 필터링을 수행하여야 한다. 데이터 프레임은 리스트를 기본적인 속성으로 하기 때문에 리스트로서 부분을 필터링하는 방법이 있고, 행렬적 외양을 가지고 있기 때문에 행렬처럼 필터링을 하는 방법이 있다.","code":""},{"path":"ch-R-Data-Frame.html","id":"리스트-형식으로-필터링","chapter":"6 R 데이터 프레임","heading":"6.4.1 리스트 형식으로 필터링","text":"데이터 프레임은 리스트 구조를 가지고 있으며, 데이터 프레임의 열은 리스트의 각 요소가 된다. 따라서 5 장에서 이용한 리스트의 부분 필터링을 수행하는 방법으로 데이터 프레임의 일부 열만 필터링을 수행할 수 있다.","code":""},{"path":"ch-R-Data-Frame.html","id":"리스트로서-필터링은-1차원-인덱스-구조를-갖는다.","chapter":"6 R 데이터 프레임","heading":"리스트로서 필터링은 1차원 인덱스 구조를 갖는다.","text":"리스트로서 데이터 프레임을 필터링하는 방법은 아래와 같이 인덱스 벡터를 이용하는 것이다. 여기서 인덱스 벡터는 벡터나 리스트의 인덱스 벡터와 마찬가지로 숫자, 이름, 논리값 벡터가 될 수 있다.다음 예는 students 데이터 프레임에서 열의 인덱스를 숫자, 이름, 논리값으로 각각 지정하여 새로운 데이터 프레임을 만든 경우이다.data.frame() 함수를 이용하면 기존의 데이터 프레임에 새로운 열을 추가하여 새로운 데이터 프레임도 만들 수 있다. 다음 예는 기존의 students 데이터 프레임에 키 데이터를 추가한 경우이다.","code":"\ndata_frame_name[index_vector]\nstudents.new <- students[1:2]\nstudents.new#>     name grade\n#> 1 김철수     1\n#> 2 김영희     4\n#> 3 이철수     3\n#> 4 이영희     2\n#> 5 홍길동     1\nstudents.new <- students[-(1:2)]\nstudents.new#>   gender midterm final retake hw\n#> 1      M      74    91   TRUE  8\n#> 2      F      82    77  FALSE  9\n#> 3      M      67    88  FALSE  7\n#> 4      F      89    78   TRUE  8\n#> 5      M      50    86  FALSE 10\nstudent.new <- students[c(\"gender\", \"grade\")]\nstudent.new#>   gender grade\n#> 1      M     1\n#> 2      F     4\n#> 3      M     3\n#> 4      F     2\n#> 5      M     1\nstudent.new <- students[c(T, F, F, T, T, F)]\nstudent.new#>     name midterm final hw\n#> 1 김철수      74    91  8\n#> 2 김영희      82    77  9\n#> 3 이철수      67    88  7\n#> 4 이영희      89    78  8\n#> 5 홍길동      50    86 10\nheight <- c(172, 167, 181, 162, 178)\nstudents.new <- data.frame(students[2:3], height=height)\nstudents.new#>   grade gender height\n#> 1     1      M    172\n#> 2     4      F    167\n#> 3     3      M    181\n#> 4     2      F    162\n#> 5     1      M    178"},{"path":"ch-R-Data-Frame.html","id":"열-지정하기-vs.-한-열만-데이터-프레임으로-필터링","chapter":"6 R 데이터 프레임","heading":"열 지정하기 vs. 한 열만 데이터 프레임으로 필터링","text":"앞서 설명하였듯이 데이터 프레임은 리스트이므로 데이터 프레임의 한 열만을 지정할 때 []뿐 아니라 [[]]나 와 $를 이용해 한 열을 지정할 수 있다. 두 방식의 차이는 전자가 데이터 프레임에서 지정된 열만으로 이루어진 새로운 데이터 프레임을 반환하는 반면, 후자는 데이터 프레임에 있는 열 자체, 즉 벡터를 반환한다. 아래는 students 데이터 프레임에서 []와 [[]]를 이용하여 두번째 열을 지정한 결과이다.지금까지 설명한 내용은 데이터 프레임이 리스트 타입이기 때문에 성립하는 내용이다. 따라서 지금까지 설명한 내용은 리스트에도 모두 적용된다.","code":"\na <- students[2]\na#>   grade\n#> 1     1\n#> 2     4\n#> 3     3\n#> 4     2\n#> 5     1\ntypeof(a)#> [1] \"list\"\nattributes(a)#> $names\n#> [1] \"grade\"\n#> \n#> $row.names\n#> [1] 1 2 3 4 5\n#> \n#> $class\n#> [1] \"data.frame\"\na <- students[[2]]\na#> [1] 1 4 3 2 1\ntypeof(a)#> [1] \"double\"\nattributes(a)#> NULL"},{"path":"ch-R-Data-Frame.html","id":"행렬-형식으로-필터링","chapter":"6 R 데이터 프레임","heading":"6.4.2 행렬 형식으로 필터링","text":"","code":""},{"path":"ch-R-Data-Frame.html","id":"행렬로서-필터링은-2차원-인덱스-구조를-갖는다.","chapter":"6 R 데이터 프레임","heading":"행렬로서 필터링은 2차원 인덱스 구조를 갖는다.","text":"데이터 프레임은 열의 길이가 모두 같기 때문에, 보통의 리스트에는 없는 행렬과 같은 필터링 방법이 존재한다. 특히 기존의 데이터 프레임에 행을 삭제 또는 추가할 필요가 있는 경우 이러한 행렬 방식의 필터링 방법은 매우 유용한다.\n데이터 프레임의 인덱스 벡터의 사용은 다음과 같이 행렬의 방식과 동일하게 행과 열을 독립적으로 지정하는 2차원 인덱스 구조를 가진다.다음은 students 데이터 프레임에서 행렬 인덱스 벡터를 이용하여 데이터의 일부를 지정한 예이다.","code":"\ndata_frame_name[row_index_vector, column_index_vector]\nstudents[1,]#>     name grade gender midterm final retake hw\n#> 1 김철수     1      M      74    91   TRUE  8\nstudents[2:3,]#>     name grade gender midterm final retake hw\n#> 2 김영희     4      F      82    77  FALSE  9\n#> 3 이철수     3      M      67    88  FALSE  7\nstudents[-(2:3),]#>     name grade gender midterm final retake hw\n#> 1 김철수     1      M      74    91   TRUE  8\n#> 4 이영희     2      F      89    78   TRUE  8\n#> 5 홍길동     1      M      50    86  FALSE 10\nstudents[,4]#> [1] 74 82 67 89 50\nstudents[,-4]#>     name grade gender final retake hw\n#> 1 김철수     1      M    91   TRUE  8\n#> 2 김영희     4      F    77  FALSE  9\n#> 3 이철수     3      M    88  FALSE  7\n#> 4 이영희     2      F    78   TRUE  8\n#> 5 홍길동     1      M    86  FALSE 10\nstudents[, c(2, 4)]#>   grade midterm\n#> 1     1      74\n#> 2     4      82\n#> 3     3      67\n#> 4     2      89\n#> 5     1      50\nstudents[2:4, 3:5]#>   gender midterm final\n#> 2      F      82    77\n#> 3      M      67    88\n#> 4      F      89    78\nstudents$midterm >= 80#> [1] FALSE  TRUE FALSE  TRUE FALSE\nstudents[students$midterm >= 80, ]#>     name grade gender midterm final retake hw\n#> 2 김영희     4      F      82    77  FALSE  9\n#> 4 이영희     2      F      89    78   TRUE  8\nstudents[students$midterm >= 80, c(\"name\", \"grade\", \"gender\")]#>     name grade gender\n#> 2 김영희     4      F\n#> 4 이영희     2      F\nstudents[students$grade != 1, c(\"name\", \"grade\", \"gender\")]#>     name grade gender\n#> 2 김영희     4      F\n#> 3 이철수     3      M\n#> 4 이영희     2      F"},{"path":"ch-R-Data-Frame.html","id":"행렬-필터링-방법을-이용한-데이터-프레임-정렬","chapter":"6 R 데이터 프레임","heading":"행렬 필터링 방법을 이용한 데이터 프레임 정렬","text":"행렬과 마찬가지로 데이터 프레임을 특정 열을 기준으로 정렬할 수 있다. 다음은 학년을 기준으로 데이터 프레임을 정렬한 예와, 기말고사 점수가 높은 학생부터 낮은 학생 순으로 정렬한 예이다.만약 학생을 학년으로 정렬을 한 후, 동일 학년이면 기말고사가 높은 사람이 먼저 나오게 정렬하고자 하면 어떻게 할까?\n사실 order() 함수는 길이가 같은 여러 개의 벡터를 차례대로 비교하여 순위를 결정할 수 있다. order()의 인수 중 맨처음 나열된 벡터를 기준으로 순서를 결정하지만, 동률이 있으면 두번째로 나열된 벡터를 기준으로 동률 간의 순서를 결정한다. 두번째 벡터에서도 동률이면 다음에 나열된 벡터를 기준으로 이용한다.\n예를 들어 학생을 학년 순서로 정렬하는데, 학년이 동률인 경우 기말고사 점수로 순서를 정한다고 하자. 그러면 다음과 같이 order() 함수를 기술하면 된다.그런데 우리는 학년은 낮은 학년부터 높은 학년으로 정렬하지만 기말고사는 높은 점수에서 낮은 점수로 정렬하고자 한다. order() 함수의 decreasing 인수를 TRUE로 하면 학년마저 높은 순에서 낮은 순으로 되니 원하는 결과를 얻을 수 없다.\n이런 경우에는 첫번째 벡터는 그대로 두고, 두번째 벡터에 -1을 곱한 후 순서를 정렬하면 원하는 결과를 얻을 수 있다.","code":"\norder(students$grade)#> [1] 1 5 4 3 2\nstudents[order(students$grade), ]#>     name grade gender midterm final retake hw\n#> 1 김철수     1      M      74    91   TRUE  8\n#> 5 홍길동     1      M      50    86  FALSE 10\n#> 4 이영희     2      F      89    78   TRUE  8\n#> 3 이철수     3      M      67    88  FALSE  7\n#> 2 김영희     4      F      82    77  FALSE  9\norder(students$final, decreasing = TRUE)#> [1] 1 3 5 4 2\nstudents[order(students$final, decreasing = TRUE), ]#>     name grade gender midterm final retake hw\n#> 1 김철수     1      M      74    91   TRUE  8\n#> 3 이철수     3      M      67    88  FALSE  7\n#> 5 홍길동     1      M      50    86  FALSE 10\n#> 4 이영희     2      F      89    78   TRUE  8\n#> 2 김영희     4      F      82    77  FALSE  9\norder(students$grade, students$final)#> [1] 5 1 4 3 2\nstudents[order(students$grade, students$final), ]#>     name grade gender midterm final retake hw\n#> 5 홍길동     1      M      50    86  FALSE 10\n#> 1 김철수     1      M      74    91   TRUE  8\n#> 4 이영희     2      F      89    78   TRUE  8\n#> 3 이철수     3      M      67    88  FALSE  7\n#> 2 김영희     4      F      82    77  FALSE  9\nstudents[order(students$grade, students$final, decreasing=T), ]#>     name grade gender midterm final retake hw\n#> 2 김영희     4      F      82    77  FALSE  9\n#> 3 이철수     3      M      67    88  FALSE  7\n#> 4 이영희     2      F      89    78   TRUE  8\n#> 1 김철수     1      M      74    91   TRUE  8\n#> 5 홍길동     1      M      50    86  FALSE 10\nstudents[order(students$grade, -students$final), ]#>     name grade gender midterm final retake hw\n#> 1 김철수     1      M      74    91   TRUE  8\n#> 5 홍길동     1      M      50    86  FALSE 10\n#> 4 이영희     2      F      89    78   TRUE  8\n#> 3 이철수     3      M      67    88  FALSE  7\n#> 2 김영희     4      F      82    77  FALSE  9"},{"path":"ch-R-Data-Frame.html","id":"subset을-이용한-필터링","chapter":"6 R 데이터 프레임","heading":"6.4.3 subset()을 이용한 필터링","text":"subset()4 함수는 벡터, 행렬, 데이터 프레임에서 조건에 맞는 부분을 반환하는 함수이다. 지금까지 우리는 벡터, 행렬, 데이터 프레임을 필터링할 때, 인덱스 벡터를 이용하여 이를 수행하였다. 사실 데이터 처리에 필요한 거의 모든 작업은 subset()을 이용할 필요가 없이, 지금까지 설명한 인덱스 벡터를 이용하여 필터링을 수행하면 된다. 그러나 subset() 함수를 이용하면 지금까지의 필터링 방법을 좀 더 쉽게 할 수 있는 경우가 있다.\nsubset() 함수는 다음과 같은 형식을 가진다.","code":""},{"path":"ch-R-Data-Frame.html","id":"subset","chapter":"6 R 데이터 프레임","heading":"subset()","text":"subset() 함수로 필터링하는 방법과 인덱스 벡터를 이용하는 필터링과의 차이점은 다음 3가지이다.조건에 부합하는 행을 필터링 할 때, subset() 함수는 subset 인수에 조건을 기술한다. 인덱스 벡터는 자연수, 음의 정수, 논리값, 문자열이 모두 가능하지만, subset에서는 논리값만 가능하다. subset에서는 열을 변수처럼 기술할 수 있기 때문에 행 필터링 조건을 인덱스 벡터를 이용하는 방법보다 좀 더 간편하게 기술할 수 있다.subset() 함수를 이용한 필터링에서는 subset의 조건식의 결과가 NA인 경우는 FALSE로 평가하여 NA 행을 자동으로 제거한다. 인덱스 벡터를 이용하는 경우는 조건식의 결과가 NA이어도 그 행은 제거되지 않는다.열을 필터링할 때, 인덱스 벡터를 이용한 필터링에서는 열의 번호나 이름으로 필터링할 열을 지정한다. 열의 이름으로 필터링 할 때는 반드시 문자열로 열의 이름이 표시된다. subset()의 경우 선택할 열은 select 인수로 표현하는데, 열의 이름을 따옴표 없이 변수처럼 그대로 기술한다. 그러면 열의 이름이 열의 번호로 대체되어 최종적으로 필터링이 수행된다.위에서 설명한 내용이 어떤 의미인지를 벡터, 행렬, 데이터 프레임의 경우에서 각각 살펴보도록 한다.","code":"\nsubset(x, subset, select, drop=FALSE, ...)"},{"path":"ch-R-Data-Frame.html","id":"subset을-이용한-벡터-필터링","chapter":"6 R 데이터 프레임","heading":"subset()을 이용한 벡터 필터링","text":"위의 예에서 보듯이 벡터를 필터링할 때, 인덱스 벡터를 이용하는 방법은 NA가 있는 경우 그 결과를 알 수 없으므로 필터링한 결과에도 NA로 표시한다. 그러나 subset() 함수는 NA를 자동으로 제거함을 알 수 있다.","code":"\nx <- c(7, 9, NA, 5, 2)\nx[x>6]#> [1]  7  9 NA\nsubset(x, x> 6)#> [1] 7 9"},{"path":"ch-R-Data-Frame.html","id":"subset을-이용한-데이터-프레임-필터링","chapter":"6 R 데이터 프레임","heading":"subset()을 이용한 데이터 프레임 필터링","text":"위의 예에서 보듯이 인덱스 벡터를 이용하는 경우에는 데이터 프레임의 열을 지정하기 위해서 $ 앞에 데이터 프레임 이름을 일일이 지정해야 했다. 그러나 subset()의 경우 두번째 인수에 열을 그냥 변수처럼 기술한다.인덱스 벡터를 이용하는 방법은 NA가 있는 경우 그 결과를 알 수 없으므로 필터링한 결과에도 NA로 표시한다. 그러나 subset() 함수는 NA를 자동으로 제거한다.인덱스 벡터의 경우 열을 지정할 때 번호나 문자열 이름을 이용하였는데, subset()은 열의 이름을 변수처럼 사용하여 지정하고 있음을 알 수 있다. 앞서 설명하였듯이 변수처럼 사용된 열의 이름은 열의 위치를 나타내는 숫자로 변환되어 처리된다. 그렇기 때문에 y:z나 -z 등의 기술이 가능하다.","code":"\ny <- 1:5\nz <- -1:-5\nlong.name <- data.frame(x, y, z)\nlong.name#>    x y  z\n#> 1  7 1 -1\n#> 2  9 2 -2\n#> 3 NA 3 -3\n#> 4  5 4 -4\n#> 5  2 5 -5\nrm(x, y, z)\nlong.name[long.name$x >6, ]#>     x  y  z\n#> 1   7  1 -1\n#> 2   9  2 -2\n#> NA NA NA NA\nsubset(long.name, x>6)#>   x y  z\n#> 1 7 1 -1\n#> 2 9 2 -2\nlong.name[long.name$x >6, 2:3]#>     y  z\n#> 1   1 -1\n#> 2   2 -2\n#> NA NA NA\nsubset(long.name, x>6, y:z)#>   y  z\n#> 1 1 -1\n#> 2 2 -2\nlong.name[long.name$x >6, c(\"x\", \"z\")]#>     x  z\n#> 1   7 -1\n#> 2   9 -2\n#> NA NA NA\nsubset(long.name, x>6, c(x, z))#>   x  z\n#> 1 7 -1\n#> 2 9 -2\nsubset(long.name, x>6, -z)#>   x y\n#> 1 7 1\n#> 2 9 2"},{"path":"ch-R-Data-Frame.html","id":"데이터-프레임에-함수-적용하기","chapter":"6 R 데이터 프레임","heading":"6.5 데이터 프레임에 함수 적용하기","text":"","code":""},{"path":"ch-R-Data-Frame.html","id":"리스트로서-각-열에-함수-적용하기","chapter":"6 R 데이터 프레임","heading":"리스트로서 각 열에 함수 적용하기","text":"데이터 프레임은 리스트로서의 속성이 있기 때문에 lapply()나 sapply() 함수를 이용하여 열별로 함수를 적용할 수 있다.","code":"\nlapply(students[4:5], mean)#> $midterm\n#> [1] 72.4\n#> \n#> $final\n#> [1] 84\nsapply(students[4:5], mean)#> midterm   final \n#>    72.4    84.0\nsapply(students[4:5], summary)#>         midterm final\n#> Min.       50.0    77\n#> 1st Qu.    67.0    78\n#> Median     74.0    86\n#> Mean       72.4    84\n#> 3rd Qu.    82.0    88\n#> Max.       89.0    91"},{"path":"ch-R-Data-Frame.html","id":"행렬-함수-적용하기","chapter":"6 R 데이터 프레임","heading":"행렬 함수 적용하기","text":"데이터 프레임은 행렬과 동일한 형식을 가지고 있기 때문에 행렬에서 사용했던 다양한 함수가 데이터 프레임에도 작동하는 경우가 많다.\n다음은 행과 열의 길이를 알아내는 nrow()과 ncol() 함수, 그리고 행과 열을 전치시키는 t() 함수를 데이터 프레임에 적용한 예이다.행과 열이 전치된 데이터 프레임을 살펴보면 모든 열이 문자열 벡터로 변경되었음을 볼 수 있다. 데이터 프레임의 각 열은 모두 동일한 타입이어야 한다. 전치된 열은 논리값, 숫자, 문자가 모두 포함되어 있다. 따라서 이를 모두 수용할 수 있는 문자 행렬로 변환되었음을 볼 수 있다.","code":"\nnrow(students)#> [1] 5\nncol(students)#> [1] 7\nt(students)#>         [,1]     [,2]     [,3]     [,4]     [,5]    \n#> name    \"김철수\" \"김영희\" \"이철수\" \"이영희\" \"홍길동\"\n#> grade   \"1\"      \"4\"      \"3\"      \"2\"      \"1\"     \n#> gender  \" M\"     \"F\"      \"M\"      \"F\"      \"M\"     \n#> midterm \"74\"     \"82\"     \"67\"     \"89\"     \"50\"    \n#> final   \"91\"     \"77\"     \"88\"     \"78\"     \"86\"    \n#> retake  \"TRUE\"   \"FALSE\"  \"FALSE\"  \"TRUE\"   \"FALSE\" \n#> hw      \" 8\"     \" 9\"     \" 7\"     \" 8\"     \"10\""},{"path":"ch-R-Data-Frame.html","id":"apply로-행이나-열에-함수-적용하기","chapter":"6 R 데이터 프레임","heading":"apply()로 행이나 열에 함수 적용하기","text":"데이터 프레임에도 apply() 함수를 적용할 수 있다. 그러나 여기서 주의할 점은 R은 apply() 함수를 적용하기 앞서 데이터 프레임을 행렬로 변환시킨다. 따라서 앞의 t() 함수의 적용 결과처럼 요소 중에 하나라도 문자가 있으면 모든 요소를 수용할 수 있는 문자 행렬로 변환하게 된다.첫번째 예에서는 students에 문자 열이 있어 모두 문자 행렬로 변환된다. 그러므로 mean이 적용될 수 없어서 경고와 함께 모두 NA의 값이 출력되었다.\n그러나 중간과 기말고사 점수가 있는 부분만으로 부분 데이터 프레임을 만들어 apply()을 적용하면 모두 숫자이므로 숫자 행렬로 변환되어 결과가 잘 수행되었음을 알 수 있다.\n따라서 열별로 함수를 적용할 때에는 행렬로 변환이 필요한 apply()보다는 lapply()나 sapply()를 바로 적용하는 것이 더 좋다.","code":"\napply(students, 2, mean)#>    name   grade  gender midterm   final  retake      hw \n#>      NA      NA      NA      NA      NA      NA      NA\napply(students[4:5], 2, mean)#> midterm   final \n#>    72.4    84.0\napply(students[4:5], 1, sum)#> [1] 165 159 155 167 136"},{"path":"ch-R-Data-Frame.html","id":"긴-데이터-프레임의-앞-또는-뒷-부분-출력하기","chapter":"6 R 데이터 프레임","heading":"긴 데이터 프레임의 앞 또는 뒷 부분 출력하기","text":"데이터 프레임에만 적용되는 것은 아니지만 head()와 tail() 함수를 이용하면 긴 데이터 프레임의 앞 부분과 뒤 부분만을 쉽게 참조할 수 있다.iris 데이터는 R에서 제공하는 데이터인데 150 개의 관측치로 되어 있으므로 이를 화면에 다 출력하면 화면이 많이 스크롤되어서 데이터를 파악하기 힘들다. 이런 경우 head()나 tail()을 사용하여 데이터의 앞 또는 뒷 부분을 파악한다. 이 두 함수는 데이터 프레임의 앞과 뒤의 6줄을 반환한다.\n다음처럼 n 인수를 사용하여 출력할 행의 수를 직접 지정할 수도 있다.","code":"\nnrow(iris)#> [1] 150\nhead(iris)#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2  setosa\n#> 2          4.9         3.0          1.4         0.2  setosa\n#> 3          4.7         3.2          1.3         0.2  setosa\n#> 4          4.6         3.1          1.5         0.2  setosa\n#> 5          5.0         3.6          1.4         0.2  setosa\n#> 6          5.4         3.9          1.7         0.4  setosa\ntail(iris)#>     Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n#> 145          6.7         3.3          5.7         2.5 virginica\n#> 146          6.7         3.0          5.2         2.3 virginica\n#> 147          6.3         2.5          5.0         1.9 virginica\n#> 148          6.5         3.0          5.2         2.0 virginica\n#> 149          6.2         3.4          5.4         2.3 virginica\n#> 150          5.9         3.0          5.1         1.8 virginica\nhead(iris, n = 3)#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2  setosa\n#> 2          4.9         3.0          1.4         0.2  setosa\n#> 3          4.7         3.2          1.3         0.2  setosa\ntail(iris, n = 2)#>     Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n#> 149          6.2         3.4          5.4         2.3 virginica\n#> 150          5.9         3.0          5.1         1.8 virginica"},{"path":"ch-R-Data-Frame.html","id":"dataFileImport","chapter":"6 R 데이터 프레임","heading":"6.6 파일에서 데이터 읽어오기","text":"규모가 큰 데이터는 R 콘솔에서 직접 입력하기보다는 파일에서 불러오는 경우가 많다. R에서는 주로 텍스트 파일이나 Excel의 데이터를 읽어오는 경우가 많다.","code":""},{"path":"ch-R-Data-Frame.html","id":"텍스트-파일에서-데이터-읽어오기","chapter":"6 R 데이터 프레임","heading":"6.6.1 텍스트 파일에서 데이터 읽어오기","text":"텍스트에 있는 모든 데이터를 데이터 프레임에 저장하려는 경우 read.table() 함수를 이용하면 편리하다.파일을 불러오기 전에 주의할 점은 파일의 이름만으로 파일을 읽어오고 싶으면 현재의 작업 디렉토리(폴더)에 파일이 있어야 한다는 것이다. 그렇지 않은 경우에는 파일의 절대 경로를 모두 써 주어야만 읽어올 수 있다.","code":""},{"path":"ch-R-Data-Frame.html","id":"작업-디렉토리-설정","chapter":"6 R 데이터 프레임","heading":"작업 디렉토리 설정","text":"R 윈도우 버전에서 작업 디렉터리의 변경은 [파일]-[작업디렉토리변경] 메뉴를 이용하면 된다. RStudio에서는 [Session]-[Set Working Directory]-[Choose Directory] 메뉴를 이용하면 된다. 현재의 작업 디렉터리가 어디인지를 알기 위해서는 getwd() 명령을 이용하면 된다. 현재 작업 디렉터리의 파일을 보고 싶으면 list.files() 명령을 이용한다.R 명령으로 작업 디렉터리를 변경하려면 setwd()를 이용한다. 다음은 getwd()로 현재 작업 디렉토리를 얻은 후 setwd()로 data라는 하위 디렉토리(폴더)로 작업 디렉토리를 변경하고, 그 안에 있는 파일 목록을 확인한 예이다.텍스트 파일을 읽어들이는 예제는 다음 파일을 사용하니 예제를 따라하고자 하는 분들은 내려받기를 하자.","code":"\nWD <- getwd()\nsetwd(file.path(WD, \"data\"))\nlist.files(pattern = \"txt\")#> [1] \"courses2.txt\"         \"scores_no_header.txt\" \"scores_rn.txt\"       \n#> [4] \"scores.txt\"           \"students.txt\""},{"path":"ch-R-Data-Frame.html","id":"머리-행이-있는-텍스트-데이터-파일-읽기","chapter":"6 R 데이터 프레임","heading":"머리 행이 있는 텍스트 데이터 파일 읽기","text":"다음처럼 파일에 있는 데이터가 첫 행은 각 항목의 이름이고 둘째 행부터 데이터가 있는 경우를 먼저 살펴보자.데이터 파일이 작업 디렉토리(폴더) 밑에 scores.txt로 저장되어 있다면 read.table() 함수를 이용하여 다음과 같이 header=TRUE 인수로 데이터 프레임으로 읽어올 수 있다.위 결과에서 보면 파일에서 데이터를 읽어와 데이터 프레임을 생성했고, 첫 행에 나와 있는 항목 이름을 데이터 프레임 각 열의 이름으로 하고 있다. 행의 이름으로는 1, 2, 3의 순서로 행 번호를 자동 부여했다. 각 행의 데이터는 공백 문자를 기준으로 구분을 하였다.앞의 명령어에서 fileEncoding 인수는 텍스트 파일이 어떤 문자 인코딩으로 저장되어 있는지를 지정한 것이다. 윈도우즈를 제외한 대부분의 시스템에서는 UTF-8 형식으로 텍스트 파일을 저장하지만, 한글 윈도우는 CP949 (EUC-KR)로 텍스트를 인코딩 한다. 여러 시스템 간의 호환성을 위하여 이 책에서는 텍스트 데이터를 UTF-8으로 저장하고 읽어들이기로 한다. read.table() 함수 등은 시스템의 디폴트 인코딩을 사용하여 데이터를 읽어 온다. 한글 윈도우즈의 디폴트 인코딩은 CP949이므로 UTF-8으로 텍스트 데이터를 처리하기 위하여 fileEncoding 인수를 지정하였다.","code":"#> prov  scores\n#> 서울  25\n#> 대전  35\n#> 천안  42\nprov.scores <- read.table(\"scores.txt\", header=TRUE, fileEncoding=\"UTF-8\")\nprov.scores#>   prov scores\n#> 1 서울     25\n#> 2 대전     35\n#> 3 천안     42\nattributes(prov.scores)#> $names\n#> [1] \"prov\"   \"scores\"\n#> \n#> $class\n#> [1] \"data.frame\"\n#> \n#> $row.names\n#> [1] 1 2 3"},{"path":"ch-R-Data-Frame.html","id":"행-이름이-있는-텍스트-데이터-파일-읽기","chapter":"6 R 데이터 프레임","heading":"행 이름이 있는 텍스트 데이터 파일 읽기","text":"다음 예는 파일에 데이터의 행 번호 또는 이름이 부여되어 있는 경우이다. 이 같은 경우에는 첫 행에 행 번호를 나타내는 이름은 표시하지 않는다. 따라서 첫 행과 다른 행은 항목의 수가 하나 차이가 난다.이와 같은 형식의 파일이 작업 디렉토리 밑의 scores_rn.txt에 저장되어 있는 경우에도 같은 방식으로 데이터를 데이터 프레임으로 읽어온다. 다음에서 볼 수 있듯이 행 번호로 파일의 첫 번째 열의 값이 사용되었다. 그리고 read.table() 함수에서 header 인수를 사용하지 않았다. 항목이 하나 적은 것으로 첫 번째 행이 머리행인 것을 자동 인식하기 때문이다.","code":"#>     prov scores\n#> 10   서울  25\n#> 20   대전  35\n#> 30   천안  42\nprov.scores <- read.table(\"scores_rn.txt\", fileEncoding=\"UTF-8\")\nprov.scores#>    prov scores\n#> 10 서울     25\n#> 20 대전     35\n#> 30 천안     42"},{"path":"ch-R-Data-Frame.html","id":"머리-행이-없는-텍스트-데이터-파일-읽기","chapter":"6 R 데이터 프레임","heading":"머리 행이 없는 텍스트 데이터 파일 읽기","text":"위의 결과에서 파일에 있는 행 번호가 데이터 프레임에 이용되었음을 볼 수 있다. read.table() 함수는 머리 행이 없는 텍스트 파일에서도 데이터를 읽어들일 수 있다. 다음과 같은 scores_no_header.txt 파일이 작업 디렉토리에 저장되어 있다고 하자.다음 명령문은 scores_no_header.txt 데이터 파일을 데이터 프레임으로 읽어들인 예이다. 열의 이름이 임의로 붙여졌음을 볼 수 있다.","code":"#> 서울   25\n#> 대전   35\n#> 천안   42\nprov.scores <- read.table(\"scores_no_header.txt\", header=FALSE, fileEncoding=\"UTF-8\")\nprov.scores#>     V1 V2\n#> 1 서울 25\n#> 2 대전 35\n#> 3 천안 42"},{"path":"ch-R-Data-Frame.html","id":"edit","chapter":"6 R 데이터 프레임","heading":"edit()","text":"데이터 프레임에서 데이터를 편집하고 싶으면 edit() 함수를 이용한다. 다음 명령을 수행하면 데이터 프레임이 스프레드시트 형태로 나타나 수정이 가능하다. 편집창에서 수정 후 편집창을 닫으면 변경한 내용이 반영되어 새로운 데이터 프레임 prov.scores.new가 생성된다.","code":"\nprov.scores.new <- edit(prov.scores)"},{"path":"ch-R-Data-Frame.html","id":"csv-파일에서-데이터-읽어오기","chapter":"6 R 데이터 프레임","heading":"6.6.2 CSV 파일에서 데이터 읽어오기","text":"","code":""},{"path":"ch-R-Data-Frame.html","id":"csv-파일","chapter":"6 R 데이터 프레임","heading":"CSV 파일","text":"많은 경우 데이터가 Excel로 저장되어 있다. Excel에서 데이터를 읽어오기 위해서는 먼저 Excel 파일을 CSV 형태의 파일로 작업 디렉토리에 저장하여야 한다.5 CSV 파일은 데이터의 각 필드가 쉼표로 분리되어 있는 파일이다. 대부분의 통계 패키지뿐 아니라 다수의 SW에서 지원하는 파일 형식이다. Excel의 버전에 따라 저장방식이 조금 차이가 있을 수 있으나, 대부분 ’다른 이름으로 저장’에서 파일 형식을 CSV 형식으로 지정해 주면 된다.CSV 파일을 읽어들이는 예제는 다음 파일을 사용하니 예제를 따라하고자 하는 독자는 내려받도록 하자.","code":""},{"path":"ch-R-Data-Frame.html","id":"read.csv","chapter":"6 R 데이터 프레임","heading":"read.csv()","text":"R에서 CSV 파일을 읽어오는 함수는 read.csv()이다. 다음은 각 국의 자살률에 대한 성별, 조사년도 데이터를 읽어온 예이다. 총 105개의 데이터인데 처음 몇 개의 데이터만 출력하여 보이고 있다.참고로 이 예에서는 영어로 된 파일이므로 파일 인코딩을 지정하지 않아도 된다.사실 read.csv() 함수는 read.table()의 wrapper 함수로서 header=TRUE, sep=‘,’ 인수로 read.table() 함수를 호출하기만 한다. 따라서 다음처럼 read.table() 함수를 이용해서도 CSV 파일을 읽어들일 수 있다. 이 때 주의할 점은 함수 호출 시 header=TRUE, sep=‘,’ 인수를 지정해야 한다는 것이다.","code":"\nsr <- read.csv(file=\"suicide_rates.csv\", fileEncoding=\"UTF-8\")\nnrow(sr)#> [1] 105\nhead(sr)#>               Country Year Males Females\n#> 1             ALBANIA    3   4.7     3.3\n#> 2 ANTIGUA AND BARBUDA   95   0.0     0.0\n#> 3           ARGENTINA    8  12.6     3.0\n#> 4             ARMENIA    8   2.8     1.1\n#> 5           AUSTRALIA    6  12.8     3.6\n#> 6             AUSTRIA    9  23.8     7.1\nsr2 <- read.table(file=\"suicide_rates.csv\", header=TRUE, sep=\",\", fileEncoding=\"UTF-8\")\nnrow(sr2)#> [1] 105\nhead(sr2)#>               Country Year Males Females\n#> 1             ALBANIA    3   4.7     3.3\n#> 2 ANTIGUA AND BARBUDA   95   0.0     0.0\n#> 3           ARGENTINA    8  12.6     3.0\n#> 4             ARMENIA    8   2.8     1.1\n#> 5           AUSTRALIA    6  12.8     3.6\n#> 6             AUSTRIA    9  23.8     7.1"},{"path":"ch-R-Data-Frame.html","id":"read.csv와-관련된-흔한-실수","chapter":"6 R 데이터 프레임","heading":"read.csv()와 관련된 흔한 실수","text":"read.csv() 함수를 이용할 때 초보자가 가장 자주 하는 실수가 일반 텍스트 파일인데 read.csv() 함수로 데이터를 읽어들이는 것이다. 다음은 공백으로 필드가 구분된 scores.txt 파일을 read.table()과 read.csv() 함수로 각각 읽어들인 결과이다.출력해 보면 두 결과가 유사해 보인다. 그러나 읽어들여진 데이터로 작업을 해보면 read.csv() 파일로 읽어들인 데이터로는 제대로 된 작업이 수행되지 않음을 알 수 있다. 먼저 두 데이터에서 scores 열에 대한 평균을 내 보자.결과에서 보듯이 read.table()로 읽어들인 데이터 프레임에서는 원하는 결과를 얻을 수 있지만 read.csv()로 읽어들인 데이터 프레임에서는 그렇지 않았다. 그 이유는 read.csv()는 데이터 열이 쉼표로 분리된 것으로 가정하므로 한 줄의 데이터를 읽어들인 후 쉼표를 발견할 수 없어서 모두 하나의 열로 처리를 했기 때문이다. 하나가 된 데이터에는 문자와 숫자가 모두 포함되어 있으므로 이를 모두 처리할 수 있는 문자 벡터로 데이터를 저장하게 된다. 따라서 숫자 데이터 처리 함수인 mean()을 적용할 때 오류가 난 것이다. 이는 두 데이터 프레임의 열의 개수와 이름 등을 확인해 보면 쉽게 확인할 수 있다.","code":"\nprov.scores <- read.table(\"scores.txt\", header=TRUE, fileEncoding=\"UTF-8\")\nprov.scores#>   prov scores\n#> 1 서울     25\n#> 2 대전     35\n#> 3 천안     42\nprov.scores.csv <- read.csv(\"scores.txt\", fileEncoding=\"UTF-8\")\nprov.scores.csv#>   prov..scores\n#> 1     서울  25\n#> 2     대전  35\n#> 3     천안  42\nmean(prov.scores$scores)#> [1] 34\nmean(prov.scores.csv$scores)#> Warning in mean.default(prov.scores.csv$scores): 인자가 수치형 또는 논리형이\n#> 아니므로 NA를 반환합니다#> [1] NA\nncol(prov.scores)#> [1] 2\nnames(prov.scores)#> [1] \"prov\"   \"scores\"\nncol(prov.scores.csv)#> [1] 1\nnames(prov.scores.csv)#> [1] \"prov..scores\""},{"path":"ch-R-Data-Frame.html","id":"excel-파일에서-데이터-읽기","chapter":"6 R 데이터 프레임","heading":"6.6.3 Excel 파일에서 데이터 읽기","text":"Excel에는 Excel 파일을 CSV 파일로 저장하는 기능이 있다.\n이 기능을 사용하여 CSV 파일로 변환을 하면 앞에서 설명한 read.csv() 함수를 이용하여 Excel 데이터를 읽어들일 수 있다.\n만약 Excel 데이터를 변환 없이 그대로 읽어들이고 싶으면, readxl 패키지의 read_excel() 함수를 사용한다.\nreadxl 패키지가 설치되어 있지 않다면 다음 명령이나 RStudio의 Packages 패널의 기능을 사용하여 설치한다.위의 파일을 내려받으면, 다음과 같이, 4 개의 워크시트가 있는 Excel 파일에서 project라는 이름의 워크시트를 데이터프레임으로 읽어들이는 예를 살펴보자.read_excel() 함수는 첫 번째 인수로 파일명을, 두 번째 sheet 인수로 읽어들일 워크시트를 지정한다.\n(read_excel() 함수는 데이터를 tibble이라는 일종의 개량된 data.frame 형식으로 저장한다. 그렇기 때문에 출력 결과과 일반 data.frame과 조금 다르다.)sheet 인수에 아무것도 지정하지 않으면, 맨 처음 워크시트의 데이터를 읽어들인다.","code":"\ninstall.packages(\"readxl\")\nlibrary(readxl)\nproject <- read_excel(\"dataMerge.xlsx\", sheet = \"project\") \nproject#> # A tibble: 4 × 2\n#>   Team  Project\n#>   <chr>   <dbl>\n#> 1 A          80\n#> 2 B          90\n#> 3 C          85\n#> 4 D          75\nclass1 <- read_excel(\"dataMerge.xlsx\") \nclass1#> # A tibble: 5 × 6\n#>   ID    Name   Adress Midterm Final Team \n#>   <chr> <chr>  <chr>    <dbl> <dbl> <chr>\n#> 1 015   김철수 서울        78    59 A    \n#> 2 018   김영희 경기        85    87 A    \n#> 3 025   이철수 충남        80    70 B    \n#> 4 034   이영희 대전        92    89 B    \n#> 5 151   홍길동 세종        58    66 B"},{"path":"ch-R-Data-Frame.html","id":"데이터-프레임을-파일로-쓰기","chapter":"6 R 데이터 프레임","heading":"6.7 데이터 프레임을 파일로 쓰기","text":"","code":""},{"path":"ch-R-Data-Frame.html","id":"write.table과-write.csv","chapter":"6 R 데이터 프레임","heading":"write.table()과 write.csv()","text":"데이터 프레임의 작업 결과를 추후에 다시 이용하기 위해서, 또는 다른 통계 패키지에서 작업 결과를 이용하기 위해서는 데이터 프레임을 파일로 저장할 수 있어야 한다. 이 경우 write.table()과 write.csv() 함수를 이용하면 데이터 프레임을 파일에 저장할 수 있다.다음 sr 데이터프레임에 남자(Males)와 여자(Females)의 자살률의 산술 평균을 Avg 열로 추가한 후, 그 결과를 sr.csv라는 파일로 저장하는 예이다.작업 디렉토리에 저장된 sr.csv 파일을 열어보면 다음처럼 행번호도 함께 저장된 것을 확인할 수 있다.행번호를 제외하고 파일에 데이터를 저장하려면 row.names=F로 설정한다.작업 디렉토리에 저장된 sr2.csv 파일을 열어보면 이번에는 행번호가 저장되지 않은 것을 확인할 수 있다.만약 데이터에 영어와 숫자 이외에 한글 등이 포함되어 있으면 파일의 인코딩을 지정하여 저장하여 저장하는 것이 좋다.\n다음 예제에서 사용하는 students는 앞선 예제에서 만든 데이터 프레임이다.\n만약 이 데이터 프레임이 현재 R 세션에 없다면, 다음 students.RData 파일을 RStudio로 적재하면 students 객체가 생성될 것이다.다음 예에서는 이 장에서 만든 students 데이터 프레임을 세 가지 형식으로 작업 디렉토리 밑에 저장하고 있다.\n한글 때문에 파일의 인코딩 방식을 지정하여 저장하였다.첫 번째 write.table()은 공백문자로 데이터 표레임의 열을 분리하여 일반 텍스트 파일로 저장한 예이다. 다음은 저장된 students.txt 파일의 모습이다. 결과에서 볼 수 있듯이 데이터 프레임의 열 이름이 머리 행으로 저장되고 데이터들이 공백문자로 구분되어 저장되었다. 숫자 데이터는 그대로, 문자 데이터는 따옴표로 둘러싸여서 저장되어 있다.두 번째 명령문은 write.csv() 함수를 사용하여 데이터 프레임을 CSV 파일 형식으로 저장한 예이다. 다음은 저장된 students.csv 파일의 모습이다. 결과에서 볼 수 있듯이 쉼표로 각 데이터가 분리되어 있다.다음 결과에서 볼 수 있듯이 쉼표로 각 데이터가 분리되어 있다. Excel에서 파일을 읽으면 데이터를 Excel의 각 셀로 잘 읽어 들일 수 있다.세 번째 명령문은 write.csv()을 사용하여 CSV 파일로 데이터를 저장한 것은 두 번째 명령문과 같은데 다만 행 번호를 같이 저장한 예이다. 다음은 저장된 students_rn.csv 파일의 모습니다. 결과에서 첫 번째 열에 행 번호가 저장되어 있음을 볼 수 있다.다음 예에서 write.table() 또는 write.csv() 파일로 저장한 데이터를 다시 데이터 프레임으로 잘 복원할 수 있음을 확인할 수 있다. 이 때로 파일의 형식이 공백으로 분리된 파일인지 CSV 파일인지에 따라 read.table()과 read.csv()를 적절히 선택하여야 한다.사실 write.csv() 함수는 write.table()에서 sep 인수에 ','를 부여한 결과와 같다. 따라서 두 번째와 세 번째 명령문은 다음처럼 하여도 같은 결과를 얻을 수 있다.","code":"\nsr$Avg <- (sr$Males + sr$Females) / 2\nhead(sr)#>               Country Year Males Females   Avg\n#> 1             ALBANIA    3   4.7     3.3  4.00\n#> 2 ANTIGUA AND BARBUDA   95   0.0     0.0  0.00\n#> 3           ARGENTINA    8  12.6     3.0  7.80\n#> 4             ARMENIA    8   2.8     1.1  1.95\n#> 5           AUSTRALIA    6  12.8     3.6  8.20\n#> 6             AUSTRIA    9  23.8     7.1 15.45\nwrite.csv(sr, file = \"sr.csv\")#> \"\",\"Country\",\"Year\",\"Males\",\"Females\",\"Avg\"\n#> \"1\",\"ALBANIA\",3,4.7,3.3,4\n#> \"2\",\"ANTIGUA AND BARBUDA\",95,0,0,0\n#> \"3\",\"ARGENTINA\",8,12.6,3,7.8\n#> \"4\",\"ARMENIA\",8,2.8,1.1,1.95\nwrite.csv(sr, file = \"sr2.csv\", row.names = F)#> \"Country\",\"Year\",\"Males\",\"Females\",\"Avg\"\n#> \"ALBANIA\",3,4.7,3.3,4\n#> \"ANTIGUA AND BARBUDA\",95,0,0,0\n#> \"ARGENTINA\",8,12.6,3,7.8\n#> \"ARMENIA\",8,2.8,1.1,1.95\nstudents#>     name grade gender midterm final retake hw\n#> 1 김철수     1      M      74    91   TRUE  8\n#> 2 김영희     4      F      82    77  FALSE  9\n#> 3 이철수     3      M      67    88  FALSE  7\n#> 4 이영희     2      F      89    78   TRUE  8\n#> 5 홍길동     1      M      50    86  FALSE 10\nwrite.table(students, \"students.txt\", row.names=FALSE, fileEncoding=\"UTF-8\")\nwrite.csv(students, \"students.csv\", row.names=FALSE, fileEncoding=\"UTF-8\")\nwrite.csv(students, \"students_rn.csv\", row.names=TRUE, fileEncoding=\"UTF-8\")#> \"name\" \"grade\" \"gender\" \"midterm\" \"final\" \"retake\" \"hw\"\n#> \"김철수\" 1 \" M\" 74 91 TRUE 8\n#> \"김영희\" 4 \"F\" 82 77 FALSE 9\n#> \"이철수\" 3 \"M\" 67 88 FALSE 7\n#> \"이영희\" 2 \"F\" 89 78 TRUE 8\n#> \"홍길동\" 1 \"M\" 50 86 FALSE 10#> \"name\",\"grade\",\"gender\",\"midterm\",\"final\",\"retake\",\"hw\"\n#> \"김철수\",1,\" M\",74,91,TRUE,8\n#> \"김영희\",4,\"F\",82,77,FALSE,9\n#> \"이철수\",3,\"M\",67,88,FALSE,7\n#> \"이영희\",2,\"F\",89,78,TRUE,8\n#> \"홍길동\",1,\"M\",50,86,FALSE,10#> \"\",\"name\",\"grade\",\"gender\",\"midterm\",\"final\",\"retake\",\"hw\"\n#> \"1\",\"김철수\",1,\" M\",74,91,TRUE,8\n#> \"2\",\"김영희\",4,\"F\",82,77,FALSE,9\n#> \"3\",\"이철수\",3,\"M\",67,88,FALSE,7\n#> \"4\",\"이영희\",2,\"F\",89,78,TRUE,8\n#> \"5\",\"홍길동\",1,\"M\",50,86,FALSE,10\nread.table(\"students.txt\", header=TRUE, fileEncoding=\"UTF-8\")#>     name grade gender midterm final retake hw\n#> 1 김철수     1      M      74    91   TRUE  8\n#> 2 김영희     4      F      82    77  FALSE  9\n#> 3 이철수     3      M      67    88  FALSE  7\n#> 4 이영희     2      F      89    78   TRUE  8\n#> 5 홍길동     1      M      50    86  FALSE 10\nread.csv(\"students.csv\", header=TRUE, fileEncoding=\"UTF-8\")#>     name grade gender midterm final retake hw\n#> 1 김철수     1      M      74    91   TRUE  8\n#> 2 김영희     4      F      82    77  FALSE  9\n#> 3 이철수     3      M      67    88  FALSE  7\n#> 4 이영희     2      F      89    78   TRUE  8\n#> 5 홍길동     1      M      50    86  FALSE 10\nwrite.table(students, \"students.csv\", sep=\",\", row.names=FALSE, fileEncoding=\"UTF-8\")\nwrite.table(students, \"students_rn.csv\", sep=\",\", row.names=TRUE, fileEncoding=\"UTF-8\")"},{"path":"ch-R-Data-Frame.html","id":"데이터-프레임을-excel-파일에-쓰기","chapter":"6 R 데이터 프레임","heading":"데이터 프레임을 Excel 파일에 쓰기","text":"데이터 프레임을 Excel 파일로 저장하려면, CSV 파일로 저장한 후 Excel에서 이를 다시 Excel의 파일 형식인 xlsx 형식의 파일로 저장하거나, writexl 패키지를 사용하여 Excel 파일을 R에서 직접 생성하면 된다.\n여기서는 writexl 패키지를 사용하여 Excel 파일로 데이터를 저장하는 방법을 설명한다.writexl 패키지가 설치되어 있지 않다면, 다음 명령이나 RStudio의 Packages 패널의 기능을 사용하여 설치한다.writexl 패키지의 write_xlsx() 함수를 사용하면 데이터 프레임을 Excel 파일로 저장할 수 있다.\n다음은 하나의 students 데이터 프레임을 Excel 파일로 저장하는 예이다.작업 디렉토리에 만들어진 students1.xlsx 파일을 Excel로 열어보면 첫 번째 워크시트에 데이터 프레임이 저장되어 있는 것을 확인할 수 있다.\n여러 데이터 프레임을 한 번에 저장하려면 다음처럼 리스트 형식으로 데이터를 전달한다.\n이 때 리스트의 각 요소에 이름을 부여하면 해당 이름으로 워크시트가 만들어져 데이터 프레임들이 저장된다.","code":"\ninstall.packages(\"writexl\")\nlibrary(writexl)\nwrite_xlsx(students, \"students1.xlsx\")\nwrite_xlsx(list(students=students, sr=sr, project=project), \"multipleData.xlsx\")"},{"path":"ch-R-Data-Frame.html","id":"바이너리-형식으로-데이터-객체-저장-및-복원","chapter":"6 R 데이터 프레임","heading":"6.7.1 바이너리 형식으로 데이터 객체 저장 및 복원","text":"데이터 프레임뿐 아니라 R의 모든 객체들을 saveRDS()와 readRDS(), 또는 save()와 load() 함수를 이용하여 바이너리 형식으로 저장하고 복원할 수 있다. 이 경우 메모리에 적재되는 형태대로 파일에 저장되었다가 복원되므로 별도의 처리 과정이 불필요해진다. 그러므로 대용량의 데이터를 R 플랫폼 내에서 저장하거나 복원할 때 매우 유용하다.다음은 x라는 벡터, y라는 행렬, z라는 데이터 프레임을 만든 후, save() 함수를 이용하여 바이너리 형식으로 xyz.RData라는 파일에 저장하는 예이다.작업 디렉토리에 가보면 xyz.RData라는 파일이 생성된 것을 확인할 수 있다.\nsave()와 load() 함수를 이용하여 저장하는 데이터 파일은 일밙거으로 .RData라는 확장자를 이용한다.\n그러면 대부분의 컴퓨터 설정에서 .RData 데이터 파일이 R이나 RStudio로 자동으로 연결되어 더블 클릭만으로 파일에 저장된 객체를 R 세션에 적재할 수 있다.파일에 데이터가 잘 저장되었고 이를 다시 load() 함수로 R 세션에 잘 복원할 수 있는지를 확인하기 위하여, 현재 R 세션에 있는, x, y, z 객체를 환경에서 제거해 보자. 다음 명령을 사용하거나 RStudio의 Environment 패널에 이 객체를 제거할 수 있다.세 객체가 모두 제거되었기 때문에 객체를 출력하려고 하면 오류가 발생한다.다음으로 작업 디렉토리의 xyz.RData를 이용하여 R 세션에 복원해 보자.\n이를 위해 다음처럼 데이터 파일이 있는 폴더를 작업 디렉토리로 설정하고 load() 함수를 사용할 수도 있고, 파일 탐색기에서 해당 파일의 컨텍스트 메뉴에서 연결 프로그램을 RStudio로 하여 파일을 열어도 된다.이번에는 세 객체가 모두 잘 출력되는 것을 확인할 수 있다.\nRStudio의 Environment 패널에서도 이 객체가 다시 생성되었음을 확인할 수 있다.","code":"\nx <- 1:3; x#> [1] 1 2 3\ny <- matrix(4:12, nrow=3, ncol=3); y#>      [,1] [,2] [,3]\n#> [1,]    4    7   10\n#> [2,]    5    8   11\n#> [3,]    6    9   12\nz <- data.frame(x, y); z#>   x X1 X2 X3\n#> 1 1  4  7 10\n#> 2 2  5  8 11\n#> 3 3  6  9 12\nsave(x, y, z, file = \"xyz.RData\")\nrm(x, y, z)\nx; y; z#> Error in eval(expr, envir, enclos): 객체 'x'를 찾을 수 없습니다#> Error in eval(expr, envir, enclos): 객체 'y'를 찾을 수 없습니다#> Error in eval(expr, envir, enclos): 객체 'z'를 찾을 수 없습니다\nload(\"xyz.RData\")\nx; y; z#> [1] 1 2 3#>      [,1] [,2] [,3]\n#> [1,]    4    7   10\n#> [2,]    5    8   11\n#> [3,]    6    9   12#>   x X1 X2 X3\n#> 1 1  4  7 10\n#> 2 2  5  8 11\n#> 3 3  6  9 12"},{"path":"ch-R-Data-Frame.html","id":"데이터-프레임의-열을-변수처럼-이용하는-방법","chapter":"6 R 데이터 프레임","heading":"6.8 데이터 프레임의 열을 변수처럼 이용하는 방법 *","text":"","code":""},{"path":"ch-R-Data-Frame.html","id":"변수-검색-경로","chapter":"6 R 데이터 프레임","heading":"변수 검색 경로","text":"$ 기호를 이용하는 방법보다 좀 더 간편하게 데이터 프레임의 열에 접근할 수 있는 방법이 있다. attach() 함수를 이용하면 데이터 프레임의 각 열을 변수로 등록할 수 있다. attach() 함수가 실행되면 해당 데이터 프레임의 각 열을 변수로 검색 경로(search path)에 등록한다. 검색 경로란 R이 어떤 변수를 참조할 때 변수에 대한 정보를 검색하는 경로를 의미한다. 현재의 검색 경로를 파악하기 위해서는 search() 함수를 이용하면 된다.위의 결과에서 알 수 있듯이 R이 기동되면 현재의 작업공간을 .GlobalEnv라는 이름으로 첫 번째 검색 경로로 등록한다. 현재의 작업 공간에서 만든 변수들은 여기서 찾을 수 있다. 그리고 package:를 접두사로 하여 패키지별 변수의 데이터베이스가 검색 경로에 등록된다. R은 검색 경로에 나와 있는 순서대로 변수들의 정보를 찾는다.","code":"\nsearch()#>  [1] \".GlobalEnv\"        \"package:writexl\"   \"package:readxl\"   \n#>  [4] \"package:stats\"     \"package:graphics\"  \"package:grDevices\"\n#>  [7] \"package:utils\"     \"package:datasets\"  \"package:methods\"  \n#> [10] \"Autoloads\"         \"package:base\""},{"path":"ch-R-Data-Frame.html","id":"attach로-데이터-프레임을-검색-경로에-등록하기","chapter":"6 R 데이터 프레임","heading":"attach()로 데이터 프레임을 검색 경로에 등록하기","text":"본격적으로 attach() 함수의 작동을 보기 전에 students 데이터 프레임을 제외하고 다른 데이터 객체를 .GlobalEnv에서 삭제하도록 하겠다. .GlobalEnv 작업공간에 있는 변수를 보기 위해서는 ls() 또는 objects() 함수를 사용한다. rm() 함수를 이용하면 작업공간의 변수를 삭제할 수 있다. 이들 함수의 자세한 사용방법은 도움말을 참조한다.아래는 attach() 함수를 이용하여 students 데이터 프레임을 검색 경로에 등록한 예이다. 아래 예에서 보듯이 students를 검색 경로에 등록하기 전에는 retake 변수가 검색 경로에 없으므로 찾을 수 없다고 나온다. 그러나 students 데이터 프레임을 검색 경로에 등록하면 데이터 프레임의 열인 retake를 변수처럼 이용할 수 있음을 알 수 있다.","code":"\nobj <- ls()\nrm(list=obj[which(obj != \"students\")])\nls()#> [1] \"obj\"      \"students\"\nrm(obj)\nobjects()#> [1] \"students\"\nretake#> Error in eval(expr, envir, enclos): 객체 'retake'를 찾을 수 없습니다\nattach(students)\nretake#> [1]  TRUE FALSE FALSE  TRUE FALSE\nsearch()#>  [1] \".GlobalEnv\"        \"students\"          \"package:writexl\"  \n#>  [4] \"package:readxl\"    \"package:stats\"     \"package:graphics\" \n#>  [7] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n#> [10] \"package:methods\"   \"Autoloads\"         \"package:base\""},{"path":"ch-R-Data-Frame.html","id":"attach로-등록된-변수는-데이터-프레임과-독립적인-복사본이다.","chapter":"6 R 데이터 프레임","heading":"attach()로 등록된 변수는 데이터 프레임과 독립적인 복사본이다.","text":"여기서 주의할 점은 attach 된 변수가 변경되더라도 원래 데이터 프레임의 데이터가 변경되지는 않는다는 것이다. attach를 통해 등록된 변수는 데이터 프레임의 데이터가 복사되어 생성되지만 데이터 프레임과는 무관한 별도의 변수처럼 작동한다.데이터 프레임의 데이터를 변경하려면 $ 기호를 써서 직접 변경하여야 한다. 마찬가지로 원래 데이터 프레임의 데이터가 변경되어도 검색 경로에 추가된 retake 변수의 데이터는 변경되지 않음을 알 수 있다.","code":"\nretake[1] <- NA\nretake#> [1]    NA FALSE FALSE  TRUE FALSE\nstudents$retake#> [1]  TRUE FALSE FALSE  TRUE FALSE\nstudents$retake[5] <- NA\nstudents$retake#> [1]  TRUE FALSE FALSE  TRUE    NA\nretake#> [1]    NA FALSE FALSE  TRUE FALSE"},{"path":"ch-R-Data-Frame.html","id":"detach","chapter":"6 R 데이터 프레임","heading":"detach()","text":"데이터 프레임을 검색 경로에서 제거하려면 detach() 함수를 이용한다.","code":"\ndetach(students)\nsearch()#>  [1] \".GlobalEnv\"        \"package:writexl\"   \"package:readxl\"   \n#>  [4] \"package:stats\"     \"package:graphics\"  \"package:grDevices\"\n#>  [7] \"package:utils\"     \"package:datasets\"  \"package:methods\"  \n#> [10] \"Autoloads\"         \"package:base\""},{"path":"ch-R-Data-Frame.html","id":"attach로-등록된-변수의-검색-경로-상의-위치","chapter":"6 R 데이터 프레임","heading":"attach()로 등록된 변수의 검색 경로 상의 위치","text":"R에서 검색 경로의 첫 번째 위치는 항상 현재의 작업공간이 차지한다. attach()에 의해 추가되는 변수들은 항상 검색 경로 상에서 두번째나 그 뒤의 위치에 놓인다. 디폴트로 attach()에 의해 추가되는 변수는 검색 경로 상에서 두번째 위치에 놓이게 되므로 현재의 작업공간을 제외하고는 검색 우선순위가 가장 높게 설정된다. 이를 바꾸고 싶으면 attach() 함수의 position 인수를 이용하면 된다. (자세한 내용은 attach()의 도움말을 참조한다.)일반적으로 데이터 프레임을 이용할 때 다음이 좋은 절차라 알려져 있다.첫째, 어떤 문제와 관련된 모든 변수를 데이터 프레임에 포함시키고 적절한 이름을 부여한다.둘째, 분석하는 문제와 관련된 데이터 프레임을 attach()하여 검색 경로 위치 두 번째에 추가한다. 검색경로의 첫 번째 위치에 작업공간이 있어서 분석 운영을 위한 수치와 임시적인 변수들이 놓인다.셋째, 분석하는 문제를 떠나기 전에 다음에 사용하고자 하는 변수는 $를 이용하여 데이터 프레임에 저장한다. 그리고 detach() 한다.넷째, 작업공간의 모든 필요 없는 변수를 삭제한다.그러나 저자의 경우 attach()와 detach()를 잘 이용하지 않는다. 왜냐하면 이러한 방식은 프로그램이 복잡하거나 동시에 다루어야 할 데이터 프레임이 여러 개인 경우 변수 이름의 충돌이 일어나기 쉽다. 그래서 자신이 원하는 곳의 변수가 아니라 다른 위치의 동일한 이름의 변수를 참조하거나 변경하는 오류가 발생하기 쉽다. 또한 RStudio 같은 IDE를 사용하면 편집기 상에서 데이터 프레임의 이름 등을 자동 완성시킬 수 있으므로 긴 이름을 입력하는 것이 그리 수고스럽지 않기 때문이다. 이 두 가지 방법 중 어떠한 스타일을 택할 것인지는 개인의 선호에 달려 있다. 이 책에서는 특별한 경우가 아니면 attach() 등을 사용하지 않을 것이다.","code":""},{"path":"ch-dataTransformation.html","id":"ch-dataTransformation","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7 dplyr을 이용한 데이터 변환","text":"데이터를 분석하려면 데이터를 분석에 적절한 형식으로 변환하는 전처리가 필요하다. 또한 기본적인 분석을 위해서도 데이터를 요약하는 작업이 필요하다. 이 장에서는 정돈 형식의 데이터 프레임을 변환하는 방법을 배운다.","code":""},{"path":"ch-dataTransformation.html","id":"sec-tidyData","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.1 정돈 데이터 (tidy data)","text":"","code":""},{"path":"ch-dataTransformation.html","id":"정돈-데이터-형식의-조건","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.1.1 정돈 데이터 형식의 조건","text":"정돈 데이터란 그림 7.1처럼 다음의 조건을 만족하는 데이터 행렬(R에서는 데이터 프레임)의 형식을 의미한다.데이터 행렬의 각 행과 관측(대상)(observations)은 일대일의 관계이다.데이터 행렬의 각 열과 변수(variables)는 일대일의 관계이다.측정값(values)은 각 셀과 일대일의 관계이다.\nFigure 7.1: 정돈 데이터\n","code":""},{"path":"ch-dataTransformation.html","id":"비정돈-데이터-형식","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.1.2 비정돈 데이터 형식","text":"현실에서 만나는 많은 데이터가 정돈 데이터 형식이지만, 그렇지 않은 데이터도 자주 볼 수 있다. 그림 7.2의 왼쪽 데이터는 어떤 가상의 감염병에 대해 세 나라의 발생 사례를 월별로 정리한 데이터이다. 이 데이터는 감염 사례라는 변수와 관련된 데이터가 3개의 열에 흩어져 있으므로 비정돈 형식이다. 월별, 년도별 매출처럼 시계열 데이터는 종종 이런 형식으로 데이터가 표현된다. 이러한 방식의 표현은 데이터를 매우 압축적인 방식으로 표현할 수 있고 같은 시간대의 데이터를 비교하기 쉬운 장점이 있다.그림 7.2의 오른쪽 데이터는 왼쪽 데이터를 정돈 형식으로 변환한 결과이다. 이러한 변환을 하는 방법에 대해서는 9 장에서 다룰 것이다.\nFigure 7.2: 비정돈 데이터\n","code":""},{"path":"ch-dataTransformation.html","id":"정돈-데이터를-사용하는-이유","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.1.3 정돈 데이터를 사용하는 이유","text":"그림 7.2를 보면 정돈 형식 데이터가 오히려 비효율적인 방식으로 보이며, 데이터를 한 눈에 비교하기도 어려워 보인다. 그럼에도 정돈 형식의 데이터를 사용하는 이유는 표준화된 데이터 변환 작업을 하기 위해서이다.한 행이 하나의 관측 대상을, 한 열이 하나의 변수를, 한 셀이 한 값을 나타낸다는 가정이 성립하면, 데이터 변환이나 데이터를 이용한 그래픽 작업을 데이터의 내용에 무관하게 항상 일정한 형식으로 수행할 수 있다.","code":""},{"path":"ch-dataTransformation.html","id":"tidyverse-패키지","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.2 tidyverse 패키지","text":"tidyverse 패키지는 정돈 데이터 패러다임을 따른 R 패키지들을 한번에 설치하고 적재할 수 있도록 돕는 패키지이다.","code":""},{"path":"ch-dataTransformation.html","id":"tidyverse-패키지-설치","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.2.1 tidyverse 패키지 설치","text":"tidyverse 패키지를 설치하려면 다음 명령을 실행하면 된다. 패키지의 이름은 문자열이므로 따옴표 안에 기술해야 한다.또는 RStudio의 Packages 탭에서 [Install]을 클릭한 후 tidyverse라고 입력을 하면 된다. 패키지 설치는 한 번만 수행하면 된다.","code":"\ninstall.packages(\"tidyverse\")"},{"path":"ch-dataTransformation.html","id":"tidyverse-패키지-적재","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.2.2 tidyverse 패키지 적재","text":"tidyverse 패키지가 설치되었으면 패키지를 사용할 때마다 네임스페이스를 적재하고 검색 리스트에 패키지를 포함하는 작업이 필요하다.6 다음은 tidyverse 패키지를 적재하는 명령어이다. 이번에는 패키지 이름에 따옴표가 없음에 주의한다.앞의 명령을 실행하면 정돈 데이터 패러다임을 따르는 여러 개의 패키지가 동시에 적재된다. 그리고 R 기본 패키지와 정돈 데이터 패키지 중에서 이름이 충돌이 나는 것에 대해 보고를 한다. 만약 R 기본 패키지에서 이 함수를 사용하는 경우에는 패키지이름::함수() 형식으로만 사용할 수 있다. 자세한 내용은 R 관련 책을 참조하기 바란다.","code":"\nlibrary(tidyverse)#> ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n#> ✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n#> ✔ tibble  3.1.8      ✔ dplyr   1.0.10\n#> ✔ tidyr   1.2.1      ✔ stringr 1.5.0 \n#> ✔ readr   2.1.3      ✔ forcats 0.5.2 \n#> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n#> ✖ dplyr::filter() masks stats::filter()\n#> ✖ dplyr::lag()    masks stats::lag()"},{"path":"ch-dataTransformation.html","id":"sec-dplyr","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.3 dplyr 패키지와 정돈 데이터의 변환","text":"","code":""},{"path":"ch-dataTransformation.html","id":"dplyr-패키지","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.3.1 dplyr 패키지","text":"정돈 데이터의 변환에는 tidyverse 패키지가 포함하고 있는 dplyr 패키지가 이용된다. 앞에서 tidyverse를 적재하였으면 이미 dplyr이 적재되어 있으므로 다시 적재할 필요가 없다.","code":""},{"path":"ch-dataTransformation.html","id":"정돈-데이터-변환의-종류","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.3.2 정돈 데이터 변환의 종류","text":"정돈 데이터의 변환은 크게 5가지 변환 작업이 있다.행 선택:filter(): 데이터에서 특정 열의 값이 조건에 맞는 행만 선택한다.slice(): 데이터에서 특정 위치의 행만 선택한다.행 정렬arrange(): 특정 열의 값을 기준으로 데이터의 행을 정렬한다.열 선택:select(): 열의 이름, 위치, 데이터 형식 등으로 일부 열만 데이터에서 선택한다.열 추가:mutate(): 기존 열을 사용하여 새로운 열을 데이터에 추가한다.데이터 요약:summarize(): 데이터 전체 또는 특정 열을 하나의 통계량으로 요약한다.group_by(): 데이터 요약에만 사용되는 것은 아니나, 그룹별로 데이터를 통계 요약할 때 자주 사용된다.그리고 위의 작업은 group_by() 함수와 같이 사용되어 전체 데이터에서 작업이 수행되는 것이 아니라, 데이터 행을 특정 열의 값을 기준으로 그룹으로 나누어서 그룹별로 데이터 변환 작업이 수행되도록 조정할 수 있다.\n다음 그림은 정돈 데이터 변환 함수에 의한 변환 결과를 예시하고 있다.이 함수들은 모두 다음과 같은 인터페이스를 가지고 있다.첫 번재 인수로 변환할 데이터프레임을 받는다.나머지 인수는 데이터프레임에 어떤 변환을 할지를 지정한다. 데이터프레임의 열을 지정할 때 열 이름을 따옴표 없이 변수처럼 사용한다.함수의 결과는 변환이 수행된 새로운 데이터프레임이다.일반적으로 데이터의 변환 작업은 위의 6가지 작업이 여러 차례 순서대로 결합하여 진행된다.","code":""},{"path":"ch-dataTransformation.html","id":"dplyr-패키지-vs.-r의-기본-기능","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.3.3 dplyr 패키지 vs. R의 기본 기능","text":"앞으로 볼 dplyr 패키지의 함수들이 수행하는 작업은 R에서 제공하는 기본 함수로도 수행될 수 있다.\n특히 filter(), arrange(), select(), mutate() 함수의 작업은 R 데이터프레임의 필터링 기능을 사용하면 대체할 수 있으며, summarize()와 group_by() 함수의 작업은 tapply(), aggregate() 등을 사용하면 대체할 수 있다.\n그럼에도 불구하고 복잡한 데이터 변환을 수행할 때 R의 기본 기능보다는 dplyr 패키지의 함수들이 선호되는 이유는 다음과 같다.dplyr 함수에서는 데이터프레임의 열을 변수처럼 사용할 수 있어서 R의 기본 기능보다 더 짧은 명령문으로 데이터의 조작과 변환이 가능하다.R의 기본 함수들은 한 함수가 여러 가지 변환을 수행하고 서로의 기능이 중복되는데 반해, dplyr 패키지의 함수는 오직 하나의 기능만을 수행하고 서로 기능이 중복되지 않아서 명령문을 이해하기 쉽다.R의 기본 함수들이 입력과 출력 형식이 제각각인데 반해, dplyr 패키지의 함수는 공통된 입력과 출력 형식을 사용하므로 여러 단계를 거치는 복잡한 데이터 변환 작업도 dplyr 함수를 파이프 연산자로 연결하여 쉽게 구현할 수 있다.","code":""},{"path":"ch-dataTransformation.html","id":"mpg-데이터","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.3.4 mpg 데이터","text":"이 장에서는 ggplot2() 패키지에서 제공하는 mpg 데이터를 이용하여 정돈 데이터를 변환하는 함수를 설명한다.다음 명령을 이용하여 mpg 데이터를 출력해 보자. 화면의 크기에 따라 출력되는 내용이 책과는 조금 다를 수 있다.mpg는 1999년과 2008년에 미국 EPA에서 조사하여 발표한 자동차 주요 모델별 연비 데이터이다. 데이터는 234 개의 행이 있으며, 각 행은 다음과 같은 변수로 구성되어 있다.manufacturer: 자동차 제조사model: 자동차 모델명displ: 자동차 배기량year: 제조년도cyl: 엔진 실린더 수trans: 자동차 트랜스미션 종류drv: 자동차 구동 방식. f=전륜구동, r=후륜구동, 4=사륜구동cty: 도심 연비 (마일/갤론)hwy: 고속도로 연비 (마일/갤론)fl: 연료 종류class: 자동차 분류","code":"\nmpg#> # A tibble: 234 × 11\n#>    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class\n#>    <chr>        <chr>      <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr>\n#>  1 audi         a4           1.8  1999     4 auto… f        18    29 p     comp…\n#>  2 audi         a4           1.8  1999     4 manu… f        21    29 p     comp…\n#>  3 audi         a4           2    2008     4 manu… f        20    31 p     comp…\n#>  4 audi         a4           2    2008     4 auto… f        21    30 p     comp…\n#>  5 audi         a4           2.8  1999     6 auto… f        16    26 p     comp…\n#>  6 audi         a4           2.8  1999     6 manu… f        18    26 p     comp…\n#>  7 audi         a4           3.1  2008     6 auto… f        18    27 p     comp…\n#>  8 audi         a4 quattro   1.8  1999     4 manu… 4        18    26 p     comp…\n#>  9 audi         a4 quattro   1.8  1999     4 auto… 4        16    25 p     comp…\n#> 10 audi         a4 quattro   2    2008     4 manu… 4        20    28 p     comp…\n#> # … with 224 more rows"},{"path":"ch-dataTransformation.html","id":"sec-filter","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.4 filter()로 행 선택하기","text":"","code":""},{"path":"ch-dataTransformation.html","id":"선택-조건이-하나인-경우","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.4.1 선택 조건이 하나인 경우","text":"선택 조건이 하나인 경우 다음 형식으로 filter()를 사용한다.’데이터프레임’에는 filter()를 적용할 데이터 프레임을 ’조건’에는 행 선택 조건을 기술한다. ’조건’은 논리값 벡터이어야 한다. 많은 경우 ’조건’은 다음처럼 변수와 어떤 값을 비교연산자로 비교한다. 다음 예에서 보는 것처럼 dplyr 패키지의 함수들은 첫번째 인수로 데이터프레임을 지정한 후, 나머지 부분에서 그 데이터프레임의 열을 변수처럼 사용할 수 있다.조건을 서술할 때 자주 틀리는 부분이 등호 기호로 =를 사용하는 것이다. R에서 두 값이 같은지를 비교할 때는 ==를 사용한다.다음처럼 조건에 사용되는 변수에 대해 연산을 수행한 후에 그 결과를 비교할 수도 있다.","code":"filter(데이터프레임, 조건)\nfilter(mpg, manufacturer==\"hyundai\")#> # A tibble: 14 × 11\n#>    manufacturer model   displ  year   cyl trans    drv     cty   hwy fl    class\n#>    <chr>        <chr>   <dbl> <int> <int> <chr>    <chr> <int> <int> <chr> <chr>\n#>  1 hyundai      sonata    2.4  1999     4 auto(l4) f        18    26 r     mids…\n#>  2 hyundai      sonata    2.4  1999     4 manual(… f        18    27 r     mids…\n#>  3 hyundai      sonata    2.4  2008     4 auto(l4) f        21    30 r     mids…\n#>  4 hyundai      sonata    2.4  2008     4 manual(… f        21    31 r     mids…\n#>  5 hyundai      sonata    2.5  1999     6 auto(l4) f        18    26 r     mids…\n#>  6 hyundai      sonata    2.5  1999     6 manual(… f        18    26 r     mids…\n#>  7 hyundai      sonata    3.3  2008     6 auto(l5) f        19    28 r     mids…\n#>  8 hyundai      tiburon   2    1999     4 auto(l4) f        19    26 r     subc…\n#>  9 hyundai      tiburon   2    1999     4 manual(… f        19    29 r     subc…\n#> 10 hyundai      tiburon   2    2008     4 manual(… f        20    28 r     subc…\n#> 11 hyundai      tiburon   2    2008     4 auto(l4) f        20    27 r     subc…\n#> 12 hyundai      tiburon   2.7  2008     6 auto(l4) f        17    24 r     subc…\n#> 13 hyundai      tiburon   2.7  2008     6 manual(… f        16    24 r     subc…\n#> 14 hyundai      tiburon   2.7  2008     6 manual(… f        17    24 r     subc…\nfilter(mpg, cty > 28)#> # A tibble: 3 × 11\n#>   manufacturer model      displ  year   cyl trans  drv     cty   hwy fl    class\n#>   <chr>        <chr>      <dbl> <int> <int> <chr>  <chr> <int> <int> <chr> <chr>\n#> 1 volkswagen   jetta        1.9  1999     4 manua… f        33    44 d     comp…\n#> 2 volkswagen   new beetle   1.9  1999     4 manua… f        35    44 d     subc…\n#> 3 volkswagen   new beetle   1.9  1999     4 auto(… f        29    41 d     subc…\nfilter(mpg, cty >= 28)#> # A tibble: 5 × 11\n#>   manufacturer model      displ  year   cyl trans  drv     cty   hwy fl    class\n#>   <chr>        <chr>      <dbl> <int> <int> <chr>  <chr> <int> <int> <chr> <chr>\n#> 1 honda        civic        1.6  1999     4 manua… f        28    33 r     subc…\n#> 2 toyota       corolla      1.8  2008     4 manua… f        28    37 r     comp…\n#> 3 volkswagen   jetta        1.9  1999     4 manua… f        33    44 d     comp…\n#> 4 volkswagen   new beetle   1.9  1999     4 manua… f        35    44 d     subc…\n#> 5 volkswagen   new beetle   1.9  1999     4 auto(… f        29    41 d     subc…\nfilter(mpg, cty * 2 > 60)#> # A tibble: 2 × 11\n#>   manufacturer model      displ  year   cyl trans  drv     cty   hwy fl    class\n#>   <chr>        <chr>      <dbl> <int> <int> <chr>  <chr> <int> <int> <chr> <chr>\n#> 1 volkswagen   jetta        1.9  1999     4 manua… f        33    44 d     comp…\n#> 2 volkswagen   new beetle   1.9  1999     4 manua… f        35    44 d     subc…\nfilter(mpg, sqrt(cty) < 3.2)#> # A tibble: 5 × 11\n#>   manufacturer model       displ  year   cyl trans drv     cty   hwy fl    class\n#>   <chr>        <chr>       <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr>\n#> 1 dodge        dakota pic…   4.7  2008     8 auto… 4         9    12 e     pick…\n#> 2 dodge        durango 4wd   4.7  2008     8 auto… 4         9    12 e     suv  \n#> 3 dodge        ram 1500 p…   4.7  2008     8 auto… 4         9    12 e     pick…\n#> 4 dodge        ram 1500 p…   4.7  2008     8 manu… 4         9    12 e     pick…\n#> 5 jeep         grand cher…   4.7  2008     8 auto… 4         9    12 e     suv"},{"path":"ch-dataTransformation.html","id":"여러-조건을-만족하는-행-추출하기","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.4.2 여러 조건을 만족하는 행 추출하기","text":"두 개 이상의 조건을 모두 만족하는 행만 뽑아내려면 다음의 문법을 사용한다.다음은 현대에서 생산한 차 중 도심 연비가 20 마일 이상인 차만 추출한 결과이다.앞의 조건에서 배기량이 2.4 이상인 차만 추출해 보자.","code":"filter(데이터프레임, 조건1, 조건2, ..., 조건n)\nfilter(mpg, manufacturer==\"hyundai\", cty >= 20)#> # A tibble: 4 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      sonata    2.4  2008     4 auto(l4)  f        21    30 r     mids…\n#> 2 hyundai      sonata    2.4  2008     4 manual(m… f        21    31 r     mids…\n#> 3 hyundai      tiburon   2    2008     4 manual(m… f        20    28 r     subc…\n#> 4 hyundai      tiburon   2    2008     4 auto(l4)  f        20    27 r     subc…\nfilter(mpg, manufacturer==\"hyundai\", cty >= 20, displ >= 2.4)#> # A tibble: 2 × 11\n#>   manufacturer model  displ  year   cyl trans      drv     cty   hwy fl    class\n#>   <chr>        <chr>  <dbl> <int> <int> <chr>      <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      sonata   2.4  2008     4 auto(l4)   f        21    30 r     mids…\n#> 2 hyundai      sonata   2.4  2008     4 manual(m5) f        21    31 r     mids…"},{"path":"ch-dataTransformation.html","id":"논리-연산자로-복합-조건-만들기","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.4.3 논리 연산자로 복합 조건 만들기","text":"지금까지는 하나의 조건이나 여러 조건을 동시에 만족하는 행을 추출하는 방법을 보았다. 어떤 경우에는 여러 조건 중 하나라도 만족하면 그 행을 추출해야 할 경우가 있다. 이러한 경우에는 2 장에서 배운 논리 연산자를 이용하여 복합 조건을 만들어야 한다.다음은 연자자인 |를 이용하여 두 조건 중 하나만 만족하여도 행이 추출되도록 하였다.만약 위의 결과에서 2008년도 데이터만 추출하고 싶다면 어떻게 해야 할까? 다음처럼 두 조건식을 사용하여 첫 번째 조건과 두 번째 조건을 모두 만족하는 결과만 추출할 수도 있고, 하나의 조건식에 연산자인 &를 사용하여 복합 조건식을 사용하여 추출할 수도 있다.단, 복합 조건식에서 연산이 연산보다 우선순위가 있으므로 괄호를 사용하여 연산의 순서가 제대로 되도록 하여야 한다. 괄호가 없으면 AND가 수행된 후 OR가 수행되어 모든 소타나 자동차의 결과가 추출되었음을 볼 수 있다.","code":"\nfilter(mpg, model==\"sonata\" | cty >= 28)#> # A tibble: 12 × 11\n#>    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class\n#>    <chr>        <chr>      <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr>\n#>  1 honda        civic        1.6  1999     4 manu… f        28    33 r     subc…\n#>  2 hyundai      sonata       2.4  1999     4 auto… f        18    26 r     mids…\n#>  3 hyundai      sonata       2.4  1999     4 manu… f        18    27 r     mids…\n#>  4 hyundai      sonata       2.4  2008     4 auto… f        21    30 r     mids…\n#>  5 hyundai      sonata       2.4  2008     4 manu… f        21    31 r     mids…\n#>  6 hyundai      sonata       2.5  1999     6 auto… f        18    26 r     mids…\n#>  7 hyundai      sonata       2.5  1999     6 manu… f        18    26 r     mids…\n#>  8 hyundai      sonata       3.3  2008     6 auto… f        19    28 r     mids…\n#>  9 toyota       corolla      1.8  2008     4 manu… f        28    37 r     comp…\n#> 10 volkswagen   jetta        1.9  1999     4 manu… f        33    44 d     comp…\n#> 11 volkswagen   new beetle   1.9  1999     4 manu… f        35    44 d     subc…\n#> 12 volkswagen   new beetle   1.9  1999     4 auto… f        29    41 d     subc…\nfilter(mpg, model==\"sonata\" | cty >= 28, year==2008)#> # A tibble: 4 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      sonata    2.4  2008     4 auto(l4)  f        21    30 r     mids…\n#> 2 hyundai      sonata    2.4  2008     4 manual(m… f        21    31 r     mids…\n#> 3 hyundai      sonata    3.3  2008     6 auto(l5)  f        19    28 r     mids…\n#> 4 toyota       corolla   1.8  2008     4 manual(m… f        28    37 r     comp…\nfilter(mpg, (model==\"sonata\" | cty >= 28) & year==2008)#> # A tibble: 4 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      sonata    2.4  2008     4 auto(l4)  f        21    30 r     mids…\n#> 2 hyundai      sonata    2.4  2008     4 manual(m… f        21    31 r     mids…\n#> 3 hyundai      sonata    3.3  2008     6 auto(l5)  f        19    28 r     mids…\n#> 4 toyota       corolla   1.8  2008     4 manual(m… f        28    37 r     comp…\nfilter(mpg, model==\"sonata\" | cty >= 28 & year==2008)#> # A tibble: 8 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      sonata    2.4  1999     4 auto(l4)  f        18    26 r     mids…\n#> 2 hyundai      sonata    2.4  1999     4 manual(m… f        18    27 r     mids…\n#> 3 hyundai      sonata    2.4  2008     4 auto(l4)  f        21    30 r     mids…\n#> 4 hyundai      sonata    2.4  2008     4 manual(m… f        21    31 r     mids…\n#> 5 hyundai      sonata    2.5  1999     6 auto(l4)  f        18    26 r     mids…\n#> 6 hyundai      sonata    2.5  1999     6 manual(m… f        18    26 r     mids…\n#> 7 hyundai      sonata    3.3  2008     6 auto(l5)  f        19    28 r     mids…\n#> 8 toyota       corolla   1.8  2008     4 manual(m… f        28    37 r     comp…"},{"path":"ch-dataTransformation.html","id":"in-연산자","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.4.4 %in% 연산자","text":"만약 조사 년도가 2008년이고, 고속도로 연비가 30 이상이면서, 자동차 모델이 sonata 또는 corolla 또는 jetta인 행을 찾고자 한다면 어떻게 해야 할까?\n앞에서 배운 복잡 조건문을 사용하여 다음처럼 수행할 수 있을 것이다.위의 명령은 %% 연산자를 사용하면 좀 더 간단해 질 수 있다.\n%% 연산자는 어떤 값이 벡터의 요소 중에 하나인지를 판별해 준다.그러므로 앞에서 수행한 명령은 다음처럼 수행할 수도 있다.","code":"\nfilter(mpg, year==2008, hwy >= 28, model==\"sonata\" | model==\"corolla\" | model==\"jetta\")#> # A tibble: 9 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      sonata    2.4  2008     4 auto(l4)  f        21    30 r     mids…\n#> 2 hyundai      sonata    2.4  2008     4 manual(m… f        21    31 r     mids…\n#> 3 hyundai      sonata    3.3  2008     6 auto(l5)  f        19    28 r     mids…\n#> 4 toyota       corolla   1.8  2008     4 manual(m… f        28    37 r     comp…\n#> 5 toyota       corolla   1.8  2008     4 auto(l4)  f        26    35 r     comp…\n#> 6 volkswagen   jetta     2    2008     4 auto(s6)  f        22    29 p     comp…\n#> 7 volkswagen   jetta     2    2008     4 manual(m… f        21    29 p     comp…\n#> 8 volkswagen   jetta     2.5  2008     5 auto(s6)  f        21    29 r     comp…\n#> 9 volkswagen   jetta     2.5  2008     5 manual(m… f        21    29 r     comp…\na <- 1:3\n0 %in% a#> [1] FALSE\n1 %in% a#> [1] TRUE\n3 %in% a#> [1] TRUE\n4 %in% a#> [1] FALSE\nfilter(mpg, year==2008, hwy >= 28, model %in% c(\"sonata\",\"corolla\",\"jetta\"))#> # A tibble: 9 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      sonata    2.4  2008     4 auto(l4)  f        21    30 r     mids…\n#> 2 hyundai      sonata    2.4  2008     4 manual(m… f        21    31 r     mids…\n#> 3 hyundai      sonata    3.3  2008     6 auto(l5)  f        19    28 r     mids…\n#> 4 toyota       corolla   1.8  2008     4 manual(m… f        28    37 r     comp…\n#> 5 toyota       corolla   1.8  2008     4 auto(l4)  f        26    35 r     comp…\n#> 6 volkswagen   jetta     2    2008     4 auto(s6)  f        22    29 p     comp…\n#> 7 volkswagen   jetta     2    2008     4 manual(m… f        21    29 p     comp…\n#> 8 volkswagen   jetta     2.5  2008     5 auto(s6)  f        21    29 r     comp…\n#> 9 volkswagen   jetta     2.5  2008     5 manual(m… f        21    29 r     comp…"},{"path":"ch-dataTransformation.html","id":"sec-slice","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.5 slice()로 행 선택하기","text":"slice() 함수는 다음 문법을 사용하여 행을 선택한다.선택위치에는 양의 정수 또는 음의 정수 벡터가 지정된다.\n양의 정수 벡터가 지정되면 해당 위치의 행이 선택되고, 음의 정수 벡터가 지정되면 해당 위치의 행을 제외한 나머지 행이 선택된다.\n그런데 주의할 점은 선택위치에 지정되는 벡터는 모두 양의 정수 벡터이거나 모두 음의 정수 벡터이어야 한다는 것이다.다음은 2008년도 현대의 자동차 모델만 filter()론 선택하여 a라는 변수에 저장한 후, 이 데이터를 가지고 slice()를 사용하여 여러 위치의 행을 선택해본 예이다.","code":"select(데이터프레임, 선택위치1, 선택위치2, ...)\na <- filter(mpg, manufacturer == \"hyundai\", year == 2008)\na#> # A tibble: 8 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      sonata    2.4  2008     4 auto(l4)  f        21    30 r     mids…\n#> 2 hyundai      sonata    2.4  2008     4 manual(m… f        21    31 r     mids…\n#> 3 hyundai      sonata    3.3  2008     6 auto(l5)  f        19    28 r     mids…\n#> 4 hyundai      tiburon   2    2008     4 manual(m… f        20    28 r     subc…\n#> 5 hyundai      tiburon   2    2008     4 auto(l4)  f        20    27 r     subc…\n#> 6 hyundai      tiburon   2.7  2008     6 auto(l4)  f        17    24 r     subc…\n#> 7 hyundai      tiburon   2.7  2008     6 manual(m… f        16    24 r     subc…\n#> 8 hyundai      tiburon   2.7  2008     6 manual(m… f        17    24 r     subc…\nslice(a, 1)   # 1 행 선택#> # A tibble: 1 × 11\n#>   manufacturer model  displ  year   cyl trans    drv     cty   hwy fl    class  \n#>   <chr>        <chr>  <dbl> <int> <int> <chr>    <chr> <int> <int> <chr> <chr>  \n#> 1 hyundai      sonata   2.4  2008     4 auto(l4) f        21    30 r     midsize\nslice(a, 1:3) # 1-3 행 선택#> # A tibble: 3 × 11\n#>   manufacturer model  displ  year   cyl trans      drv     cty   hwy fl    class\n#>   <chr>        <chr>  <dbl> <int> <int> <chr>      <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      sonata   2.4  2008     4 auto(l4)   f        21    30 r     mids…\n#> 2 hyundai      sonata   2.4  2008     4 manual(m5) f        21    31 r     mids…\n#> 3 hyundai      sonata   3.3  2008     6 auto(l5)   f        19    28 r     mids…\nslice(a, 1:3, 6:7) # 1-3과 6-7 행 선택#> # A tibble: 5 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      sonata    2.4  2008     4 auto(l4)  f        21    30 r     mids…\n#> 2 hyundai      sonata    2.4  2008     4 manual(m… f        21    31 r     mids…\n#> 3 hyundai      sonata    3.3  2008     6 auto(l5)  f        19    28 r     mids…\n#> 4 hyundai      tiburon   2.7  2008     6 auto(l4)  f        17    24 r     subc…\n#> 5 hyundai      tiburon   2.7  2008     6 manual(m… f        16    24 r     subc…\nslice(a, -1)  # 1 행 제외#> # A tibble: 7 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      sonata    2.4  2008     4 manual(m… f        21    31 r     mids…\n#> 2 hyundai      sonata    3.3  2008     6 auto(l5)  f        19    28 r     mids…\n#> 3 hyundai      tiburon   2    2008     4 manual(m… f        20    28 r     subc…\n#> 4 hyundai      tiburon   2    2008     4 auto(l4)  f        20    27 r     subc…\n#> 5 hyundai      tiburon   2.7  2008     6 auto(l4)  f        17    24 r     subc…\n#> 6 hyundai      tiburon   2.7  2008     6 manual(m… f        16    24 r     subc…\n#> 7 hyundai      tiburon   2.7  2008     6 manual(m… f        17    24 r     subc…\nslice(a, -1, -(4:6))  # 1 행과 4-6 행 제외#> # A tibble: 4 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      sonata    2.4  2008     4 manual(m… f        21    31 r     mids…\n#> 2 hyundai      sonata    3.3  2008     6 auto(l5)  f        19    28 r     mids…\n#> 3 hyundai      tiburon   2.7  2008     6 manual(m… f        16    24 r     subc…\n#> 4 hyundai      tiburon   2.7  2008     6 manual(m… f        17    24 r     subc…"},{"path":"ch-dataTransformation.html","id":"slice_sample로-표본-추출하기","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.5.1 slice_sample()로 표본 추출하기","text":"데이터를 분석할 때 데이터의 일부 행만 임의로 추출해야하는 경우가 있다.\nslice_sample()을 사용하면 데이터에서 원하는 수 또는 비율만큼 행을 임의 추출할 수 있다.\n원하는 수만큼 임의 추출하려면 n 인수를 원하는 비율만큼 행을 추출하려면 prop 인수를 사용한다.","code":"\nslice_sample(a, n=3) # 데이터에서 3 개의 행을 추출 #> # A tibble: 3 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      tiburon   2    2008     4 manual(m… f        20    28 r     subc…\n#> 2 hyundai      tiburon   2    2008     4 auto(l4)  f        20    27 r     subc…\n#> 3 hyundai      tiburon   2.7  2008     6 auto(l4)  f        17    24 r     subc…\nslice_sample(a, prop=0.8) # 데이터에서 80% 행을 추출 #> # A tibble: 6 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      tiburon   2.7  2008     6 auto(l4)  f        17    24 r     subc…\n#> 2 hyundai      sonata    2.4  2008     4 auto(l4)  f        21    30 r     mids…\n#> 3 hyundai      tiburon   2.7  2008     6 manual(m… f        17    24 r     subc…\n#> 4 hyundai      tiburon   2    2008     4 manual(m… f        20    28 r     subc…\n#> 5 hyundai      tiburon   2.7  2008     6 manual(m… f        16    24 r     subc…\n#> 6 hyundai      sonata    3.3  2008     6 auto(l5)  f        19    28 r     mids…"},{"path":"ch-dataTransformation.html","id":"slice_head와-slice_tail","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.5.2 slice_head()와 slice_tail()","text":"데이터의 맨 앞의 행들이나, 맨 뒤의 행을 추출할 때 사용한다.\nn 인수를 지정하여 원하는 수만큼의 행을 추출할 수도 있고, prop 인수를 지정하여 원하는 비율만큼의 행을 추출할 수도 있다.","code":"\nslice_head(mpg, n=4)  # 데이터의 처음 4 행 추출#> # A tibble: 4 × 11\n#>   manufacturer model displ  year   cyl trans      drv     cty   hwy fl    class \n#>   <chr>        <chr> <dbl> <int> <int> <chr>      <chr> <int> <int> <chr> <chr> \n#> 1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p     compa…\n#> 2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p     compa…\n#> 3 audi         a4      2    2008     4 manual(m6) f        20    31 p     compa…\n#> 4 audi         a4      2    2008     4 auto(av)   f        21    30 p     compa…\nslice_tail(mpg, prop=0.05) # 데이터의 마지막 5% 추출#> # A tibble: 11 × 11\n#>    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class\n#>    <chr>        <chr>      <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr>\n#>  1 volkswagen   new beetle   2    1999     4 manu… f        21    29 r     subc…\n#>  2 volkswagen   new beetle   2    1999     4 auto… f        19    26 r     subc…\n#>  3 volkswagen   new beetle   2.5  2008     5 manu… f        20    28 r     subc…\n#>  4 volkswagen   new beetle   2.5  2008     5 auto… f        20    29 r     subc…\n#>  5 volkswagen   passat       1.8  1999     4 manu… f        21    29 p     mids…\n#>  6 volkswagen   passat       1.8  1999     4 auto… f        18    29 p     mids…\n#>  7 volkswagen   passat       2    2008     4 auto… f        19    28 p     mids…\n#>  8 volkswagen   passat       2    2008     4 manu… f        21    29 p     mids…\n#>  9 volkswagen   passat       2.8  1999     6 auto… f        16    26 p     mids…\n#> 10 volkswagen   passat       2.8  1999     6 manu… f        18    26 p     mids…\n#> 11 volkswagen   passat       3.6  2008     6 auto… f        17    26 p     mids…"},{"path":"ch-dataTransformation.html","id":"slice_min과-slice_max","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.5.3 slice_min()과 slice_max()","text":"특정 열을 기준으로 가장 값이 작은 행 또는 가장 값이 큰 행을 추출하는 함수이다.\n사실 뒤에서 설명할 arrange() 함수를 적용한 후 slice() 함수를 적용하면 같은 효과를 구현할 수 있다.결과에서 보듯이 동률이 있는 경우 동률인 행도 모두 추출되므로 n으로 정한 행의 수보다 많은 행이 추출될 수 있다. 동률인 행인 추출되지 않도록 하려면 with_ties=FALSE 인수를 설정하면 된다.","code":"\nslice_min(a, cty, n=2) # cty 열의 값이 가장 작은 2 행 추출#> # A tibble: 3 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      tiburon   2.7  2008     6 manual(m… f        16    24 r     subc…\n#> 2 hyundai      tiburon   2.7  2008     6 auto(l4)  f        17    24 r     subc…\n#> 3 hyundai      tiburon   2.7  2008     6 manual(m… f        17    24 r     subc…\nslice_min(a, hwy, n=2) # hwy 열의 값이 가장 큰 2 행 추출#> # A tibble: 3 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      tiburon   2.7  2008     6 auto(l4)  f        17    24 r     subc…\n#> 2 hyundai      tiburon   2.7  2008     6 manual(m… f        16    24 r     subc…\n#> 3 hyundai      tiburon   2.7  2008     6 manual(m… f        17    24 r     subc…\nslice_min(a, cty, n=2, with_ties = F) # 동률 행을 추출하지 않는다.#> # A tibble: 2 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      tiburon   2.7  2008     6 manual(m… f        16    24 r     subc…\n#> 2 hyundai      tiburon   2.7  2008     6 auto(l4)  f        17    24 r     subc…"},{"path":"ch-dataTransformation.html","id":"sec-arrange","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.6 arrange()로 행 정렬하기","text":"arrange()는 다음 문법을 사용하여 행을 정렬한다.filter()와 마찬가지로 첫 번재 인수로 정렬할 데이터 프레임을 전달 받는다. 그리고 두번재 인수부터 정렬의 기준이 되는 변수를 차례로 기술한다. 첫 번째 기준 변수의 값이 같으면, 두 번째 기준 변수를, 두 번째 기준 변수의 값까지 같으면 그 다음 변수를 기준으로 차례로 순서를 결정하여 정렬을 수행한다.다음은 2008년도 현대의 자동차 모델만 filter()론 선택하여 a라는 변수에 저장한 후, 이 데이터에 대하여 여러 조건으로 정렬을 수행해본 예이다.","code":"arrange(데이터프레임, 첫번째 정렬 기준 변수, 두번째 정렬 기준 변수, ....)\na <- filter(mpg, manufacturer == \"hyundai\", year == 2008)\na#> # A tibble: 8 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      sonata    2.4  2008     4 auto(l4)  f        21    30 r     mids…\n#> 2 hyundai      sonata    2.4  2008     4 manual(m… f        21    31 r     mids…\n#> 3 hyundai      sonata    3.3  2008     6 auto(l5)  f        19    28 r     mids…\n#> 4 hyundai      tiburon   2    2008     4 manual(m… f        20    28 r     subc…\n#> 5 hyundai      tiburon   2    2008     4 auto(l4)  f        20    27 r     subc…\n#> 6 hyundai      tiburon   2.7  2008     6 auto(l4)  f        17    24 r     subc…\n#> 7 hyundai      tiburon   2.7  2008     6 manual(m… f        16    24 r     subc…\n#> 8 hyundai      tiburon   2.7  2008     6 manual(m… f        17    24 r     subc…\narrange(a, cyl)#> # A tibble: 8 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      sonata    2.4  2008     4 auto(l4)  f        21    30 r     mids…\n#> 2 hyundai      sonata    2.4  2008     4 manual(m… f        21    31 r     mids…\n#> 3 hyundai      tiburon   2    2008     4 manual(m… f        20    28 r     subc…\n#> 4 hyundai      tiburon   2    2008     4 auto(l4)  f        20    27 r     subc…\n#> 5 hyundai      sonata    3.3  2008     6 auto(l5)  f        19    28 r     mids…\n#> 6 hyundai      tiburon   2.7  2008     6 auto(l4)  f        17    24 r     subc…\n#> 7 hyundai      tiburon   2.7  2008     6 manual(m… f        16    24 r     subc…\n#> 8 hyundai      tiburon   2.7  2008     6 manual(m… f        17    24 r     subc…\narrange(a, cyl, cty)#> # A tibble: 8 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      tiburon   2    2008     4 manual(m… f        20    28 r     subc…\n#> 2 hyundai      tiburon   2    2008     4 auto(l4)  f        20    27 r     subc…\n#> 3 hyundai      sonata    2.4  2008     4 auto(l4)  f        21    30 r     mids…\n#> 4 hyundai      sonata    2.4  2008     4 manual(m… f        21    31 r     mids…\n#> 5 hyundai      tiburon   2.7  2008     6 manual(m… f        16    24 r     subc…\n#> 6 hyundai      tiburon   2.7  2008     6 auto(l4)  f        17    24 r     subc…\n#> 7 hyundai      tiburon   2.7  2008     6 manual(m… f        17    24 r     subc…\n#> 8 hyundai      sonata    3.3  2008     6 auto(l5)  f        19    28 r     mids…\narrange(a, model, trans)#> # A tibble: 8 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      sonata    2.4  2008     4 auto(l4)  f        21    30 r     mids…\n#> 2 hyundai      sonata    3.3  2008     6 auto(l5)  f        19    28 r     mids…\n#> 3 hyundai      sonata    2.4  2008     4 manual(m… f        21    31 r     mids…\n#> 4 hyundai      tiburon   2    2008     4 auto(l4)  f        20    27 r     subc…\n#> 5 hyundai      tiburon   2.7  2008     6 auto(l4)  f        17    24 r     subc…\n#> 6 hyundai      tiburon   2    2008     4 manual(m… f        20    28 r     subc…\n#> 7 hyundai      tiburon   2.7  2008     6 manual(m… f        17    24 r     subc…\n#> 8 hyundai      tiburon   2.7  2008     6 manual(m… f        16    24 r     subc…"},{"path":"ch-dataTransformation.html","id":"desc를-이용하여-내림차순으로-정렬하기","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.6.1 desc()를 이용하여 내림차순으로 정렬하기","text":"앞의 예에서 arrange()는 수치 변수는 올림차순으로 문자 변수는 알파벳 순으로 정렬하는 것을 볼 수 있다. 만약 위의 예에서 내림차순으로, 또는 알파벳 역순으로 정렬을 하고 싶으면 어떻게 하여야 할까? dplyr 패키지는 desc()를 이용하면 된다.desc()가 적용된 변수만 내림차순을 기준으로 정렬을 하는 것을 볼 수 있다.","code":"\narrange(a, desc(cyl))#> # A tibble: 8 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      sonata    3.3  2008     6 auto(l5)  f        19    28 r     mids…\n#> 2 hyundai      tiburon   2.7  2008     6 auto(l4)  f        17    24 r     subc…\n#> 3 hyundai      tiburon   2.7  2008     6 manual(m… f        16    24 r     subc…\n#> 4 hyundai      tiburon   2.7  2008     6 manual(m… f        17    24 r     subc…\n#> 5 hyundai      sonata    2.4  2008     4 auto(l4)  f        21    30 r     mids…\n#> 6 hyundai      sonata    2.4  2008     4 manual(m… f        21    31 r     mids…\n#> 7 hyundai      tiburon   2    2008     4 manual(m… f        20    28 r     subc…\n#> 8 hyundai      tiburon   2    2008     4 auto(l4)  f        20    27 r     subc…\narrange(a, desc(cyl), cty)#> # A tibble: 8 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      tiburon   2.7  2008     6 manual(m… f        16    24 r     subc…\n#> 2 hyundai      tiburon   2.7  2008     6 auto(l4)  f        17    24 r     subc…\n#> 3 hyundai      tiburon   2.7  2008     6 manual(m… f        17    24 r     subc…\n#> 4 hyundai      sonata    3.3  2008     6 auto(l5)  f        19    28 r     mids…\n#> 5 hyundai      tiburon   2    2008     4 manual(m… f        20    28 r     subc…\n#> 6 hyundai      tiburon   2    2008     4 auto(l4)  f        20    27 r     subc…\n#> 7 hyundai      sonata    2.4  2008     4 auto(l4)  f        21    30 r     mids…\n#> 8 hyundai      sonata    2.4  2008     4 manual(m… f        21    31 r     mids…\narrange(a, model, desc(trans))#> # A tibble: 8 × 11\n#>   manufacturer model   displ  year   cyl trans     drv     cty   hwy fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <int> <int> <chr> <chr>\n#> 1 hyundai      sonata    2.4  2008     4 manual(m… f        21    31 r     mids…\n#> 2 hyundai      sonata    3.3  2008     6 auto(l5)  f        19    28 r     mids…\n#> 3 hyundai      sonata    2.4  2008     4 auto(l4)  f        21    30 r     mids…\n#> 4 hyundai      tiburon   2.7  2008     6 manual(m… f        16    24 r     subc…\n#> 5 hyundai      tiburon   2    2008     4 manual(m… f        20    28 r     subc…\n#> 6 hyundai      tiburon   2.7  2008     6 manual(m… f        17    24 r     subc…\n#> 7 hyundai      tiburon   2    2008     4 auto(l4)  f        20    27 r     subc…\n#> 8 hyundai      tiburon   2.7  2008     6 auto(l4)  f        17    24 r     subc…"},{"path":"ch-dataTransformation.html","id":"sec-select","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.7 select()를 이용하여 변수 이름으로 열 선택하기","text":"","code":""},{"path":"ch-dataTransformation.html","id":"변수-이름을-나열하여-선택하기","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.7.1 변수 이름을 나열하여 선택하기","text":"select() 함수는 다음처럼 변수 이름을 일일이 나열하여 원하는 열을 선택할 수 있다. R의 기본 문법을 알고 있는 사람들은 데이터 프레임의 인덱싱에서처럼 문자열로 이름을 나열하는 것이 아니라 변수를 사용하듯 따옴표 없이 이름을 나열하는 것에 주의한다.","code":"select(데이터프레임, 변수이름1, 변수이름 2, ....)\nselect(a, model, year, cty, hwy)#> # A tibble: 8 × 4\n#>   model    year   cty   hwy\n#>   <chr>   <int> <int> <int>\n#> 1 sonata   2008    21    30\n#> 2 sonata   2008    21    31\n#> 3 sonata   2008    19    28\n#> 4 tiburon  2008    20    28\n#> 5 tiburon  2008    20    27\n#> 6 tiburon  2008    17    24\n#> 7 tiburon  2008    16    24\n#> 8 tiburon  2008    17    24"},{"path":"ch-dataTransformation.html","id":"변수-이름으로-변수-범위를-선택하기","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.7.2 변수 이름으로 변수 범위를 선택하기","text":"select() 함수는 다음처럼 변수 이름으로 선택할 변수의 범위를 지정할 수 있다.반대로 다음처럼 변수 이름으로 선택하지 않을 변수의 범위를 지정할 수 있다.","code":"select(데이터프레임, 범위시작_변수이름:범위종료_변수이름, ...)\nselect(a, model:trans)#> # A tibble: 8 × 5\n#>   model   displ  year   cyl trans     \n#>   <chr>   <dbl> <int> <int> <chr>     \n#> 1 sonata    2.4  2008     4 auto(l4)  \n#> 2 sonata    2.4  2008     4 manual(m5)\n#> 3 sonata    3.3  2008     6 auto(l5)  \n#> 4 tiburon   2    2008     4 manual(m5)\n#> 5 tiburon   2    2008     4 auto(l4)  \n#> 6 tiburon   2.7  2008     6 auto(l4)  \n#> 7 tiburon   2.7  2008     6 manual(m6)\n#> 8 tiburon   2.7  2008     6 manual(m5)\nselect(a, model:trans, cty:hwy)#> # A tibble: 8 × 7\n#>   model   displ  year   cyl trans        cty   hwy\n#>   <chr>   <dbl> <int> <int> <chr>      <int> <int>\n#> 1 sonata    2.4  2008     4 auto(l4)      21    30\n#> 2 sonata    2.4  2008     4 manual(m5)    21    31\n#> 3 sonata    3.3  2008     6 auto(l5)      19    28\n#> 4 tiburon   2    2008     4 manual(m5)    20    28\n#> 5 tiburon   2    2008     4 auto(l4)      20    27\n#> 6 tiburon   2.7  2008     6 auto(l4)      17    24\n#> 7 tiburon   2.7  2008     6 manual(m6)    16    24\n#> 8 tiburon   2.7  2008     6 manual(m5)    17    24select(데이터프레임, -(범위시작_변수이름:범위종료_변수이름), ...)\nselect(a, -(model:trans))#> # A tibble: 8 × 6\n#>   manufacturer drv     cty   hwy fl    class     \n#>   <chr>        <chr> <int> <int> <chr> <chr>     \n#> 1 hyundai      f        21    30 r     midsize   \n#> 2 hyundai      f        21    31 r     midsize   \n#> 3 hyundai      f        19    28 r     midsize   \n#> 4 hyundai      f        20    28 r     subcompact\n#> 5 hyundai      f        20    27 r     subcompact\n#> 6 hyundai      f        17    24 r     subcompact\n#> 7 hyundai      f        16    24 r     subcompact\n#> 8 hyundai      f        17    24 r     subcompact\nselect(a, -(model:trans), -manufacturer)#> # A tibble: 8 × 5\n#>   drv     cty   hwy fl    class     \n#>   <chr> <int> <int> <chr> <chr>     \n#> 1 f        21    30 r     midsize   \n#> 2 f        21    31 r     midsize   \n#> 3 f        19    28 r     midsize   \n#> 4 f        20    28 r     subcompact\n#> 5 f        20    27 r     subcompact\n#> 6 f        17    24 r     subcompact\n#> 7 f        16    24 r     subcompact\n#> 8 f        17    24 r     subcompact"},{"path":"ch-dataTransformation.html","id":"변수-위치로-매칭하여-선택하기","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.7.3 변수 위치로 매칭하여 선택하기","text":"select() 함수는 R의 기본 인덱싱(필터링)처럼 선택할 열의 위치를 자연수 인덱스 벡터로, 선택하지 않을 열은 음의 정수 인덱스 벡터로 지정할 수도 있다.","code":"\nselect(a, 1:3) # 1 번부터 3번 열 선택#> # A tibble: 8 × 3\n#>   manufacturer model   displ\n#>   <chr>        <chr>   <dbl>\n#> 1 hyundai      sonata    2.4\n#> 2 hyundai      sonata    2.4\n#> 3 hyundai      sonata    3.3\n#> 4 hyundai      tiburon   2  \n#> 5 hyundai      tiburon   2  \n#> 6 hyundai      tiburon   2.7\n#> 7 hyundai      tiburon   2.7\n#> 8 hyundai      tiburon   2.7\nselect(a, 1:3, 5) # 1 번부터 3번 열과 5 번 열 선택#> # A tibble: 8 × 4\n#>   manufacturer model   displ   cyl\n#>   <chr>        <chr>   <dbl> <int>\n#> 1 hyundai      sonata    2.4     4\n#> 2 hyundai      sonata    2.4     4\n#> 3 hyundai      sonata    3.3     6\n#> 4 hyundai      tiburon   2       4\n#> 5 hyundai      tiburon   2       4\n#> 6 hyundai      tiburon   2.7     6\n#> 7 hyundai      tiburon   2.7     6\n#> 8 hyundai      tiburon   2.7     6\nselect(a, -(4:10)) # 4 번부터 10 번 열 제외하고 선택#> # A tibble: 8 × 4\n#>   manufacturer model   displ class     \n#>   <chr>        <chr>   <dbl> <chr>     \n#> 1 hyundai      sonata    2.4 midsize   \n#> 2 hyundai      sonata    2.4 midsize   \n#> 3 hyundai      sonata    3.3 midsize   \n#> 4 hyundai      tiburon   2   subcompact\n#> 5 hyundai      tiburon   2   subcompact\n#> 6 hyundai      tiburon   2.7 subcompact\n#> 7 hyundai      tiburon   2.7 subcompact\n#> 8 hyundai      tiburon   2.7 subcompact"},{"path":"ch-dataTransformation.html","id":"변수-이름을-매칭하여-선택하기","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.7.4 변수 이름을 매칭하여 선택하기","text":"dplyr 패키지는 다양한 형태로 변수를 선택할 수 있도록 다음의 변수 이름 매칭 함수를 제공한다.\n이러한 함수는 변수의 수가 많을 때 매우 유용하다.starts_with(\"abs\"): abc로 이름이 시작하는 모든 변수ends_with(\"abs\"): abc로 이름이 끝나는 모든 변수contains(\"abs\"): abc를 이름에 포함하고 있는 모든 변수matches(\"(.)\\\\1\"): 정규 표현식을 만족하는 이름을 가진 모든 변수num_range(\"x\", 1:3): “x1”, “x2”, “x3”이라는 이름의 변수","code":"\nselect(a, starts_with(\"c\"))#> # A tibble: 8 × 3\n#>     cyl   cty class     \n#>   <int> <int> <chr>     \n#> 1     4    21 midsize   \n#> 2     4    21 midsize   \n#> 3     6    19 midsize   \n#> 4     4    20 subcompact\n#> 5     4    20 subcompact\n#> 6     6    17 subcompact\n#> 7     6    16 subcompact\n#> 8     6    17 subcompact"},{"path":"ch-dataTransformation.html","id":"변수의-형식이나-조건으로-매칭하여-선택하기","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.7.5 변수의 형식이나 조건으로 매칭하여 선택하기*","text":"select() 함수에 () 함수를 사용하면 해당 조건에 맞는 열만 매칭하여 선택할 수 있다.\n() 함수는 유일한 인수로 함수를 입력받는데, 이 함수는 논리값을 반환하는 함수여야 하며, () 함수는 각 열에 이 함수를 적용한다.\nselect() 함수는 ()의 결과가 TRUE인 열만 선택한다.() 함수가 주로 사용되는 곳은 데이터 형식에 따라 열을 선택할 때이다.\n.로 시작하는 함수들은 어떤 객체가 특정 형식인지를 테스트 한다.\n다음 예는 ()와 .character() 함수를 사용하여 문자열인 열만 선택한 것이다.다음 예는 무기명 함수를 이용하여 열이 수치 벡터이고, 열의 평균이 10 이상인 열만 출력한 것이다.또는 다음처럼 purr 형식의 수식으로 무기명 함수를 좀 더 간략하게 정의할 수도 있다.","code":"\nselect(a, where(is.character))#> # A tibble: 8 × 6\n#>   manufacturer model   trans      drv   fl    class     \n#>   <chr>        <chr>   <chr>      <chr> <chr> <chr>     \n#> 1 hyundai      sonata  auto(l4)   f     r     midsize   \n#> 2 hyundai      sonata  manual(m5) f     r     midsize   \n#> 3 hyundai      sonata  auto(l5)   f     r     midsize   \n#> 4 hyundai      tiburon manual(m5) f     r     subcompact\n#> 5 hyundai      tiburon auto(l4)   f     r     subcompact\n#> 6 hyundai      tiburon auto(l4)   f     r     subcompact\n#> 7 hyundai      tiburon manual(m6) f     r     subcompact\n#> 8 hyundai      tiburon manual(m5) f     r     subcompact\nselect(a, where(function(x) is.numeric(x) && mean(x) >= 10))#> # A tibble: 8 × 3\n#>    year   cty   hwy\n#>   <int> <int> <int>\n#> 1  2008    21    30\n#> 2  2008    21    31\n#> 3  2008    19    28\n#> 4  2008    20    28\n#> 5  2008    20    27\n#> 6  2008    17    24\n#> 7  2008    16    24\n#> 8  2008    17    24\nselect(a, where(~ is.numeric(.x) && mean(.x) < 10))#> # A tibble: 8 × 2\n#>   displ   cyl\n#>   <dbl> <int>\n#> 1   2.4     4\n#> 2   2.4     4\n#> 3   3.3     6\n#> 4   2       4\n#> 5   2       4\n#> 6   2.7     6\n#> 7   2.7     6\n#> 8   2.7     6"},{"path":"ch-dataTransformation.html","id":"변수-이름-바꾸기","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.7.6 변수 이름 바꾸기","text":"select() 함수에서 변수 이름을 지정할 때, (새로운 변수 이름)=(기존 변수 이름) 형식으로 지정하면 변수의 이름을 바꿀 수 있다.만약 전체 데이터를 유지한 상태에서 변수 이름만 변경하려면, rename() 함수를 이용한다. 문법은 select()와 같다.","code":"\nselect(a, model, city=cty, highway=hwy)#> # A tibble: 8 × 3\n#>   model    city highway\n#>   <chr>   <int>   <int>\n#> 1 sonata     21      30\n#> 2 sonata     21      31\n#> 3 sonata     19      28\n#> 4 tiburon    20      28\n#> 5 tiburon    20      27\n#> 6 tiburon    17      24\n#> 7 tiburon    16      24\n#> 8 tiburon    17      24\nrename(a, city=cty, highway=hwy)#> # A tibble: 8 × 11\n#>   manufacturer model   displ  year   cyl trans   drv    city highway fl    class\n#>   <chr>        <chr>   <dbl> <int> <int> <chr>   <chr> <int>   <int> <chr> <chr>\n#> 1 hyundai      sonata    2.4  2008     4 auto(l… f        21      30 r     mids…\n#> 2 hyundai      sonata    2.4  2008     4 manual… f        21      31 r     mids…\n#> 3 hyundai      sonata    3.3  2008     6 auto(l… f        19      28 r     mids…\n#> 4 hyundai      tiburon   2    2008     4 manual… f        20      28 r     subc…\n#> 5 hyundai      tiburon   2    2008     4 auto(l… f        20      27 r     subc…\n#> 6 hyundai      tiburon   2.7  2008     6 auto(l… f        17      24 r     subc…\n#> 7 hyundai      tiburon   2.7  2008     6 manual… f        16      24 r     subc…\n#> 8 hyundai      tiburon   2.7  2008     6 manual… f        17      24 r     subc…"},{"path":"ch-dataTransformation.html","id":"변수-순서-바꾸기","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.7.7 변수 순서 바꾸기","text":"select() 함수는 나열된 변수의 순서에 따라 새롭게 만들어진 데이터 프레임의 변수의 순서를 조정한다.이러한 성질과 everything() 함수를 이용하면 변수의 순서를 쉽게 바꿀 수 있다. everything()은 이미 선택된 변수를 제외한 나머지 변수를 의미한다.","code":"\nselect(a, cty, hwy)#> # A tibble: 8 × 2\n#>     cty   hwy\n#>   <int> <int>\n#> 1    21    30\n#> 2    21    31\n#> 3    19    28\n#> 4    20    28\n#> 5    20    27\n#> 6    17    24\n#> 7    16    24\n#> 8    17    24\nselect(a, hwy, cty)#> # A tibble: 8 × 2\n#>     hwy   cty\n#>   <int> <int>\n#> 1    30    21\n#> 2    31    21\n#> 3    28    19\n#> 4    28    20\n#> 5    27    20\n#> 6    24    17\n#> 7    24    16\n#> 8    24    17\nselect(a, cty, hwy, everything())#> # A tibble: 8 × 11\n#>     cty   hwy manufacturer model   displ  year   cyl trans     drv   fl    class\n#>   <int> <int> <chr>        <chr>   <dbl> <int> <int> <chr>     <chr> <chr> <chr>\n#> 1    21    30 hyundai      sonata    2.4  2008     4 auto(l4)  f     r     mids…\n#> 2    21    31 hyundai      sonata    2.4  2008     4 manual(m… f     r     mids…\n#> 3    19    28 hyundai      sonata    3.3  2008     6 auto(l5)  f     r     mids…\n#> 4    20    28 hyundai      tiburon   2    2008     4 manual(m… f     r     subc…\n#> 5    20    27 hyundai      tiburon   2    2008     4 auto(l4)  f     r     subc…\n#> 6    17    24 hyundai      tiburon   2.7  2008     6 auto(l4)  f     r     subc…\n#> 7    16    24 hyundai      tiburon   2.7  2008     6 manual(m… f     r     subc…\n#> 8    17    24 hyundai      tiburon   2.7  2008     6 manual(m… f     r     subc…"},{"path":"ch-dataTransformation.html","id":"sec-mutate","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.8 mutate()로 새로운 변수 만들기","text":"mutate()는 기존 변수를 이용하여 새로운 변수를 만들어 데이터 프레임의 가장 마지막 열로 추가한다.다음은 도심 연비와 고속도로 연비의 합과, 평균, 그리고 고속도로 대비 도심 연비의 비율(%)을 계산하여 새로운 열을 만든 예이다.","code":"mutate(데이터프레임, 새로운_변수=기존_변수_연산식, ....)\nb <- select(a, -(cyl:drv), -(fl:class))\nb#> # A tibble: 8 × 6\n#>   manufacturer model   displ  year   cty   hwy\n#>   <chr>        <chr>   <dbl> <int> <int> <int>\n#> 1 hyundai      sonata    2.4  2008    21    30\n#> 2 hyundai      sonata    2.4  2008    21    31\n#> 3 hyundai      sonata    3.3  2008    19    28\n#> 4 hyundai      tiburon   2    2008    20    28\n#> 5 hyundai      tiburon   2    2008    20    27\n#> 6 hyundai      tiburon   2.7  2008    17    24\n#> 7 hyundai      tiburon   2.7  2008    16    24\n#> 8 hyundai      tiburon   2.7  2008    17    24\nmutate(b, sum=cty + hwy)#> # A tibble: 8 × 7\n#>   manufacturer model   displ  year   cty   hwy   sum\n#>   <chr>        <chr>   <dbl> <int> <int> <int> <int>\n#> 1 hyundai      sonata    2.4  2008    21    30    51\n#> 2 hyundai      sonata    2.4  2008    21    31    52\n#> 3 hyundai      sonata    3.3  2008    19    28    47\n#> 4 hyundai      tiburon   2    2008    20    28    48\n#> 5 hyundai      tiburon   2    2008    20    27    47\n#> 6 hyundai      tiburon   2.7  2008    17    24    41\n#> 7 hyundai      tiburon   2.7  2008    16    24    40\n#> 8 hyundai      tiburon   2.7  2008    17    24    41\nmutate(b, \n       sum=cty + hwy, \n       mean=(cty + hwy) / 2,\n       ratio= cty / hwy * 100)#> # A tibble: 8 × 9\n#>   manufacturer model   displ  year   cty   hwy   sum  mean ratio\n#>   <chr>        <chr>   <dbl> <int> <int> <int> <int> <dbl> <dbl>\n#> 1 hyundai      sonata    2.4  2008    21    30    51  25.5  70  \n#> 2 hyundai      sonata    2.4  2008    21    31    52  26    67.7\n#> 3 hyundai      sonata    3.3  2008    19    28    47  23.5  67.9\n#> 4 hyundai      tiburon   2    2008    20    28    48  24    71.4\n#> 5 hyundai      tiburon   2    2008    20    27    47  23.5  74.1\n#> 6 hyundai      tiburon   2.7  2008    17    24    41  20.5  70.8\n#> 7 hyundai      tiburon   2.7  2008    16    24    40  20    66.7\n#> 8 hyundai      tiburon   2.7  2008    17    24    41  20.5  70.8"},{"path":"ch-dataTransformation.html","id":"transmute로-새로운-변수만-남기기","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.8.1 transmute()로 새로운 변수만 남기기","text":"만약 새롭게 만들어진 변수만 데이터에 남기려면 mutate() 대신 transmute()를 사용한다. 문법은 두 함수가 동일하다.","code":"\ntransmute(b, \n       sum=cty + hwy, \n       mean=(cty + hwy) / 2,\n       ratio= cty / hwy * 100)#> # A tibble: 8 × 3\n#>     sum  mean ratio\n#>   <int> <dbl> <dbl>\n#> 1    51  25.5  70  \n#> 2    52  26    67.7\n#> 3    47  23.5  67.9\n#> 4    48  24    71.4\n#> 5    47  23.5  74.1\n#> 6    41  20.5  70.8\n#> 7    40  20    66.7\n#> 8    41  20.5  70.8"},{"path":"ch-dataTransformation.html","id":"새로운-변수를-만들-때-사용할-수-있는-함수들","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.8.2 새로운 변수를 만들 때 사용할 수 있는 함수들","text":"새로운 변수를 생성할 때, 기존 변수와 관련된 수치, 논리, 문자열 연산을 수행할 수 있다. 다음처럼 제조사와 모델을 하나로 합쳐서 새로운 변수를 만들수도 있고, 배기량이 3 이상인지 여부를 나타내는 변수도 만들 수 있다.아울러 다음 함수가 새로운 변수를 만들 때 자주 사용된다.row_number(): 각 행의 행번호. 각 행에 일련번호를 붙일 때 유용.lead(): 기존 변수를 한 행, 또는 여러 행 빠르게 시작하는 변수lag(): 기존 변수를 한 행, 또는 여러 행 늦게 시작하는 변수cumsum(), cummean(): 누적 합과 평균min_rank(): 가장 작은 것부터 차례대로 크기 순서로 등수를 매기는 함수. desc() 함수를 변수에 적용한 후 등수를 매기면 가장 큰 것부터 순서를 매길 수 있다.dense_rank(), percent_rank(), cume_dist(), ntile() 등도 사용될 수 있다. 자세한 내용은 도움말을 참조하기 바란다.다음의 가상의 상점의 월별 매출 데이터를 사용하여 위에서 설명한 함수의 기능을 살펴보자.다음은 앞의 예에서 만든 b라는 데이터프레임에 일련번호를 사용하여 id라는 열을 추가한 사례이다.","code":"\nmutate(b, newName=paste(manufacturer, model, sep=\"-\"), dis3=displ >= 3)#> # A tibble: 8 × 8\n#>   manufacturer model   displ  year   cty   hwy newName         dis3 \n#>   <chr>        <chr>   <dbl> <int> <int> <int> <chr>           <lgl>\n#> 1 hyundai      sonata    2.4  2008    21    30 hyundai-sonata  FALSE\n#> 2 hyundai      sonata    2.4  2008    21    31 hyundai-sonata  FALSE\n#> 3 hyundai      sonata    3.3  2008    19    28 hyundai-sonata  TRUE \n#> 4 hyundai      tiburon   2    2008    20    28 hyundai-tiburon FALSE\n#> 5 hyundai      tiburon   2    2008    20    27 hyundai-tiburon FALSE\n#> 6 hyundai      tiburon   2.7  2008    17    24 hyundai-tiburon FALSE\n#> 7 hyundai      tiburon   2.7  2008    16    24 hyundai-tiburon FALSE\n#> 8 hyundai      tiburon   2.7  2008    17    24 hyundai-tiburon FALSE\nstore <- data.frame(month=1:6, sales=c(23, 45, 34, 67, 30, 41))\nstore#>   month sales\n#> 1     1    23\n#> 2     2    45\n#> 3     3    34\n#> 4     4    67\n#> 5     5    30\n#> 6     6    41\nmutate(store,\n       before = lag(sales, n = 1),   # 1 달 전 판매량  \n       after = lead(sales, n = 1),   # 1 달 후 판매량  \n       total = cumsum(sales),        # 누적 판매량\n       mean = cummean(sales),        # 누적 평균 판매량\n       rank1 = min_rank(sales),   # 판매량 순위 (올림차순)\n       rank2 = min_rank(desc(sales))   # 판매량 순위 (내림차순)\n       )#>   month sales before after total  mean rank1 rank2\n#> 1     1    23     NA    45    23 23.00     1     6\n#> 2     2    45     23    34    68 34.00     5     2\n#> 3     3    34     45    67   102 34.00     3     4\n#> 4     4    67     34    30   169 42.25     6     1\n#> 5     5    30     67    41   199 39.80     2     5\n#> 6     6    41     30    NA   240 40.00     4     3\nmutate(b, id = row_number())#> # A tibble: 8 × 7\n#>   manufacturer model   displ  year   cty   hwy    id\n#>   <chr>        <chr>   <dbl> <int> <int> <int> <int>\n#> 1 hyundai      sonata    2.4  2008    21    30     1\n#> 2 hyundai      sonata    2.4  2008    21    31     2\n#> 3 hyundai      sonata    3.3  2008    19    28     3\n#> 4 hyundai      tiburon   2    2008    20    28     4\n#> 5 hyundai      tiburon   2    2008    20    27     5\n#> 6 hyundai      tiburon   2.7  2008    17    24     6\n#> 7 hyundai      tiburon   2.7  2008    16    24     7\n#> 8 hyundai      tiburon   2.7  2008    17    24     8"},{"path":"ch-dataTransformation.html","id":"sec-summarize","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.9 summarize()로 변수 요약하기","text":"summarize() 함수는 데이터프레임을 하나의 행으로 요약한다.\n하나의 행으로 요약하기 위하여 변수의 모든 값을 하나의 값으로 통계요약하는 함수를 주로 이용한다.\n대표적인 통계요약 함수는 다음과 같다.n(): 행의 수를 구한다.sum(): 수치 변수의 합을 구한다.mean(): 수치 변수의 균을 구한다.median(): 수치 변수의 중위수를 구한다.sd(): 수치 변수의 표준편차를 구한다.var(): 수치 변수의 분산을 구한다.min(): 수치 변수의 최소값을 구한다.max(): 수치 변수의 최대값을 구한다.quantile(변수, probs):  수치 변수의probs` 분위수를 구한다.다음은 도심 연비의 데이터 수, 평균, 중위수, 최소값, 최대값을 구한 결과이다.다음처럼 여러 변수에 대하여 통계 요약할 수도 있다.","code":"summarize(데이터프레임, 요약변수이름=요약함수(변수), ....)\nsummarize(b, count=n(), mean=mean(cty), med=median(cty), \n          min=min(cty), max=max(cty))#> # A tibble: 1 × 5\n#>   count  mean   med   min   max\n#>   <int> <dbl> <dbl> <int> <int>\n#> 1     8  18.9  19.5    16    21\nsummarize(b, meanCty=mean(cty), meanHwy=mean(hwy),\n          medianCty=median(cty), medianHqy=median(hwy))#> # A tibble: 1 × 4\n#>   meanCty meanHwy medianCty medianHqy\n#>     <dbl>   <dbl>     <dbl>     <dbl>\n#> 1    18.9      27      19.5      27.5"},{"path":"ch-dataTransformation.html","id":"across로-여려-변수를-요약하기","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.9.1 across()로 여려 변수를 요약하기*","text":"앞의 예에서 우리는 도심 연비와 고속도로 연비 열에 대해 동일한 통계요약 함수를 적용하였다.\n동일한 통계요약 함수를 적용할 열이 한두 개이면 앞의 예처럼 일일이 기술해주면 되지만, 적용해야 할 열이 많아지면 이를 일일이 기술하는 것은 번잡할 뿐만 아니라 오류의 발생 가능성을 높이고 나중에 코드를 변경하기 어렵게 만든다.across() 함수는 select()처럼 열을 선택하여 동일한 함수를 적용할 수 있게 해준다.\nacross() 함수는 두 개의 주요 인수를 가지고 있다.첫 번째 인수는 .cols로 함수를 적용할 열을 지정한다. 열의 지정은 select() 함수처럼 변수 이름, 위치, 형식으로 지정할 수 있다.두 번재 인수는 .fns로 열에 적용할 함수를 지정한다.across() 함수는 summarize() 함수와 함께 자주 사용되는데 다음처럼 사용된다.여러 함수를 함께 적용하려면 함수를 리스트로 묶어서 .fns 인수로 전달한다.\n이 때 리스트의 요소의 이름을 부여하면 열이름과 해당 요소의 이름으로 결과 열의 이름이 생성된다.결과 열의 이름을 다른 형태로 지정하고 싶으면 .name 인수에 원하는 형식을 함수 이름을 나타내는 {.fn}과 열의 이름을 나타내는 {.col}을 사용하여 설정할 수 있다.\n다음은 함수 이름 후에 -가 나온 후 열 이름이 나오도록 한 것이다.만약 지금처럼 적용되는 열을 기준으로 정렬되는 것이 아니라 함수 별로 정렬되어 결과가 나오게 하고 싶으면, across() 함수를 각 함수 별로 적용을 한다. 이 때 서로 열 이름이 충돌이 나지 않도록 .names 인수를 설정해 준다.다음 예는 모든 수치 열에 대하여 표준편차를 구한 것이다.","code":"\nsummarize(b, across(c(cty, hwy), mean))#> # A tibble: 1 × 2\n#>     cty   hwy\n#>   <dbl> <dbl>\n#> 1  18.9    27\nsummarize(b, across(c(cty, hwy), list(mean=mean, med=median)))#> # A tibble: 1 × 4\n#>   cty_mean cty_med hwy_mean hwy_med\n#>      <dbl>   <dbl>    <dbl>   <dbl>\n#> 1     18.9    19.5       27    27.5\nsummarize(b, \n  across(c(cty, hwy), list(mean=mean, med=median), .names=\"{.fn}-{.col}\"))#> # A tibble: 1 × 4\n#>   `mean-cty` `med-cty` `mean-hwy` `med-hwy`\n#>        <dbl>     <dbl>      <dbl>     <dbl>\n#> 1       18.9      19.5         27      27.5\nsummarize(b, across(c(cty, hwy), mean, .names=\"mean-{.col}\"),\n    across(c(cty, hwy), median, .names=\"med-{.col}\"))#> # A tibble: 1 × 4\n#>   `mean-cty` `mean-hwy` `med-cty` `med-hwy`\n#>        <dbl>      <dbl>     <dbl>     <dbl>\n#> 1       18.9         27      19.5      27.5\nsummarize(b, across(where(is.numeric), sd))#> # A tibble: 1 × 4\n#>   displ  year   cty   hwy\n#>   <dbl> <dbl> <dbl> <dbl>\n#> 1 0.427     0  1.96  2.78"},{"path":"ch-dataTransformation.html","id":"sec-groupBy","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.10 group_by()로 그룹별로 요약하기","text":"group_by() 함수는 기준이 되는 변수의 구분되는 값에 따라 데이터를 그룹화한다. 그룹화된 결과를 summarize() 함수에 전달하면 그룹별로 요약된 결과를 출력한다.그룹화된 결과를 출력해 보면, 원 데이터인 b와 같아보이는데, 출력시 model 변수로 그룹화 되어 있다는 것이 같이 출력된다.변수를 여러 개를 조합하여 그룹화를 할 수도 있다.여러 변수로 그룹화를 하면 summarize() 함수는 그룹별로 하나의 행만 생성이 되었으면 결과에서 마지막 그룹을 제거한다.\n위의 결과에서는 model과 cyl의 값의 조합에 대하여 하나의 행만 생성되었으므로, 마지막 그룹 변수인 cyl와 관련된 그룹은 사라지고, model과 관련된 그룹만 남는다.\n출력된 결과와 메시지에서 이를 확인할 수 있다.\nsummarize() 함수의 .groups 인수를 사용하면 summarize() 후에 그룹을 유지할지, 모두 없앨지 등을 조정할 수 있다. 관심있는 독자는 summarize() 함수의 도움말을 참조하기 바란다.","code":"group_by(데이터프레임, 그룹기준변수1, 그룹기준변수2, ...)\nbyModel <- group_by(b, model)\nsummarize(byModel, count=n(), mean=mean(cty), sd=sd(cty))#> # A tibble: 2 × 4\n#>   model   count  mean    sd\n#>   <chr>   <int> <dbl> <dbl>\n#> 1 sonata      3  20.3  1.15\n#> 2 tiburon     5  18    1.87\nbyModel#> # A tibble: 8 × 6\n#> # Groups:   model [2]\n#>   manufacturer model   displ  year   cty   hwy\n#>   <chr>        <chr>   <dbl> <int> <int> <int>\n#> 1 hyundai      sonata    2.4  2008    21    30\n#> 2 hyundai      sonata    2.4  2008    21    31\n#> 3 hyundai      sonata    3.3  2008    19    28\n#> 4 hyundai      tiburon   2    2008    20    28\n#> 5 hyundai      tiburon   2    2008    20    27\n#> 6 hyundai      tiburon   2.7  2008    17    24\n#> 7 hyundai      tiburon   2.7  2008    16    24\n#> 8 hyundai      tiburon   2.7  2008    17    24\nbyModel <- group_by(a, model, cyl)\nsummarize(byModel, count=n(), mean=mean(cty))#> `summarise()` has grouped output by 'model'. You can override using the\n#> `.groups` argument.#> # A tibble: 4 × 4\n#> # Groups:   model [2]\n#>   model     cyl count  mean\n#>   <chr>   <int> <int> <dbl>\n#> 1 sonata      4     2  21  \n#> 2 sonata      6     1  19  \n#> 3 tiburon     4     2  20  \n#> 4 tiburon     6     3  16.7"},{"path":"ch-dataTransformation.html","id":"group_by로-그룹별로-새-변수-추가하기","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.10.1 group_by()로 그룹별로 새 변수 추가하기","text":"group_by()는 summarize()와 함께 자주 사용되지만, mutate()나 filter() 등의 다른 dplyr 함수와 함께 사용될 수 있다.다음은 mutate()로 전체 대이터에 대하여 고속도로 연비 순으로 순위를 매기는 것과, group_bu()와 함께 사용하여 모델별로 고속도로 연비의 순위를 매긴 것을 비교하여 보여 주고 있다.","code":"\nmutate(b, rank=min_rank(desc(hwy)))  # 전체 데이터에서 고속도로 연비 순위 매기기#> # A tibble: 8 × 7\n#>   manufacturer model   displ  year   cty   hwy  rank\n#>   <chr>        <chr>   <dbl> <int> <int> <int> <int>\n#> 1 hyundai      sonata    2.4  2008    21    30     2\n#> 2 hyundai      sonata    2.4  2008    21    31     1\n#> 3 hyundai      sonata    3.3  2008    19    28     3\n#> 4 hyundai      tiburon   2    2008    20    28     3\n#> 5 hyundai      tiburon   2    2008    20    27     5\n#> 6 hyundai      tiburon   2.7  2008    17    24     6\n#> 7 hyundai      tiburon   2.7  2008    16    24     6\n#> 8 hyundai      tiburon   2.7  2008    17    24     6\nmutate(byModel, rank=min_rank(desc(hwy)))  # 모델 별로 고속도로 연비 순위 매기기#> # A tibble: 8 × 12\n#> # Groups:   model, cyl [4]\n#>   manufacturer model displ  year   cyl trans drv     cty   hwy fl    class  rank\n#>   <chr>        <chr> <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr> <int>\n#> 1 hyundai      sona…   2.4  2008     4 auto… f        21    30 r     mids…     2\n#> 2 hyundai      sona…   2.4  2008     4 manu… f        21    31 r     mids…     1\n#> 3 hyundai      sona…   3.3  2008     6 auto… f        19    28 r     mids…     1\n#> 4 hyundai      tibu…   2    2008     4 manu… f        20    28 r     subc…     1\n#> 5 hyundai      tibu…   2    2008     4 auto… f        20    27 r     subc…     2\n#> 6 hyundai      tibu…   2.7  2008     6 auto… f        17    24 r     subc…     1\n#> 7 hyundai      tibu…   2.7  2008     6 manu… f        16    24 r     subc…     1\n#> 8 hyundai      tibu…   2.7  2008     6 manu… f        17    24 r     subc…     1"},{"path":"ch-dataTransformation.html","id":"count로-개수-세기","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.10.2 count()로 개수 세기","text":"앞의 예에서 모델 별로 데이터 개수만을 세려면 다음과 같은 명령어를 사용하면 된다.그런데 이렇게 특정 열을 기준으로 값의 빈도를 세는 작업은 매우 빈번히 수행되므로, count() 함수는 위에서 두 단계로 수행해야 하는 명령을 하나의 명령만으로 수행할 수 있게 해 준다.다음은 mpg 데이터에서class` 열의 각 값의 빈도를 센 결과이다.만약 빈도가 큰 값일수록 위에 표시되게 하려면 다음처럼 sort=TRUE 인수를 설정한다.count()는 하나의 열뿐만 아니라 여러 열을 사용하여 빈도를 계산할 수 있다. 다음은 class와 cyl의 값의 가능한 조합별로 빈도를 계산한 결과이다.이외에도 count() 함수는 빈도를 계산할 때, wt 인수를 사용하여 행의 개수로 빈도를 계산하는 것이 아니라 해당 행의 특정 열의 값의 합으로 빈도를 계산할 수도 있다.\n관심있는 독자는 count() 함수의 도움말을 찾아보기 바란다.","code":"\nbyModel <- group_by(b, model)\nsummarise(byModel, n=n())#> # A tibble: 2 × 2\n#>   model       n\n#>   <chr>   <int>\n#> 1 sonata      3\n#> 2 tiburon     5\ncount(b, model)#> # A tibble: 2 × 2\n#>   model       n\n#>   <chr>   <int>\n#> 1 sonata      3\n#> 2 tiburon     5\ncount(mpg, class)#> # A tibble: 7 × 2\n#>   class          n\n#>   <chr>      <int>\n#> 1 2seater        5\n#> 2 compact       47\n#> 3 midsize       41\n#> 4 minivan       11\n#> 5 pickup        33\n#> 6 subcompact    35\n#> 7 suv           62\ncount(mpg, class, sort=TRUE)#> # A tibble: 7 × 2\n#>   class          n\n#>   <chr>      <int>\n#> 1 suv           62\n#> 2 compact       47\n#> 3 midsize       41\n#> 4 subcompact    35\n#> 5 pickup        33\n#> 6 minivan       11\n#> 7 2seater        5\ncount(mpg, class, cyl, sort=T)#> # A tibble: 19 × 3\n#>    class        cyl     n\n#>    <chr>      <int> <int>\n#>  1 suv            8    38\n#>  2 compact        4    32\n#>  3 midsize        6    23\n#>  4 subcompact     4    21\n#>  5 pickup         8    20\n#>  6 midsize        4    16\n#>  7 suv            6    16\n#>  8 compact        6    13\n#>  9 minivan        6    10\n#> 10 pickup         6    10\n#> 11 suv            4     8\n#> 12 subcompact     6     7\n#> 13 2seater        8     5\n#> 14 subcompact     8     5\n#> 15 pickup         4     3\n#> 16 compact        5     2\n#> 17 midsize        8     2\n#> 18 subcompact     5     2\n#> 19 minivan        4     1"},{"path":"ch-dataTransformation.html","id":"sec-pipeOperator","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.11 %>% 파이프 연산자","text":"","code":""},{"path":"ch-dataTransformation.html","id":"여러-단계를-거쳐-데이터를-변환할-때","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.11.1 여러 단계를 거쳐 데이터를 변환할 때","text":"mpg 데이터에서 조사 연도와 모델 별로 데이터 수와 도심 연비의 평균을 구한 후, 평균이 22 이상인 모델로 이루어진 행을 추출하려고 한다. 이를 수행하려면 다음처럼 변수를 이용하여 결과를 차례로 전달하거나, 함수를 결합하여 한 문장에 사용하여야 한다.전자는 불피요하게 중간 결과를 저장할 변수를 만들어야 하고, 후자는 복잡하여 이 명령이 무엇을 하는 명령어인지 쉽게 파악하기 힘들다. 또한 중첩된 괄호 때문에 오류가 발생하기 쉽다.","code":"\nbyModel <- group_by(mpg, model, year)\nmeanCty <- summarize(byModel, count=n(), mean=mean(cty))#> `summarise()` has grouped output by 'model'. You can override using the\n#> `.groups` argument.\nfilter(meanCty, mean >= 22)#> # A tibble: 5 × 4\n#> # Groups:   model [3]\n#>   model       year count  mean\n#>   <chr>      <int> <int> <dbl>\n#> 1 civic       1999     5  24.8\n#> 2 civic       2008     4  24  \n#> 3 corolla     1999     3  24.7\n#> 4 corolla     2008     2  27  \n#> 5 new beetle  1999     4  26\nfilter(summarize(group_by(mpg, model, year), count=n(), mean=mean(cty)), mean >= 22)#> `summarise()` has grouped output by 'model'. You can override using the\n#> `.groups` argument.#> # A tibble: 5 × 4\n#> # Groups:   model [3]\n#>   model       year count  mean\n#>   <chr>      <int> <int> <dbl>\n#> 1 civic       1999     5  24.8\n#> 2 civic       2008     4  24  \n#> 3 corolla     1999     3  24.7\n#> 4 corolla     2008     2  27  \n#> 5 new beetle  1999     4  26"},{"path":"ch-dataTransformation.html","id":"파이프-연산자","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.11.2 파이프 연산자","text":"파이프 연산자는 데이터 변환이 여러 단계를 거칠 때 불필요한 변수의 생성 없이도 함수 간에 중간 데이터를 전달할 수 있게 해 준다.파이프 연산자는 앞의 함수의 결과를 뒤 함수의 첫 번째 인수로 전달해 준다. 파이프 연산자를 사용할 때는 그러므로 첫 번째 인수는 생략하여 기술한다.\n파이프 연산자로는 magrittr 패키지가 제공하는 %>% 연산자를 사용할 수도 있고, R 4.1.0 버전부터 도입된 기본 기능에 포함된 |> 연산자를 사용할 수도 있다.\n여기서는 R 버전이 낮은 사용자에게도 동일하게 적용될 수 있도록 %>% 연산자를 사용하도록 한다.\n이 연산자는 tidyverse 패키지를 적재하였으면 사용할 수 있다.다음은 앞의 예와 동일한 예를 파이프 연산자를 사용하여 수행한 결과이다.불필요하게 데이터를 기술하는 부분이 사라져서 각 단계에서 수행하는 작업이 무엇인지 명확하게 들어나고 불필요한 중간 변수를 만들지 않아도 되므로 파이프 연산자는 매우 편리하다.그런데 파이프 연산자를 사용하려면 앞의 함수의 결과가 뒤의 함수의 첫 인수로 사용하기 적절한 형태이어야 한다. dplyr 패키지의 주요 함수들은 정돈 데이터 형식으로 데이터의 결과를 반환하고, 첫 인수가 정돈 데이터 형식의 데이터로 간주한다.파이프 연산자를 사용할 때 주의할 점은 여러 줄로 명령을 기술할 때, 파이프 연산자로 중간 문장이 종료되어야 한다는 것이다. 그래야 아직 문장이 완료되지 않았다는 것을 이해하여 다음 단계의 명령이 입력되기를 기다린다. 다음처럼 기술하면 R은 명령 입력이 중간에 완료된 것으로 보고 잘못된 결과를 출력한다.%>% 연산자 이외에도 연산 결과를 출력도 하고 결과를 반환하고 싶을 때 사용하는 %T>% 연산자, 입력된 객체에 결과를 재할당하고 싶을 때 사용하는 %<>% 연산자 등도 있으니 관심있는 독자는 도움말을 살펴보기 바란다.","code":"\nmpg %>% group_by(model, year) %>% \n  summarize(count=n(), mean=mean(cty)) %>%\n  filter(mean >= 22)#> `summarise()` has grouped output by 'model'. You can override using the\n#> `.groups` argument.#> # A tibble: 5 × 4\n#> # Groups:   model [3]\n#>   model       year count  mean\n#>   <chr>      <int> <int> <dbl>\n#> 1 civic       1999     5  24.8\n#> 2 civic       2008     4  24  \n#> 3 corolla     1999     3  24.7\n#> 4 corolla     2008     2  27  \n#> 5 new beetle  1999     4  26b %>% group_by(model) %>% \n  summarize(count=n(), mean=mean(cty)) \n  %>% filter(mean >= 20)#> Error: <text>:3:3: 예기치 않은 SPECIAL입니다\n#> 2:   summarize(count=n(), mean=mean(cty)) \n#> 3:   %>%\n#>      ^"},{"path":"ch-dataTransformation.html","id":"ungroup","chapter":"7 dplyr을 이용한 데이터 변환","heading":"7.11.3 ungroup()","text":"파이프 연산자를 사용하여 데이터를 전달하다 보면 데이터가 그룹화 된 것을 중간 단계에서 해제하고 싶을 때가 있다. 이 경우에는 ungroup() 명령을 사용한다.","code":"\nbyModel <- b %>% group_by(model) \nbyModel %>% summarize(count=n())#> # A tibble: 2 × 2\n#>   model   count\n#>   <chr>   <int>\n#> 1 sonata      3\n#> 2 tiburon     5\nbyModel %>% ungroup() %>% summarize(count=n())#> # A tibble: 1 × 1\n#>   count\n#>   <int>\n#> 1     8"},{"path":"ch-visualization.html","id":"ch-visualization","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8 ggplot2를 이용한 데이터 시각화","text":"이 장에서는 ggplot2를 이용하여 데이터를 시각화하는 방법을 배운다. ggplot2 패키지는 tidyverse 패키지를 설치하였으면 자동으로 설치된다. 그리고 tidyverse 패키지를 적재하면 ggplot2 패키지도 자동 적재된다.","code":"\nlibrary(tidyverse)#> ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n#> ✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n#> ✔ tibble  3.1.8      ✔ dplyr   1.0.10\n#> ✔ tidyr   1.2.1      ✔ stringr 1.5.0 \n#> ✔ readr   2.1.3      ✔ forcats 0.5.2 \n#> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n#> ✖ dplyr::filter() masks stats::filter()\n#> ✖ dplyr::lag()    masks stats::lag()"},{"path":"ch-visualization.html","id":"sec-getStarted-ggplot2","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.1 ggplot2 시작하기","text":"이 절에서는 ggplot2에서 제공하는 mpg 데이터를 이용하여 ‘배기량이 커지면 연비가 낮아지는가?’ 라는 물음을 그래프를 이용하여 탐색해 보자.\nmpg는 1999년과 2008년에 미국 EPA에서 조사하여 발표한 자동차 주요 모델별 연비 데이터이다.\nmpg 데이터에 대한 자세한 설명은 7.3 절의 mpg 데이터에 대한 설명이나 R 도움말을 참조하기 바란다.","code":""},{"path":"ch-visualization.html","id":"subsec-tryGgplot","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.1.1 ggplot2 그래프 그려보기","text":"mpg 데이터로부터 배기량(displ)을 x 축으로, 고속도로 연비(hwy)를 y 축으로 하는 산점도를 그려보자.산점도에서 배기량이 커짐지면 연비가 줄어드는 경향을 관찰할 수 있다. 이 산점도를 그린 R 명령어는 두 개의 함수가 결합하여 실행되었다.ggplot(): ggplot2 그래프의 좌표축과 좌표평면을 만드는 함수이다. 뒤에서 살펴보겠지만 그래프에 공통된 데이터와 매핑을 설정할 수 있다.geom_point(): ggplot() 함수가 만들어 놓은 좌표평면 위에, 점이라는 도형을 이용하여 그래프를 그린다. 각 geom 함수의 그래프는 좌표평면 상에서 별도의 층으로 구성된다.ggplot2의 명령문을 입력할 때 여러 함수를 합쳐서 실행하기 위하여 + 연산자를 이용한다. dplyr 패키지의 파이프 연산자와 유사한 역할을 한다. 그러나 문법이 다르기 때문에 ggplot2 명령어 들 사이에는 + 연산자를 사용하여야 한다.앞의 예에서는 geom_point() 함수의 data와 mapping이라는 인수를 설정하였다.data: 도형으로 표현할 데이터 프레임을 지정한다.mapping: 도형의 시각적 속성과 data에 지정된 데이터 프레임의 열을 쌍으로 대응시킨다. aes() 함수 내에 <도형의 속성>=<데이터 열 이름>의 형식으로 기술된다. 앞의 예에서 점의 x-축 위치에 displ 열이, y-축 위치에 hwy 열이 쌍으로 대응되었다.ggplot2에는 점을 그리는 geom_point() 함수뿐 아니라 다양한 도형을 그리는 geom 함수들이 있다. 이 함수들은 모두 data와 mapping이라는 인수를 가지고 있다.ggplot2는 그래픽 문법(grammar graphics)를 가지고 있어서 모든 그래프를 동일한 형식으로 생성할 수 있다.\n다음은 ggplot2의 그래픽 문법의 개요를 보여준다.\n우리는 이 장에서 ggplot2의 여러 문법적 요소를 하나씩 살펴볼 것이다.\nFigure 8.1: ggplot2의 그래픽 문법 (출처: Data visualization ggplot2::cheat sheet (RStudio))\n","code":"\nggplot() +\n  geom_point(mapping=aes(x=displ, y=hwy), data=mpg)"},{"path":"ch-visualization.html","id":"sec-aesMapping","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.2 도형의 속성에 데이터 열을 대응시키기 (aesthetic mapping)","text":"앞의 산점도에서 배기량에 따라 연비가 줄어드는 관계를 조금 벗어나는 관측치들이 있다.이 예외적인 관측치들이 자동차 종류의 차이 때문에 발생했다, 라고 가설을 세웠다 하자. 이 가설을 확인해 보려면 자동차 종류별로 관측치를 시각화할 필요가 있다. 앞서 본 geom_point() 함수는 ’점’이라는 도형을 좌표평면 상에서 그린다. 점이라는 도형은 x-축의 위치(x)와 y-축의 위치(y)뿐 아니라 색상(color), 모양(shape), 크기(size), 투명도(alpha) 등의 다른 시각적 속성을 가지고 있다. 우리는 이러한 속성 중 하나에 mpg 데이터의 class 열을 대응시켜 자동차 종류 별로 좌표평면에서 시각적으로 구분되는 점으로 표현할 수 있다.","code":""},{"path":"ch-visualization.html","id":"범주형-변수를-색상color-속성에-매핑하기","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.2.1 범주형 변수를 색상(color) 속성에 매핑하기","text":"다음은 관측치의 종류(class)에 따라 점을 서로 다른 색상(color)으로 표현한 예이다. 자동차의 종류에 따라 점이 다른 색상으로 표현되고, 어떤 색상이 어떤 자동차 종류에 대응되었는지에 대한 범례가 자동 생성된다.앞선 그래프에서 이상치로 표현되었던 점들 중 한 점만 제외하고 모두 2seater 자동차의 관측치였음을 알 수 있다. 이 종류의 차는 스포츠카로 배기량에 비해 가벼운 몸체를 가지고 있어 예외적인 연비가 관측된 것으로 보인다.다음으로 class 열을 shape, size, alpha 등의 속성에 대응시켜 어떤 결과가 나오는지 살펴보자.","code":"\nggplot() +\n  geom_point(mapping=aes(x=displ, y=hwy, color=class), data=mpg)"},{"path":"ch-visualization.html","id":"범주형-변수를-모양shape-속성에-매핑하기","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.2.2 범주형 변수를 모양(shape) 속성에 매핑하기","text":"shape 속성은 점의 모양을 결정한다. 다음은 앞의 산점도를 구동 방식(drv)에 따라 점의 모양이 다르게 표시한 예이다.shape 속성에 매핑할 때 주의할 점은 shape은 최대 6개의 모양으로만 점을 구분하기 때문에 class 열처럼 6개보다 많은 종류의 데이터가 있는 열을 매핑하면 데이터가 제대로 표시가 되지 않는다. 다음 예처럼 shape 속성에 class 열을 매핑하니 경고가 나타나고 suv 데이터를 표시하지 못한 것을 확인할 수 있다.","code":"\nggplot() + \n  geom_point(mapping=aes(x=displ, y=hwy, shape=drv), data=mpg)\nggplot() +\n  geom_point(mapping=aes(x=displ, y=hwy, shape=class), data=mpg)#> Warning: The shape palette can deal with a maximum of 6 discrete values because\n#> more than 6 becomes difficult to discriminate; you have 7. Consider\n#> specifying shapes manually if you must have them.#> Warning: Removed 62 rows containing missing values (`geom_point()`)."},{"path":"ch-visualization.html","id":"연속형-변수를-크기size-투명도alpha-색상color-속성에-매핑하기","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.2.3 연속형 변수를 크기(size), 투명도(alpha), 색상(color) 속성에 매핑하기","text":"모양(shape) 속성은 몇 가지 값으로 표현되는 범주형 변수를 표현하기 좋다. 데이터의 열이 연속형 변수이면 연속적인 값을 표현하기 좋은 가로축(x), 세로축(y), 크기(size), 투명도(alpha) 등을 이용하는 것이 좋다. 색상(color)은 범주형 변수와 연속형 변수에 모두 매핑될 수 있다. 범주형 변수로 매핑되면 구분되는 색상으로, 연속형 변수로 매핑되면 색상의 그라데이션으로 값을 표시한다.다음은 도심 연비와 고속도로 연비를 가로축과 세로축으로 하는 그래프에서 점의 크기 속성을 배기량 열에 매핑한 결과이다. 도심 연비와 고속도로 연비가 좋은 차들은 배기량이 작은 차임을 알 수 있다.다음은 동일한 도심 연비와 고속도로 연비 산점도에서 그래프에서 점의 색상을 배기량 열에 매핑한 결과이다. 범주형 변수가 매핑될 때와는 달리 색상의 연속적인 변화인 그라데이션을 사용하여 배기량을 표현하고 있음을 볼 수 있다.다음은 동일한 도심 연비와 고속도로 연비 산점도에서 그래프에서 점의 투명도를 실린더 수 열에 매핑한 결과이다.그럼 size와 alpha 등의 속성에 연속형 변수가 아니라 범주형 변수를 매핑하면 어떻게 될까?\n범주의 순서를 기준으로 각 범주를 1부터 1씩 증가하는 수치로 간주하여 그래프를 그려준다.\n다음 예는 size와 alpha 속성에 자동차 종류(class)를 매핑한 결과이다. size와 alpha 속성은 범산형 데이터를 표시하기에는 적절하지 않아서 관련된 경고 메시지를 표시한다. 왜냐하면 점의 크기와 투명도는 연속적인 값을 가지는 속성이기 때문에 연속형 변수를 매핑하는 것이 자연스럽기 때문이다.","code":"\nggplot() + \n  geom_point(mapping=aes(x=cty, y=hwy, size=displ), data=mpg)\nggplot() + \n  geom_point(mapping=aes(x=cty, y=hwy, color=displ), data=mpg)\nggplot() + \n  geom_point(mapping=aes(x=cty, y=hwy, alpha=cyl), data=mpg)\nggplot() +\n  geom_point(mapping=aes(x=displ, y=hwy, size=class), data=mpg)#> Warning: Using size for a discrete variable is not advised.\nggplot() +\n  geom_point(mapping=aes(x=displ, y=hwy, alpha=class), data=mpg)#> Warning: Using alpha for a discrete variable is not advised."},{"path":"ch-visualization.html","id":"도형의-여러-속성에-데이터-열을-매핑시키기","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.2.4 도형의 여러 속성에 데이터 열을 매핑시키기","text":"도형의 여러 속성에 데이터의 한 열을 매핑시킬 수도 있다. 다음 예에서는 구동방식(drv)에 따라 점의 모양과 색상을 다르게 표시하였다. 아울러 어떤 구동방식이 어떤 색상과 모양의 점으로 표현되었는지에 대한 범례도 자동 생성되었다.그래프에서 보듯이 예외적인 관측치를 구동방식의 차이로 설명하기는 어려워 보인다. 예외적인 관측치의 대부분이 후륜구동(r)이긴 하지만 주류적인 연비 경향 안에 포함되어 있는 후륜구동 관측치들도 많기 때문이다.위의 예에서 color와 shape 속성에 각각 다른 데이터 열을 매핑할 수도 있다.","code":"\nggplot() +\n  geom_point(mapping=aes(x=displ, y=hwy, color=drv, shape=drv), data=mpg)\nggplot() +\n  geom_point(mapping=aes(x=displ, y=hwy, color=class, shape=drv), data=mpg)"},{"path":"ch-visualization.html","id":"도형-속성에-데이터-열을-매핑하기---예제","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.2.5 도형 속성에 데이터 열을 매핑하기 - 예제","text":"지금까지 x-축과 y-축을 배기량(displ)과 고속도로 연비(hwy) 열로만 매핑하였다. 다음처럼 도심 연비(cty)와 고속도로 연비(hwy)의 관계를 보기 위하여 x-축과 y-축에 이 두 데이터 열을 매핑하여 그래프를 그릴 수도 있다.iris 데이터는 R의 기본 기능에서 제공하는 붓꽃에 대한 데이터이다.다음은 iris 데이터의 Sepal.Length와 Sepal.Width를 점의 x-축과 y-축 속성에 매핑하고, 색상과 모양 속성에 Species 열을 매핑한 예이다.","code":"\nggplot() +\n  geom_point(mapping=aes(x=cty, y=hwy, color=drv, shape=drv), data=mpg)\nhead(iris)#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2  setosa\n#> 2          4.9         3.0          1.4         0.2  setosa\n#> 3          4.7         3.2          1.3         0.2  setosa\n#> 4          4.6         3.1          1.5         0.2  setosa\n#> 5          5.0         3.6          1.4         0.2  setosa\n#> 6          5.4         3.9          1.7         0.4  setosa\nggplot() +\n  geom_point(mapping=aes(x=Sepal.Length, y=Sepal.Width, color=Species, shape=Species), data=iris)"},{"path":"ch-visualization.html","id":"도형의-속성에-대응시키기-vs.-도형의-속성-인수를-설정하기","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.2.6 도형의 속성에 대응시키기 vs. 도형의 속성 인수를 설정하기","text":"마지막으로 데이터를 도형의 속성으로 대응시키기와 도형의 속성 인수를 설정하기의 차이를 살펴보자.","code":""},{"path":"ch-visualization.html","id":"도형의-속성-인수-설정하기","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.2.6.1 도형의 속성 인수 설정하기","text":"지금까지는 점의 속성에 데이터의 열을 대응시켜 관측치의 값에 따라 점이 시각적으로 다르게 표현되도록 하였다. 그런데 데이터와 무관하게 점의 속성을 특정한 값으로 설정할 수도 있다. 다음은 산점도 점을 모두 파란색으로 지정한 예이다.이처럼 도형의 어떤 속성을 특정한 값으로 지정하는 것을 도형의 속성 인수를 설정한다고 한다. 이 경우 도형의 시각적 속성의 변화는 데이터와는 무관하며, 그렇기 때문에 mapping 인수의 aes() 함수 내에 정의되지 않는다. 대신 aes() 바깥에 별도의 geom 함수의 인수로서 설정된다.도형의 속성 인수를 설정할 때, 설정되는 값은 인수에 따라 다르다.color 인수: 색상의 이름이 문자열로 부여된다. 부여할 수 있는 생상의 이름을 확인하려면 colors() 함수를 실행해 본다.size 인수: 점의 크기가 mm 단위로 설정된다.shape 인수: 표시할 문자를 직접 설정할 수도 있고, 0에서 24까지의 숫자로도 지정할 수 있다. 다음은 color=\"red\"와 fill=\"blue\"로 인수가 설정되었을 때 shape 인수의 값에 따라 점의 모양을 보여준다.","code":"\nggplot() +\n  geom_point(mapping=aes(x=displ, y=hwy), data=mpg, color=\"blue\")"},{"path":"ch-visualization.html","id":"도형의-속성-인수를-속성-대응시키기에-잘못-설정하는-경우","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.2.6.2 도형의 속성 인수를 속성 대응시키기에 잘못 설정하는 경우","text":"ggplot2의 초보자가 가끔 도형의 속성을 데이터의 열에 대응시키기와 도형의 속성 인수를 설정하는 것을 혼동할 때가 있다. 다음처럼 color=\"blue\"의 인수 설정을 aes() 안에 기술하면 어떻게 될까? 실제 이를 실행해 보면 점들이 파란색이 아니라 빨간색으로 표시되는 것을 볼 수 있다.aes() 함수 안에 설정되었기 때문에 ggplot은 color=\"blue\"를 color 속성에 “blue”라는 하나의 값을 가진 열이 대응된 것으로 간주한다. 그러므로 이 값에 적절한 색-이 예에서는 빨간색-을 대응시켜 점을 표시한 후, 범례에 blue라는 값이 빨간색으로 대응되었음을 표시하였다. 따라서 도형 속성을 데이터 열에 대응시키기와 도형의 속성 인수를 설정하는 것을 구분하여 사용하지 않으면 이렇듯 엉뚱한 결과를 얻을 수 있으므로 주의가 필요하다.","code":"\nggplot() +\n  geom_point(mapping=aes(x=displ, y=hwy, color=\"blue\"), data=mpg)"},{"path":"ch-visualization.html","id":"group-속성","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.2.7 group 속성","text":"geom 도형의 대부분의 속성은 도형의 시각적 표현을 직접적으로 변화시키는 속성들이다. 대표적인 예가 x, y, color, shape, size, fill 등의 속성이다. 이러한 속성은 시각적으로 효과가 직접적으로 들어나므로 이해하기 쉽다.반면 group 속성은 도형의 시각적 속성을 직접 변형하는 것이 아니라, 도형을 그릴 때 데이터를 어떤 식으로 그룹으로 묶어 사용할지만 지정한다. 이를 통해 그래프의 전체 모양에 영향을 준다.geom_point() 함수는 관측치 하나에 점 하나를 대응시켜 그래프를 그린다. 그러나 어떤 geom 함수는 여러 관측치를 그룹으로 묶어서 하나의 도형을 그린다. 대표적인 예가 geom_line()과 geom_smooth() 함수이다. 이 함수들은 여러 관측치를 사용하여 하나의 선을 완성한다. 만약 group 속성이 매핑되어 있지 않으면 모든 데이터를 하나의 그룹으로 하여 선 하나를 그린다. 반면 group 속성이 매핑되면, group속성에 매핑된 값을 기준으로 데이터를 그룹화하여 각각 도형 하나(geom_line()과 geom_smooth() 함수에서는 선 하나)를 그린다. 지금 설명한 내용을 예를 들어 살펴보자.","code":""},{"path":"ch-visualization.html","id":"그룹으로-나누어-선-그래프-그리기","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.2.8 그룹으로 나누어 선 그래프 그리기","text":"Orange 데이터는 5 그루의 나무에서 age(나이: 일)와 circumference(둘레: mm)을 측정한 결과이다. Tree 변수는 5그루 나무에 붙인 일련번호이다.다음은 age와 circumference를 x와 y aesthetics에 매핑한 그래프이다.이번에는 위와 동일한 매핑으로 geom_line()을 그려보자. geom_line()은 x좌표가 작은 것에서 큰 것 순으로 점을 연결하여 하나의 선을 완성한다.동일한 나이 대의 데이터가 많아서 하나의 선으로 연결한 그래프가 의미를 갖기 어려워 보인다. 이번에는 group 속성에 Tree 변수를 매핑해 보자. 데이터가 Tree의 값에 따라 그룹으로 묶여 선이 각각 그려졌음을 확인할 수 있다.","code":"\nOrange#>    Tree  age circumference\n#> 1     1  118            30\n#> 2     1  484            58\n#> 3     1  664            87\n#> 4     1 1004           115\n#> 5     1 1231           120\n#> 6     1 1372           142\n#> 7     1 1582           145\n#> 8     2  118            33\n#> 9     2  484            69\n#> 10    2  664           111\n#> 11    2 1004           156\n......\nggplot() + geom_point(mapping=aes(x=age, y=circumference), data=Orange)\nggplot() + geom_line(mapping=aes(x=age, y=circumference), data=Orange)\nggplot() + \n  geom_line(mapping=aes(x=age, y=circumference, group=Tree), data=Orange)"},{"path":"ch-visualization.html","id":"이산형-변수는-group-속성으로-자동-매핑된다.","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.2.9 이산형 변수는 group 속성으로 자동 매핑된다.","text":"각 나무의 데이터를 구분해 보기 위하여 다음처럼 color 속성을 추가해 보자. Tree 변수는 순서형 범주 데이터로 이산형 데이터이므로, color가 뚜렷이 구분되는 색으로 매핑되었다. 그리고 수준의 순서에 따라 범례도 정렬되었다.그런데 이를 좀 더 간편히 할 수 있는 방법이 있다. ggplot2는 속성에 매핑된 변수 중에 이산형 변수가 있으면 이를 group 속성에 자동으로 매핑시킨다. 다음처럼 color 속성에 Tree를 매핑만 하면, 자동으로 이를 group 속성에 반영하여 선을 구분하여 그려준다.다음 예는 linetype 속성으로 각 나무를 구분한 예이다.","code":"\nOrange$Tree#>  [1] 1 1 1 1 1 1 1 2 2 2 2 2 2 2 3 3 3 3 3 3 3 4 4 4 4 4 4 4 5 5 5 5 5 5 5\n#> Levels: 3 < 1 < 5 < 2 < 4\nggplot() + \n  geom_line(mapping=aes(x=age, y=circumference, group=Tree, color=Tree), data=Orange )\nggplot() + \n  geom_line(mapping=aes(x=age, y=circumference, color=Tree), data=Orange)\nggplot() + \n  geom_line(mapping=aes(x=age, y=circumference, linetype=Tree), data=Orange)"},{"path":"ch-visualization.html","id":"geom_smooth-함수에서-group-속성","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.2.10 geom_smooth() 함수에서 group 속성","text":"group 속성이 이용되는 또 다른 예가 geom_smmooth() 함수이다. 이 함수는 group에 매핑된 정보에 따라 데이터를 그룹화하여 추세선을 그린다.마지막 예에서는 geom_smooth() 함수의 se 인수를 FALSE로 설정하여 신뢰구간이 표시되지 않도록 하였다.","code":"\nggplot() + \n  geom_smooth(mapping=aes(x=age, y=circumference), data=Orange )#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\nggplot() + \n  geom_smooth(mapping=aes(x=age, y=circumference, color=Tree), \n              data=Orange )#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\nggplot() + \n  geom_smooth(mapping=aes(x=age, y=circumference, color=Tree), \n              data=Orange, se=F)#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'"},{"path":"ch-visualization.html","id":"sec-facets","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.3 측면(facets)으로 나누어 그리기","text":"8.2 장에서 배기량과 고속도로 연비의 산점도를 자동차 종류에 따라 분리하여 살펴보기 위해 점의 시각적 속성 중 하나에 자동차 종류를 대응시켰다. 원래의 그래프를 또 다른 변수의 측면에서 세분화하여 살펴보는 방법으로는 도형의 다른 속성에 해당 변수를 대응시키는 것 말고도 해당 변수값에 따라 데이터를 나누어 각각에 대한 그래프를 그려볼 수도 있다. ggplot2에서는 이러한 방식으로 그래프를 그리는 것을 측면(facets)으로 나누어 그래프를 그린다고 한다.","code":""},{"path":"ch-visualization.html","id":"facet_wrap로-일차원-측면-그래프-그리기","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.3.1 facet_wrap()로 일차원 측면 그래프 그리기","text":"다음은 facet_wrap() 함수의 사용법을 보여준다. ~ 은 R에서 수식을 표현할 때 사용되는데, facet_wrap() 함수는 수식을 인수로 입력받는다. facet_wrap() 함수는 ~ 우변에 기술된 변수를 측면(facets)으로 하여 데이터를 나누어 그래프를 그린다. 이 때 측면(facets)으로 사용되는 변수는 범주형 데이터이어야 한다. facet_wrap()은 부분 그래프가 많아지면 줄바꿈하여 그래프를 표시한다. ncol이나 ncol을 설정하면 그래프의 행과 열의 수를 지정하여 줄바꿈 처리를 제어할 수 있다.두 개 이상의 변수를 조합하여 측면을 만드려면 다음처럼 수식의 우변에 두 개의 변수를 +로 연결하여 기술하면 된다.","code":"\nggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) +\n  facet_wrap(~class, nrow = 2)\nggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) +\n  facet_wrap(~drv + year, nrow = 2)"},{"path":"ch-visualization.html","id":"facet_grid로-이차원-측면-그래프-그리기","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.3.2 facet_grid()로 이차원 측면 그래프 그리기","text":"원래 그래프를 두 변수의 측면에서 나누어 그리기를 하려면 facet_grid()를 사용하는 것이 좋다.\nfacet_grid()도 수식은 인수로 입력 받는데, 수식의 좌변과 우변에 데이터의 변수를 지정할 수 있다.\n그러면 수식의 좌변에 기술된 변수를 그래프의 행으로, 우변에 기술된 변수를 그래프의 열로 하여 측면 그래프를 그린다.facet_wrap() 함수와 마찬가지로 수식의 좌변과 우변에 +로 하나 이상의 변수를 지정할 수 있다.","code":"\nggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) +\n  facet_grid(drv~cyl)\nggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg) +\n  facet_grid(drv+year~cyl)"},{"path":"ch-visualization.html","id":"sec-layerAndGeom","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.4 그래프 계층(layers)과 도형(geoms)","text":"ggplot2의 장점은 필요에 따라 다양한 형식의 그래프를 쉽게 만들 수 있고, 만들 수 있는 형식도 무궁무진하다는데 있다. ggplot2 그래프의 계층적 구조와 데이터 열과 속성을 자유롭게 매핑할 수 있다는 점이 이러한 무궁무진한 그래프 형식을 만들어 내는 핵심 요소라 할 수 있다.","code":""},{"path":"ch-visualization.html","id":"geom-함수의-순서와-그래프-계층","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.4.1 geom 함수의 순서와 그래프 계층","text":"ggplot2는 좌표평면 위에 여러 계층으로 그래프를 그려서 하나의 좌표평명에 나타냄으로써 복잡한 형식의 그래프를 만들어 낼 수 있다.다음 두 그래프에서는 배기량과 고속도로 연비의 산점도와 추세선을 각각 그렸다.위의 두 그래프는 다음처럼 한 좌표평면 위에 겹쳐서 그릴 수 있다. ggplot2에서 서로 다른 geom 함수는 서로 다른 도형-앞의 예는 점과 추세선-을 그래프에 표시한다.ggplot() 함수가 여러 개의 geom 함수와 연결되면, 하나의 좌표평면에 각각의 geom() 함수의 결과를 층층이 그린다. 이 때, 명령문에 나타나는 순서에 따라 첫번째 나온 geom 함수의 도형이 가장 아래 계층에, 다음에 나오는 geom 함수의 도형이 차례로 그 윗 계층에 그려진다.","code":"\nggplot() + geom_point(mapping=aes(x=displ, y=hwy), data=mpg)\nggplot() + geom_smooth(mapping=aes(x=displ, y=hwy), data=mpg)#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\nggplot() + \n  geom_point(mapping=aes(x=displ, y=hwy), data=mpg) +\n  geom_smooth(mapping=aes(x=displ, y=hwy), data=mpg)#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'"},{"path":"ch-visualization.html","id":"ggplot-함수는-좌표축을-자동-조정한다.","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.4.2 ggplot() 함수는 좌표축을 자동 조정한다.","text":"만약 위의 그래프에 배기량과 도심연비의 산점도와 추세선을 겹쳐서 표시하려면 다음처럼 네 계층으로 이루어진 그래프를 그린다. ggplot() 함수가 데이터에 따라 좌표평면의 범위를 자동적으로 조정하는 것을 볼 수 있다.","code":"\nggplot() + \n  geom_point(mapping=aes(x=displ, y=hwy), data=mpg) +\n  geom_smooth(mapping=aes(x=displ, y=hwy), data=mpg) + \n  geom_point(mapping=aes(x=displ, y=cty), data=mpg, col=\"red\", shape=1) +\n  geom_smooth(mapping=aes(x=displ, y=cty), data=mpg, linetype=2, col=\"red\")#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'"},{"path":"ch-visualization.html","id":"여러-데이터를-사용하여-그래프-계층-만들기","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.4.3 여러 데이터를 사용하여 그래프 계층 만들기","text":"지금까지는 동일한 데이터(data)에 대해서 geom 함수들이 그래프를 그렸다. 그러나 사실 각 계층의 geom 함수가 이용할 data와 mapping을 독립적으로 설정할 수 있다.다음 예는 mpg 데이터와 함께 R의 기본 패키지에서 제공하는 iris 데이터를 사용하여 그래프를 그려보자.iris 데이터는 꽃받침의 길이(‘Sepal.Length’)와 폭(‘Sepal.Width’) 열을 가지고 있는데, 이 두 열의 산점도를 앞의 그래프에 겹쳐서 그려보았다.물론 이 그래프는 배기량과 꽃받침의 길이를 같은 x-축으로, 고속도로 연비와 꽃받침의 폭을 같은 y-축으로 그래프를 그렸으므로 억지스러운 측면이 있다. 단지 아주 별개의 데이터를 동시에 사용해서 하나의 그래프를 그릴 수 있다는 것을 보여주기 위해 그린 그래프일 뿐이다.그러나 이 예에서 다음 사실을 확인할 수 있다.\n첫째, 서로 다른 데이터를 사용해도 좌표평면이 자동으로 조정되어 모든 계층의 도형이 모두 적절히 표시된다.\n둘째, 아울러 축의 이름은 첫 계층의 geom 함수의 x와 y로 대응된 변수가 자동으로 선택된다. 뒤에서 보겠지만 labs() 함수 등을 사용하면 축의 이름을 자유롭게 변경할 수 있다.","code":"\nhead(iris)#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2  setosa\n#> 2          4.9         3.0          1.4         0.2  setosa\n#> 3          4.7         3.2          1.3         0.2  setosa\n#> 4          4.6         3.1          1.5         0.2  setosa\n#> 5          5.0         3.6          1.4         0.2  setosa\n#> 6          5.4         3.9          1.7         0.4  setosa\nggplot() + \n  geom_point(mapping=aes(x=displ, y=hwy), data=mpg) +\n  geom_smooth(mapping=aes(x=displ, y=hwy), data=mpg) + \n  geom_point(mapping=aes(x=displ, y=cty), data=mpg, col=\"red\", shape=1) +\n  geom_smooth(mapping=aes(x=displ, y=cty), data=mpg, linetype=2, col=\"red\") +\n  geom_point(mapping=aes(x=Sepal.Length, y=Sepal.Width), data=iris, col=\"orange\") #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'"},{"path":"ch-visualization.html","id":"다른-데이터-범위로-그래프-계층-만들기","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.4.4 다른 데이터 범위로 그래프 계층 만들기","text":"8.2 절을 시작할 때, 주경향에서 벗어난 점들을 더 큰 빨간색 점으로 표현한 그래프를 보았을 것이다. 이 그래프는 어떻게 그렸을까? 답은 7.4 절에서 설명한 filter() 함수를 이용하여 예외적인 경향의 데이터만 뽑아낸 후, 이 데이터를 가지고 별도의 산점도를 그리는 것이다. 이 데이터를 이용해서 그린 산점도가 마지막 그래프 계층에 그려졌으므로 빨간 점이 원래의 검은 점 위에 그려진다.","code":"\nggplot() +\n  geom_point(mapping=aes(displ, hwy), data=mpg) +\n  geom_point(mapping=aes(displ, hwy), \n             data=filter(mpg, displ > 5, hwy > 20), \n             color=\"red\", size=2)"},{"path":"ch-visualization.html","id":"subsec-commonDataMapping","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.4.5 공통 data와 mapping의 설정","text":"지금까지 geom 함수에 data와 mapping 인수를 각각 설정하였다. 그런데 공통된 data와 mapping을 사용하여 여러 층으로 그래프를 겹쳐 그리는 경우, 이러한 방식으로 data와 mapping을 일일이 설정하는 것은 귀찮을 뿐 아니라 명령문의 오류 가능성을 증가시키고 변경을 어렵게 만든다.","code":""},{"path":"ch-visualization.html","id":"ggplot-함수에-공통-데이터와-매핑-설정하기","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.4.5.1 ggplot() 함수에 공통 데이터와 매핑 설정하기","text":"ggplot() 함수는 좌표평면을 생성하는 기능뿐 아니라, 그래프 계층에 공통된 data와 mapping을 설정하는 기능도 가지고 있다. 다음 예에서는 배기량과 고속도로 연비의 산점도와 추세선을 공통된 data와 mapping 설정을 이용하여 그렸다. 주의할 점은 data와 mapping 인수의 위치가 geom 함수와 ggplot() 함수에서 반대라는 것이다.위와 같은 형식으로 명령문을 구성하면, 다음처럼 한 군데만 변경하면 고속도로 연비가 아니라 도심 연비로 산점도와 추세선을 그릴 수 있어 편리하다.","code":"\nggplot(data=mpg, mapping=aes(x=displ, y=hwy)) +\n  geom_point() + geom_smooth()#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\nggplot(data=mpg, mapping=aes(x=displ, y=cty)) +\n  geom_point() + geom_smooth()#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'"},{"path":"ch-visualization.html","id":"geom-함수에서-데이터와-매핑의-재정의","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.4.5.2 geom 함수에서 데이터와 매핑의 재정의","text":"ggplot() 함수에 data와 mapping 인수가 정의되어 있어도, geom 함수에 이를 재지정할 수 있다. 이 경우 각 geom 함수에서 사용하는 data와 mapping은 다음 규칙에 의해 결정된다.geom 함수는 ggplot() 함수에 설정된 data와 mapping을 상속받아 그래프를 그린다.만약 geom 함수에 data 인수가 설정되면 ggplot() 함수에 설정된 data는 무시된다.만약 geom 함수에 mapping 인수가 설정되면 ggplot() 함수에 설정된 mapping에 geom 함수에 설정된 mapping이 추가된다. 만약 동일한 도형 속성에 대한 정의가 두 군데 나타나면 geom 함수의 설정이 사용된다.도형 속성과 데이터 열의 매핑이 어디에 나타나는지에 따라 그래프가 어떻게 변화하는지 살펴보자.\n다음은 ggplot() 함수에서 color 속성을 drv 열에 매핑하여 점과 추세선 모두 drv 값에 따라 구분되는 다른 색으로 표현하였다.만약 color 속성의 drv 열 매핑을 geom_point()로 옮기면 어떻게 될까?\n다음 결과에서 보듯이 color 속성이 점에만 매핑되었으므로, 점만 drv에 따라 구분되어 색상이 표시되고, 추세선은 모든 데이터에 대하여 하나만 그려지는 것을 볼 수 있다.\n왜냐하면 geom_smooth()는 ggplot()에 매핑된 x와 y 속성에 대한 매핑만 상속 받고, 다른 계층에 있는 매핑은 상속받지 않기 때문이다.마찬가지로 color 속성의 drv 열 매핑을 geom_smooth()로 옮기면 추세선만 drv에 따라 구분된 색상으로 각각 표시되고, 점은 모든 데이터에 대하여 하나의 색상으로 구별없이 표현되는 것을 볼 수 있다.geom 함수들은 ggplot() 함수에서 상속한 매핑에다 새로운 매핑을 추가할 수도 있다.\n앞의 배기량과 고속도로 연비의 산점도와 추세선을 그린 그래프에서 추세선을 선 종류(linttype)가 구동 방식(drv)에 따라 다르게 표현하고 싶다. 그런데 산점도는 점이라는 도형으로 그래프를 그리므로 선 종류라는 속성을 가지고 있지 않다. 그리고 산점도도 점의 모양(shape)이 구동 방식에 따라 다르게 표현하고 싶다고 하자. 마찬가지로 추세선은 선이라는 도형으로 그래프를 그리므로 점의 모양이라는 속성을 가지고 있지 않다.\n이렇듯 여러 geom 함수를 연결하여 그래프를 그릴 때, 특정 geom 함수에만 해당하는 속성은 해당 geom 함수에서 속성과 데이터 열을 매핑하는 것이 좋다. geom 함수도 ggplot() 함수처럼 aes() 함수를 이용하여 그래프 속성과 데이터 열을 매핑하는데, 이 매핑이 geom 함수의 첫 번째 인수로 기술된다는 점만 다르다.또한 ggplot() 함수에 이미 설정된 매핑 중 일부 매핑판을 geom 함수에서 다시 설정할 수도 있다.\n다음은 배기량과 고속도로 연비의 산점도와 추세선에 배기량과 도심 연비의 추세선을 더한 그래프는 다음 명령으로도 그릴 수 있다.\n두 번째로 나타나는 geom_point()와 geom_smooth()에서 y의 매핑을 hwy가 아니라 cty로 변경한 것을 볼 수 있다.아울러 geom 함수에서 ggplot() 함수에 정의된 데이터도 재설정할 수 있다. 다음 그래프에서는 추세선을 자동차 종류가 suv인 데이터에 대해서만 그려지도록 하였다. 이를 위해 filter 함수를 이용하여 mpg 데이터에서 class 변수가 suv인 관측치만 선택하여 새로운 데이터를 만들어 geom_smooth() 함수의 data 인수에 설정하였다.\n그리고 geom_smooth()에 설정된 데이터는 해당 계층에서만 유효한 것이고, geom_point()는 ggplot() 함수에 정의된 전체 mpg 데이터를 사용하여 점을 그리고 있음을 확인하라.","code":"\nggplot(data=mpg, mapping=aes(x=displ, y=hwy, color=drv)) +\n  geom_point() + geom_smooth()#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\nggplot(data=mpg, mapping=aes(x=displ, y=hwy)) +\n  geom_point(mapping=aes(color=drv)) + geom_smooth()#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\nggplot(data=mpg, mapping=aes(x=displ, y=hwy)) +\n  geom_point() + geom_smooth(mapping=aes(color=drv))#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\nggplot(data=mpg, mapping=aes(x=displ, y=hwy, color=drv)) + \n  geom_point(mapping=aes(shape=drv)) + \n  geom_smooth(mapping=aes(linetype=drv))#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\nggplot(data=mpg, mapping=aes(x=displ, y=hwy)) + \n  geom_point() + geom_smooth() + \n  geom_point(mapping=aes(y=cty), col=\"red\", shape=1) + \n  geom_smooth(mapping=aes(y=cty), linetype=2, col=\"red\")#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\nggplot(data=mpg, mapping=aes(x=displ, y=hwy)) + \n  geom_point(aes(color=class)) + \n  geom_smooth(data=filter(mpg, class==\"suv\"))#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'"},{"path":"ch-visualization.html","id":"ggplot과-geom-함수에서-대표-인수의-이름을-생략하기","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.4.5.3 ggplot()과 geom 함수에서 대표 인수의 이름을 생략하기","text":"지금까지 공통 데이터와 매핑을 ggplot() 함수에 기술하여 명령문을 단순화하였다. 그런데 이 명령문들은 더 단순화할 수 있다.R 함수에서 인수를 인수의 순서대로 입력하는 경우에는 인수의 이름을 굳이 표시하지 않아도 된다. ggplot() 함수의 처음 두 인수는 차례로 data와 mapping이고 모든 geom 함수의 처음 두 인수는 차레로 mapping과 data이다. 또한 aes() 함수의 처음 두 인수는 x와 y이다. 따라서 이 정보를 사용하면 위 명령어는 다음처럼 단순해 진다. 주의할 점은 마지막 점과 추세선 geom 함수의 aes() 함수에서는 y만 나오므로 인수 이름을 사용하였다.","code":"\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + geom_smooth() + \n  geom_point(aes(y=cty), col=\"red\", shape=1) +\n  geom_smooth(aes(y=cty), linetype=2, col=\"red\")"},{"path":"ch-visualization.html","id":"sec-commonProblems","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.5 ggplot 명령문을 입력할 때 자주 발생하는 문제들","text":"ggplot은 매우 강력한 기능을 가지고 있지만 Excel 등의 GUI 프로그램에만 익숙한 사람은 문자 기반 명령어를 입력하는 것에 어려움을 느낄 수 있다. 컴퓨터는 사람만큼의 유연성을 발휘하지 못하므로 컴퓨터는 자신이 실행해야 할 명령문의 문법에 매우 까다롭게 반응한다. ggplot 명령어 입력시 흔히 발생하는 문제들은 다음과 같다.R 명령문은 대소문자를 구분한다. 따라서 Color와 color는 ggplot에서 서로 다른 인수로 인식되어 오류가 발생한다.ggplot 명령문의 키워드의 철자가 틀리면 다른 키워드로 간주하기 때문에 오류가 발생할 수 있다. 이를 방지하려면 키워드의 일부만 입력한 후 Tab 키를 눌러 자동완성 기능을 사용하여 입력하는 것을 권장한다.R 명령문이 조금 길어지면 가장 흔하게 발생하는 실수가 ( )와 \"  \"을 짝을 맞추어 제대로 입력하지 못하는 것이다. ggplot2의 명령문도 많은 함수를 사용하다 보니 이를 주의하여야 한다. R 콘솔은 명령이 계속 입력 중이라고 생각하여 >가 아니라 +를 콘솔의 프롬프트로 표시한다. 이 경우 가장 간단한 해결책은 Esc 키를 눌러 명령 입력에서 빠져나와 다시 명령문을 입력하는 것이다.ggplot2의 명령문을 입력할 때 여러 함수를 합쳐서 실행하기 위하여 + 연산자를 이용한다.7 ggplot2의 명령문이 길어지면 명령문을 여러 줄로 쓰는 것이 필요한데, 보통 +로 연결되는 곳에서 줄바꿈하는 것이 읽기에 좋다. 이 때 주의할 점이, 줄바꿈을 + 앞이 아니라 뒤에서 해야 한다는 것이다. + 앞에서 하면 R은 명령문의 입력이 완성된 것으로 간주하기 때문이다.다음은 산점도와 추세선을 한 그래프에 그린 예이다.그런데 위의 명령어는 길기 때문에 스크립트 파일을 작성할 때 보기에 불편하다. 이러한 경우에 위의 명령은 다음처럼 세 줄로 나누어 기술될 수 있다. 세 함수를 연결하는 + 위치가 어디에 있는지 살펴보라. (다음 예에서 왼쪽의 > 프롬프트 아래 있는 +는 R 콘솔에서 명령문이 계속되고 있음을 나타내는 표시이다. 이 표시와 사용자가 입력한 +를 혼동하면 안 된다.)만약 다음처럼 + 위치가 잘못되면 오류가 발생한다. 왜 이런 결과가 나왔고 오류 메시지의 의미는 무엇일까? R은 Enter로 명령문을 구분한다. 그러므로 첫번째 줄은 +가 없으므로 완벽한 명령문이기 입력된 것으로 간주하고 실행이되어 좌표평면만 그린 것이다. 그러고 나서 두번째 줄을 새로운 명령문으로 실행을 한다. 그런데 갑자기 명령문이 +로 시작하니 R은 명령문에 오류가 있다고 판단한다. 왜냐하면 + 연산은 왼편과 오른편에 더할 요소가 있어야 하는데, 왼편의 요소가 기술되지 않았기 때문이다.","code":"\nggplot(mpg, aes(x=displ, y=hwy, color=drv)) + geom_point() + geom_smooth()#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\nggplot(mpg, aes(x=displ, y=hwy, color=drv)) + \n  geom_point() + \n  geom_smooth()\nggplot(mpg, aes(x=displ, y=hwy, color=drv))  \n  + geom_point()  #> Error:\n#> ! Cannot use `+` with a single argument\n#> ℹ Did you accidentally put `+` on a new line?"},{"path":"ch-visualization.html","id":"sec-ggplotStat","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.6 통계 변환","text":"","code":""},{"path":"ch-visualization.html","id":"subsec-statCategorical","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.6.1 범주형 변수의 통계 요약","text":"ggplot2 패키지의 diamonds는 약 54,000개의 다이아몬드에 대한 다음 정보를 측정한 데이터이다.caret: 다이아 몬드 무게cut: 가공의 품질. Fair, Good, Good, Premium, Idealcolor: 색상. D(최상)에서 F(최하)까지clarity: 투명도. I1(최하), SI2, SI1, VS2, VS1, VVS2, VVS1, (최상)x, y, z: 길이, 폭, 깊이depth: 깊이 비율 = z / mean(x, y)table: 최대폭 대비 윗면의 폭의 길이 비율다이아몬드의 가공의 품질(cut) 수준에 따른 빈도를 시각화해 보자. 현재 cut의 수준별 빈도수에 대한 데이터가 없기 때문에 먼저 이 데이터를 구하기 위한 통계적 변환을 수행해야 한다. 이를 위해 뒤에 설명할 dplyr 패키지의 summarize() 함수를 이용하였다.그리고 geom_col() 함수를 이용하여 막대 그래프를 그린다. geom_col() 함수는 막대라는 도형을 그리는 geom 함수로 x 값의 위치에 y에 매핑된 값을 높이로 가지는 막대를 그린다.그런데 geom 함수의 stat 인수를 이용하면 원래 데이터를 통계 요약하여 그래프를 그리는 과정을 사용자의 개입없이 쉽게 수행할 수 있다.그림 8.2는 geom_bar() 함수에서 stat 인수가 어떻게 작동하는지를 보여준다. geom_bar() 함수는 stat 인수에 \"count\"가 설정되면 stat_count() 함수를 사용하여 원래 데이터를 통계 요약한다. stat_count()는 x에 맵핑된 열을 수준(level; 구분되는 값) 별로 절대적 빈도와 상대적 빈도를 계산하여 count와 prop라는 열을 가지는 요약 데이터를 만든다.\n그리고 이 요약 데이터를 이용하여 x-축에 원래 변수의 수준을, y-축에 count 변수를 맵핑하여 막대 그래프를 그린다.\nFigure 8.2: stat의 작동 방식 (출처: R Data Science)\n사실 geom_bar() 함수의 디폴트 stat는 \"count\"이기 때문에, stat를 생략하여도 같은 결과를 얻을 수 있다.stat_count()가 요약한 데이터에서 절대 빈도수 count가 아니라 상대 빈도수 prop을 사용하여 그래프를 그리려면 y=..prop..을 mapping에 추가하여야 한다. stat가 생성한 요약 데이터의 열을 지정할 때는 ..<요약 변수 이름>.. 형식으로 지정을 한다. 그래야 원래 데이터가 아니라 요약 데이터에서 해당 열을 찾아 매핑을 한다. 상대 빈도는 group 속성에 따라 계산을 하는데, 전체 데이터를 대상으로 상대 빈도를 구하기 위해 모든 데이터가 동일한 그룹이 되도록 group=1로 설정을 하였다.8","code":"\ndiamonds#> # A tibble: 53,940 × 10\n#>    carat cut       color clarity depth table price     x     y     z\n#>    <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n#>  1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n#>  2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n#>  3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n#>  4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n#>  5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n#>  6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n#>  7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n#>  8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n#>  9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n#> 10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n#> # … with 53,930 more rows\ncut_table <- diamonds %>% \n  group_by(cut) %>%\n  summarize(n=n())\ncut_table#> # A tibble: 5 × 2\n#>   cut           n\n#>   <ord>     <int>\n#> 1 Fair       1610\n#> 2 Good       4906\n#> 3 Very Good 12082\n#> 4 Premium   13791\n#> 5 Ideal     21551\nggplot(cut_table) + geom_col(aes(x=cut, y=n))\nggplot(diamonds) + geom_bar(aes(x=cut), stat=\"count\")\nggplot(diamonds) + geom_bar(aes(x=color))\nggplot(diamonds) + geom_bar(aes(clarity, ..prop.., group=1))#> Warning: The dot-dot notation (`..prop..`) was deprecated in ggplot2 3.4.0.\n#> ℹ Please use `after_stat(prop)` instead."},{"path":"ch-visualization.html","id":"subsec-statNumerical","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.6.2 수치형 변수의 통계 요약","text":"carat 같은 연속형 변수에 geom_bar()를 적용하면 구별되는 모든 수치에 대해 빈도를 계산하여 막대를 그린다. 그러나 연속형 변수는 구별되는 값이 매우 많으므로 이렇게 만들어진 그래프로 데이터의 경향을 파악하긴 어렵다.","code":"\nggplot(diamonds) + geom_bar(aes(carat))"},{"path":"ch-visualization.html","id":"stat_bin을-이용한-히스토그램","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.6.2.1 stat_bin()을 이용한 히스토그램","text":"연속형 변수는 구분되는 값이 아니라 일정한 구간 별로 빈도를 계산하여 막대 그래프를 그리는 것이 더 적절하다. (이러한 그래프를 히스토그램이라고 한다.) stat 인수에 stat_bin()을 사용하면 x에 맵핑된 연속형 변수의 값을 구간으로 나누어 이러한 작업을 한다.","code":"\nggplot(diamonds) + geom_bar(aes(carat), stat=\"bin\")#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`."},{"path":"ch-visualization.html","id":"geom_histogram","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.6.2.2 geom_histogram()","text":"사실 stat_bin()을 디폴트 stat로 사용하는 geom 함수가 있다. geom_histogram()이 그 함수이다. geom_histogram()를 이용하면 다음처럼 연속형 변수에 대한 히스토그램을 그릴 수 있다.그리고 bins 또는 binwidth 인수를 사용하면 구간의 수 또는 구간의 길이를 직접 지정하여 히스토그램을 그릴 수 있다.stat_bin()은 구간 별 절대 빈도수(count)뿐 아니라 구간의 밀도(density)와 빈도수와 밀도의 최대 값이 1이 되도록 규모를 변환한 ncount와 ndensity 변수도 생성한다. 그러므로 필요에 따라 이 값을 이용하여 히스토그램을 그림 수 있다.","code":"\nggplot(diamonds) + geom_histogram(aes(carat))#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nggplot(diamonds) + geom_histogram(aes(table), bins=50)\nggplot(diamonds) + geom_histogram(aes(price), binwidth=500)\nggplot(diamonds) + geom_histogram(aes(x=x, y=..density..))#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nggplot(diamonds) + geom_histogram(aes(x=y, y=..ncount..))#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nggplot(diamonds) + geom_histogram(aes(x=z, y=..ndensity..))#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`."},{"path":"ch-visualization.html","id":"geom_boxplot","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.6.2.3 geom_boxplot()","text":"geom_boxplot() 함수는 수치 변수를 4분위수와 이상치로 요약하여 그래프를 그려준다.\n다음은 다이아몬드의 중량(carat) 변수에 대한 4분위수와 이상치를 상자 그래프로 표시한 예이다.상자 그래프에 대한 해석은 다음처럼 한다.상자의 상단의 3분위수를 표현한다.상자의 하단은 1분위수를 표현한다.상자의 가운데 선분은 중위수(2분위수)를 표현한다.상자의 상단과 하단의 길이를 inter-quartile range라고 하고 IQR이라고 표현한다.일반적으로 3분위 수에서 1.5 IQR보다 큰 수치나, 1분위수에서 1.5 IQR보다 작은 수치는 이상치(outliers)라고 판단한다.상자의 하단과 상단에 나타나는 선분은 1.5 IQR 내의 최소치와 최대치를 나타낸다.상자의 상하단에서 1.5 IQR 바깥에 있는 데이터는 이상치로 보고 점으로 표시한다.상자 그래프는 위와 같이 세로축을 기준으로 그리기도 하지만 다음처럼 가로축을 기준으로 표시하기도 한다.\n가로축으로 그래프를 표시하려면 수치 변수를 y가 아니라 x에 매핑을 하여야 한다.상자 그래프는 앞의 예처럼 한 수치형 변수를 요약할 때는 잘 사용되지 않는다.\n왜냐하면 히스토그램이 수치형 변수를 더 자세히 요약할 수 있기 때문이다.\n상자 그래프는 주로 다음 절에서 보듯이 범주형 변수와 수치형 변수의 관계를 탐색할 때 주로 이용한다.","code":"\nggplot(diamonds) + geom_boxplot(aes(y = carat))\nggplot(diamonds) + geom_boxplot(aes(x = carat))"},{"path":"ch-visualization.html","id":"subsec-statNumericalPerCategory","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.6.3 수치형 변수의 범주별 통계요약","text":"다이아몬드의 가격이 가공 품질에 따라 어떤 범위로 움지이는지 살펴보자. 이 때 유용한 geom 함수가 geom_boxplot()이다. geom_boxplot() 함수는 상자그림으로 수치 데이터를 표현한다. 이 함수는 stat로 stat_boxplot()을 디폴트로 사용한다. stat_boxplot()은 x에 매핑된 열의 수준 별로 y에 매핑된 데이터를 모아서 상자그림에 필요한 통계량을 계산한다.이 외에도 stat_summary()를 이용하면 연속형 변수 데이터를 범주별로 나누어 함수를 적용한 결과를 출력할 수 있다.\nfun, fun.max, fun.min에 각각 수치 변수를 요약할 함수를 지정하면 해당 함수로 수치의 값을 y, ymax, ymin이라는 변수로 요약한다.\n다음은 가공품질(cut) 별로 다이아몬드의 깊이(depth)의 중위수, 최대값, 최소값을 점과 구간으로 나타낸 결과이다.위의 예에서 geom 함수를 사용하지 않고 stat 함수를 ggplot() 함수에 연결한 것을 볼 수 있다.\ngeom 함수마다 디폴트 stat 함수가 정의되어 있는 것처럼, stat 함수에는 디폴트 geom 함수가 정의되어 있다.\n그래서 위와 같이 stat 함수가 그래프의 계층(layer)로 사용되면 stat 함수의 디폴트 geom 함수에 의해 요약 결과가 그려진다.\nstat_summary() 함수의 디폴트 geom 함수는 geom_pointrange()로 점과 구간으로 그래프를 표현해 준다.","code":"\nggplot(diamonds) + geom_boxplot(aes(cut, price))\nggplot(diamonds) + geom_boxplot(aes(cut, carat), notch=T)\nggplot(diamonds, aes(cut, depth)) +\n  stat_summary(fun=median, fun.max=max, fun.min=min)"},{"path":"ch-visualization.html","id":"sec-position","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.7 위치 조정","text":"geom_bar()는 막대의 색상과 관련된 fill, color, alpha라는 속성이 있는데, 각각 막대의 색, 막대 테두리 색, 막대 색의 투명도를 조정한다.\n다음은 mpg 데이터에서 class별 빈도를 막대 그래프로 그린 예이다. fill 속성 인수에 남색을 부여하였다.앞의 막대 그래프는 class별로 데이터의 빈도를 구해 한 색상으로 막대를 그렸다. 이번에는 class 별 빈도에 대한 막대 그래프를 그리는데 fill 속성에 drv 열을 매핑하여 어떤 차이가 있는지 살펴보자.fill 속성에 drv라는 이산 변수가 매핑되자, 동일한 class 값이지만 서로 다른 drv의 값을 가지는 경우를 구분하여 다른 색상으로 막대를 그렸다. 그리고 동일한 class인데 drv 값이 다른 막대를 동일한 가록축에 층(stack)으로 쌓아 올렸다. 예를 들어 subcompact 클래스의 경우 drv가 4, f, r이 모두 있으므로 총 3개의 막대가 그려져야 한다. 그러나 이 3 막대는 모두 동일한 x 값을 가지므로 서로 겹치는 것을 피하기 위하여 쌓아 표현하였다.geom 함수에서 position 인수는 동일한 위치의 도형 객체를 어떻게 조화롭게 표현할지를 결정한다. 앞의 예에서는 geom_bar()의 position 인수의 디폴트 값은 \"stack\"이므로 같은 x 위치의 막대를 쌓아 표현하였다. 만약 같은 위치의 막대를 쌓아 표현하지 않고 옆으로 나란히 세워 표현하고 싶으면 postion 인수를 \"dodge\"로 설정한다.geom 함수에 따라 취할 수 있는 position 인수의 값은 다를 수 있다. geom_bar()의 경우 \"stack\", \"dodge\", \"fill\" 그리고 \"identity\" 값을 가질 수 있다. (여기서 \"fill\"과 \"identity\"는 막대의 fill 속성이나 통계 요약 함수인 stat_identity()와는 상관없는 동일 위치의 도형의 위치 조정에 관한 값이다.) position인수가 \"fill\"이면, 막대의 전체 길이가 1이 되도록 조정하여 동일한 x의 값에서의 상대적 비율을 파악할 수 있게 해준다.position이 \"identity\"로 설정되면 동일한 위치에 겹쳐지는 geom 객체에 아무 조정도 하지 않는다. 앞과 동일한 예에서 position=\"identity\"로 설정해 보자. 모두 동일한 자리에 그려지므로 아래 그려진 막대가 가려지므로 막대의 윤곽선만 그리고 투명도를 조정하여 겹쳐진 막대를 확인할 수 있도록 하자.사실 \"identity\" position은 막대 그래프에서 별로 유용한 조정 방법이 아니다. 그러나 geom_frepoly() 등 빈도를 선으로 표현하는 geom 객체에는 매우 유용하다.사실 geom_freqpoly()는 \"identity\"를 position의 디폴트 값으로 가지므로 다음 명령어도 동일한 결과를 준다.","code":"\nggplot(mpg) + geom_bar(aes(class), fill=\"dark blue\")\nggplot(mpg) + geom_bar(aes(class), color=\"dark blue\")\nggplot(mpg) + geom_bar(aes(class, fill=drv))\nggplot(mpg) + geom_bar(aes(class, fill=drv), position=\"dodge\")\nggplot(mpg) + geom_bar(aes(class, fill=drv), position=\"fill\")\nggplot(mpg) + geom_bar(aes(class, col=drv), position=\"identity\", alpha=0.1)\nggplot(mpg) + geom_freqpoly(aes(hwy, color=drv), position=\"identity\")#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nggplot(mpg) + geom_freqpoly(aes(hwy, color=drv))"},{"path":"ch-visualization.html","id":"sec-typeofgraph","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.8 ggplot2 그래프의 종류","text":"이 절에서는 ggplot2에서 그릴 수 있는 대표적인 그래프 종류를 하나씩 살펴본다.\n그래프는 결국 데이터를 시각적 객체로 변환한 것이므로 그래프의 종류는 그래프가 어떤 geom 객체를 이용하는가에 따라 나눠 볼 수 있다. Table 8.1에는 그래프에서 자주 사용되는 geom 함수들이 제시되어 있다.Table 8.1: geom 함수한편 그래프는 데이터에 대한 시각적 표현이므로 표현하려는 데이터의 형식에 따라 그래프를 구분해 볼 수도 있다. 데이터의 각 변수는 크게 수치형 변수와 범주형 변수로 나누어 볼 수 있다. 앞으로 우리는 그래프에서 표현하려는 데이터가 무엇인지에 따라 다음처럼 그래프를 분류하여 살펴보고자 한다.하나의 범주형 변수를 나타내는 그래프하나의 수치형 변수를 나타내는 그래프두 개의 범주형 변수의 관계를 나타내는 그래프하나의 범주형 변수와 하나의 수치형 변수의 관계를 나타내는 그래프두 개의 수치형 변수의 관계를 나타내는 그래프세 개 이상의 변수의 관계를 나타내는 그래프이를 각각 살펴보기에 앞서 그래프에 단순한 선과 도형을 표현하는 기본 함수를 먼저 살펴보자.","code":""},{"path":"ch-visualization.html","id":"basic-graph","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.8.1 직선을 그리는 그래픽 함수","text":"직선을 그리는 그래픽 함수를 살펴보기 위해 mpg 데이터에 대한 도심 연비와 고속도로 연비를 나타내는 산점도 그래프를 고려해 보자.앞의 산점도에 도심 연비와 고속도로 연비의 평균을 나타내보자.\nggplot2에서는 수평선은 geom_hline(), 수직선은 geom_vline() 함수로 그릴 수 있다. 다음은 geom_vline()으로 도심연비의 평균선을 나타낸 예이다. xintercept는 수직선이 지나가는 x축의 절편의 값이다. linetype 인수는 선의 종류를 결정하는 인수인데, 1은 실선, 2는 파선을 나타낸다. 이 외에도 다양한 linetype을 설정할 수 있으니 자세한 내용은 ??linetype을 이용하여 관련된 설명을 확인해 보길 바란다.다음으로 geom_hline()으로 고속도로 연비의 평균선을 그려보자. yintercept는 수평선이 지나가는 y 절편의 값이다.이렇게 그려 놓고 보면, 도심 및 고속도로 연비가 모두 평균 이상인 그룹과 어느 하나만 평균 이상인 그룹, 둘 다 평균 이하인 그룹을 구분해 볼 수 있다.\n도심 연비와 고속도로 연비의 비율을 알기 위하여 기울기가 1이고 절편이 0인 직선을 그려보자. geom_abline()은 절편이 , 기울기가 b인 직선을 그래프에 그려준다. 결과에서 확인하듯이 모든 차들이 도심 연비에 비해 고속도로 연비가 좋음을 확인할 수 있다. 아울러 두 연비의 비를 알아볼 수 있도록 scale 함수를 이용하여 좌표축의 범위를 동일하게 설정하였다(8.9 장 참조).","code":"\np <- ggplot(mpg, aes(cty, hwy)) + geom_point()\np\np + geom_vline(xintercept = mean(mpg$cty), linetype=2, color=\"red\")\np1 <- p + geom_vline(xintercept = mean(mpg$cty), linetype=2, color=\"red\") +\n  geom_hline(yintercept = mean(mpg$hwy), linetype=2, color=\"red\")\np1\np1 + geom_abline(a=0, b=1, linetype=3, color=\"blue\") +\n  scale_x_continuous(limits = c(0, 45)) +\n  scale_y_continuous(limits = c(0, 45))#> Warning in geom_abline(a = 0, b = 1, linetype = 3, color = \"blue\"): Ignoring\n#> unknown parameters: `a` and `b`"},{"path":"ch-visualization.html","id":"onecategory","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.8.2 한 범주형 변수의 그래프","text":"우리는 이미 geom_bar()를 이용하여 하나의 범주형 변수의 빈도에 대한 막대 그래프를 그리는 법을 보았다. 여기서는 범주형 변수의 막대 그래프 표현에 대하여 좀 더 자세히 살펴본다.먼저 범주형 변수가 무엇인지 살펴보자. 범주형 변수란 변수의 값이 몇 개의 정해진 범주로 한정되는 변수라고 할 수 있다. 예를 들어 gender라는 변수가 어떤 수업의 수강생의 성별 정보를 표현하고 있다면, 남자 또는 여자라는 두 가지 범주에 의해서 데이터가 표현될 것이다. mpg의 class 열은 연비가 조사된 자동차의 종류를 compact, midsize, suv, 2seater, minivan, pickup, subcompact라는 7 가지 값으로 표현하는 변수이다. 다음 명령을 실행해 데이터를 확인해 보자.ggplot2에서는 geom_bar() 함수를 이용하여 다음 형식 중 하나를 선택하여 막대 그래프를 그린다.geom_bar() 함수는 x에 매핑된 변수를 범주형 변수로 간주하고, 해당 변수에서 구분되는 값을 범주로 뽑아낸 후, 범주 별로 빈도수 계산한 후 이를 막대 그래프로 그려준다. (빈도수를 계산하는 과정은 사실 stat_count() 함수가 수행한다.) class 변수는 7가지의 구분되는 값으로 구성되어 있다. 문자열로 표현되는 범주는 알파벳 순으로 정렬되어 그래프의 가록축에 표현된다. 다음은 mpg 데이터의 class 열에 대한 막대 그래프를 그린 예이다.mpg 데이터이 cyl 열은 수치로 표현되어 있지만 사실은 실린더 개수이므로 4, 6, 8, 5라는 4 개의 범주를 가진 범주형 변수이다. geom_bar()를 이용하면 이 범주로 이용하여 빈도수를 계산한 후 막대 그래프로 그릴 수 있다. 범주가 수치인 경우에는 수의 크기로 정렬하여 가로축을 생성한다.수치형 변수도 구별되는 값의 개수가 많지 않으면 geom_bar()를 이용할 수 있다. 예를 들어 도심 연비를 나타내는 cty는 다음처럼 총 21 개의 값을 가지고 있다. 그러므로 geom_bar()를 이용하여 각 값 별로 데이터의 빈도를 세어 막대 그래프를 그릴 수 있다.이 경우는 cty 변수에 구별되는 값이 많지 않아 막대 그래프로 표현해도 크게 어색하지 않다. 그러나 대부분의 수치형 변수는 연속적인 값을 가지므로 이런 식으로 막대 그래프를 그리기가 어렵다. 따라서 수치형 변수의 경우 geom_histogram()을 이용하여 구간으로 나누어 구간별 빈도에 대한 막대 그래프를 그리는 것이 좋다.막대 그래프를 그릴 때 그래프의 x-축에 표현되는 범주의 순서를 바꾸고 싶을 때가 있다. 예를 들어 다음같은 drv에 대한 막대 그래프를 f, r, 4 순으로 막대를 표현하고 싶다고 하자.geom_bar()는 기본적으로 문자는 알파벳 순으로 숫자는 숫자의 크기 순으로 정렬하여 막대를 그리므로 이를 바꾸고 싶으면 요인(factor)로 바꾸어야 한다. 요인의 경우는 수준(levels)에 정의된 순서에 따라 막대 그래프를 그리기 때문이다. 마지막의 labs() 함수는 x-축의 레이블을 \"drv\"로 표시하기 위해 사용되었다. 이 함구가 없으면 x-축 레이블이 어떻게 변하는지 확인해 보라.다음 예는 mpg의 class 데이터에서 빈도가 작은 범주부터 차례로 막대가 나오도록 하는 예이다. reorder() 함수는 첫 번째 인수인 factor를 두 번째 인수로 주어진 벡터를 factor의 범주 별로 나누어 세 번째 인수로 주어진 함수를 적용한 결과의 순서로 factor의 levels를 정렬한다.\n아래 예에서 세 번째 인수로 length() 함수가 설정되었으므로, class 열의 범주 별 개수에 의해 class 열의 범주가 정렬된다.위의 예에서 reorder() 함수는 결과가 작은 범주부터 큰 범주로 levels를 정렬하는 것을 알 수 있다.\n만약 결과가 큰 범주부터 작은 범주로 levels를 정렬하려면 어떻게 해야 할까?\n다음처럼 length() 함수의 결과를 음수로 바꾸면 가장 빈도가 큰 범주가 가장 작은 수가 되므로 원하는 결과를 얻을 수 있다.reorder() 함수로 범주의 순서를 결정할 때, 다른 변수의 값으로도 정렬이 가능하다.\n다음은 class의 범주를 hwy의 평균이 작은 것에서 큰 것 순으로 정렬한 예이다.정말로 hwy 평균에 따라 class의 범주가 정렬되었는지 확인해 보자.\n다음 결과에서 정말 그렇게 되었음을 확인할 수 있다.범주형 데이터를 막대로 그릴 때, 각 범주별 데이터를 다른 변수로 좀 더 세분화하여 살펴보고 싶을 때가 있다. 이 경우 흔히 한 범주를 표현하는 막대를 다른 변수의 범주에 따라 색상으로 구분하여 세분화하여 표현한다. geom_bar()의 fill aesthetics에 범주형 변수를 매핑하면 각 범주별로 색상을 달리 표시한다. 다음은 class별 막대 그래프를 년도(year)로 더 세분화하여 표현한 경우이다. mpg 데이터의 year 변수는 수치형 데이터로 표현되어 있으므로 factor() 함수를 이용하여 이산형으로 변형하여 fill aesthetics에 매핑하였다.만약 각 class 값에 따라 1999년도와 2008년도의 상대적 빈도를 비교해 보고 싶다면, 다음처럼 position 인수를 \"fill\"로 설정하면 된다. postion 인수에 대한 자세한 설명은 8.7 절을 참조하기 바란다. 이렇게 하면 막대 그래프를 이용하여 두 범주형 변수의 관계를 살펴볼 수 있다.","code":"\nunique(mpg$class)#> [1] \"compact\"    \"midsize\"    \"suv\"        \"2seater\"    \"minivan\"   \n#> [6] \"pickup\"     \"subcompact\"\nggplot(data=데이터, mapping=aes(x=범주형.변수.이름)) + geom_bar()\nggplot(데이터, aes(범주형.변수.이름)) + geom_bar()\nggplot(데이터) + geom_bar(aes(범주형.변수.이름))\nggplot() + geom_bar(aes(범주형.변수.이름), 데이터)\nggplot(mpg, aes(class)) + geom_bar()\nggplot(mpg, aes(cyl)) + geom_bar()\nunique(mpg$cty)#>  [1] 18 21 20 16 19 15 17 14 11 13 12 22  9 28 24 25 23 26 33 35 29\nggplot(mpg, aes(cty)) + geom_bar()\nggplot(mpg, aes(drv)) + geom_bar()\nggplot(mpg, aes(factor(drv, levels=c(\"f\", \"r\", \"4\")))) + \n  geom_bar() +\n  labs(x=\"drv\")\nggplot(mpg) + \n  geom_bar(aes(reorder(class, class, length))) +\n  labs(x=\"class\")\nggplot(mpg) + \n  geom_bar(aes(reorder(class, class, function(x) -length(x))))+\n  labs(x=\"class\")\nggplot(mpg) + \n  geom_bar(aes(reorder(class, hwy, mean))) +\n  labs(x=\"class\")\nmpg %>%\n  group_by(class) %>%\n  summarise(hwy_mean = mean(hwy)) %>%\n  arrange(hwy_mean)#> # A tibble: 7 × 2\n#>   class      hwy_mean\n#>   <chr>         <dbl>\n#> 1 pickup         16.9\n#> 2 suv            18.1\n#> 3 minivan        22.4\n#> 4 2seater        24.8\n#> 5 midsize        27.3\n#> 6 subcompact     28.1\n#> 7 compact        28.3\nggplot(mpg, aes(class, fill=factor(year))) + geom_bar() + labs(fill=\"year\")\nggplot(mpg, aes(class, fill=factor(year))) +\n  geom_bar(position=\"fill\") + labs(fill=\"year\")"},{"path":"ch-visualization.html","id":"onenumeric","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.8.3 한 수치형 변수의 그래프","text":"한 수치형 변수에서 일차적으로 확인해야 할 내용은 그 변수의 분포이다. 분포를 확인하는 가장 단순한 방법은 수치를 구간으로 나누어 빈도를 나타내는 히스토그램을 그려보는 것이다. geom_histogram() 함수는 x로 매핑된 변수를 구간으로 나누어 빈도수를 구한 후 - 이 작업은 stat_bin() 함수가 수행한다 - 막대 형태의 히스토그램 그래프를 그려준다. 다음은 고속도로 연비 데이터를 구간 크기를 2로하여 나눈 후 히스토그램을 그린 예이다. 구간의 길이는 bandwidth 인수를 이용하여 설정한다.히그토그램은 구간의 크기에 따라 다른 모양의 그래프가 나오므로, 구간의 크기를 변화시키면서 분포를 가장 적절하게 나타내는 구간크기를 찾아 보아야 한다.그런데 앞의 고속도로 연비 히스토그램을 보면 두 개의 봉우리를 가지는 분포를 보인다. 이처럼 분포에 여러 봉우리가 나타날 때는 서로 다른 특성을 가지는 데이터 그룹이 하나로 섞여 있기 때문인 경우가 많다. 예를 들어 성인의 키의 분포를 그리면 남자와 여자라는 서로 다른 특성의 그룹 때문에 쌍봉 형태의 그래프가 나온다.고속도로 연비가 쌍봉 형태를 보이는 것이 자동차의 구동 방식 때문인지를 한번 살펴보자. 다음처럼 fill aesthetics에 drv 변수를 매핑하면 빈도를 drv 요소로 분해하여 살펴볼 수 있다. 결과에서 보듯이 왼쪽 봉우리는 주로 4륜 구동(4) 차가, 오른쪽 봉우리는 전륜 구동(f) 차가 분포의 대부분을 차지하고 있음을 볼 수 있다.그런데 앞의 예에서 geom_histogram()은 디폴트 position이 \"stack\"으로 설정되어 있어서 쌓인 형태로 막대 그래프가 나타났다. 쌓인 그래프 형태로 표현되다 보니 각 구동방식에 따른 고속도로 연비의 분포를 파악하기는 어렵다. 이런 경우 geom_freqpoly()를 이용하여 각 범주별 분포를 분리하여 그려보면 좋다. geom_freqpoly()는 geom_histogram()과 마찬가지로 연속형 수치 변수를 구간으로 나누어 빈도를 보여주는데, 막대가 아니라 선을 이용하여 빈도를 보여준다.따라서 여러 그룹으로 나누어 구간으로 나누어 빈도를 보일 때도 서로 구분이 용이하다. geom_freqpoly()의 디폴트 position은 \"identity\"이다. 아래 그래프를 보면 4륜 구동과 전륜 구동의 분포에 의해 전체 분포에서 쌍봉이 나타났음을 뚜렷하게 확인할 수 있다.그런데 위의 그래프는 구동방식에 따라 구간별 고속도로 연비의 절대빈도를 보여준다. 따라서 데이터 수가 적은 후륜 구동(r)의 경우 매우 작게 표시되어 상대적인 분포를 확인하기 어렵다. 이런 경우 전체 면적을 1로하는 상대빈도를 이용하여 그래프를 나타내는 것이 더 좋다. geom_histogram()과 geom_freqpoly() 모두 디필트 stat로 stat_bin()을 이용하는데, 이 함수는 x로 매핑된 변수를 구간으로 나누어 구간별 빈도(count), 밀도(density), 최대값이 1로 조정된 빈도(ncount), 최대값이 1로 조정된 밀도(ndensity) 등을 산출한다. 특별한 지시가 없으면 stat_bin()은 count 변수를 y로 매핑하여 준다. 그리고 이 y 값을 geom_histogram()에서는 막대의 높이로, geom_freqpoly()에서는 선의 y 값으로 이용한다. count 대신 density를 이용하여 그래프를 그리고 싶으면, aes() 매핑에서 y가 density가 되도록 매핑하면 된다. 단, 이 때 stat 함수에 의해 계산된 변수는 ..<변수이름>.. 형태로 표시한다.4륜 구동 차는 15에서 20사이의 구간에서 가장 많은 빈도를 보였고, 후륜구동 차는 15에서 30 사이로 펴져서 분포를 하고 있고, 전륜구동 차는 25에서 30에서 가장 많은 빈도를 보이는 것을 확인할 수 있다.그런데 geom_histogram()과 geom_freqpoly()는 구간을 어떻게 나누는가에 따라 그래프의 형태가 크게 달라지는 단점이 있다. geom_density() 함수는 수치형 변수의 값을 사용하여 확률밀도를 추정한 후 추정된 확률밀도에 대한 그래프를 보여주므로 구간 나누기의 임의성을 피할 수 있다.","code":"\nggplot(mpg, aes(hwy)) + geom_histogram(binwidth=2)\nggplot(mpg, aes(hwy)) + geom_histogram(binwidth=1)\nggplot(mpg, aes(hwy, fill=drv)) + geom_histogram(binwidth=1)\nggplot(mpg, aes(hwy)) + geom_freqpoly(binwidth=2)\nggplot(mpg, aes(hwy, color=drv)) + geom_freqpoly(binwidth=2)\nggplot(mpg, aes(hwy, ..density.., color=drv)) + geom_freqpoly(binwidth=2)\nggplot(mpg, aes(hwy)) + geom_density()\nggplot(mpg, aes(hwy, color=drv)) + geom_density()"},{"path":"ch-visualization.html","id":"twocategories","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.8.4 두 범주형 변수의 그래프","text":"두 범주형 변수의 관계는 8.8.2 절에서 본 것과 같이 한 범주형 변수의 막대 그래프에 fill aesthetics에 다른 범주형 변수를 매핑하여 두 변수의 관계를 살펴보거나, 아니면 다음처럼 facet을 이용하여 한 범주형 변수의 값을 고정시켜 놓고 다른 범주형 변수에 대해 막대 그래프를 그려 두 변수의 관계를 살펴본다.이 경우 절대빈도로 막대 그래프가 표시되어 facet에 지정된 변수의 값에 따라 분포가 다른지 비교하기가 어렵다. geom_bar()의 디폴트 stat인 stat_count()는 x로 매핑된 변수에 대해 범주별로 빈도수를 세어 count 변수에 저장하고, 상대빈도를 prop 변수에 저장한다. stat_count()는 디폴트로 count 변수의 값을 y에 매핑한다. 만약 prop 변수를 막대 그래프의 y의 값으로 매핑하려면, y를 ..prop..으로 지정한다. (8.8.3 절에서 설명한 바와 같이 stat 함수가 생성한 변수의 지정은 ..<변수 이름>..의 형식을 사용한다.) 그러면 각 범주별 상대 빈도가 나타나 facet으로 지정된 변수의 값에 따라 상대적 비율이 달라지는지 비교해 볼 수 있다.두 범주형 변수의 관계를 살펴보는 또 다른 방법은 두 범주형 변수의 데이터를 산점도로 표시해 보는 것이다.그런데, 문제는 같은 값을 갖는 데이터가 너무 많으므로 여러 데이터가 한 점으로 표시되어 빈도를 알 수 없다. 이 경우 geom_jitter()를 사용하면 각 점의 x, y 좌표에 임의의 변동을 주어 겹치는 점이 다른 곳에 표시되도록 할 수 있다. width와 height 인수는 임의의 변동의 최대값이다. 범주형 변수의 범주 사이의 길이는 1이므로 다음의 예는 붙어 있는 두 범주 사이의 거리의 약 \\(\\pm\\) 20% 정도의 변동이 일어나도록 조정한 예라 할 수 있다.그러나 산저도의 점의 수가 많으면 두 변수의 관계를 명확하게 알기는 힘들다. 이 경우 geom_count()를 이용하면 빈도에 따라 더 큰 원이 그려지는 그래프를 그릴 수 있다.","code":"\nggplot(mpg, aes(class)) + geom_bar() +\n  facet_wrap(~drv)\nggplot(mpg, aes(class, ..prop.., group=drv)) + geom_bar() +\n  facet_wrap(~drv)\nggplot(mpg, aes(class, drv)) + geom_point()\nggplot(mpg, aes(class, drv)) + geom_jitter(width=0.2, height=0.2)\nggplot(mpg, aes(class, drv)) + geom_count()"},{"path":"ch-visualization.html","id":"category-numeric","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.8.5 범주형 변수와 수치형 변수의 그래프","text":"범주형 변수와 수치형 변수의 관계를 살펴보는 가장 쉬운 방법은 범주형 변수에 따른 수치형 변수의 분포를 산점도로 나타내 보는 것이다. 다음은 클래스별 도심 연비의 산점도를 보여준다. 비슷한 데이터와 매핑으로 그래프를 여러번 그릴 것이므로 ggplot2 그래프를 변수에 할당하여 사용해 보자.그런데 실제 데이터보다 점이 더 적게 찍힌 것을 볼 수 있다. 이는 동일한 지점에 여러 데이터가 표현되었기 때문이다.geom_jitter() 함수는 앞서 설명하였드시 동일한 지점의 점을 임의로 조금씩 변동시켜 점을 표시한다. width와 height 인수를 설정하면 임의의 변동의 폭과 높이의 범위를 설정할 수 있다. 다음은 폭을 \\(\\pm 0.2\\)로 제한한 경우이다. 이산시간 변수는 한 칸이 1로 계산되므로 총 공간의 40% 정도에 임의로 변동된 점이 놓이게 된다.geom_jitter()로 범주별로 수치 변수의 대락적 분포를 확인할 수는 있으나 전체적인 분포를 요약하여 비교하긴 어렵다. geom_boxplot()를 이용하면 각 범주에서의 수치형 변수의 분포를 상자 그림으로 요약하여 보여준다. 상자의 상한은 3분위수, 상자의 하한은 1분위수, 상자 안의 가로선은 중위수를 나타낸다. 상자 밖의 위와 아래에 그려진 선은 상자 높이(IQR)의 1.5배 내의 데이터 중 최대값과 최소값을 보여준다. 그 범위 밖의 데이터는 이상치로 간주하여 별도의 점으로 나타낸다.앞의 그래프는 자동차 종류 별로 도심 연비의 중위수가 차이가 나는지를 살펴볼 수 있게 해준다. 그런데, 그래프에 나타난 중위수는 조사된 데이터, 즉 표본의 중위수이므로 모집단의 중위수와 다를 수 있다. 모집단 중위수에 대한 신뢰구간을 같이 표시하고 싶으면 notch=TRUE로 하여 상자그림을 그린다. 만약 두 종류의 차의 V자 모양의 notch가 서로 겹치지 않는다면 두 종류의 차의 도심 연비의 중위수가 통계적으로 유의미하게 다르다는 것을 의미한다. 데이터가 적은 클래스의 경우에 notch의 크기가 너무 커져서 상자 바깥까지 그려지는 경우도 있다. 이 경우 경고 메시지가 출력된다.상자 그래프 자주 같이 표시되는 정보가 수치 데이터의 평균에 대한 정보이다. stat_summary()를 이용하면 범주별 평균을 구할 수 있고, geom 함수로는 geom_point()를 설정하여 범주별 평균을 상자 그림 위에 점으로 덧붙일 수 있다.상자 그래프는 수치형 데이터를 분위수와 이상치로 요약된 정보를 주는 장점이 있지만 실제 분포를 파악하기 어렵다. 바이올린 차트는 상자 그래프의 이러한 단점을 보완해 준다. 바이롤린 차트는 수치 변수의 확률밀도를 추정하여 확률밀도가 높은 곳은 폭이 넓게, 확률밀도가 낮은 곳은 폭이 좁게 그래프를 그려주는데, 이 모향이 바이올린 모양을 닯아서 바이올린 차트라 한다.그런데 바이올린 차트는 확률밀도를 계산할 때 확률밀도가 연속적이고 유한한 값을 가지는 함수라는 가정하에 각 지점에 작은 정규분포를 적합하여 이를 연결하여 확률밀도를 추정한다. 그런데 이런 가정이 적합하지 않을 때도 있으니 이 경우 바이올린 차트를 사용하지 않는 것이 좋다.\n다음은 바이올린 차트와 상자그림을 겹쳐 그린 그래프이다.","code":"\np <- ggplot(mpg, aes(class, cty))\np + geom_point()\np + geom_jitter(width = 0.2)\np + geom_boxplot()\np + geom_boxplot(notch = T)#> Notch went outside hinges\n#> ℹ Do you want `notch = FALSE`?\n#> Notch went outside hinges\n#> ℹ Do you want `notch = FALSE`?\n#> Notch went outside hinges\n#> ℹ Do you want `notch = FALSE`?\np + geom_boxplot(notch = T) +\n  stat_summary(fun=mean, color=\"red\", size=5, shape=\"*\", geom = \"point\")#> Notch went outside hinges\n#> ℹ Do you want `notch = FALSE`?\n#> Notch went outside hinges\n#> ℹ Do you want `notch = FALSE`?\n#> Notch went outside hinges\n#> ℹ Do you want `notch = FALSE`?\np + geom_violin()\np + geom_boxplot(width=0.1) +\n  geom_violin(alpha=0.3)"},{"path":"ch-visualization.html","id":"twonumeric","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.8.6 두 수치형 변수의 그래프","text":"우리는 앞선 여러 예제에서 geom_point()를 이용하여 두 수치형 변수의 산점도와 geom_smooth()를 이용하여 평균 적합선을 그려보았다. 여기서는 다른 방식으로 두 수치형 변수의 관계를 그래프로 나나태 보자.","code":""},{"path":"ch-visualization.html","id":"geom_text","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"geom_text()","text":"두 수치형 변수의 데이터를 나타낼 때, 점 대신 텍스트로 표현하고 싶을 때가 있다. 다음 예는 geom_text()로 midsize 차의 2008년도의 도심 및 고속도로 연비 데이터를 모델명으로 보여주는 그래프이다.앞의 예는 동일한 데이터를 가지는 차의 이름이 겹쳐서 표현되어 구분이 어렵다. 이를 개선하기 위하여 글자의 크기(size 인수)를 줄이고 다음처럼 position 인수에 position_jitter() 함수를 이용하여 텍스트 위치에 임의적인 변동을 주어 같은 자리의 데이터가 겹치지 않도록 해 본다.텍스트를 겹치지 않게 만드는 또다른 방법은 check_overlap=TRUE로 설정하여 이미 한 자리에 텍스트가 놓이면 같은 위치에 텍스트가 더 이상 쓰이지 않도록 하는 것이다. 이 경우 뒤에 나타나는 동일한 위치의 데이터는 그래프에 표시되지 못할 것이다.텍스트로 관측치의 위치를 표현하면, 텍스트의 길이가 가변적이라 관측치의 정확한 위치를 파악하기 어렵다. 따라서 관측치의 위치는 점으로 표현한 후, 점의 옆이나 위, 아래에 텍스트를 같이 표현하기도 한다. geom_text() 함수의 nudge_x와 nudge_y는 원래 관측치의 위치에서 정해진 크기만큼 표시할 텍스트의 위치를 이동시킨다. 다음은 텍스트를 점 위로 0.3 정도 이동시켜 표시한 예이다.위의 경우에는 동일한 위치에 여러 텍스트가 겹치므로 position_jitter()를 이용하여 임의로 위치로 텍스트를 조정할 수도 있다. 참고로 position_jitter()와 nudge_x/nudge_y는 함께 사용될 수 없다.","code":"\ndf <- filter(mpg, class == \"midsize\", year == 2008) \nggplot(df, aes(cty, hwy)) + geom_text(aes(label=model))\nggplot(df, aes(cty, hwy)) + \n  geom_text(aes(label=model), size=3, \n            position=position_jitter(width=0.3, height=0.3))\nggplot(df, aes(cty, hwy)) + geom_text(aes(label=model), check_overlap = T)\nggplot(df, aes(cty, hwy)) + geom_point() + \n  geom_text(aes(label=model), nudge_y=0.3, size=3)\nggplot(df, aes(cty, hwy)) + \n  geom_point() + \n  geom_text(aes(label=model),  size=3,\n            position=position_jitter(width=0.3, height=0.3))"},{"path":"ch-visualization.html","id":"geom_label","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"geom_label()","text":"geom_label()은 geom_text()와 거의 유사한데, 텍스트를 박스 안에 넣어 글자를 구별하기 좀 더 쉽도록 해 준다.","code":"\nggplot(df, aes(cty, hwy)) + \n  geom_point() + \n  geom_label(aes(label=model), nudge_y=0.2, size=3)"},{"path":"ch-visualization.html","id":"geom_bin2d","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"geom_bin2d()","text":"두 변수의 결합 분포를 확인하고 싶을 때는 geom_bin2d()를 이용하여 두 수치형 변수를 각각 구간으로 나눈 후, 각 셀별로 빈도수를 계산한다. 그리고 각 셀의 빈도에 따라 색상을 다르게 하여 그래프에 표시한다. binwidth 인수는 가로축과 세로축의 구간을 길이를 지정한다.","code":"\nggplot(mpg, aes(cty, hwy)) + geom_bin2d(binwidth=c(2,2))"},{"path":"ch-visualization.html","id":"morethanthree","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.8.7 세 변수 이상의 그래프","text":"3개 변수 이상의 관계를 파악하고자 할 때 조건부 그래프이다. 조건부 그래프는 관심의 대상인 한 변수의 분포 또는 두 변수의 관계가 다른 변수의 값이 변함에 따라 어떻게 변하는지를 보여준다. ggplot2에서는 facet을 사용하여 이를 수행한다.다음은 구동 방식(drv)의 차이에 따라 배기량(displ)과 도심 연비(cty)의 관계가 어떻게 변하는지를 보여주는 그래프이다. 전륜 구동(f)의 차일수록 배기량이 커짐에 따라 도심 연비의 감쇄가 크게 나타남을 볼수 있다.\n위에서 사용된 facet_wrap() 함수는 그래프가 매우 많으면 그래프를 줄 바꾸기를 하여 배치를 한다.3개 변수 이상의 관계를 파악할 때 조건부 그래프뿐 아니라, 산점도 상에서 색상 등의 다른 aethetics를 사용하여 제 3의 변수의 영향을 살펴볼 수도 있다. 다음은 구동 방식의 차이를 색상으로 구분하여 한 산점도에 나타낸 예이다.\n색상 등의 aesthetics를 제 3의 변수에 매핑하여 그래프를 그리는 것은 한 그래프에 그래프가 모두 함께 표시되어 비교가 쉬운 장점이 있다. 그러나 제 3의 변수가 여러 값을 가지거나 제3, 4, 5의 변수들이 관심있는 두 변수에 영향을 미치는 것을 살펴보려면 너무 그래프가 복잡해서 파악이 어려운 단점이 있다. 다음은 구동방식뿐 아니라 조사 년도(year)가 배기량과 도심 연비의 관계에 어떤 영향을 미치는지 보기 위해 추가적으로 year 변수를 linetype에 매핑한 결과이다. 여러 그래프가 한 곳에 그려지다 보니 구분이 어려운 것을 볼 수 있다. 또한 연도별로 구동방식으로 나누어 비교를 하기도 어렵다.\nfacet을 사용하면 제3, 4 변수의 값에 따라 그래프 각각 그린 후 행과 열로 배치해 주므로 그래프를 좀 더 체계적으로 비교해 볼 수 있다. 다음은 drv와 year의 값에 따라 displ와 cty의 관계가 어떻게 변하는지는 facet을 이용하여 그래프를 그린 예이다. facet_grid()은 수식 표현을 사용하여 그래프 배열의 행과 열의 기준이 되는 변수를 지정한다.facet_wrap()이 한 변수를 조건으로 하여 그래프를 그린다면 facet_grid()는 두 변수를 조건으로 그래프를 그려준다. 행이 될 변수를 수식의 왼편에 열이 될 변수를 수식의 오른편에 기술을 한다. 앞의 예에서는 조사 년도별 차이는 행으로, 구동 방식의 차이는 열로 구분되어 그래프를 표시하였다. 전륜 구동(f)의 차들의 연비 감쇄 현상이 더 가파른 것은 연도별로 차이가 없었지만, 1999년도에 비해 2008년도의 전륜구동(f)과 후륜구동(r)의 차들 중에 배기량이 큰 차들이 출시되었고 배기량에 따른 연비 감쇄 경향도 줄어들었음을 볼 수 있다.","code":"\nggplot(mpg, aes(displ, cty)) + \n  geom_point() + geom_smooth(method=\"lm\") + \n  facet_wrap(~drv)#> `geom_smooth()` using formula = 'y ~ x'\nggplot(mpg, aes(displ, cty)) + \n  geom_point() + geom_smooth(method=\"lm\") + \n  facet_wrap(~class)#> `geom_smooth()` using formula = 'y ~ x'\nggplot(mpg, aes(displ, cty, col=drv)) + \n  geom_point() + geom_smooth(method=\"lm\") #> `geom_smooth()` using formula = 'y ~ x'\nggplot(mpg, aes(displ, cty, col=drv, linetype=factor(year))) + \n  geom_point() + geom_smooth(method=\"lm\") + labs(linetype=\"year\")#> `geom_smooth()` using formula = 'y ~ x'\nggplot(mpg, aes(displ, cty)) + \n  geom_point() + geom_smooth(method=\"lm\") + \n  facet_grid(year~drv)#> `geom_smooth()` using formula = 'y ~ x'"},{"path":"ch-visualization.html","id":"modification","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.9 그래프의 외양 바꾸기","text":"ggplot2는 사용자가 데이터를 geom의 각 aesthetics 요소로 매핑하면 자동으로 가로축과 세로축의 스케일을 결정하고, 표시할 색상의 스케일도 결정하고, 축과 범례에 표시될 레이블도 결정하여 그래프를 그려준다. 이러한 ggplot2의 기능은 사용자가 그래프의 세부 사항이 아니라 그래프의 핵심적인 매핑과 형태에만 집중할 수 있게 해주므로 매우 편리하다. 그러나 가끔은 ggplot2가 생성한 그래프의 모양이 최종적으로 원하는 형태가 아닐 수 있다. 이러한 경우에 그래프의 세부적인 사항을 조정할 필요가 있다. 사실 발표용 그래프는 세심한 조정이 필요한 경우가 더 많다. 이 장에서는 ggplot2로 그래프를 그린 후 자주 조정하게 되는 요소를 어떻게 변경할 수 있는지를 살펴본다.","code":""},{"path":"ch-visualization.html","id":"axes","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.9.1 좌표축의 조정","text":"ggplot2는 데이터가 x와 y aesthetics에 매핑되면, 이를 이용하여 가로축과 세로축의 축척(scale)를 생성한다. x와 y에 매핑된 변수가 수치형 변수이면 scale_x_continous()와 scale_y_continous()가, 범주형 변수이면 scale_x_discrete()와 scale_y_discrete()가 사용되어 가로축과 세로축의 축척을 생성한다.\n좌표축의 축적을 위한 이러한 함수들은 매핑된 데이터의 값을 이용하여 다음 사항을 적절히 결정한다.name: 축의 이름breaks: 축에 표시될 눈금의 위치minor_breaks: 축에 표시될 세부 눈금의 위치labels: 축 눈금에 씌여질 레이블limits: 축의 상한과 하한trans: 축에 별도의 변환을 적용할지 여부position: 축의 그래프 상에서의 위치 등ggplot2가 자동으로 설정한 이러한 요소가 원하는 것이 아니라면 직접 이를 조정해야 한다.midwest 데이터는 미국 중서부의 각 카운티(county)의 인구통계 정보이다.area: 면적poptotal: 총 인수수popdensity: 인구밀도popwhite: 백인 거주자수popblack: 흑인 거주자수popamerindian: 인디언 거주자수\npopasian: 아시아인 거주자수popother: 다른 인종 거주자수percwhite, percwhite, percamerindan, percasian, percother: 각 인종의 비율popadults: 성인 거주자수percollege: 대학 졸업자 비율percprof: 전문직 비율다음은 백인 거주자 비율과 대학 졸업자 비율에 대한 산점도이다.위의 그래프에서 가로축은 백인의 비율인데 25% 단위로 주눈금(breaks)과 눈금의 값이 레이블(labels)로 표시되어 있다. 아울러 주눈금 사이에 보조 눈금(minor.breaks)이 하나씩 그려져 있고 별도의 레이블은 표시되어 있지 않다. 위의 가록축을 10% 단위로 주눈금을 표시하고 보조눈금은 디폴트 값인 주눈금 사이에 하나의 보조눈금이 그려지도록 그래프를 조정해 보자. 또한 눈금에 표시되는 레이블도 숫자만이 아니라 %가 같이 표시되도록 해 본다.현재 x와 y 축은 데이터의 최소값과 최대값이 모두 표시될 수 있도록 적절히 그 범위가 설정되어 있다. 그런데 현재 백인의 비율은 대부분 80% 이상이어서 데이터가 서로 구분이 되지 않는다. 따라서 x축을 60에서 100%까지만 표시되도록 조정해 보자. 또한 y축의 이름을 “Percent college educated”로 바꾸어 보자. 이 경우 2개의 관측치가 그래프에 표시되지 않으므로 그에 대한 정보가 함께 출력된다.아울러 position 인수를 사용하면 좌표축의 위치를 지정할 수 있다. “left”, “right”, “top”, “bottom”의 값이 사용되는데 다음 예는 가로축과 세로축을 좌표평면의 맨 위와 맨 오른쪽으로 조정한 예이다.다음은 각 카운티의 면적과 인구의 산점도이다.대부분의 인구가 100만 미만에 몰려 있어서 그래프를 확인하기 어렵다. 이렇듯 한쪽으로 편향된 데이터를 가진 경우 로그 변환을 하면 데이터를 구분하기 좋은 때가 많다. 앞의 그래프의 y축을 로그 축적으로 변경해 보자.","code":"\nmidwest#> # A tibble: 437 × 28\n#>      PID county    state  area poptotal popden…¹ popwh…² popbl…³ popam…⁴ popas…⁵\n#>    <int> <chr>     <chr> <dbl>    <int>    <dbl>   <int>   <int>   <int>   <int>\n#>  1   561 ADAMS     IL    0.052    66090    1271.   63917    1702      98     249\n#>  2   562 ALEXANDER IL    0.014    10626     759     7054    3496      19      48\n#>  3   563 BOND      IL    0.022    14991     681.   14477     429      35      16\n#>  4   564 BOONE     IL    0.017    30806    1812.   29344     127      46     150\n#>  5   565 BROWN     IL    0.018     5836     324.    5264     547      14       5\n#>  6   566 BUREAU    IL    0.05     35688     714.   35157      50      65     195\n#>  7   567 CALHOUN   IL    0.017     5322     313.    5298       1       8      15\n#>  8   568 CARROLL   IL    0.027    16805     622.   16519     111      30      61\n#>  9   569 CASS      IL    0.024    13437     560.   13384      16       8      23\n#> 10   570 CHAMPAIGN IL    0.058   173025    2983.  146506   16559     331    8033\n#> # … with 427 more rows, 18 more variables: popother <int>, percwhite <dbl>,\n#> #   percblack <dbl>, percamerindan <dbl>, percasian <dbl>, percother <dbl>,\n#> #   popadults <int>, perchsd <dbl>, percollege <dbl>, percprof <dbl>,\n#> #   poppovertyknown <int>, percpovertyknown <dbl>, percbelowpoverty <dbl>,\n#> #   percchildbelowpovert <dbl>, percadultpoverty <dbl>,\n#> #   percelderlypoverty <dbl>, inmetro <int>, category <chr>, and abbreviated\n#> #   variable names ¹​popdensity, ²​popwhite, ³​popblack, ⁴​popamerindian, …\np <- ggplot(midwest, aes(percwhite, percollege)) + geom_point()\np\np + scale_x_continuous(breaks=seq(0, 100, by=10), \n                  labels=paste0(seq(0, 100, by=10),\"%\"))\np + scale_x_continuous(breaks=seq(0, 100, by=10),  \n                       labels=paste0(seq(0, 100, by=10),\"%\"),\n                       limits=c(60, 100)) +\n  scale_y_continuous(name=\"Percent college educated\")#> Warning: Removed 2 rows containing missing values (`geom_point()`).\np + scale_x_continuous(position=\"top\") +\n  scale_y_continuous(position=\"right\")\nap <- ggplot(midwest, aes(area, poptotal)) + geom_point() +\n  geom_smooth(method=\"lm\")\nap#> `geom_smooth()` using formula = 'y ~ x'\nap + scale_y_continuous(trans=\"log10\")#> `geom_smooth()` using formula = 'y ~ x'"},{"path":"ch-visualization.html","id":"좌표계의-변경","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.9.2 좌표계의 변경","text":"가끔은 그래프의 x와 y축을 변경하고 싶을 때가 있다. 산점도의 경우는 x와 y의 매핑을 바꾸면 간단히 축을 서로 바꿀 수 있지만 다음처럼 히스토그램의 가로축과 세로축을 바꾸려면 좀 복잡한 작업이 필요하다.이럴 때 쉽게 사용할 수 있는 것이 coord_flip() 함수이다. coord_flip() 함수는 그래프의 가로축과 세로축을 바꾸어 준다.coord_flip() 함수 말고도 좌표계를 변경하는 함수들이 있다. coord_polar()는 직교좌표계를 극좌표계로 변경해 준다.","code":"\np <- ggplot(mpg, aes(cty)) + geom_histogram(binwidth=1)\np\np + coord_flip()\np + coord_polar()\nggplot(mpg, aes(class, fill=drv)) + \n  geom_bar(position=\"fill\") + coord_polar()"},{"path":"ch-visualization.html","id":"색상-척도color-scales의-변경","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.9.3 색상 척도(color scales)의 변경","text":"ggplot2는 x와 y에 매핑되는 데이터 열의 값의 범위에 따라 좌표축을 자동 생성한다. 마찬가지로 color나 fill 등의 속성에 매핑되는 데이터 열에 따라 자동으로 색상의 척도를 자동으로 지정하여, 데이터의 값에 따라 적절한 색상을 선택하여 그래프를 그린다.ggplot2는 데이터 열을 색상 속성에 매핑할 때 데이터 열이 연속형 변수인지, 이산형 변수인지에 따라 색상 척도를 다르게 설정한다. 다음 두 그래프를 비고해 보자. 첫번째 그래프는 점의 color 속성에 이산형 변수인 drv가 매핑되었고, 두번재 그래프는 color에 연속형 변수인 cty가 매핑되었다.이산형 변수는 구분되는 색상이 지정되는 반면, 연속형 변수는 색상의 그라데이션으로 매핑이 되는 것을 볼 수 있다. 그 이유는 이산형 변수는 구분되는 제한된 값만 가지므로 정해진 색상으로 그래프를 표현할 수 있는 반면, 연속형 변수는 무수히 많은 값을 가질 수 있으므로 색상의 그라데이션의 연속적인 변화로 표현하는 것이 더 적절하기 때문이다.가끔 데이터의 열이 수치로 입력이 되었지만 이산형 데이터인 경우가 있다. 예를 들어 mpg 데이터의 year는 수치로 데이터가 입력되었지만 구분되는 두 개의 연도를 가진 변수이다. 이렇듯 이산형 변수가 수치로 입력이 되어 있으면 ggplot2는 이 데이터가 연속형 수치로 판단을 하여 그라데이션으로 색상을 표현한다. 이를 방지하려면 원래의 데이터를 factor로 변환하여 이산형 변수로 변환해 주면 구별되는 색상으로 그래프를 표현한다.ggplot2가 디폴트로 매핑한 색상이 마음에 들지 않으면 이를 직접 조정할 수 있다. 이를 위해서는 색상에 대한 기본적인 지식을 가지고 있어야 한다. 이 책에서는 세부적인 색상 지정과 관련된 내용은 다루지 않고, 대신 이산형 변수와 연속형 변수에 대해서 이미 만들어져 있는 색상 척도 중 하나로 색상 척도를 변경하는 방법만 다루도록 한다.\n이산형 변수의 색상 매핑은 ColorBrewer에서 지정한 색상 매핑(팔레트)을 사용할 수 있다. RColorBrewer 패키지는 ColorBrewer에서 제공하는 다양한 색상 척도를 R에서 사용할 수 있도록 해 준다. RColorBrewer 패키지에서 사용할 수 있는 색상 팔레트를 확인해 보려면 다음 명령을 실행해 본다.팔레트에 대한 좀 더 자세한 설명을 확인하려면 다음을 수행한다. maxcolors 열은 팔레트가 이산형 변수에 사용되었을 때 최대 몇 개의 범주를 나타낼 수 있는지를 나타낸다. colorblind 열은 해당 팔레트가 색맹 친화적인 팔레트인지 아닌지에 대한 정보를 준다. category 열은 팔레트의 종류를 나타낸다.Qualitative (qual) 팔레트는 명목형 범주를 나타내기에 좀 더 적합한 팔레트로, 수치형이나 순서형 변수를 표현하기에는 적합하지 않은 팔레트이다.Sequential (seq) 팔레트는 색상이 밝은 색상에서 어두운 색상으로 변화하는 팔레트로 수치형이나 순서형 변수를 표현하기에 적합한 팔레트이다.Diverging (div) 팔레트는 팔레트로 수치형이나 순서형 변수를 표현하기에 적합한 팔레트인 것은 seq 팔레트와 동일하지만, 가운데 값을 밝은 색상으로, 양 극단의 값을 어두운 색으로 표현하여 가운데에 분포한 값과 극단에 위치한 값을 구분하여 표현하고 싶을 때 사용한다.이산형 변수로 매핑된 color 또는 fill의 ColorBrewer 척도를 바꾸려면 scale_color_brewer() 또는 scale_fill_brewer()를 사용한다.연속형 변수로 매핑된 color 또는 fill도 ColorBrewer 척도를 이용하여 연속적인 그라데이션으로 연속형 변수의 값을 표현할 수 있다. ColorBrewer 척도를 바꾸려면 scale_color_distiller() 또는 scale_fill_distiller()를 사용한다. Distiller 척도는 팔레트의 색상을 내삽하여 부드러운 그라데이션을 만들어 준다.","code":"\np <- ggplot(mpg, aes(displ, hwy))\np + geom_point(aes(color=drv), size=2)\np + geom_point(aes(color=cty), size=2)\np <- ggplot(mpg, aes(displ, hwy))\np + geom_point(aes(color=year), size=2)\np + geom_point(aes(color=factor(year)), size=2)\nRColorBrewer::display.brewer.all()\nRColorBrewer::brewer.pal.info#>          maxcolors category colorblind\n#> BrBG            11      div       TRUE\n#> PiYG            11      div       TRUE\n#> PRGn            11      div       TRUE\n#> PuOr            11      div       TRUE\n#> RdBu            11      div       TRUE\n#> RdGy            11      div      FALSE\n#> RdYlBu          11      div       TRUE\n#> RdYlGn          11      div      FALSE\n#> Spectral        11      div      FALSE\n#> Accent           8     qual      FALSE\n#> Dark2            8     qual       TRUE\n#> Paired          12     qual       TRUE\n#> Pastel1          9     qual      FALSE\n#> Pastel2          8     qual      FALSE\n#> Set1             9     qual      FALSE\n#> Set2             8     qual       TRUE\n#> Set3            12     qual      FALSE\n#> Blues            9      seq       TRUE\n#> BuGn             9      seq       TRUE\n#> BuPu             9      seq       TRUE\n#> GnBu             9      seq       TRUE\n#> Greens           9      seq       TRUE\n#> Greys            9      seq       TRUE\n#> Oranges          9      seq       TRUE\n#> OrRd             9      seq       TRUE\n#> PuBu             9      seq       TRUE\n#> PuBuGn           9      seq       TRUE\n#> PuRd             9      seq       TRUE\n#> Purples          9      seq       TRUE\n#> RdPu             9      seq       TRUE\n#> Reds             9      seq       TRUE\n#> YlGn             9      seq       TRUE\n#> YlGnBu           9      seq       TRUE\n#> YlOrBr           9      seq       TRUE\n#> YlOrRd           9      seq       TRUE\np_drv <- p + geom_point(aes(color=drv), size=2)\np_drv\np_drv + scale_color_brewer(palette = \"Set1\")\np_drv + scale_color_brewer(palette = \"Accent\")\np_drv + scale_color_brewer(palette = \"Spectral\")\np_cty <- p + geom_point(aes(color=cty), size=2)\np_cty\np_cty + scale_color_distiller(palette = \"RdPu\")\np_cty + scale_color_distiller(palette = \"YlOrBr\")\np_cty + scale_color_distiller(palette = \"Greens\")"},{"path":"ch-visualization.html","id":"labelsmodification","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.9.4 레이블 조정","text":"ggplot2는 그래프의 좌표축과 범례의 이름을 자동으로 설정한다.\n기본 설정은 사용된 열 이름이나 표현식이다.\n데이터를 탐색하기 위해 그래프를 그리는 동안에는 이러한 레이블을 사용하는 것은 문제가 없지만, 발표를 위해서는 독자가 이해하기 쉬운 레이블로 그래프의 제목, 축 이름, 범례의 이름을 바꿔주는 것이 좋다.labs() 함수는 그래프의 제목, 축 이름, 범례의 이름을 쉽게 바꿀 수 있게 해준다.위 그래프를 다음처럼 범례 이름, 축의 이름, 그래프의 제목을 좀 더 의미있는 내용으로 바꾸어 보자.","code":"\np <- ggplot(mpg, aes(displ, cty, color=class, shape=factor(cyl))) + geom_point()\np\np <- p + labs(title=\"displacement vs. city fuel economy\", \n         x=\"displacement(liter)\", y=\"city fuel economy(miles/gallon)\",\n         color=\"car class\", shape=\"number of cylinders\")\np"},{"path":"ch-visualization.html","id":"themes","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.9.5 테마 변경","text":"테마는 ggplot2 그래프의 전체적인 외양을 결정한다. 테마는 그래프의 배경 색, 글자 폰트, 격자선 모양, 범례의 위치 등의 그래프의 외양을 결정한다. theme_gray()는 디폴트 테마이며, 다음처럼 테마 함수를 추가하면 관련 테마가 적용된다.지금까지는 ggplot2 패키지가 자체적으로 제공하는 테마만 보았다. ggthemes 패키지를 설치하면 더 많은 테마를 사용할 수 있다.ggthemes 패키지가 제공하는 테마는 매우 많지만 그 중에 몇 가지 예만 살펴본다.이 중에 어떤 테마를 사용하는가는 시각화의 목적과 사용자의 취향에 달려있다.\n그런데 좋은 데이터 시각화의 원칙에서 보면 그래프는 높은 데이터 밀도를 가져야 한다.\n높은 데이터 밀도란 사용된 잉크 대비 표현되는 데이터가 많은 것을 의미한다.\n따라서 뒷 배경이 복잡하거난 색상이 많은 테마보다는 간결한 테마를 선택하는 것이 좋다.\n그래야 시각화에서 강조하려는 부분을 강조할 수 있는 여유 공간이 그래프에 생기고, 독자가 더 빨리 그래프의 의미를 알아차릴 수 있다.그런데 모든 그래프에 기본 테마가 아닌 테마를 일괄 적용하고 싶으면, 모든 그래프에 해당 theme 함수를 일일이 적용하기보다는 기본 테마 설정을 변경하는 것이 편리하다.\ntheme_get() 함수는 현재의 기본 테마를 반환하고, theme_set() 함수는 기본 테마를 변경한다.\n현재의 기본 테마를 임시 저장한 후, 새로운 테마로 그래프를 그리고, 다시 원해의 기본 테마를 복원하고자 할 때, 이 두 함수가 사용된다. (theme_set()은 현재의 기본 테마를 반환하기 때문에 다음 예에서 oldTheme 변수에 기존 테마를 저장하는 작업을 theme_set() 함수에서도 할 수도 있다.)사용자는 테마를 바꾸는 것뿐만 아니라, 현재 적용된 테마에 설정된 각 요소를 theme() 함수를 사용하여 직접 변경할 수 있다. 테마에서 가장 빈번이 변경되는 요소가 범례의 위치이다.이 외에도 그래프 레이블들의 형태와 백그라운드 색 등 다양한 요소를 조정할 수 있다. 더 자세한 내용을 알고싶으면 ??theme을 이용하여 관련 도움말을 확인하기 바란다. 만약 빈번히 사용되는 테마 요소가 있다면 다음 예처럼 변수에 저장을 해 둔 후, 여러 그래프에 적용시킬 수 있다.그런데 다수의 그래프에 변경된 테마 요소를 적용하여 한다면, 테마 요소를 변수에 저장하였어도 매번 그래프에 일일이 적용해야 하므로 꽤 번거롭다.\n이 경우 theme_update() 함수를 사용하면 기본 테마의 요소를 변경할 수 있다.\ntheme_update() 함수는 theme_set() 함수와 마찬가지로 기존 기본 테마를 반환하므로 이를 저장하였다가 다시 원래의 테마를 복원할 수 있다.","code":"\np + theme_gray()\np + theme_bw()\np + theme_dark()\np + theme_light()\np + theme_linedraw()\np + theme_classic()\np + theme_minimal()\ninstall.packages(\"ggthemes\")#> '/home/sys4ppl/R/x86_64-pc-linux-gnu-library/4.2'의 위치에 패키지(들)을 설치합니다.\n#> (왜냐하면 'lib'가 지정되지 않았기 때문입니다)\np + ggthemes::theme_base()       # R의 기본 graphics과 유사한 테마\np + ggthemes::theme_economist()  # The Economist 그래프와 유사한 테마\np + ggthemes::theme_excel()      # MS Excel 그래프와 유사한 테마\np + ggthemes::theme_few()        # Stephen Few가 주창한 가이드를 따르는 테마\np + ggthemes::theme_tufte()      # Edward Turfte가 주창한 가이드를 따르는 테마\noldTheme <- theme_get()     # 현재 기본 테마 저장\np                           # 현재의 기본 테마로 그래프 출력\ntheme_set(theme_classic())  # theme_classic으로 기본 테마 설정 \np                           # 바뀐 기본 테마로 그래프 출력\np + labs(shape = \"실린더 수\", color = \"분류\")\np + geom_hline(yintercept = mean(mpg$cty), linetype=2)\ntheme_set(oldTheme)         # 원래의 기본 테마 복원\np                           # 원래의 기본 테마로 그래프 출력\np + theme(legend.position = \"bottom\")\nmyTheme <- theme(\n    plot.title=element_text(face=\"bold.italic\", size=16, color=\"orange\", hjust=0.5),\n    panel.background = element_rect(fill=\"lightyellow\", color=\"green\"),\n    legend.position = \"top\")\np + myTheme\nggplot(mpg, aes(hwy, fill=drv)) + geom_histogram() + \n  labs(title=\"A graph with my theme\") + myTheme #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\np\noldTheme <- theme_update(\n    plot.title=element_text(face=\"bold.italic\", size=16, color=\"orange\", hjust=0.5),\n    panel.background = element_rect(fill=\"lightyellow\", color=\"green\"),\n    legend.position = \"top\")\np\np + geom_hline(yintercept = mean(mpg$cty), linetype=2)\ntheme_set(oldTheme)"},{"path":"ch-visualization.html","id":"misc","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.10 기타 유용한 팁들","text":"","code":""},{"path":"ch-visualization.html","id":"combinegraph","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.10.1 여러 그래프를 한 도표에 넣기","text":"ggplot2에서 그린 여러 그래프를 한 도표에 넣으려면 gridExtra 패키지의 grid.arrange() 함수를 이용하면 편리하다.\ngridExtra 패키지를 사용하려면 먼저 설치를 해야 한다.그리고 나서 메모리에 적재한다.다음처럼 4개의 그래프를 ggplot2로 그렸다고 해보자. grid.arrange() 함수는 다양한 방식으로 그래프를 조합하여 하나의 도표를 만들 수 있다.다음은 arrangeGrob() 함수로 그래프를 묶은 다음 다시 이를 grid.arrange()에 보내 좀더 다양한 레이아웃의 그래프를 그린 예이다.그런데 gridExtra 패키지의 grid.arrange() 함수는 조합하는 그래프의 패널을 정렬하지 않는다.\n따라서 조합된 각 그래프의 축들이 서로 정렬이 되어 나타나지 않을 수 있다.\n아울러 조합되는 그래프에 공통된 범례가 있는 경우 하나의 법례를 공통으로 나타내기도 어렵다.\nggpubr 패키지의 ggarrange()을 사용하면 조합되는 그래프의 패널을 정렬시키고 공통의 범례를 부여할 수 있다.\nggpubr 패키지에 대한 자세한 내용은 ggpubr: ‘ggplot2’ Based Publication Ready Plots을 참조한다.","code":"\ninstall.packages(\"gridExtra\")\nlibrary(gridExtra)#> \n#> 다음의 패키지를 부착합니다: 'gridExtra'#> The following object is masked from 'package:dplyr':\n#> \n#>     combine\np1 <- ggplot(mpg, aes(drv, displ)) + geom_jitter()\np2 <- ggplot(mpg, aes(drv, displ)) + geom_boxplot()\np3 <- ggplot(mpg, aes(drv, displ)) + geom_violin()\ngrid.arrange(p1, p2, p3, ncol=3)\ngrid.arrange(p1, p2, p3, nrow=2, ncol=2) \ngrid.arrange(p1, p2, p3, ncol=3, widths=c(0.5, 0.25, 0.25))\ngrid.arrange(p1, p2, p3, nrow=3, heights=c(0.25, 0.25, 0.5))\ngrid.arrange(p1, arrangeGrob(p2, p3, ncol=2, widths=c(0.6, 0.4)), nrow=2, heights=c(0.4, 0.6))"},{"path":"ch-visualization.html","id":"savegraph","chapter":"8 ggplot2를 이용한 데이터 시각화","heading":"8.10.2 그래프 저장하기","text":"RStudio 사용자가 R에서 그린 그래프를 저장하려면, RStudio의 [Plot] 패널에서 [Export]-[Save Image…] 메뉴를 이용하면 된다. 이 메뉴를 사용하면 그래프를 저장할 파일 형식, 위치, 이름, 크기를 지정하여 저장할 수 있다. R 콘솔에서 그래프를 저장하려면 다음처럼 ggsave() 함수를 이용한다.","code":"\np <- ggplot(mpg, aes(cty, hwy)) + geom_point()\nggsave(file=\"myplot.png\", plot=p, width=5, height=4)"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"ch-R-Advanced-Data-Mgmt","chapter":"9 R 고급 데이터 변환","heading":"9 R 고급 데이터 변환","text":"7 장과 8 장에서 정돈 형식의 데이터를 변환하고 시각화하는 방법을 배웠다. 그러나 실제 데이터 분석에서는 분석하고자 하는 데이터가 하나의 데이터 프레임에 정돈 형식으로 제공되는 경우가 많지 않다. 대부분의 경우 다음 두 가지 작업 중 하나 또는 두 가지 모두가 필요한 경우가 많다.[Merge] 다양한 원천에서 획득된 데이터를 하나의 정돈 형식의 데이터로 결합하기[Reshape] 비정돈 형식의 데이터를 정돈 데이터 형식으로 변형하기본 장에서는 이러한 데이터 전처리에 필요한 다양한 기법을 논의한다.\n데이터의 결합을 위해서는 dplyr 패키지를 사용할 것이며, 비정돈 형식의 데이터를 정돈 데이터 형식으로 변형하기 위해서는 tidyr 패키지를 사용할 것이다. 이 두 패키지는 모두 tidyverse 패키지에 속해 있으므로, 이 두 패키지를 사용하기 위해서 tidyverse 패키지를 적재한다.","code":"\nlibrary(tidyverse)"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"데이터의-단순-결합","chapter":"9 R 고급 데이터 변환","heading":"9.1 데이터의 단순 결합","text":"","code":""},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"행으로-결합-vs.-열로-결합","chapter":"9 R 고급 데이터 변환","heading":"행으로 결합 vs. 열로 결합","text":"데이터에 대한 결합이 필요한 다음 두 가지 상황을 고려해 보자.데이터가 동일한 열 형식으로 여러 파일로 나뉘어져 있는 경우: 예를 들어 판매 실적 데이터가 2021년 데이터는 2021.csv 파일에 2022년 데이터는 2022.csv 파일에 있다고 가정해 보자. 이 경우 각 파일을 별도의 데이터 프레임으로 읽어들인 후 행으로 결합시켜야 할 것이다.데이터가 동일한 열 형식으로 여러 파일로 나뉘어져 있는 경우: 예를 들어 판매 실적 데이터가 2021년 데이터는 2021.csv 파일에 2022년 데이터는 2022.csv 파일에 있다고 가정해 보자. 이 경우 각 파일을 별도의 데이터 프레임으로 읽어들인 후 행으로 결합시켜야 할 것이다.데이터가 동일한 행으로 되어 있으나, 서로 다른 열을 가지고 있는 경우: 예를 들어 사원 번호 순으로 한 파일에는 입사시점의 개인 정보가, 다른 파일에는 작년 인사 평가 결과 데이터가 있다고 하자. 두 파일에 동일한 사원 번호 순으로 데이터가 기록되어 있다면 두 파일의 정보를 데이터 프레임으로 읽어들인 후 열로 결합하여야 할 것이다.데이터가 동일한 행으로 되어 있으나, 서로 다른 열을 가지고 있는 경우: 예를 들어 사원 번호 순으로 한 파일에는 입사시점의 개인 정보가, 다른 파일에는 작년 인사 평가 결과 데이터가 있다고 하자. 두 파일에 동일한 사원 번호 순으로 데이터가 기록되어 있다면 두 파일의 정보를 데이터 프레임으로 읽어들인 후 열로 결합하여야 할 것이다.데이터 프레임을 행과 열로 결합하는 작업은 6 장에서 소개한 R의 기본 함수인 rbind()와 cbind()를 사용하여도 수행할 수 있다. 그러나 여기에서는 dplyr 패키지의 bind_rows()와 bind_cols() 함수를 사용하여 여러 데이터 프레임을 행과 열로 결합할 것이다.\nbind_rows()와 bind_cols() 함수를 사용하는 이유는 이 두 함수가 R의 기본 함수보다 처리 속도가 빠를 뿐 아니라, R의 기본 함수보다는 편리한 기능을 가지고 있기 때문이다.","code":""},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"데이터를-행으로-결합하기","chapter":"9 R 고급 데이터 변환","heading":"9.1.1 데이터를 행으로 결합하기","text":"","code":""},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"열-구조가-다른-데이터를-행으로-결합하기","chapter":"9 R 고급 데이터 변환","heading":"열 구조가 다른 데이터를 행으로 결합하기","text":"데이터를 행으로 결합하는 작업이 필요한 경우, 데이터가 동일한 열 구조를 가지고 있지 않은 경우가 종종 발생한다. 동일한 열을 가지고 있더라도 열 이름이 서로 다른 경우도 있다. 이런 경우에는 결합하려는 데이터 프레임을 동일한 열 구조로 변형하여 결합하여야 한다.앞으로의 예제들은 다음 파일에 포함된 데이터를 사용하니 예제를 따라하고자 하는 분들은 내려받기를 하자.내려받은 파일을 우클릭하여 RStudio로 열거나 내려받은 파일이 있는 폴더를 작업디렉토리로 설정한 후 다음 명령을 수행하면\nclass1과 class2 등의 데이터가 적재된다. 이 데이터는 대학의 어떤 강의의 두 분반의 중간 및 기말 고사 정보이다.두 데이터 모두 학번(ID), 중간고사(Midterm), 기말고사(Final), 프로젝트 팀(Team), 성별(Gender), 학년(Year)에 대한 정보를 포함하고 있으나, class1에는 학생의 주소(Address) 열이 포함되어 있고 class2는 그렇지 않다. 또한 두 데이터의 열의 위치와 이름도 조금 다르다.","code":"\nload(\"advancedDataMgmt.RData\")\nclass1#>    ID   Name Gender Year Address Midterm Final Team\n#> 1  15 김철수      M    1    서울      78    59    A\n#> 2  18 김영희      F    3    경기      85    87    A\n#> 3  25 이철수      M    3    충남      80    70    B\n#> 4  34 이영희      F    2    대전      92    89    B\n#> 5 151 홍길동   Male    4    세종      58    66    B\nclass2#>   ID Mid Final   Name Team Gen Year\n#> 1 12  75    79 장철수    C   M    2\n#> 2 19  75    89 장영희    C   F    2\n#> 3 28  87    76 최철수    D   M    1\n#> 4 45  82    79 최영희    D   F   30"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"rbind는-열의-개수가-다른-데이터-프레임을-행으로-결합하지-못한다.","chapter":"9 R 고급 데이터 변환","heading":"rbind()는 열의 개수가 다른 데이터 프레임을 행으로 결합하지 못한다.","text":"두 분반 학생의 점수를 통합하여 성적 처리를 하기 위해 두 분반의 데이터를 결합하려고 한다고 하자. 이를 어떻게 수행하여야 할까? rbind()로 먼저 두 데이터 프레임을 통합하려고 시도해 보자.열의 수가 다르기 때문에 결합이 되지 않음을 알 수 있다. 따라서 rbind()로 두 데이터를 결합하려면 class1에만 있는 Address 열을 어떻게 처리할지를 결정해야 한다. 일반적으로 다음 둘 중 하나의 방법을 택하여 문제를 해결한다. 첫번째 방법은 class1의 Address 열을 제외하고 결합하는 것이고, 두번째 방법은 class2에 Address 열을 추가하고 결측치(NA)로 값을 준 후 결합하는 것이다.","code":"\nrbind(class1, class2)#> Error in rbind(deparse.level, ...): numbers of columns of arguments do not match"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"bind_rows는-열의-개수가-다른-데이터-프레임임도-행으로-결합을-한다.","chapter":"9 R 고급 데이터 변환","heading":"bind_rows()는 열의 개수가 다른 데이터 프레임임도 행으로 결합을 한다.","text":"두 분반 학생의 데이터를 dplyr 패키지의 bind_rows() 함수를 사용하여 연결해 보자.열의 개수가 달라도 결합이 이루어지는 것을 볼 수 있다. 두 데이터에서 서로 없는 열은 결측치 NA로 처리되어 결합이 이루어지는 것을 볼 수 있다. 그러나 사실 class1의 Midterm과 class2의 Mid는 중간고사 점수 열로 같은 정보가 다른 열 이름으로 표현된 것 뿐이다. bind_rows()는 이름이 다르면 서로 다른 열이라고 생각하여 각각 새로운 열을 만들어 결합을 한다. 그러므로 사실상 같은 열이 서로 다른 이름으로 되어 있다면 이름을 동일하게 바꾸어 주어서 결합을 하여야 한다.","code":"\nbind_rows(class1, class2)#>    ID   Name Gender Year Address Midterm Final Team Mid  Gen\n#> 1  15 김철수      M    1    서울      78    59    A  NA <NA>\n#> 2  18 김영희      F    3    경기      85    87    A  NA <NA>\n#> 3  25 이철수      M    3    충남      80    70    B  NA <NA>\n#> 4  34 이영희      F    2    대전      92    89    B  NA <NA>\n#> 5 151 홍길동   Male    4    세종      58    66    B  NA <NA>\n#> 6  12 장철수   <NA>    2    <NA>      NA    79    C  75    M\n#> 7  19 장영희   <NA>    2    <NA>      NA    89    C  75    F\n#> 8  28 최철수   <NA>    1    <NA>      NA    76    D  87    M\n#> 9  45 최영희   <NA>   30    <NA>      NA    79    D  82    F"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"rbind는-두-데이터의-열의-이름이-다른-경우-행으로-결합하지-못한다.","chapter":"9 R 고급 데이터 변환","heading":"rbind()는 두 데이터의 열의 이름이 다른 경우 행으로 결합하지 못한다.","text":"class1 데이터의 Address 열을 제외하고 두 데이터를 다시 rbind()로 결합해 보자.rbind()는 열의 개수가 동일하더라도 두 데이터 프레임의 열의 이름이 서로 다르면 행으로 결합하지 못함을 볼 수 있다. 지금 중간고사 점수 열과 성별 열의 이름이 서로 다르기 때문에 연결이 안되는 것이므로 다음처럼 열의 이름을 변경한 후 두 데이터 프레임을 행으로 연결시킨다.","code":"\nrbind(select(class1, -Address), class2)#> Error in match.names(clabs, names(xi)): 이전에 사용된 이름들과 일치하지 않습니다.\nrbind(select(class1, -Address), rename(class2, Midterm = Mid, Gender = Gen))#>    ID   Name Gender Year Midterm Final Team\n#> 1  15 김철수      M    1      78    59    A\n#> 2  18 김영희      F    3      85    87    A\n#> 3  25 이철수      M    3      80    70    B\n#> 4  34 이영희      F    2      92    89    B\n#> 5 151 홍길동   Male    4      58    66    B\n#> 6  12 장철수      M    2      75    79    C\n#> 7  19 장영희      F    2      75    89    C\n#> 8  28 최철수      M    1      87    76    D\n#> 9  45 최영희      F   30      82    79    D"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"rbind와-bind_rows는-열의-순서를-자동으로-맞춘다.","chapter":"9 R 고급 데이터 변환","heading":"rbind()와 bind_rows()는 열의 순서를 자동으로 맞춘다.","text":"이제 두 데이터 프레임의 열의 형태가 같아졌으므로 bind_rows()로 두 데이터를 원하는 방식으로 합칠 수 있다.\n두 데이터 프레임의 열의 순서가 다른 경우 rbind()와 bind_rows()는 첫번째 데이터 프레임의 열 이름을 기준으로 열의 순서를 자동으로 맞추어 준다.","code":"\nclass12 <- bind_rows(select(class1, -Address), \n             rename(class2, Midterm = Mid, Gender = Gen))\nclass12#>    ID   Name Gender Year Midterm Final Team\n#> 1  15 김철수      M    1      78    59    A\n#> 2  18 김영희      F    3      85    87    A\n#> 3  25 이철수      M    3      80    70    B\n#> 4  34 이영희      F    2      92    89    B\n#> 5 151 홍길동   Male    4      58    66    B\n#> 6  12 장철수      M    2      75    79    C\n#> 7  19 장영희      F    2      75    89    C\n#> 8  28 최철수      M    1      87    76    D\n#> 9  45 최영희      F   30      82    79    D"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"합쳐지는-데이터에-식별자-부여하기","chapter":"9 R 고급 데이터 변환","heading":"합쳐지는 데이터에 식별자 부여하기","text":"앞의 class1과 class2 데이터는 1분반과 2분반 학생의 데이터이다. 그런데 이 두 데이터를 행으로 결합한 데이터에서는 각 행이 어떤 데이터에서 온 것인지에 대한 정보가 없기 때문에 학생이 속한 분반을 확인할 수 없다.\n이런 경우 bind_rows()의 .id 인수를 사용하면, 결합되는 데이터의 순서에 따라 일련번호를 부여하는 열을 생성할 수 있다.실제 데이터를 행으로 결합하는 과정에는 훨씬 더 다양한 문제들이 발생한다. 예를 들어 동일한 키를 나타내는 열이 하나는 cm로 하나는 m 단위로 정보가 주어져 있으면 이를 하나의 단위로 통일해야 한다. 그러나 복잡한 문제들도 결국 서로 다른 열 구조를 행으로 결합하기 위해서 어떤 열을 추가하거나 제외할 것인지를 결정하고, 열의 형식과 이름을 어떻게 통일할 것인가를 고려하는 과정이라는 점에서 본질적으로는 앞의 예와 동일하다 할 수 있다.","code":"\nbind_rows(select(class1, -Address), \n         rename(class2, Midterm = Mid, Gender = Gen),\n         .id = \"Class\")  # class 열로 데이터 출처 식별#>   Class  ID   Name Gender Year Midterm Final Team\n#> 1     1  15 김철수      M    1      78    59    A\n#> 2     1  18 김영희      F    3      85    87    A\n#> 3     1  25 이철수      M    3      80    70    B\n#> 4     1  34 이영희      F    2      92    89    B\n#> 5     1 151 홍길동   Male    4      58    66    B\n#> 6     2  12 장철수      M    2      75    79    C\n#> 7     2  19 장영희      F    2      75    89    C\n#> 8     2  28 최철수      M    1      87    76    D\n#> 9     2  45 최영희      F   30      82    79    D"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"데이터를-열로-결합하기","chapter":"9 R 고급 데이터 변환","heading":"9.1.2 데이터를 열로 결합하기","text":"","code":""},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"행-순서가-다른-데이터를-열로-결합하기","chapter":"9 R 고급 데이터 변환","heading":"행 순서가 다른 데이터를 열로 결합하기","text":"데이터를 열로 결합하는 경우 실제 데이터가 동일한 행 순서로 정렬되어 있지 않은 경우가 종종 있다.\n예를 들어 앞의 예에서 성적 처리를 위해서는 학생의 중간, 기말 고사 점수와 함께 출석 점수를 고려해야 한다고 하자. 그리고 출석점수는 attendance 데이터 프레임에 다음과 같이 class1과 class2의 모든 학생의 학번(ID) 순으로 정렬되어 분반 정보(Class)와 출석 점수(Attend)가 저장되어 있다고 하자.앞서 두 분반의 중간 및 기말 고사 데이터가 합쳐진 class12는 학번이 기준이 아니라 분반으로 정렬되어 있다. 따라서 이 두 데이터 프레임을 단순하게 열로 결합하면 출석점수가 엉뚱한 학생에게 부여된다.","code":"\nattendance#>    ID Class Attend\n#> 1  12     2    185\n#> 2  15     1     90\n#> 3  18     1     95\n#> 4  19     2    100\n#> 5  25     1    100\n#> 6  28     2    100\n#> 7  34     1    100\n#> 8  45     2    100\n#> 9 151     1     95"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"정렬-후-열로-결합하기","chapter":"9 R 고급 데이터 변환","heading":"정렬 후 열로 결합하기","text":"이를 해결하는 가장 간단한 방법은 두 데이터 프레임을 동일한 기준으로 정렬한 후 cbind()나 bind_cols()를 수행하는 것이다.\n먼저 class12를 ID 순으로 정렬한 후 열로 결합해 보자.\n그런데 ID 열은 두 데이터 프레임에 모두 있으므로 하나는 불필요하다. 따라서 attendance 데이터 프레임의 ID 열을 제거한 후 결합한다.다른 방법으로 attendance 데이터 프레임을 Class와 ID 열로 정렬한 후 class12 데이터 프레임과 결합할 수도 있다. attendence 데이터를 분반과 학번으로 정렬하여 class112와 순서를 맞춘 후 데이터를 열로 결합해 보자.실제 데이터는 이보다 더 복잡한 문제를 가지고 있는 경우가 많다. 예를 들어 한 파일에 있는 행이 다른 파일에는 없는 경우도 있다. 이러한 경우엔 그 행의 정보를 모두 제거할 것인지, 아니면 그 행에 대해 없는 정보는 NA로 하여 결합을 할지 결정해야 한다. 결국 cbind()나 bind_rows()를 이용하여 열로 결합하기 위해서는 두 데이터의 행이 동일한 개체에 대한 정보가 되도록 일치시키는 것이 중요하다. 그런데 매번 두 데이터가 동일한 행으로 결합되도록 정렬하여 결합하는 작업을 사용자가 직접 하는 것은 오류 발생 가능성이 많다. 따라서 이 작업은 다음에 소개하는 ’관계형 데이터베이스처럼 데이터 결합하기’에 소개하는 방법을 사용할 것을 권장한다.","code":"\nclass12.a <- bind_cols(arrange(class12, ID), select(attendance, -ID))\nclass12.a#>    ID   Name Gender Year Midterm Final Team Class Attend\n#> 1  12 장철수      M    2      75    79    C     2    185\n#> 2  15 김철수      M    1      78    59    A     1     90\n#> 3  18 김영희      F    3      85    87    A     1     95\n#> 4  19 장영희      F    2      75    89    C     2    100\n#> 5  25 이철수      M    3      80    70    B     1    100\n#> 6  28 최철수      M    1      87    76    D     2    100\n#> 7  34 이영희      F    2      92    89    B     1    100\n#> 8  45 최영희      F   30      82    79    D     2    100\n#> 9 151 홍길동   Male    4      58    66    B     1     95\nclass12.b <- bind_cols(class12, \n                attendance %>% arrange(Class, ID) %>% select(-ID))\nclass12.b#>    ID   Name Gender Year Midterm Final Team Class Attend\n#> 1  15 김철수      M    1      78    59    A     1     90\n#> 2  18 김영희      F    3      85    87    A     1     95\n#> 3  25 이철수      M    3      80    70    B     1    100\n#> 4  34 이영희      F    2      92    89    B     1    100\n#> 5 151 홍길동   Male    4      58    66    B     1     95\n#> 6  12 장철수      M    2      75    79    C     2    185\n#> 7  19 장영희      F    2      75    89    C     2    100\n#> 8  28 최철수      M    1      87    76    D     2    100\n#> 9  45 최영희      F   30      82    79    D     2    100"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"관계형-데이터베이스처럼-데이터-결합하기","chapter":"9 R 고급 데이터 변환","heading":"9.2 관계형 데이터베이스처럼 데이터 결합하기","text":"관계형 데이터베이스에서는 서로 다른 열 정보를 담고 있는 두 데이터 테이블을 key를 사용하여 join이라는 방식을 이용하여 연결시킨다. 여기서 key란 앞서 성적 데이터와 출석 데이터에서 특정 학생 정보임을 식별할 수 있는 학번(ID) 등을 말한다.R에서도 두 데이터 프레임을 관계형 데이터베이스의 join과 같은 방식으로 결합시킬 수 있다. 이 작업은 R의 기본 함수인 merge() 함수를 이용하여 수행할 수도 있고, dplyr 패키지의 join 함수들을 사용하여 수행할 수도 있다. 이 책에서는 dplyr의 join 함수들을 이용하여 관계형 데이터베이스처럼 결합하기를 수행하는 방법을 설명하도록 한다.","code":""},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"inner-join과-outer-join","chapter":"9 R 고급 데이터 변환","heading":"9.2.1 Inner join과 outer join","text":"앞의 예에서 우리는 중간, 기말 고사 점수를 가지고 있는 class12 데이터 프레임과 출석 점수를 가지고 있는 attendance 데이터 프레임을 합치기 위해 ID 열로 데이터 프레임을 정렬한 후 bind_cols()로 연결하였다. 이 작업은 dplyr의 inner_join() 함수를 이용하면 더 손쉽게 수행할 수 있다.","code":""},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"inner_join","chapter":"9 R 고급 데이터 변환","heading":"inner_join()","text":"inner_join() 함수는 결합할 두 데이터 프레임을 인수로 먼저 기술한 다음 인수에 어떤 열을 기준으로 결합할 것인지를 열 이름으로 기술한다. inner_join() 함수는 두 데이터 프레임에서 인수로 주어진 열의 값이 동일한 행을 서로 연결하여 새로운 데이터 프레임을 만든다. 또한 새로 만들어진 데이터 프레임은 열을 기준으로 정렬이 이루어진다.만약 두 데이터 프레임이 결합의 기준이 되는 열의 이름이 다르면 `= c(“key.x” = “key.y”) 형식으로 두 데이터 프레임의 키 열의 이름을 기술하여 결합하면 된다.만약 결합의 기준이 되는 열이 두 개 이상이면 `= c(“key1”, “key2”) 형식으로 기술한다.만약 결합의 기준이 되는 열이 두 개 이상이고 서로 이름이 다르면 = c(\"key1.x\" = \"key1.y\", \"key2.x\" = \"key2.y\") 형식으로 두 데이터 프레임의 키 열의 이름을 기술한다. 관련 정보는 inner_join() 함수의 도움말을 참조하라.","code":"\ninner_join(class12, attendance, by=\"ID\")#>    ID   Name Gender Year Midterm Final Team Class Attend\n#> 1  15 김철수      M    1      78    59    A     1     90\n#> 2  18 김영희      F    3      85    87    A     1     95\n#> 3  25 이철수      M    3      80    70    B     1    100\n#> 4  34 이영희      F    2      92    89    B     1    100\n#> 5 151 홍길동   Male    4      58    66    B     1     95\n#> 6  12 장철수      M    2      75    79    C     2    185\n#> 7  19 장영희      F    2      75    89    C     2    100\n#> 8  28 최철수      M    1      87    76    D     2    100\n#> 9  45 최영희      F   30      82    79    D     2    100"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"inner-join","chapter":"9 R 고급 데이터 변환","heading":"1:1 inner join","text":"앞의 예처럼 데이터가 결합되는 방식을 1 대 1 inner join이라고 부른다. 두 데이터 프레임에 ID가 동일한 학생은 오직 한 명만 존재하고, 두 데이터 프레임의 학생의 ID가 일 대 일로 대응된다. 따라서 두 데이터 프레임의 행들이 일 대 일로 결합되어 새로운 데이터 프레임이 생성된다.인수가 주어지지 않으면 inner_join() 함수는 두 데이터 프레임에서 이름이 같은 열을 찾고 그 열을 기준으로 결합을 한다. 따라서 위의 경우 인수를 설정하지 않으면, 두 데이터 프레임에 공통으로 있는 ID 열을 기준으로 데이터가 결합된다.","code":"\ninner_join(class12, attendance)#> Joining, by = \"ID\"#>    ID   Name Gender Year Midterm Final Team Class Attend\n#> 1  15 김철수      M    1      78    59    A     1     90\n#> 2  18 김영희      F    3      85    87    A     1     95\n#> 3  25 이철수      M    3      80    70    B     1    100\n#> 4  34 이영희      F    2      92    89    B     1    100\n#> 5 151 홍길동   Male    4      58    66    B     1     95\n#> 6  12 장철수      M    2      75    79    C     2    185\n#> 7  19 장영희      F    2      75    89    C     2    100\n#> 8  28 최철수      M    1      87    76    D     2    100\n#> 9  45 최영희      F   30      82    79    D     2    100"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"inner-join-1","chapter":"9 R 고급 데이터 변환","heading":"0:1 inner join","text":"앞서 inner_join() 함수는 두 데이터 프레임에서 인수로 주어진 열의 값이 같은 행을 서로 연결한다고 했다. 그러면 한 데이터 프레임에는 해당 개체의 정보가 있으나 다른 데이터 프레임에는 해당 개체의 정보가 없는 경우에 두 데이터 프레임을 연결하면 어떻게 될까?\n다음 예처럼 class1에는 1분반 학생의 데이터만 있고, attendance는 1, 2분반의 학생 데이터가 모두 있는 경우 두 데이터 프레임을 ID 열로 결합하는 경우를 고려해 보자. attendance에는 동일한 ID를 가지고 있는 학생이 오직 한 명만 존재하고, class1에는 attendance에 있는 학생 정보가 0개 또는 1개가 있는 경우이다. 이러한 데이터 결합 방식을 0 대 1 inner join이라고 부른다.Inner join은 두 데이터 프레임에서 by로 지정된 열이 값이 서로 대응이 되는 행만 남겨둔다. 따라서 위의 경우에는 class1에 있는 학생의 행으로만 구성된 데이터 프레임이 생성된다. 즉, 인수에 주어진 열이 서로 동일한 값을 가진 행만 결합되어 결과가 나오므로 한 쪽 데이터 프레임에 없는 행은 제거되었음을 알 수 있다.","code":"\ninner_join(class1, attendance, by=\"ID\")#>    ID   Name Gender Year Address Midterm Final Team Class Attend\n#> 1  15 김철수      M    1    서울      78    59    A     1     90\n#> 2  18 김영희      F    3    경기      85    87    A     1     95\n#> 3  25 이철수      M    3    충남      80    70    B     1    100\n#> 4  34 이영희      F    2    대전      92    89    B     1    100\n#> 5 151 홍길동   Male    4    세종      58    66    B     1     95"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"outer-join","chapter":"9 R 고급 데이터 변환","heading":"outer join","text":"한 쪽 데이터 프레임에 해당 행이 없더라도 어느 한쪽의 데이터 프레임에 행이 있으면 그 행을 포함시킬 필요가 있는 경우가 있다. 예를 들어 앞의 예에서 2분반의 중간 및 기말 고사 정보가 나중에 획득되면 추후 보강하기로 하고 현재 출석 점수가 있는 모든 학생의 정보가 나오도록 중간과 기말 점수와 출석 데이터를 결합한다고 하자.\n이러한 경우 outer_join 함수들을 사용한다. Outer join 함수는 다음 세 가지가 있다.left_join(x, y): x에 있는 행을 모두 유지하여 join을 수행한다.right_join(x, y): y에 있는 행을 모두 유지하여 join을 수행한다.full_join(x, y): x와 y의 모든 행을 유지하여 join을 수행한다.대신 한 쪽에 없는 정보는 모두 결측치 NA가 입력되어 결합된다.\n다음은 inner_join(), left_join(), right_join(), full_join()의 차이가 무엇인지를 보여주는 예이다.다음은 class1과 attendance 데이터에서 attendance의 모든 행을 남겨두는 outer join을 수행한 결과이다.","code":"\nx <- data.frame(id = 1:3, name = letters[1:3]); x#>   id name\n#> 1  1    a\n#> 2  2    b\n#> 3  3    c\ny <- data.frame(id = 2:4, addr = LETTERS[2:4]); y#>   id addr\n#> 1  2    B\n#> 2  3    C\n#> 3  4    D\ninner_join(x, y)#> Joining, by = \"id\"#>   id name addr\n#> 1  2    b    B\n#> 2  3    c    C\nleft_join(x, y)#> Joining, by = \"id\"#>   id name addr\n#> 1  1    a <NA>\n#> 2  2    b    B\n#> 3  3    c    C\nright_join(x, y)#> Joining, by = \"id\"#>   id name addr\n#> 1  2    b    B\n#> 2  3    c    C\n#> 3  4 <NA>    D\nfull_join(x, y)#> Joining, by = \"id\"#>   id name addr\n#> 1  1    a <NA>\n#> 2  2    b    B\n#> 3  3    c    C\n#> 4  4 <NA>    D\nright_join(class1, attendance, by=\"ID\")#>    ID   Name Gender Year Address Midterm Final Team Class Attend\n#> 1  15 김철수      M    1    서울      78    59    A     1     90\n#> 2  18 김영희      F    3    경기      85    87    A     1     95\n#> 3  25 이철수      M    3    충남      80    70    B     1    100\n#> 4  34 이영희      F    2    대전      92    89    B     1    100\n#> 5 151 홍길동   Male    4    세종      58    66    B     1     95\n#> 6  12   <NA>   <NA>   NA    <NA>      NA    NA <NA>     2    185\n#> 7  19   <NA>   <NA>   NA    <NA>      NA    NA <NA>     2    100\n#> 8  28   <NA>   <NA>   NA    <NA>      NA    NA <NA>     2    100\n#> 9  45   <NA>   <NA>   NA    <NA>      NA    NA <NA>     2    100"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"n-inner-join","chapter":"9 R 고급 데이터 변환","heading":"1:n inner join","text":"만약에 한 데이터 프레임에서 결합의 기준이 되는 열에 동일한 값이 여러번 나오면 어떻게 될까? 다음의 예를 살펴보면서 그 결과가 어떻게 되는지 확인해 보자.\n지금까지 우리는 class12.a라는 데이터 프레임에 중간, 기말, 출석 점수를 통합하였다. 그런데 다음과 같이 프로젝트 팀별로 프로젝트 평가 점수가 있다고 하자.한 프로젝트 팀에는 2, 3 명의 학생이 포함되고, 프로젝트 점수는 프로젝트 팀별로 주어지고 학생 개별로는 부여되지 않는다. 따라서 학생의 성적을 산정하려면 각 학생이 어떤 프로젝트 팀에 속한지를 확인한 후 학생이 속한 프로젝트 팀의 점수를 그 학생의 프로젝트 점수로 부여하는 작업이 필요하다.\n이 경우 class12.a와 pjt 데이터 프레임이 결합되어야 하는데, 결합의 기준 열은 프로젝트 팀을 나타내는 Team 열이 되어야 한다. 그런데 pjt 데이터 프레임에는 한 팀에 해당되는 행이 오직 한 개만 존재하지만, class12.데이터 프레임에는 한 팀에 속한 학생이 여러 명 있으므로 여러 행이 존재한다. 이러한 경우의 데이터 결합 방식을 1 대 n inner join이라고 한다.\n다음은 inner_join()를 사용하여 n 대 1의 관계의 두 데이터 프레임을 inner join 한 결과이다.결과에서 보듯이 인수로 Team을 주게 되면, pjt 데이터 프레임에서 Team이 A인 행은 하나지만, class12.a에서 Team이 A이고 학번이 15번과 18번인 학생과 관련된 두 행이 존재하므로, pjt의 한 행이 이 두 행에 차례로 결합되어 새로운 행을 만들었음을 알 수 있다. 이처럼 inner_joint()는 인수로 주어진 행에 동일한 값이 여러번 있으면 해당 값으로 결합이 여러번 발생한다.","code":"\npjt#>   Team Project\n#> 1    A      80\n#> 2    B      90\n#> 3    C      85\n#> 4    D      75\nclass12.c <- inner_join(class12.a, pjt, by=\"Team\")\nclass12.c#>    ID   Name Gender Year Midterm Final Team Class Attend Project\n#> 1  12 장철수      M    2      75    79    C     2    185      85\n#> 2  15 김철수      M    1      78    59    A     1     90      80\n#> 3  18 김영희      F    3      85    87    A     1     95      80\n#> 4  19 장영희      F    2      75    89    C     2    100      85\n#> 5  25 이철수      M    3      80    70    B     1    100      90\n#> 6  28 최철수      M    1      87    76    D     2    100      75\n#> 7  34 이영희      F    2      92    89    B     1    100      90\n#> 8  45 최영희      F   30      82    79    D     2    100      75\n#> 9 151 홍길동   Male    4      58    66    B     1     95      90"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"두-열-이상을-기준으로-join","chapter":"9 R 고급 데이터 변환","heading":"두 열 이상을 기준으로 join","text":"Join의 기준이 되는 열은 하나가 아니라 여러 개가 될 수 있다. 다음과 같은 두 개의 데이터 프레임이 있다고 하자. 그리고 이 두 데이터 프레임을 하나의 데이터 프레임으로 결합한다고 하자.두 데이터 프레임 각각에는 한 사람에 대한 정보는 오직 한 행에만 정보가 기술되어 있다. 그러나 두 데이터 프레임에서 first.name이 동일한 사람이 2명, last.name이 동일한 사람이 2명이 있다. 그래서 first.name이나 last.name만으로 데이터를 결합한다면 동일한 이름을 가진 사람이 있어서 원하는 결과를 얻을 수 없다. 다음은 first.name으로 결합한 결과이다.결과에서 보듯이 cAge의 James Bolton 행은 cIncome의 James Bolton과 James Tiger 행과 first.name이 동일하므로 두 번 결합이 이루어진다. 마찬가지로 cAge의 James Tiger 행도 cIncome의 James Bolton과 James Tiger 행과 first.name이 동일하므로 역시 두 번 행 결합이 발생한다. 그래서 결합된 결과가 3건이 아니라 총 5건의 데이터 행을 갖는다.\n그리고 cAge와 cIncome 모두 last.name 열이 있어서 어떤 last.name을 남겨두어야 할지 모르므로, 첫번째 데이터 프레임에서 온 열은 .x, 두번째 데이터 프레임에서 온 열은 .y라는 접미사를 붙여서 열을 만들었다.이러한 경우는 first.name과 last.name이 모두 같은 경우에만 행이 결합되도록 하는 것이 더 바람직하다. 그렇게 하려면 이 두 열의 이름을 모두 인수로 전달하면 된다.","code":"\ncAge#>   first.name last.name age\n#> 1      James    Bolton  34\n#> 2      James     Tiger  26\n#> 3     Goerge     Tiger  47\ncIncome#>   first.name last.name income\n#> 1     Goerge     Tiger     35\n#> 2      James    Bolton     24\n#> 3      James     Tiger     18\ninner_join(cAge, cIncome, by=\"first.name\")#>   first.name last.name.x age last.name.y income\n#> 1      James      Bolton  34      Bolton     24\n#> 2      James      Bolton  34       Tiger     18\n#> 3      James       Tiger  26      Bolton     24\n#> 4      James       Tiger  26       Tiger     18\n#> 5     Goerge       Tiger  47       Tiger     35\ninner_join(cAge, cIncome, by=c(\"last.name\", \"first.name\"))#>   first.name last.name age income\n#> 1      James    Bolton  34     24\n#> 2      James     Tiger  26     18\n#> 3     Goerge     Tiger  47     35"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"filtering-join","chapter":"9 R 고급 데이터 변환","heading":"9.2.2 Filtering join","text":"지금까지는 두 데이터 프레임의 키 값이 같은 행을 inner 또는 outer join으로 연결하는 방법을 살펴보았다. 그런데 어떤 경우에는 한 데이터 프레임의 데이터를 다른 데이터 프레임의 정보를 사용하여 필터링해야 하는 경우가 있다. 다음의 두 예를 고려해 보자.어떤 도시의 거주자의 자산 데이터와 그 도시의 세금 체납자 데이터가 있다고 하자. 이 때 거주자의 자산 정보에서 세금 체납자의 자산 정보만 뽑아서 분석하려고 한다. 어떻게 이 정보를 뽑아낼 수 있을까?어떤 도시의 거주자의 자산 데이터와 그 도시의 세금 체납자 데이터가 있다고 하자. 이 때 거주자의 자산 정보에서 세금 체납자의 자산 정보만 뽑아서 분석하려고 한다. 어떻게 이 정보를 뽑아낼 수 있을까?어떤 텍스트에서 사용된 단어 데이터와 의마가 없는 단어인 불용어 데이터가 있다고 하자. 이 때 텍스트의 단어 데이터에서 불용어는 제외하고 데이터를 분석하려고 한다. 어떻게 이 정보를 뽑아낼 수 있을까?어떤 텍스트에서 사용된 단어 데이터와 의마가 없는 단어인 불용어 데이터가 있다고 하자. 이 때 텍스트의 단어 데이터에서 불용어는 제외하고 데이터를 분석하려고 한다. 어떻게 이 정보를 뽑아낼 수 있을까?dplyr 패키지에는 이 작업을 위해 다음 두 함수를 제공한다.semi_join(x, y): x 데이터 프레임에서 y에 있는 데이터만 뽑아낸다. Inner join과 다른 점은 두 데이터 프레임의 정보를 결합하지 않는다는 것이다. x 데이터 프레임에서 남겨둘 행을 지정하기 위해서만 y를 사용한다.anti_join(x, y): x 데이터 프레임에서 y에 있는 행은 제외한다.","code":"\nsemi_join(x, y, by = \"id\")#>   id name\n#> 1  2    b\n#> 2  3    c\nanti_join(x, y, by = \"id\")#>   id name\n#> 1  1    a"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"join을-수행하는-다른-방법들","chapter":"9 R 고급 데이터 변환","heading":"9.2.3 Join을 수행하는 다른 방법들","text":"","code":""},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"merge-함수","chapter":"9 R 고급 데이터 변환","heading":"9.2.3.1 merge() 함수","text":"R의 기본 함수인 merge() 함수는 dplyr 패키지의 inner와 outer join을 수행해 준다.","code":"\nmerge(x, y)                 # inner join#>   id name addr\n#> 1  2    b    B\n#> 2  3    c    C\nmerge(x, y, all.x = TRUE)   # left join#>   id name addr\n#> 1  1    a <NA>\n#> 2  2    b    B\n#> 3  3    c    C\nmerge(x, y, all.y = TRUE)   # right join#>   id name addr\n#> 1  2    b    B\n#> 2  3    c    C\n#> 3  4 <NA>    D\nmerge(x, y, all = TRUE)     # full join#>   id name addr\n#> 1  1    a <NA>\n#> 2  2    b    B\n#> 3  3    c    C\n#> 4  4 <NA>    D"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"sqldf-패키지","chapter":"9 R 고급 데이터 변환","heading":"sqldf 패키지","text":"지금까지 dplyr의 join 함수를 이용하여 관계형 데이터베이스의 join과 유사한 데이터 결합을 어떻게 수행하는지 살펴보았다. 그런데 관계형 데이터베이스의 SQL에 익숙한 사람들은 R에서 SQL처럼 좀 더 다양한 방식으로 join을 수행할 수 없을까라는 의문을 가질 수 있다. sqldf 패키지는 SQL 문법을 이용하여 R의 데이터 프레임에서 데이터를 조회하거나 결합할 수 있도록 해 준다. 이러한 기능이 필요한 사람은 이 패키지의 문서를 참조하기 바란다. 그러나 R은 데이터 분석을 위한 도구이지 관계형 데이터베이스와 같은 일을 수행하기 위한 도구가 아님을 명심할 필요가 있다. 대량의 데이터의 결합이 필요하다면 관계형 데이터베이스에서 SQL을 이용하여 이를 먼저 수행한 후 최종 결과를 R로 보내어 분석을 수행하는 것이 일반적으로 더 효율적인 방법이다.","code":""},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"sec-tidyr","chapter":"9 R 고급 데이터 변환","heading":"9.3 tidyr 패키지를 이용하여 정돈 데이터 형식으로 바꾸기","text":"tidyr 패키지는 tidyverse 패키지에 포함된 패키지로 비정돈 형식의 데이터를 정돈 형식으로 바꾸어주는 함수를 가지고 있다.","code":""},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"pivot_longer-여러-열에-걸친-한-변수의-데이터를-하나의-열로-길게-모으기","chapter":"9 R 고급 데이터 변환","heading":"9.3.1 pivot_longer: 여러 열에 걸친 한 변수의 데이터를 하나의 열로 길게 모으기","text":"정돈 데이터는 한 열이 하나의 변수에 대응을 해야 한다. 그러나 현실의 데이터에서는 동일한 변수의 값이 여러 열에 흩뿌려져 있는 경우가 발생한다. 시계열 데이터들이 대표적인 사례라 할 수 있다. 다음은 tidyr에 포함된 table4a 데이터이다. 세 나라의 1999년도와 2000년도의 어떤 사건의 발생 건수를 보여주고 있다. 발생 건수를 나타내는 데이터 열이 두 개의 열로 나눠져 있음을 볼 수 있다.table4a를 정돈 데이터로 바꾸려면 두 열을 한 열로 모아야 한다. tidyr의 pivot_longer() 함수는 그러한 역할을 수행한다.pivot_longer()에 모아야 할 열의 이름을 지정한다. 이 예에서는 1999와 2000이다. 두 열의 이름은 숫자로 시작하고 있어서 표준적인 형태를 따르지 않아서 ` `으로 둘러쌓여 표현되었다.원 데이터의 열 이름을 표현할 변수를 names_to로 지정한다.원 데이터의 열의 값을 표현할 변수를 values_to로 지정한다.원 데이터의 열 이름은 변수로서 따옴표 없이 지정되고, 결과 데이터에 만들 열 이름은 아직 만들어진 변수가 아니므로 변수의 이름이 따옴표로 둘러쌓여 문자열로 전달된다.다음 그림은 앞의 pivot_longer() 함수의 작동 방식을 보여준다. 원 데이터보다 길어진 형식으로 데이터가 변환되므로 longer라는 표현이 사용되었다.\nFigure 9.1: pivot_longer 작동 방식 (출처: R Data Science)\n","code":"\ntable4a#> # A tibble: 3 × 3\n#>   country     `1999` `2000`\n#> * <chr>        <int>  <int>\n#> 1 Afghanistan    745   2666\n#> 2 Brazil       37737  80488\n#> 3 China       212258 213766\ntable4a %>%\n  pivot_longer(c(`1999`, `2000`), names_to = \"year\", values_to =\"cases\")#> # A tibble: 6 × 3\n#>   country     year   cases\n#>   <chr>       <chr>  <int>\n#> 1 Afghanistan 1999     745\n#> 2 Afghanistan 2000    2666\n#> 3 Brazil      1999   37737\n#> 4 Brazil      2000   80488\n#> 5 China       1999  212258\n#> 6 China       2000  213766"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"결측치가-있는-경우","chapter":"9 R 고급 데이터 변환","heading":"결측치가 있는 경우","text":"table4a에서 중국의 2000년도 데이터가 조사되지 않아서 NA로 표시되어 있다면 pivot_longer()는 어떤 결과를 줄까? 다음 결과에서 보듯이 결측치가 있는 셀도 모두 별도의 행으로 표현이 된다.만약 긴 형식에서는 결측치인 행을 없애고 싶으면 values_drop_na 인수를 TRUE로 설정한다.","code":"\nna_table4a <- table4a\nna_table4a$`2000`[3] <- NA\nna_table4a#> # A tibble: 3 × 3\n#>   country     `1999` `2000`\n#>   <chr>        <int>  <int>\n#> 1 Afghanistan    745   2666\n#> 2 Brazil       37737  80488\n#> 3 China       212258     NA\nna_table4a %>% \n  pivot_longer(c(`1999`, `2000`), names_to = \"year\", values_to = \"cases\")#> # A tibble: 6 × 3\n#>   country     year   cases\n#>   <chr>       <chr>  <int>\n#> 1 Afghanistan 1999     745\n#> 2 Afghanistan 2000    2666\n#> 3 Brazil      1999   37737\n#> 4 Brazil      2000   80488\n#> 5 China       1999  212258\n#> 6 China       2000      NA\nna_long_table4a <- na_table4a %>% \n  pivot_longer(c(`1999`, `2000`), names_to = \"year\",\n               values_to = \"cases\", values_drop_na = T)\nna_long_table4a#> # A tibble: 5 × 3\n#>   country     year   cases\n#>   <chr>       <chr>  <int>\n#> 1 Afghanistan 1999     745\n#> 2 Afghanistan 2000    2666\n#> 3 Brazil      1999   37737\n#> 4 Brazil      2000   80488\n#> 5 China       1999  212258"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"gather-함수","chapter":"9 R 고급 데이터 변환","heading":"gather 함수","text":"tidyr 패키지는 1.0 버전이 출시되면서 많은 변화가 있었다. 이전 버전의 에서는 gather() 함수가 pivot_longer() 함수의 역할을 수행하였다. 그리고 호환성을 위해 현재의 버전에서도 gather() 함수를 사용할 수 있다. 아직도 많은 R 관련 책에서 이 함수를 사용하고 있어서 사용법을 여기에 기술한다.pivot_longer와 유사한 형식인데, gather에서는 합칠 열의 이름을 각각의 인수로 전달된다.names_to와 values_to라는 원 데이터 입장에서의 인수 이름이 gather에서는 합쳐진 데이터 입장에서의 인수 이름인 key와 value라고 기술된다.","code":"\ntable4a %>%\n  gather(`1999`, `2000`, key = \"year\", value =\"cases\")#> # A tibble: 6 × 3\n#>   country     year   cases\n#>   <chr>       <chr>  <int>\n#> 1 Afghanistan 1999     745\n#> 2 Brazil      1999   37737\n#> 3 China       1999  212258\n#> 4 Afghanistan 2000    2666\n#> 5 Brazil      2000   80488\n#> 6 China       2000  213766"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"subsec-pivot-wider","chapter":"9 R 고급 데이터 변환","heading":"9.3.2 pivot_wider: 한 열에 기술된 여러 변수의 데이터를 여러 열로 넓게 펼치기","text":"정돈 데이터는 하나의 열은 하나의 변수에 대응을 해야 한다. 그러나 현실의 데이터에서는 한 열에 여러 변수의 값이 표현되어 있는 경우도 있다. 다음 데이터는 세 나라의 어떤 년도의 사건의 발생 건수와 인구수가 count라는 한 열에 표현되었다. 그렇기 때문에 count 열은 인구수와 사건 횟수라는 두 변수의 값을 모두 포함한 열이 되었다.table2를 정돈 데이터로 바꾸려면 count 열의 데이터를 인구수와 사건 횟수를 나타내는 열로 분리하여 한다. tidyr의 pivot_wider() 함수는 그러한 역할을 수행한다.pivot_wider()는 결과 펼쳐진 결과 데이터에서 열의 이름으로 사용될 변수를 names_from 인수로 지정한다.펼쳐진 결과 데이터에서 열의 값으로 사용될 변수를 values_from 인수로 지정한다.names_from과 values_from 인수를 지정할 때, 원 데이터의 열을 지정하는 것이므로 따옴표 없이 변수로서 지정한다.다음 그림은 앞의 pivot_wider() 함수의 작동 방식을 보여준다.\nFigure 9.2: pivot_wider의 작동 방식 (출처: R Data Science)\n","code":"\ntable2#> # A tibble: 12 × 4\n#>    country      year type            count\n#>    <chr>       <int> <chr>           <int>\n#>  1 Afghanistan  1999 cases             745\n#>  2 Afghanistan  1999 population   19987071\n#>  3 Afghanistan  2000 cases            2666\n#>  4 Afghanistan  2000 population   20595360\n#>  5 Brazil       1999 cases           37737\n#>  6 Brazil       1999 population  172006362\n#>  7 Brazil       2000 cases           80488\n#>  8 Brazil       2000 population  174504898\n#>  9 China        1999 cases          212258\n#> 10 China        1999 population 1272915272\n#> 11 China        2000 cases          213766\n#> 12 China        2000 population 1280428583\ntable2 %>%\n  pivot_wider(names_from = type, values_from = count)#> # A tibble: 6 × 4\n#>   country      year  cases population\n#>   <chr>       <int>  <int>      <int>\n#> 1 Afghanistan  1999    745   19987071\n#> 2 Afghanistan  2000   2666   20595360\n#> 3 Brazil       1999  37737  172006362\n#> 4 Brazil       2000  80488  174504898\n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"결측치가-있는-경우-1","chapter":"9 R 고급 데이터 변환","heading":"결측치가 있는 경우","text":"앞서 pivot_longer()에서 중국의 2000년도 데이터에 결측값이 있는 행을 제거하여 데이터 프레임을 만들었다.만약 이 데이터를 넓은 형식으로 합치면 어떤 결과가 나올까? 결과에서 보듯이 결측이 있는 곳이 NA로 표시되고 데이터가 넓은 형식으로 변환된다.","code":"\nna_long_table4a#> # A tibble: 5 × 3\n#>   country     year   cases\n#>   <chr>       <chr>  <int>\n#> 1 Afghanistan 1999     745\n#> 2 Afghanistan 2000    2666\n#> 3 Brazil      1999   37737\n#> 4 Brazil      2000   80488\n#> 5 China       1999  212258\nna_long_table4a %>%\n  pivot_wider(names_from = year, values_from = cases)#> # A tibble: 3 × 3\n#>   country     `1999` `2000`\n#>   <chr>        <int>  <int>\n#> 1 Afghanistan    745   2666\n#> 2 Brazil       37737  80488\n#> 3 China       212258     NA"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"spread-함수","chapter":"9 R 고급 데이터 변환","heading":"spread 함수","text":"tidyr 패키지는 1.0 버전이 출시되면서 많은 변화가 있었다. 이전 버전의 에서는 spread() 함수가 pivot_wider() 함수의 역할을 수행하였다. 그리고 호환성을 위해 현재의 버전에서도 spread() 함수를 사용할 수 있다. 아직도 많은 R 관련 책에서 이 함수를 사용하고 있어서 사용법을 여기에 기술한다.pivot_wider와 유사한 형식인데 names_from와 values_from이라는 인수 이름이 spread에서는 key와 value라고 기술된다.","code":"\ntable2 %>%\n  spread(key = type, value = count)#> # A tibble: 6 × 4\n#>   country      year  cases population\n#>   <chr>       <int>  <int>      <int>\n#> 1 Afghanistan  1999    745   19987071\n#> 2 Afghanistan  2000   2666   20595360\n#> 3 Brazil       1999  37737  172006362\n#> 4 Brazil       2000  80488  174504898\n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"seperate-한-셀을-여러-셀로-분리하기","chapter":"9 R 고급 데이터 변환","heading":"9.3.3 seperate: 한 셀을 여러 셀로 분리하기","text":"한 셀에 여러 값이 기술되어 있으면 정돈 형식의 데이터가 아니다. table3의 rate 열은 사건의 수와 인구수 데이터가 문자열 형식으로 표현된 열이다.","code":"\ntable3#> # A tibble: 6 × 3\n#>   country      year rate             \n#> * <chr>       <int> <chr>            \n#> 1 Afghanistan  1999 745/19987071     \n#> 2 Afghanistan  2000 2666/20595360    \n#> 3 Brazil       1999 37737/172006362  \n#> 4 Brazil       2000 80488/174504898  \n#> 5 China        1999 212258/1272915272\n#> 6 China        2000 213766/1280428583"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"특정-문자를-기준으로-분리하기","chapter":"9 R 고급 데이터 변환","heading":"9.3.3.1 특정 문자를 기준으로 분리하기","text":"seperate()는 정해진 열을 sep에 지정된 문자를 기준으로 분리하여 분리된 값을 into에 지정된 열 이름으로 분리한다. 앞의 다른 함수와 마찬가지로 원 데이터의 열은 변수로서 따옴표 없이 지정되었고 결과 데이터에 사용될 열 이름은 따옴표를 사용하여 문자열로 전달되었다.다음 그림은 앞의 seperate() 함수의 작동 방식을 보여준다.\nFigure 9.3: separate의 작동 방식 (출처: R Data Science)\nsep은 구분자로 사용할 일반 문자뿐 아니라 정규 표현식을 사용하여 문자를 분리할 수 있다.","code":"\ntable3 %>%\n  separate(rate, into=c(\"cases\", \"population\"), sep=\"/\")#> # A tibble: 6 × 4\n#>   country      year cases  population\n#>   <chr>       <int> <chr>  <chr>     \n#> 1 Afghanistan  1999 745    19987071  \n#> 2 Afghanistan  2000 2666   20595360  \n#> 3 Brazil       1999 37737  172006362 \n#> 4 Brazil       2000 80488  174504898 \n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"분리한-열의-형변환","chapter":"9 R 고급 데이터 변환","heading":"9.3.3.2 분리한 열의 형변환","text":"앞의 결과를 보면 rate 열의 데이터가 문자열이기 때문에 결과 열도 모두 문자열 형식임을 볼 수 있다. 그런데 cases와 population 열은 모두 숫자로서 의미를 가지고 있으므로 숫자로 변환되는 것이 좋다. 셀의 내용을 분리한 후 숫자나 논리값으로 변형이 가능하면 변형을 하려면 convert 인수를 TRUE로 설정한다.","code":"\nx <- table3 %>%\n  separate(rate, into=c(\"cases\", \"population\"), sep=\"/\", convert = TRUE) \nx#> # A tibble: 6 × 4\n#>   country      year  cases population\n#>   <chr>       <int>  <int>      <int>\n#> 1 Afghanistan  1999    745   19987071\n#> 2 Afghanistan  2000   2666   20595360\n#> 3 Brazil       1999  37737  172006362\n#> 4 Brazil       2000  80488  174504898\n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583\nx %>% summarise(total_cases=sum(cases), mean_pop=mean(population))#> # A tibble: 1 × 2\n#>   total_cases   mean_pop\n#>         <int>      <dbl>\n#> 1      547660 490072924."},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"문자-수를-기준으로-분리하기","chapter":"9 R 고급 데이터 변환","heading":"9.3.3.3 문자 수를 기준으로 분리하기","text":"sep 인수에 문자 대신 숫자를 입력하면 문자 수를를 기준으로 열을 분리한다. 양수이면 왼쪽에서 시작하여 sep에 입력된 문자 수까지와 그 이후로 열을 분리하고, 음수이면 오른쪽을 기준으로 sep에 입력된 문자 수까지와 그 이전으로 열을 분리한다.앞의 예에서 숫자열인 year에 적용하여 세기와 나머지 년도로 분리해 내보자.만약 세기와 연도를 숫자로 표현하는 것이 필요하다면 앞서 설명한 것처럼 convert 인수를 TRUE로 설정하면 된다. 이 경우 00년도가 모두 숫자 0으로 변환된 것을 볼 수 있다.","code":"\ntable3 %>%\n  separate(rate, into=c(\"cases\", \"population\"), sep=3)#> # A tibble: 6 × 4\n#>   country      year cases population    \n#>   <chr>       <int> <chr> <chr>         \n#> 1 Afghanistan  1999 745   /19987071     \n#> 2 Afghanistan  2000 266   6/20595360    \n#> 3 Brazil       1999 377   37/172006362  \n#> 4 Brazil       2000 804   88/174504898  \n#> 5 China        1999 212   258/1272915272\n#> 6 China        2000 213   766/1280428583\ntable3 %>%\n  separate(rate, into=c(\"cases\", \"population\"), sep=-3)#> # A tibble: 6 × 4\n#>   country      year cases          population\n#>   <chr>       <int> <chr>          <chr>     \n#> 1 Afghanistan  1999 745/19987      071       \n#> 2 Afghanistan  2000 2666/20595     360       \n#> 3 Brazil       1999 37737/172006   362       \n#> 4 Brazil       2000 80488/174504   898       \n#> 5 China        1999 212258/1272915 272       \n#> 6 China        2000 213766/1280428 583\ntable3 %>% \n  separate(year, into=c(\"century\", \"year\"), sep=2)#> # A tibble: 6 × 4\n#>   country     century year  rate             \n#>   <chr>       <chr>   <chr> <chr>            \n#> 1 Afghanistan 19      99    745/19987071     \n#> 2 Afghanistan 20      00    2666/20595360    \n#> 3 Brazil      19      99    37737/172006362  \n#> 4 Brazil      20      00    80488/174504898  \n#> 5 China       19      99    212258/1272915272\n#> 6 China       20      00    213766/1280428583\ntable3 %>% \n  separate(year, into=c(\"century\", \"year\"), sep=2, convert = T)#> # A tibble: 6 × 4\n#>   country     century  year rate             \n#>   <chr>         <int> <int> <chr>            \n#> 1 Afghanistan      19    99 745/19987071     \n#> 2 Afghanistan      20     0 2666/20595360    \n#> 3 Brazil           19    99 37737/172006362  \n#> 4 Brazil           20     0 80488/174504898  \n#> 5 China            19    99 212258/1272915272\n#> 6 China            20     0 213766/1280428583"},{"path":"ch-R-Advanced-Data-Mgmt.html","id":"unite-여러-셀의-데이터를-하나의-셀로-병합하기","chapter":"9 R 고급 데이터 변환","heading":"9.3.4 unite: 여러 셀의 데이터를 하나의 셀로 병합하기","text":"separate() 함수와 반대 작용을 하는 함수가 unite() 함수이다. unite() 함수는 여러 셀의 내용을 하나의 셀로 합친다. table5는 년도 데이터가 세기(century)와 나머지 년도(year)로 나뉘어져 있는 데이터이다. 세기와 무관하게 년도 별로 데이터를 분석하려고 하면 이 두 열을 합쳐서 온전한 년도 데이터를 만들어야 한다.unite()의 기본 설정은 _을 구분자로 사용하여 합쳐진 셀의 내용을 연결한다. 이를 조정하려면, sep 인수를 설정하면 된다. 다음처럼 하면 구분자 없이 연결을 수행한다.","code":"\ntable5 %>%\n  unite(c(century, year), col = \"year\")#> # A tibble: 6 × 3\n#>   country     year  rate             \n#>   <chr>       <chr> <chr>            \n#> 1 Afghanistan 19_99 745/19987071     \n#> 2 Afghanistan 20_00 2666/20595360    \n#> 3 Brazil      19_99 37737/172006362  \n#> 4 Brazil      20_00 80488/174504898  \n#> 5 China       19_99 212258/1272915272\n#> 6 China       20_00 213766/1280428583\ntable5 %>%\n  unite(c(century, year), col = \"year\", sep=\"\")#> # A tibble: 6 × 3\n#>   country     year  rate             \n#>   <chr>       <chr> <chr>            \n#> 1 Afghanistan 1999  745/19987071     \n#> 2 Afghanistan 2000  2666/20595360    \n#> 3 Brazil      1999  37737/172006362  \n#> 4 Brazil      2000  80488/174504898  \n#> 5 China       1999  212258/1272915272\n#> 6 China       2000  213766/1280428583"},{"path":"ch-R-Programming-Structure.html","id":"ch-R-Programming-Structure","chapter":"10 R 프로그래밍 구조","heading":"10 R 프로그래밍 구조","text":"R은 통계 및 데이터 처리를 위한 프로그래밍 언어이다. 모든 언어가 그렇지만 처음 언어를 배울 때는 여러 단어와 표현 패턴에 익숙해지는 과정을 거친다. 그러나 좀 더 정확하고 복잡한 표현을 하기 위해서는 단순히 표현 패턴을 익히는 것에서 벗어나 그 언어의 고유한 문법 체계를 이해하는 것이 필요하다.R은 프로그래밍 언어이므로 프로그램 흐름을 제어하는 조건문과 반복문을 가지고 있다. 조건문은 조건에 따라 프로그램 흐름을 분기하고, 반복문은 조건에 따라 프로그램의 부분을 계속 반복 수행한다.","code":""},{"path":"ch-R-Programming-Structure.html","id":"r-조건문","chapter":"10 R 프로그래밍 구조","heading":"10.1 R 조건문","text":"","code":""},{"path":"ch-R-Programming-Structure.html","id":"if-조건문","chapter":"10 R 프로그래밍 구조","heading":"10.1.1 if 조건문","text":"","code":""},{"path":"ch-R-Programming-Structure.html","id":"if-else-조건문","chapter":"10 R 프로그래밍 구조","heading":"if-else 조건문","text":"R은 if를 이용하여 조건문을 만든다. 표준적인 -else 조건문은 다음 형식을 취한다.statement1은 TRUE 또는 FALSE의 논리값을 결과로 주는 표현식이어야 한다. 예로 \\(4 > 2\\) 이나 \\(x < 0\\) 처럼 참 또는 거짓으로 판별될 수 있어야 한다. statement1이 참이면 statement2가 실행되고 statement1이 거짓이면 else 다음의 statement3이 실행된다. 그림 10.1의 ()는 -else 조건문에 의해 발생하는 프로그램의 제어 흐름은 보여준다.\nFigure 10.1: 단순한 형태의 조건문에서의 제어 흐름\n다음은 -else 조건문의 예이다. x를 주사위를 굴려서 나온 눈금의 수라고 하자. 만약 x가 4 이상이면 상금 1을 받고, 4보다 작으면 오히려 벌금을 1을 내야 한다고 하자. y를 주사위 경기 한번 후의 손익이라고 하면, 주사위 눈금이 4일 때 y는 다음과 같이 계산할 수 있다.실제 주사위를 굴리는 것처럼 하기 위하여 sample() 함수를 사용하여 1에서부터 6까지의 수 중에서 임의로 한 개의 수를 추출하여 주사위 눈금과 손익을 출력해 보자.\n매번 수행할 때마다 주사위 눈금이 달라지고, 그에 따라 손익이 달라지는 것을 확인할 수 있다.만약 statement1 조건이 참이냐 거짓이냐에 따라 여러 문장이 함께 실행되어야 하면 다음과 같이 statment2나 statement3 표현식을 블록으로 만들면 된다. 다음 예에서 중괄호로 묶인 두 개의 블럭이 statement2와 statement3을 대체하고 있음을 볼 수 있다. 중괄호로 묶인 여러 표현식으로 구성된 블록은 마치 하나의 표현식처럼 동시에 평가가 이루어진다. 블록 표현식을 사용할 때 주의할 점은 statment2의 블록이 종료되는 같은 줄에 else가 기술되어야 한다는 것이다. 그래야 -else 문이 하나의 명령으로 취급되어 처리된다.다음은 cat() 함수를 사용하여 주사위 게임에서 주사위 눈금에 따라 이겼는지, 졌는지를 출력을 같이 하고 있다.","code":"\nif (statement1) statement2 else statement3\nx <- 4\nif( x >= 4 ) y <- 1 else y <- -1\ny#> [1] 1\nx <- sample(1:6, size=1)\nif( x >= 4 ) y <- 1 else y <- -1\nx#> [1] 1\ny#> [1] -1\nx <- sample(1:6, size=1)\nif (x >= 4) {\n  y <- 1\n  cat(\"손님이 이겼습니다.\\n\")\n} else {\n  y <- -1\n  cat(\"딜러가 이겼습니다.\\n\")\n}\ncat(\"주사위 눈금:\", x, \"\\n\")\ncat(\"손익:\", y, \"\\n\")#> 손님이 이겼습니다.\n#> 주사위 눈금: 5 \n#> 손익: 1"},{"path":"ch-R-Programming-Structure.html","id":"단순-if-조건문","chapter":"10 R 프로그래밍 구조","heading":"단순 if 조건문","text":"어떤 경우에는 조건이 만족하면 어떤 작업을 수행하지만, 그렇지 않은 경우에는 아무 것도 하지 않아야 할 때가 있다. 그러한 경우에는 다음처럼 else 부분이 제외된 단순한 형태의 조건문을 사용하면 된다. statement1이 참이면 statement2가 실행되는 것은 -else 조건문과 마찬가지이지만, statement1이 거짓이면 statement2를 건너띄고 조건문 다음으로 프로그램의 실행 흐름이 넘어간다(그림 10.1의 (b) 참조). -else 조건문과 마찬가지로 statement2는 블럭 표현식으로 대체될 수 있다.다음 예는 주사위 눈금 x가 4 이상이면 승리 횟수 n을 하나씩 증가시키지만, 그렇지 않은 경우에는 n을 증가시키지 않는 예이다.우리는 나중에 문을 사용하여 게임을 원하는 만큼 반복시킬 것이다.","code":"\nif (statement1) statement2 \nn <- 0  # 승리 횟수 초기화\nx <- sample(1:6, size=1)   # 게임 1회\nif (x >= 4) n <- n + 1\ncat(\"x:\", x, \", n:\", n, \"\\n\")#> x: 5 , n: 1\nx <- sample(1:6, size=1)   # 게임 2회\nif (x >= 4) n <- n + 1\ncat(\"x:\", x, \", n:\", n, \"\\n\")#> x: 2 , n: 1\nx <- sample(1:6, size=1)   # 게임 3회\nif (x >= 4) n <- n + 1\ncat(\"x:\", x, \", n:\", n, \"\\n\")#> x: 4 , n: 2"},{"path":"ch-R-Programming-Structure.html","id":"복합-조건문","chapter":"10 R 프로그래밍 구조","heading":"복합 조건문","text":"지금까지는 하나의 조건에 의해서 두 가지 방향으로 프로그램 실행이 분기되는 경우를 살펴보았다. 그런데 어떤 경우에는 조건에 따라 세 개 이상으로 프로그램 실행을 분기하고 싶을 때가 있다.\n예를 들어, 주사위 게임에서 게임의 규칙이 복잡해져서, 5, 6이 나오면 손님이 이기고, 1, 2가 나오면 딜러가 이기고, 3, 4가 나오면 아무도 이지기 않고 게임이 무효가 된다고 하자. 앞의 -else 예에서는 주사위 눈금에 대한 두 조건을 고려하여 x가 4 이상이면 y에 1을 부여하고 x가 4 미만이면 -1을 부여하였는데, 이제는 주사위 눈금의 세 가지 조건을 고려하여 y에 1, 0, -1을 적절히 부여하여야 한다. 이럴 땐 어떻게 해야 할까? 이런 경우에는 다음처럼 else 다음의 statement3 부분에 또 다른 조건문을 넣으면 된다. 이렇게 else 이후에 또 다른 조건문을 실행하는 조건문을 복합 조건문이라고 한다.이 경우 statement1이 TRUE이면 statement2가 실행되고 else 부분은 실행이 되지 않는다. statement1이 FALSE이면 statement2는 건너뛰고 첫번째 else 부분이 실행된다. 그런데 else 다음에 기술된 statement3이 단순한 실행문이 아니라 그 자체가 또 다른 조건문이다. 따라서 statement1이 FALSE인 경우에는 else의 if문이 실행되어 statement3.1 조건을 비교하고, statement3.1이 TRUE이면 statement3.2가 실행되고, FALSE이면 statement3.3이 실행된다. 그림 10.2의 ()는 복합 조건문의 제어 흐름을 보여준다.\nFigure 10.2: 복잡한 형태의 조건문에서의 제어 흐름\n다음 예는 변경된 주사위 경기에 따라 손익과 경기 결과를 알려주는 복합 조건문이다. 먼저 x가 5 이상인지를 비교하여 만족하면 손익을 1을 부여하고 복합 조건문을 종료된다. 만약에 첫 번째 조건을 만족하지 않으면 첫번째 else 부분이 실행된다. 그리고 두번째 if에서 x가 3 이상인지를 비교한다. 처음 조건은 FALSE이고 두번째 조건이 TRUE이면 손익은 0이 되고 복합 조건문은 종료된다. 만약 이 두 조건 모두 FALSE이면 손익에 -1을 부여한다.\n여러 번 반복 실행하여 x의 값에 따라 어떤 부분이 실행되는지 확인해 보라.복합 조건문의 조건은 계속 추가될 수 있다. 앞의 예는 세 개의 분기를 가지고 있지만, 두번째 else 부분에 다시 문을 연결하면 네 개의 분기가 되도록 조건을 더 세분화할 수 있다.","code":"\nif (statement1) {\n  statement2 \n} else if (statement3.1) {\n  statement3.2\n} else {\n  statement3.3\n}\nx <- sample(1:6, size=1)\nif (x>=5) {\n  cat(\"손님이 이겼습니다.\\n\")\n  y <- 1\n} else if ( x >=3 ) {\n  cat(\"무승부입니다.\\n\")\n  y <- 0\n} else {\n  cat(\"딜러가 이겼습니다.\\n\")\n  y <- -1\n}\ncat(\"주사위 눈금:\", x, \"\\n\")\ncat(\"손익:\", y, \"\\n\")#> 무승부입니다.\n#> 주사위 눈금: 4 \n#> 손익: 0"},{"path":"ch-R-Programming-Structure.html","id":"중첩-조건문","chapter":"10 R 프로그래밍 구조","heading":"중첩 조건문","text":"복합 조건문이 else 부분에 조건문으로 꼬리를 물듯이 이어 나가면서 분기를 세분화한다면, 중첩 조건문은 if문의 statement2와 statement3의 안에 또 다른 문을 두어 분기를 세분화하는 경우이다. 그림 10.2의 (b)는 중첩 조건문의 제어 흐름을 보여준다.다음 예를 살펴보자. -else 조건문의 예처럼 x가 양수인지에 따라 y에 1 또는 0으로 부여하는 것뿐 아니라, x가 양수이고 홀수이면 z에 1을, 짝수이면 z에 2를 부여하고 싶다고 하자. 그리고 x가 0 이하이고 3의 배수이면 z에 3을, 3의 배수가 아니면 z에 4를 부여하고 싶다. 이러한 경우는 다음과 같은 중첩 조건문을 사용하면 쉽게 구현할 수 있다. 다음 예는 x에 -10부터 10 사이의 정수를 임의로 뽑은 후 x의 값에 따라 결과를 출력한 것이다. 여러 번 반복하여 x의 값에 따라 어떤 부분이 실행되는지 살펴보라.중첩 조건문은 여러번 조건문을 중첩시킬 수 있다. 그러나 너무 많은 조건문을 중첩시키거나, 너무 복잡한 복합 조건문을 사용하는 것은 프로그램 흐름을 이해하기 어렵게 만들므로 되도록 피하는 것이 좋다.","code":"\nif (statement1) {\n  ...\n  if (statement2.1) {\n    statement2.2\n  } else {\n    statement2.3\n  }\n  ...\n} else {\n  ...\n  if (statement3.1) {\n    statement3.2\n  } else {\n    statement3.3\n  }\n  ...\n}\nx <- sample(-10:10, size=1)\nif (x>0) {\n  cat(x, \"은(는) 양수이고 \")\n  if (x %% 2 == 0) cat(\"짝수입니다.\\n\") else cat(\"홀수입니다.\\n\")\n} else {\n  cat(x, \"은(는) 0 또는 음수이고 \")\n  if (x %% 3 == 0) cat(\"3의 배수입니다.\\n\") else cat(\"3의 배수가 아닙니다.\\n\")\n}#> -3 은(는) 0 또는 음수이고 3의 배수입니다."},{"path":"ch-R-Programming-Structure.html","id":"조건문의-결과가-두-개-이상의-논리값을-주는-경우","chapter":"10 R 프로그래밍 구조","heading":"조건문의 결과가 두 개 이상의 논리값을 주는 경우","text":"지금까지 문의 statement1 조건에 들어가는 표현식이 하나의 논리값을 가진 경우만을 다루었다. 만약에 이 표현식의 결과가 길이가 2 이상인 논리값 벡터이면 어떻게 될까?\n다음 예에서 보듯이 R은 조건의 논리값 결과가 2개 이상인 경우, 오류가 발생한다.9따라서 조건의 결과가 여러 개가 될 수 있는 경우에는 논리값 벡터의 어떤 요소를 사용할지를 특정하여 조건문을 실행하여야 한다.","code":"\nx <- c(5, 0, -5)\nx > 0#> [1]  TRUE FALSE FALSE\nif (x > 0) y <- 1 else y <- 0#> Error in if (x > 0) y <- 1 else y <- 0: the condition has length > 1\ny#> [1] 0\nif (x[3] > 0) y <- 1 else y <- 0\ny#> [1] 0"},{"path":"ch-R-Programming-Structure.html","id":"복합-조건","chapter":"10 R 프로그래밍 구조","heading":"복합 조건","text":"지금까지의 예는 statement1에 단순 조건을 사용하였다. 어떨 때는 AND나 등의 논리값 연산자로 단순 조건을 연결하여 복합 조건을 만들어 statement1에 부여하는 것이 프로그램을 간단하게 만들 수 있다. 다음 예를 살펴 보자. x와 y가 모두 0보다 크면 두 수의 합을 출력하지만 그렇지 않으면 두 수가 모두 0 이상이어야 한다는 경고 메시지를 출력하도록 해 보자. 물론 이를 다음처럼 중첩 또는 복합 조건문으로 구현할 수 있다.이러한 경우에는 동일한 경고 메시지를 여러 분기에서 출력하도록 해야 한다. 만약 경고의 방식이 바뀌면 x와 y가 0 이상인 분기를 제외하고 관련 부분을 모두 변경해야 한다. 동일한 코드를 여러 부분에 산재시키는 방식은 프로그램이 진화함에 따라 프로그램 유지 보수를 어렵게 만들고 오류 발생의 근원이 되므로 좋지 않은 방식이라 할 수 있다. 이 경우에는 두 조건을 AND로 연결하여 표현하면 조건문의 표현이 단순해진다.그런데 여기서 논리값 벡터의 연산에서 설명한 연산자인 & 대신 &&를 사용하였다. & 연산자는 논리값 벡터의 연산자로 논리값 벡터들의 같은 위치의 요소별로 AND를 수행하여 그 결과를 반환한다. 반면 && 연산자는 각 논리값 벡터의 첫번째 요소만 취하여 결과를 제공하고, 대신 맨 처음 요소만 사용했다는 것을 경고한다.10 따라서 다음 예처럼 () 함수 안의 논리값 벡터가 여러 개의 논리값을 가질 때에는 불필요한 오류나 경고가 발생되지 않도록 한 요소만 특정하여 논리값 연산을 수행하는 것이 좋다.마찬가지로 연산자로는 | 대신 ||가 있다.따라서 만약 앞의 예에서 x와 y 둘 중에 하나만 0 이상이면 합을 출력한다면 다음처럼 수정하면 된다.","code":"\nx <- 3\ny <- -4\nif ( x >= 0 ) {\n  if ( y >= 0 ) {\n    print(x + y)\n  } else {\n    warning(\"x와 y는 모두 0 이상이어야 합니다.\")\n  }\n} else {\n  warning(\"x와 y는 모두 0 이상이어야 합니다.\")\n}#> Warning: x와 y는 모두 0 이상이어야 합니다.\nif ( x >= 0 && y >= 0 ) {\n  print(x + y)\n} else {\n  warning(\"x와 y는 모두 0 이상이어야 합니다.\")\n}#> Warning: x와 y는 모두 0 이상이어야 합니다.\na <- c(T, F)\nb <- c(T, T)\na & b#> [1]  TRUE FALSE\na && b#> Warning in a && b: 'length(x) = 2 > 1' in coercion to 'logical(1)'\n\n#> Warning in a && b: 'length(x) = 2 > 1' in coercion to 'logical(1)'#> [1] TRUE\nif (a & b) print(\"TRUE\") else print(\"FALSE\") # 오류 발생#> Error in if (a & b) print(\"TRUE\") else print(\"FALSE\"): the condition has length > 1\nif (a && b) print(\"TRUE\") else print(\"FALSE\") # 경고 발생#> Warning in a && b: 'length(x) = 2 > 1' in coercion to 'logical(1)'\n\n#> Warning in a && b: 'length(x) = 2 > 1' in coercion to 'logical(1)'#> [1] \"TRUE\"\nif (a[1] && b[1]) print(\"TRUE\") else print(\"FALSE\")#> [1] \"TRUE\"\na | b#> [1] TRUE TRUE\na || b#> Warning in a || b: 'length(x) = 2 > 1' in coercion to 'logical(1)'#> [1] TRUE\nif (a & b) print(\"TRUE\") else print(\"FALSE\") # 오류 발생#> Error in if (a & b) print(\"TRUE\") else print(\"FALSE\"): the condition has length > 1\nif (a && b) print(\"TRUE\") else print(\"FALSE\") # 경고 발생#> Warning in a && b: 'length(x) = 2 > 1' in coercion to 'logical(1)'#> Warning in a && b: 'length(x) = 2 > 1' in coercion to 'logical(1)'#> [1] \"TRUE\"\nif (a[1] && b[1]) print(\"TRUE\") else print(\"FALSE\")#> [1] \"TRUE\"\nif ( x >= 0 || y >= 0 ) {\n  print(x + y)\n} else {\n  warning(\"x와 y 중 하나는 0 이상이어야 합니다.\")\n}#> [1] -1"},{"path":"ch-R-Programming-Structure.html","id":"if-else-조건문은-ifelse-함수와는-다르다.","chapter":"10 R 프로그래밍 구조","heading":"if-else 조건문은 ifelse() 함수와는 다르다.","text":"그리고 본 절에서 배운 -else 조건문은 ifelse() 함수와는 다르다는 것에 주의해야 한다. 이 절에서 배운 -else 조건문은 프로그램의 흐름을 조건에 따라 분기하기 위한 표현식이다. 반면 ifelse() 함수는 첫번째 인수인 논리값 벡터에 따라 새로운 벡터를 만들어주는 함수이다. 다음은 벡터의 값이 음수이면 절대값으로 바꾸어 주는 예이다. (물론 우리는 절대값을 만들어주는 abs() 함수를 이용할 수 있지만 예제를 위하여 ifelse() 함수를 사용하였다.) ifelse() 함수는 요소별로 논리값에 따라 결과 요소를 선택함을 볼 수 있다. 반면 -else 문은 조건에 대한 하나의 논리값에 따라 한번만 프로그램 실행 흐름에 대한 분기가 이루어지는 점이 다르다.","code":"\ne <- c(5, -4, 3)\nifelse(e >=0, e, -e)#> [1] 5 4 3"},{"path":"ch-R-Programming-Structure.html","id":"switch-함수","chapter":"10 R 프로그래밍 구조","heading":"10.1.2 switch 함수","text":"switch()는 하나의 함수이지만 -else 조건문처럼 프로그램 흐름 제어에 사용될 수 있다. switch() 함수는 다음의 함수 형식을 갖는다.switch()의 EXPR 인수에는 하나의 숫자나 문자열로 평가되는 표현식이 부여된다. EXPR 인수 다음에는 표현식의 목록이 나온다. expression_1부터 expression_n까지 n 개의 표현식이 EXPR 인수 다음에 인수로 추가되어 있다고 하자.\nEXPR 인수의 평가 결과가 숫자이고 그 숫자가 1부터 n 사이이면, switch() 함수는 해당 숫자 위치에 있는 expression 표현식을 실행하고 실행 결과를 반환한다. 만약 EXPR의 결과가 그 외의 숫자라면 아무 것도 수행하지 않고 NULL을 반환한다. 다음 예를 살펴보자.switch()의 EXPR 인수의 결과가 하나의 문자열이 될 수 있는데, 그 경우에는 EXPR 뒤에 나오는 표현식 앞에 이름을 붙인다. EXPR 인수 뒤에 나오는 표현식 중 하나는 이름이 없을 수 있다. 이 경우 EXPR의 결과값과 같은 이름을 가진 표현식이 실행된 후 그 결과값이 반환된다. 만약 EXPR 결과값이 뒤에 나오는 어떠한 표현식의 이름과도 같지 않으면, 이름이 없는 expression_default 표현식이 실행된다.다음은 사용자에게 메뉴를 선택하게 하여 사용자가 선택한 메뉴에 따라 다른 내용을 출력하는 예이다. 예에서 repeat 반복문이 사용되는 데 관련 내용은 다음 절을 참조하기 바란다.","code":"\nswitch(EXPR, expression_1, ..., expression_n)\ni <- 2\nswitch(i, 10, 1:5, pi)#> [1] 1 2 3 4 5\ni <- 3\nswitch(i, 10, 1:5, pi)#> [1] 3.141593\ni <- 4\nswitch(i, 10, 1:5, pi)\nswitch(EXPR, name_1=expression_1, ..., \n       name_n=expression_n, expression_default)menu <- c(\"(b)anana\", \"(o)range\", \"(s)trawberry\")\nrepeat{\n  price <- 0\n  cat(\"\\n다음 중 메뉴를 골라주세요:\", paste(1:3, menu, sep=\".\"), \"\\n\")\n  choice <- readline(\"메뉴 선택 [b|o|s] 또는 종료 [q]: \")\n  switch(choice, \n         b = {cat(\"바나나가 나왔습니다.\\n\"); price <- 1000},  \n         o = {cat(\"오렌지가 나왔습니다.\\n\"); price <- 1200}, \n         s = {cat(\"딸기가 나왔습니다.\\n\"); price <- 1500},\n         q = break,\n         cat(\"번호를 잘못 눌렀습니다.\\n\"))\n  cat(\"이번 거래는 총\",  price, \"원 입니다.\\n\")\n}"},{"path":"ch-R-Programming-Structure.html","id":"r-반복문","chapter":"10 R 프로그래밍 구조","heading":"10.2 R 반복문","text":"","code":""},{"path":"ch-R-Programming-Structure.html","id":"for-반복문","chapter":"10 R 프로그래밍 구조","heading":"10.2.1 for 반복문","text":"프로그램을 작성하다 보면 변수의 값을 변화시키면서 동일한 작업을 반복할 필요가 있는 경우가 있다. 이러한 경우 반복문을 이용하면 좋다.","code":""},{"path":"ch-R-Programming-Structure.html","id":"벡터-또는-리스트의-각-요소별로-반복하기","chapter":"10 R 프로그래밍 구조","heading":"벡터 또는 리스트의 각 요소별로 반복하기","text":"for문은 vector의 요소를 차례로 변수 variable에 넣은 후 statement를 vector의 요소별로 한번씩 반복 실행한다. 다음은 반복문을 이용하여 1부터 5까지의 합을 구한 예이다. n의 각 요소가 차례로 x에 들어가서 s에 x를 더하는 작업이 반복된다. (물론 우리는 sum() 함수로 이를 더 빨리 수행할 수 있다. 그러니 실제 프로그램에서는 이러한 방식의 반복문을 만들지 말라. 이 예는 단지 이해를 위해 만든 예제이다.)반복할 명령문이 여러개이면 statement 부분에 블록 표현식을 이용하면 된다.\n위의 예에서 반복문이 실제로 어떻게 수행되었는지를 확인해보기 위해서 반복되는 부문에 몇 가지 명령문을 추가해 보자. cat() 함수는 나열된 인수를 차례로 콘솔에 출력하는 함수이다. 아래 결과에서 블록 표현식 부분이 x값이 바뀌면서 5번 실행되었음을 볼 수 있다. 그리고 왜 s가 x의 합이 되는지 그 이유도 보여주고 있다.다음은 복합 조건문을 설명할 때 사용한 예를 주사위 게임을 여러 번 주사위를 던진 결과를 이용하여 복합 조건문을 반복한 결과이다 예이다. 복합 조건문의 예에서 x의 값을 바꾸려면 사람이 일일이 재실행해 보아야 했다. 여기서는 반복문을 통해 한번에 이와 같은 일을 수행할 수 있다.\n이를 위해서 sample() 함수의 size를 10을 설정하여 1에서 6까지의 임의의 숫자를 5번 반복하여 복원 추출하도록 하였다.\n아울러 총 손익을 합산하기 위하여 total이라는 변수도 도입하였다.","code":"\nfor ( variable in vector ) statement\nfor ( variable in list ) statement\nn <- 1:5\ns <- 0\nfor (x in n) s <- s + x\ns#> [1] 15\ns <- 0\nfor (x in n) {\n  cat(\"반복 시작: x =\", x, \", s =\", s, \"\\n\")\n  s <- s + x\n  cat(\"반복 끝  : x =\", x, \", s =\", s, \"\\n\\n\")\n}#> 반복 시작: x = 1 , s = 0 \n#> 반복 끝  : x = 1 , s = 1 \n#> \n#> 반복 시작: x = 2 , s = 1 \n#> 반복 끝  : x = 2 , s = 3 \n#> \n#> 반복 시작: x = 3 , s = 3 \n#> 반복 끝  : x = 3 , s = 6 \n#> \n#> 반복 시작: x = 4 , s = 6 \n#> 반복 끝  : x = 4 , s = 10 \n#> \n#> 반복 시작: x = 5 , s = 10 \n#> 반복 끝  : x = 5 , s = 15\ntotal <- 0 # 총 손익 초기화\nx_vec <- sample(1:6, size=5, replace = T) \nx_vec#> [1] 3 4 2 5 2\nfor( x in x_vec) {\n  if (x>=5) {\n    cat(\"손님이 이겼습니다.\\n\")\n    y <- 1\n  } else if ( x >=3 ) {\n    cat(\"무승부입니다.\\n\")\n    y <- 0\n  } else {\n    cat(\"딜러가 이겼습니다.\\n\")\n    y <- -1\n  }\n  cat(\"주사위 눈금:\", x, \"\\n\")\n  cat(\"이번 게임 손익:\", y, \"\\n\")\n  \n  total <- total + y\n  cat(\"지금까지의 총 손익:\", total, \"\\n\\n\")\n}#> 무승부입니다.\n#> 주사위 눈금: 3 \n#> 이번 게임 손익: 0 \n#> 지금까지의 총 손익: 0 \n#> \n#> 무승부입니다.\n#> 주사위 눈금: 4 \n#> 이번 게임 손익: 0 \n#> 지금까지의 총 손익: 0 \n#> \n#> 딜러가 이겼습니다.\n#> 주사위 눈금: 2 \n#> 이번 게임 손익: -1 \n#> 지금까지의 총 손익: -1 \n#> \n#> 손님이 이겼습니다.\n#> 주사위 눈금: 5 \n#> 이번 게임 손익: 1 \n#> 지금까지의 총 손익: 0 \n#> \n#> 딜러가 이겼습니다.\n#> 주사위 눈금: 2 \n#> 이번 게임 손익: -1 \n#> 지금까지의 총 손익: -1"},{"path":"ch-R-Programming-Structure.html","id":"벡터의-인덱스를-이용하여-벡터-요소-반복하기","chapter":"10 R 프로그래밍 구조","heading":"벡터의 인덱스를 이용하여 벡터 요소 반복하기","text":"반복문에서는 반복 실행의 대상이 되는 벡터의 요소를 변수 variable에 넣어 반복 실행을 수행한다. 그런데 어떤 경우는 벡터의 요소를 variable에 부여하는 것이 아니라 벡터의 인덱스를 variable에 부여하여 반복하는 것이 편리한 경우가 있다. 이 경우는 앞의 반복문의 vector 부분에 반복의 대상이 되는 벡터 자체가 아니라 벡터의 인덱스 벡터를 부여한다.\n다음은 앞의 주사위 게임의 반복에서 인덱스 벡터를 사용하여 게임의 횟수를 같이 출력하였다.조건문을 설명할 때 사용한 x와 y 벡터가 모두 0 이상이면 합을 출력하지만 그렇지 않은 경우에는 경고를 출력하는 예를 고려해 보자. 반복문을 이용하여 이 조건문을 테스트하려고 한다. 이 때는 테스트에 필요한 벡터가 x, y로 2개나 되어서 문의 vector에 어떤 벡터를 넣어야 할지 고민이 된다. 이런 경우 vector 부분에 인덱스 벡터를 넣어 반복문을 실행하면 문제가 해결된다. x의 모든 요소에 대한 자연수 인덱스 벡터를 구하기 위해서 seq() 함수를 이용하였다. seq() 함수는 along 인수에 주어진 벡터의 모든 요소에 대한 자연수 인덱스 벡터를 반환한다.","code":"\ntotal <- 0 # 총 손익 초기화\nx_vec <- sample(1:6, size=5, replace = T) \nx_vec#> [1] 5 4 5 5 5\nfor( idx in 1:length(x_vec) ) {\n  cat(idx, \"번째 게임입니다.\\n\")\n  x <- x_vec[idx]\n  if (x>=5) {\n    cat(\"손님이 이겼습니다.\\n\")\n    y <- 1\n  } else if ( x >=3 ) {\n    cat(\"무승부입니다.\\n\")\n    y <- 0\n  } else {\n    cat(\"딜러가 이겼습니다.\\n\")\n    y <- -1\n  }\n  cat(\"주사위 눈금:\", x, \"\\n\")\n  cat(\"이번 게임 손익:\", y, \"\\n\")\n  \n  total <- total + y\n  cat(\"지금까지의 총 손익:\", total, \"\\n\\n\")\n}#> 1 번째 게임입니다.\n#> 손님이 이겼습니다.\n#> 주사위 눈금: 5 \n#> 이번 게임 손익: 1 \n#> 지금까지의 총 손익: 1 \n#> \n#> 2 번째 게임입니다.\n#> 무승부입니다.\n#> 주사위 눈금: 4 \n#> 이번 게임 손익: 0 \n#> 지금까지의 총 손익: 1 \n#> \n#> 3 번째 게임입니다.\n#> 손님이 이겼습니다.\n#> 주사위 눈금: 5 \n#> 이번 게임 손익: 1 \n#> 지금까지의 총 손익: 2 \n#> \n#> 4 번째 게임입니다.\n#> 손님이 이겼습니다.\n#> 주사위 눈금: 5 \n#> 이번 게임 손익: 1 \n#> 지금까지의 총 손익: 3 \n#> \n#> 5 번째 게임입니다.\n#> 손님이 이겼습니다.\n#> 주사위 눈금: 5 \n#> 이번 게임 손익: 1 \n#> 지금까지의 총 손익: 4\nx <- rep(c(1, -1), each=2)\ny <- rep(c(1, -1), times=2)\nx#> [1]  1  1 -1 -1\ny#> [1]  1 -1  1 -1\nfor ( i in seq(along=x)) {\n  cat(x[i], \"+\", y[i], \"= \")\n  if ( x[i] >= 0 || y[i] >= 0 ) {\n    cat(x[i] + y[i], \"입니다\\n\")\n  } else {\n    warning(\"x와 y 중 하나는 0 이상이어야 합니다.\")\n  } \n}#> 1 + 1 = 2 입니다\n#> 1 + -1 = 0 입니다\n#> -1 + 1 = 0 입니다\n#> -1 + -1 =#> Warning: x와 y 중 하나는 0 이상이어야 합니다."},{"path":"ch-R-Programming-Structure.html","id":"while-반복문","chapter":"10 R 프로그래밍 구조","heading":"10.2.2 while 반복문","text":"","code":""},{"path":"ch-R-Programming-Structure.html","id":"조건에-따라-반복하기","chapter":"10 R 프로그래밍 구조","heading":"조건에 따라 반복하기","text":"반복문처럼 처음부터 반복할 횟수가 벡터의 크기로 정해져 있는 경우도 있지만 어떤 경우에는 사전에 몇번을 반복할지 결정이 안되어 있는 경우도 있다. 어떤 조건이 만족될 때는 반복이 계속되지만 그렇지 않은 경우에는 반복이 종료되는 경우가 대표적인 예이다. 이러한 경우에는 문을 이용하여 반복문을 구현하는 경우가 많다.문은 statement1이 TRUE이면 statement2를 실행한다. 그리고 다시 문의 맨 앞으로 돌아와 다시 statement1 조건을 비교하는 작업을 수행한다. 만약 statement1이 FALSE가 되면 statement2를 실행하지 않고 반복문에서 빠져나온다. 다음은 문을 사용하여 1부터 5까지 더한 예를 문으로 다시 수행한 예이다. 다음 예에서 statement2 부분은 블록문으로 구현되었다.","code":"\nwhile (statement1) statement2\ns <- 0\nx <- 1\nwhile ( x <= 5 ) {\n  s <- s + x\n  x <- x + 1\n}\ns#> [1] 15"},{"path":"ch-R-Programming-Structure.html","id":"무한-반복이-발생하는-경우","chapter":"10 R 프로그래밍 구조","heading":"무한 반복이 발생하는 경우","text":"문에서는 statement2에서 statement1이 FALSE가 되도록 하는 부분이 있어야 한다. 만약 없다면 문은 무한 반복된다.\n위의 예에서 반복이 일어나는 블록문에서 x를 하나씩 증가시키는 부분을 제외시켜 보라. 그러면 프로그램은 무한 반복에 빠질 것이다. (프로그램이 무한 반복에 들어가면 ESC 키를 눌러라. 그러면 프로그램의 실행에서 빠져나올 수 있다.)","code":""},{"path":"ch-R-Programming-Structure.html","id":"사용자의-입력에-따라-반복할지-결정하기","chapter":"10 R 프로그래밍 구조","heading":"사용자의 입력에 따라 반복할지 결정하기","text":"문은 사용자 입력에 따라 반복을 할지 말지를 결정하는 경우에 자주 사용된다. 다음과 같은 예를 생각해 보자. iris 데이터 프레임에 대해 사용자에게 히스토그램을 그릴 열 번호를 입력받은 후, 해당 열에 대한 히스토그램을 그려주려고 한다. 사용자의 입력을 받아 히스토그램을 그린 후에는 다시 사용자의 입력을 받는 작업을 반복하고자 한다. 그리고 사용자의 입력이 숫자가 아니라 ‘q’이면 이러한 반복을 종료하고자 한다.\n다음 예는 문을 이용하여 위에 설명한 기능을 구현한 예이다. 여기서는 사용자가 ’q’ 또는 0부터 4까지의 정수만 정확히 입력한다고 가정하여, 사용자가 이외의 값을 입력할 때의 예외 처리는 수행하지 않았다. 사용자의 입력은 readline() 함수를 이용하여 수행하였다. readline()은 콘솔 또는 파일에서 한 줄씩 입력을 받아 그 결과를 전달하는 함수이다. 이에 대한 자세한 설명은 R 도움말을 참조하라.","code":"num <- \"1\"\nwhile ( num != \"0\") {\n  n <- as.integer(num)\n  hist(iris[[n]], main = names(iris)[n])\n  \n  cat(\"히스토그램을 출력할 열을 선택하세요[1-4]. 종료를 원하면 0을 입력\")\n  num <- readline()\n}"},{"path":"ch-R-Programming-Structure.html","id":"repeat-반복문","chapter":"10 R 프로그래밍 구조","heading":"10.2.3 repeat 반복문","text":"repeat 문은 다음과 같은 형식을 가진다. 벡터의 패턴을 반복하여 새로운 벡터를 만들어 주는 rep() 함수와 혼동하는 경우가 많으니 주의하길 바란다.","code":"\nrepeat statement"},{"path":"ch-R-Programming-Structure.html","id":"repeat-문의-무한-반복은-break-문으로-빠져나온다.","chapter":"10 R 프로그래밍 구조","heading":"repeat 문의 무한 반복은 break 문으로 빠져나온다.","text":"문은 statement1 부분에 반복의 종료 조건이 명시적으로 기술되는데 반해, repeat 문은 반복의 종료 조건이 명시적으로 표시되지 않는다. repeat 문은 statement를 그저 무한 반복할 뿐이다. 반복을 중지하려면 repeat 문 안에 break 문을 넣어 반복에서 직접 빠져나와야 한다.\n다음은 iris 데이터에 대한 히스토그램을 그리는 예를 repeat 문으로 수행한 예이다. 문은 처음에 조건을 비교하여 반복을 결정하므로 초기에 num을 1로 설정하였으나 repeat 문을 이용하는 경우 그럴 필요가 없다. repeat 문 안에서 사용자 입력이 처음으로 이루어진 후 ’0’인지를 비교하여 빠져나올지 아닐지를 결정하면 된다.repeat 문은 블록문 내부 어디서나 반복 종료의 조건이 발생하면 break 문을 이용하여 자유롭게 빠져 나올 수 있으므로 매우 유연한 반복문을 만들 수 있는 장점이 있다. 하지만 반복문의 종료 조건이 무엇인지 파악하려면 repeat 문 전체를 살펴보아야 하는 단점이 있다. 특히 반복되는 부분이 길면 이를 파악하는 것이 쉽지가 않다. 반면 문과 문은 종료 조건이 반복문 앞에 명시적으로 놓이므로 이를 파악하기가 쉽다.","code":"repeat {\n  cat(\"히스토그램을 출력할 열을 선택하세요[1-4]. 종료를 원하면 0을 입력\")\n  num <- readline()\n  if (num == \"0\") {\n    cat(\"Bye~~!\")\n    break\n  }\n  n <- as.integer(num)\n  hist(iris[[n]], main = names(iris)[n])\n}"},{"path":"ch-R-Programming-Structure.html","id":"반복문의-제어-명령","chapter":"10 R 프로그래밍 구조","heading":"10.2.4 반복문의 제어 명령","text":"우리는 앞서서 repeat 반복문에서 break 명령문을 이용하여 반복문을 빠져 나오는 방법을 배웠다. 사실 break 문은 모든 반복문에서 사용이 가능하다. 문이나 문이 아직 종료 조건이 되지 않았다 하더라도 반복 중에 break 문을 만나면 즉시 실행이 종료된다. 보통 프로그램에서 복구할 수 없는 오류를 인지했을 때 종료 조건이 만족되지 않아도 break 문으로 프로그램 반복을 빠져 나오도록 하는 경우가 많다.break 문과 함께 반복문을 제어하는 명령문으로 next가 있다. 이 명령이 실행되면 반복문을 완전히 빠져나오지는 않지만, 이번 차의 반복에서 빠져 나와 다음번 차의 반복이 실행한다. 다음은 문을 사용하여 벡터에서 홀수만을 더한 예이다. a가 짝수이면 next 문을 이용하여 s에 a가 더해지는 부분을 건너띄고 다음번 회차의 반복으로 넘어가고 있다.","code":"\nx <- c(5, 4, 8, 9, 10, 11)\ns <- 0\nfor (a in x) {\n  if( a %% 2 == 0) next\n  cat(a, s, \"\\n\")\n  s <- s + a\n}#> 5 0 \n#> 9 5 \n#> 11 14\ns#> [1] 25"},{"path":"ch-R-Programming-Structure.html","id":"r에서-반복문-사용의-주의점","chapter":"10 R 프로그래밍 구조","heading":"10.2.5 R에서 반복문 사용의 주의점","text":"","code":""},{"path":"ch-R-Programming-Structure.html","id":"명시적-반복문은-되도록-피하는-것이-좋다.","chapter":"10 R 프로그래밍 구조","heading":"명시적 반복문은 되도록 피하는 것이 좋다.","text":"지금까지 R의 다양한 반복문의 문법에 대해서 설명하였지만, 사실 R에서는 반복문이 꼭 필요한 경우가 아니라면 반복문의 사용을 피하는 것이 좋다. R은 사실 함수 프로그래밍 언어로서 앞의 모든 명령문은 함수 호출로 구현된다. 따라서 반복문의 반복 횟수가 커지면 엄청나게 많은 함수 호출이 발생한다. 일반적으로 프로그래밍 언어에서 함수 호출은 스택 프레임 등을 설정해야 하므로 계산 시간이 많이 요구되는 고비용 작업이다.","code":""},{"path":"ch-R-Programming-Structure.html","id":"벡터화된-내장-함수로-암시적인-반복을-수행하라.","chapter":"10 R 프로그래밍 구조","heading":"벡터화된 내장 함수로 암시적인 반복을 수행하라.","text":"많은 R의 함수들은 벡터가 인수로 전달될 때, 벡터 요소 전체에 대해 암시적인 방식으로 반복 작업을 수행하여 결과를 제공한다. 이러한 R 함수를 벡터화(vectorized) 되었다고 하는데, 보통 벡터화된 내장 함수는 C로 구현되어 매우 빠른 계산 반복을 수행하므로, 명시적으로 반복문을 이용하는 것보다 훨씬 빠른 시간 내에 결과를 제공해 준다.다음은 x와 y의 두 벡터의 같은 위치의 요소를 비교하여 둘 중 더 큰 요소만을 뽑아서 합을 구한 예이다. R의 ifelse()와 sum()를 이용하면 이를 쉽게 수행할 수 있다. 이 두 함수는 벡터화된 내장 함수이다. system.time() 함수는 함수의 인수로 전달된 표현식을 실행하고 이 표현식을 실행하는 데 걸린 시간을 반환해 준다.앞의 문제를 문을 이용하여 구현한 후, 실행 시간을 측정해 보자. 쉽게 두 방식의 시간 차이를 확인할 수 있을 것이다.다음은 -1000부터 1000사이의 정수에서 복원 추출로 1,000,000 개의 수를 뽑은 후, 그 중 3의 배수가 되는 원소만 뽑아서 합을 구한 예이다. 첫번째 방식은 벡터 인덱싱과 sum() 함수를 이용했고, 두번째 방식은 () 문을 이용해 각 원소별로 반복 작업을 하였다 그리고 이 두 방식의 실행 시간을 비교하였다. 마찬가지로 큰 시간 차이를 보임을 알 수 있다.","code":"\nset.seed(123)\nn <- 1000000\nx <- rnorm(n)\ny <- rnorm(n)\nsystem.time(sum(ifelse(x > y, x, y)))#>  사용자  시스템 elapsed \n#>   0.023   0.016   0.039\ns <- 0\nsystem.time({\n  for (i in 1:n){\n    if (x[i] > y[i]) s <- s + x[i] else s <- s + y[i]\n  }\n})#>  사용자  시스템 elapsed \n#>   0.074   0.000   0.075\nset.seed(111)\nn <- 1000000\nx <- sample(-1000:1000, n, replace=T)\n\nsystem.time({\n  sum( x[x %% 3 == 0] ) \n})#>  사용자  시스템 elapsed \n#>   0.026   0.000   0.026\nsystem.time({\n  s <- 0\n  for (a in x) {\n    if (a %% 3 == 0)\n    s <- s + a\n  }\n  print(s)\n})#> [1] 198993#>  사용자  시스템 elapsed \n#>   0.174   0.000   0.175"},{"path":"ch-R-Programming-Structure.html","id":"apply-계열-함수로-암시적인-반복을-수행하라.","chapter":"10 R 프로그래밍 구조","heading":"apply 계열 함수로 암시적인 반복을 수행하라.","text":"R에서는 리스트의 요소에 대해 동일한 작업을 반복할 때, lapply나 sapply() 함수를 이용하여 암시적인 반복을 수행한다. 또한 행렬의 열이나 행에 반복 작업을 할 때에도 apply() 함수를 사용한다.\n이러한 작업은 반복문 등을 이용해서도 수행할 수 있다. 사실 C나 다른 언어에 익숙한 사람이 R을 처음 접하게 되면 반복이 필요한 경우 반복문 등을 이용하여 명시적인 반복을 하는 경우가 많다. 그러면 이 두 가지 반복 방법 중 어느 것이 더 권장되어야 할까?가끔 apply 종류 함수가 더 빠르게 실행하기 때문에 명시적 반복보다는 apply 계열 함수로 암시적 반복을 하라는 의견들을 볼 수 있는데, 이러한 주장은 신빙성이 크지는 않다.\n다음은 예에서는 -1000부터 1000사이의 정수에서 복원 추출로 100,000 개의 수를 뽑아내는 작업을 100번 반복하여 x라는 리스트의 요소로 넣었다. 그 후 리스트의 각 요소에서 3의 배수의 합을 구한 후 합의 최대값을 구하였다. 필요한 반복 작업은 lappy, sapply 함수에 의해 수행되었다.다음은 문을 이용하여 x의 요소에 대하여 같은 작업을 반복하였다.\n계산 시간의 차이를 비교해 보자. 결과에서 보듯이 두 방법 모두 벡터화된 함수를 적절히 이용하면 속도의 차이는 거의 나지 않는다.그렇다면 두 방법 중 어느 것을 선택해도 될까? 일반적으로 이 두 방법 중 어느 것이 더 좋다고 확언하기는 어렵지만 다음의 두 가지 이유 때문에 apply 계열 함수를 이용하는 것이 더 선호된다. 첫째, apply 계열 함수를 이용하면 코드를 더 간단하게 작성할 수 있어 코드의 가독성이 증가한다. 둘째, apply 계열 함수는 데이터 요소에 적용할 함수를 인수로 전달하는 방식으로 암시적 반복이 이루어진다. 따라서 함수 프로그래밍의 특징인 반복 실행의 부수적인 효과(side effect)가 반복문 바깥으로 전달되지 않는다. 따라서 동일한 프로그램을 병렬 프로그램으로 전환하기가 더 용이하다. 그러므로 처리해야 할 데이터가 커지면 병렬 프로그래밍 기법을 이용하여 추가적인 속도 향상을 꾀할 수 있는 가능성이 커진다.","code":"\nset.seed(11)\nn <- 100000\nx <- lapply(1:100, function(i) sample(-1000:1000, n, replace=T))\n\nsystem.time( {\n  s <- sapply(x, function(y) sum(y[y %% 3 == 0]))\n  print(max(s))\n})#> [1] 285816#>  사용자  시스템 elapsed \n#>   0.261   0.020   0.280\nsystem.time({\n  s.max <- -Inf\n  for(i in 1:length(x)) {\n    s <- sum(x[[i]][x[[i]] %% 3 == 0])\n    if(s > s.max) s.max <- s\n  }\n  print(s.max)\n})#> [1] 285816#>  사용자  시스템 elapsed \n#>   0.246   0.004   0.251"},{"path":"ch-R-Programming-Structure.html","id":"r-함수","chapter":"10 R 프로그래밍 구조","heading":"10.3 R 함수","text":"","code":""},{"path":"ch-R-Programming-Structure.html","id":"함수의-필요성","chapter":"10 R 프로그래밍 구조","heading":"함수의 필요성","text":"우리는 앞서서 반복문을 사용하여 동일한 작업을 재입력 없이 원하는 횟수만큼 반복시킬 수 있음을 보았다. 그런데 어떤 경우에는 동일한 작업을 입력 변수에 따라 다른 출력 결과로 얻고 싶을 때가 있다. 예를 들어 1부터 시작하여 자연수 n까지의 홀수의 합을 구하고 싶은데, 매번 다른 n에 대하여 결과를 구하고 싶다고 하자. 이러한 경우에 함수를 이용하면 원하는 결과를 얻을 수 있다. 함수는 입력 변수에 따라 다른 결과를 반환하는 일련의 프로그램 덩어리라 할 수 있다.R은 함수를 closure 타입의 객체로 생성한다. R에서 제공하는 많은 함수들은 내장 함수(builtin functions)를 제외하고는 사용자가 생성하는 함수와 본질적으로 동일하다. 다음은 R에서 자주 사용되는 함수의 타입을 보여준다. sum() 함수를 제외하고는 모두 closure 타입임을 알 수 있다.","code":"\ntypeof(sum)#> [1] \"builtin\"\ntypeof(mean)#> [1] \"closure\"\ntypeof(summary)#> [1] \"closure\"\ntypeof(plot)#> [1] \"closure\""},{"path":"ch-R-Programming-Structure.html","id":"함수의-생성과-호출","chapter":"10 R 프로그래밍 구조","heading":"10.3.1 함수의 생성과 호출","text":"","code":""},{"path":"ch-R-Programming-Structure.html","id":"함수-정의하기","chapter":"10 R 프로그래밍 구조","heading":"함수 정의하기","text":"R에서 함수 만들기는 function() 함수의 호출에 의해 이뤄진다. (함수를 생성하는 것을 함수를 정의한다라고 한다.)function() 함수를 호출하여 그 결과를 변수에 할당하는데, 그 변수 이름이 함수의 이름으로 사용된다.\nfuntion()의 인수로는 새롭게 생성할 함수에 사용할 형식 인수(formal_arg 부분)가 나열된다. 그리고는 함수가 호출되면 실행될 함수 본문 표현식(function_body_expression 부분)을 기술한다.\n함수 본문 표현식은 R의 어떠한 표현식도 가능하며 함수 본문 표현식이 실행된 결과가 함수의 결과값으로 반환된다.\n보통은 함수가 실행될 때 여러 개의 명령문이 실행되어야 하는 경우가 많다. 이러한 경우 함수 본문 표현식을 { }을 이용한 블록 표현식으로 표현하다. 그러면 return() 함수로 명시적으로 반환한 결과값을 지정하지 않을 경우, 블록 표현식 안의 마지막 표현식의 실행 결과가 함수의 결과값으로 반환된다.다음은 함수 g()를 생성한 예이다. g() 함수를 생성하려면 function()의 결과가 할당되는 변수의 이름이 g이어야 한다. 그리고 g() 함수의 형식 인수로 x, y, z가 정의되었고, 함수 본문 표현식은 \\(100x + 10y + z\\)로 정의되었다. 따라서 g() 함수는 호출될 때마다 x, y, z 인수에 값을 전달받아, \\(100x + 10y + z\\)를 계산하여 반환하도록 정의된 것이다.","code":"\nfunction_name <- function(formal_arg1, formal_arg2, ...) \n          function_body_expression\ng <- function(x, y, z) 100 * x + 10 * y + z"},{"path":"ch-R-Programming-Structure.html","id":"함수도-객체이다.","chapter":"10 R 프로그래밍 구조","heading":"함수도 객체이다.","text":"함수 객체가 잘 생성되었는지를 확인하기 위해 함수 객체 g를 출력해 보았다. R 콘솔에서 변수 이름을 입력하면 변수가 지정하고 있는 객체의 내용을 출력하게 되는데, closure 객체는 함수 정의를 출력한다.","code":"\ng#> function(x, y, z) 100 * x + 10 * y + z"},{"path":"ch-R-Programming-Structure.html","id":"함수-호출하기","chapter":"10 R 프로그래밍 구조","heading":"함수 호출하기","text":"함수에 정의된 프로그램 덩어리를 실행시키는 과정을 함수를 호출한다고 표현한다.\n함수에 대한 호출은 다음의 형태로 이루어진다. 먼저 함수의 이름을 적고 괄호 안에 함수의 형식 인수에 전달할 값을 기술한다(이를 실질 인수라고 한다).함수를 호출할 때, 다음처럼 실질 인수 값만 기술하여 함수를 호출할 수도 있고, 실질 인수가 어떤 형식 인수로 전달될지를 (형식 인수)=(실질 인수)의 쌍으로 기술하여 호출할 수도 있다.","code":"\nfunction_name(actual_arg1, actual_arg2, ...)\nfunction_name(formal_arg1=actual_arg1, formal_arg2=actual_arg2, ...)"},{"path":"ch-R-Programming-Structure.html","id":"형식-인수를-지정하지-않고-호출하기","chapter":"10 R 프로그래밍 구조","heading":"형식 인수를 지정하지 않고 호출하기","text":"형식 인수를 지정하지 않고 실질 인수를 기술하여 호출하면, 함수 정의 때 기술된 형식 인수 순으로 실질 인수가 차례로 전달된다.\n다음은 실질 인수를 1, 2, 0으로 하여 g() 함수를 호출한 예이다.\ng() 함수의 정의에서 형식 인수가 x, y, z 순으로 정의되었으므로, x에 1, y에 2, z에는 0이 전달되어 함수 본문 표현식이 실행된다. 따라서, 함수 본문 표현식의 결과인 9가 함수 호출의 결과로 반환된다.다음은 실질 인수 값을 바꾸어 가면서 g() 함수를 호출한 결과이다.","code":"\ng(1, 2, 0)#> [1] 120\ng(2, 1, 0)#> [1] 210\ng(0, 7, 1)#> [1] 71"},{"path":"ch-R-Programming-Structure.html","id":"벡터화된-함수","chapter":"10 R 프로그래밍 구조","heading":"벡터화된 함수","text":"그런데 g() 함수 본문 표현식에서 곱하기와 더하기 연산자만을 사용하였다. 이 연산자들은 벡터의 요소끼리 곱하기와 더하기를 수행해 주는 연산자이다. 따라서, g() 함수의 실질 인수에 숫자 하나뿐 아니라 여러 숫자를 가진 벡터가 전달되어도 요소끼리 계산이 수행되어 벡터로서 결과가 반환될 수 있다. g() 함수처럼 벡터가 인수로 전달되면 벡터의 인수별로 계산을 수행하여 벡터로 결과를 주는 함수를 벡터화(vectorization)된 함수라고 한다. 일반적으로 R의 기본 연산자와 함수는 벡터화되어 있는 경우가 많으므로, 이러한 함수와 연산자를 이용하여 함수를 만들면 이 함수 역시 벡터화된 함수가 된다. 다음 예에서는 벡터가 인수로 전달될 때, 벡터의 요소끼리 계산과 벡터의 재사용이 일어남을 볼 수 있다. 주의할 점은 모든 함수가 벡터화되어 있지는 않다는 것이다. 따라서 어떤 함수가 벡터화된 함수인지를 확인하려면 도움말을 참조하거나 직접 테스트를 해보아야 한다.","code":"\ng(1:3, 1, c(2, 4, 6))#> [1] 112 214 316"},{"path":"ch-R-Programming-Structure.html","id":"형식-인수를-지정하여-함수-호출-하기","chapter":"10 R 프로그래밍 구조","heading":"형식 인수를 지정하여 함수 호출 하기","text":"함수 호출 시에 실질 인수가 어떤 형식 인수로 전달할지를 지정할 수 있다. 그러면 함수 호출 시의 실질 인수의 순서는 중요하지 않고, 실질 인수에 지정된 형식 인수로 값이 전달되어 함수 본문이 실행된다.마지막 두 예에서 볼 수 있듯이 실질 인수에 형식 인수가 지정된 것과 그렇지 않은 실질 인수가 섞여서 호출이 이루어질 수도 있다. 이 경우 형식 인수가 지정된 실질 인수는 해당 형식 인수로 전달되지만, 나머지 실질 인수는 아직 실질 인수가 부여되지 않은 형식 인수에 함수 정의에 기술된 순서대로 차례로 전달된다.","code":"\ng(y=2, x=1, z=0)#> [1] 120\ng(z=0, x=1, y=2)#> [1] 120\ng(1, 2, x=3)#> [1] 312\ng(x=1, 2, y=0)#> [1] 102"},{"path":"ch-R-Programming-Structure.html","id":"형식-인수-수와-실질-인수의-수가-다르면-오류가-발생한다.","chapter":"10 R 프로그래밍 구조","heading":"형식 인수 수와 실질 인수의 수가 다르면 오류가 발생한다.","text":"다음처럼 형식 인수 수와 호출 시 전달되는 실질 인수 수가 맞지 않으면 오류가 발생한다. 첫번째 예는 형식 인수 z에 전달되는 값이 없어서 오류가 발생하였고, 두번째 예는 실질 인수 4를 전달할 형식 인수가 없어서 오류가 발생하였다.","code":"\ng(1, x=2)#> Error in g(1, x = 2): 기본값이 없는 인수 \"z\"가 누락되어 있습니다\ng(1, 2, 3, 4)#> Error in g(1, 2, 3, 4): 사용되지 않은 인자 (4)"},{"path":"ch-R-Programming-Structure.html","id":"형식-인수의-초기값-설정하기","chapter":"10 R 프로그래밍 구조","heading":"형식 인수의 초기값 설정하기","text":"그런데 함수를 정의할 때 형식 인수에 초기값을 설정할 수 있다. 이러한 경우에는 함수 호출 시 형식 인수에 실질 인수 값이 전달되지 않으면 초기값을 형식 인수에 부여한 후 함수 본문을 실행한다. 초기값은 함수 정의 시 형식 인수를 나열할 때, (형식 인수)=(초기값) 형태로 기술하면 된다.11형식 인수의 초기값이 어떻게 작동하는지를 살펴보기 위해서 1부터 어떤 자연수 b까지 홀수의 합을 구하는 다음과 같은 oddsum() 함수를 고려해 보자.앞서 설명하였듯이 형식 인수 b에 값을 전달하지 않으면 oddsum() 함수의 호출은 오류가 난다.그런데 다음처럼 형식 인수 b에 초기값으로 100을 설정해 두면, 형식 인수 b에 전달할 실질 인수가 없어도 b에 100이 전달되어 잘 실행됨을 볼 수 있다. 그리고 형식 인수 b에 실질 인수가 부여되면 초기값은 무시되고 실질 인수 값으로 함수가 수행됨을 볼 수 있다.위의 oddsum() 함수는 형식 인수 b를 이용하여 1부터 시작하는 홀수 수열의 종료 지점만을 입력받아 합을 구하도록 구현되어 있다. 이 함수의 범용성을 높이기 위해 홀수 수열의 시작 지점을 형식 인수 a에 입력받아 홀수 합을 구하도록 개선해 보자. 그런데, 이렇게 함수를 개선하면 기존에 이 함수를 이용하는 프로그램은 형식 인수 a에 값을 부여하지 않고 호출하기 때문에 모두 오류가 발생할 것이다. 따라서 앞서 작동하던 방식과 호환성을 유지하기 위해 호출시 시작 지점 a가 지정되지 않으면 1부터 시작하는 홀수 수열의 합을 구하도록 개선된 함수를 정의해 보자.위의 예의 마지막 oddsum() 함수 호출에서 실질 인수가 하나밖에 없으므로 형식 인수 정의 순서에서 가장 빠른 b에 3이 부여된다. 그러므로 a는 값이 지정되지 않았으므로 초기값 1이 부여되어 실행된다. b도 초기값이 지정되어 있으므로 값만 지정하여 호출도 가능하다. 이 경우 형식 인수 a가 형식 인수 b 뒤에 정의되어 있으므로 a에만 실질 인수를 전달하고 실질 인수 앞에 형식 인수 a를 지정하여 호출해야 한다.","code":"\noddsum <- function(b) sum(seq(from=1, to=b, by=2))\noddsum(5)#> [1] 9\noddsum(10)#> [1] 25\noddsum()#> Error in seq(from = 1, to = b, by = 2): 기본값이 없는 인수 \"b\"가 누락되어 있습니다\noddsum <- function(b=100) sum( seq(from=1, to=b, by=2) )\noddsum()#> [1] 2500\noddsum(3)#> [1] 4\noddsum <- function(b=100, a=1) sum(seq(from=a, to=b, by=2))\noddsum(a=5, b=10)#> [1] 21\noddsum(3)#> [1] 4\noddsum(a=97)#> [1] 196"},{"path":"ch-R-Programming-Structure.html","id":"r-기본-함수에서의-초기값-사용","chapter":"10 R 프로그래밍 구조","heading":"R 기본 함수에서의 초기값 사용","text":"이러한 원리로 R의 많은 함수들이 함수의 모든 인수를 일일이 지정하지 않아도 호출이 가능하도록 정의되어 있다. 예를 들어 수열을 만드는 seq() 함수는 인수는 초기값이 1, 인수도 초기값이 1, 인수는 to부터 사이를 1씩 증가하도록 초기값이 설정되어 있다. 그리고, 형식 인수의 정의 순서는 , , 순으로 되어 있다. 이러한 사실을 고려하면 왜 다음의 seq() 호출이 해당 결과를 출력하는지 이해할 수 있을 것이다.또 다른 예로 CSV 파일에서 데이터 프레임을 읽어들이는 read.csv() 파일의 정의를 살펴보자.첫번째 형식 인수가 file로서 초기값이 없으므로 항상 read.csv() 호출시에는 파일 이름이 제공되어야 함을 알 수 있다. 두번째 형식 인수는 header인데 TRUE로 초기값을 가지고 있다. 따라서 header 인수를 지정하지 않고 호출하면 파일에 header가 있는 것으로 생각하고 파일을 읽어들인다. 그리고 sep 형식 인수는 파일이 데이터의 필드(열)를 무엇으로 분리하고 있는지를 전달하는 인수이다. 초기값이 ’,’로 되어 있어서 함수 호출시 특별한 지정이 없으면 쉼표로 데이터를 분리하여 인식한다는 것을 알 수 있다.12","code":"\nseq()#> [1] 1\nseq(by=2)#> [1] 1\nseq(1, 5, 2)#> [1] 1 3 5\nseq(to=4)#> [1] 1 2 3 4\nseq(to=-5)#> [1]  1  0 -1 -2 -3 -4 -5\nseq(to=10, by=2)#> [1] 1 3 5 7 9\nread.csv#> function (file, header = TRUE, sep = \",\", quote = \"\\\"\", dec = \".\", \n#>     fill = TRUE, comment.char = \"\", ...) \n#> read.table(file = file, header = header, sep = sep, quote = quote, \n#>     dec = dec, fill = fill, comment.char = comment.char, ...)\n#> <bytecode: 0x561448e589e8>\n#> <environment: namespace:utils>"},{"path":"ch-R-Programming-Structure.html","id":"형식-인수","chapter":"10 R 프로그래밍 구조","heading":"... 형식 인수","text":"R 함수의 형식 인수 중에 ...라는 형식 인수가 있다. 이 형식 인수는 함수 정의 때 기술된 형식 인수 말고 다른 형식 인수 이름으로 실질 인수를 전달받을 수 있게 해준다.\n다음 예에서 g()에서 w 형식 인수가 정의되어 있지 않아, 실질 인수 1을 형식 인수 w로 전달하려는 호출에 오류가 발생하는 것을 볼 수 있다.그런데 함수를 정의할 때, 형식 인수 목록에 ’...’를 지정하면, 정의된 형식 인수 말고 다른 이름의 형식 인수로 실질 인수를 전달받아도 오류가 나지 않음을 알 수 있다.그런데 위의 예에서는 전달 받은 w나 r을 함수 본문에서 전혀 사용하지 않았으므로 쓸모 없는 실질 인수의 전달이 되었다. 만약 위의 예가 x, y, z로 전달된 인수뿐 아니라 다른 이름으로 전달된 인수를 모두 출력한 후 그 인수들을 합산하여 결과에 반영한다고 하면 새롭게 전달된 형식 인수들이 의미를 가질 것이다. 다음은 ’...’를 이용하여 이름이 지정되지 않은 형식 인수를 전달받아 처리하는 예를 보여준다.일반적으로 ... 인수는 다음 두 가지 경우에 많이 사용된다. c()나 sum() 함수처럼 개수가 지정되지 않은 여러 개의 요소를 받아서 일괄적인 처리가 필요한 경우이다. 이 경우 몇 개의 실질 인수가 전달될지 모르기 때문에 이름을 가진 형식 인수로 실질 인수를 전달받을 수 없다.두번째는 자신에게 전달된 부차적인 인수들을 자신이 직접 처리하지 않고, 다른 함수에게 전달하여 처리하는 경우이다.\nplot()의 주요한 형식 인수는 그래프 상에서의 점을 그릴 x 축과 y 축의 좌표이다.plot() 함수는 이러한 주요 인수뿐 아니라 ... 인수를 이용하여 다양한 그래픽 매개변수를 선택적으로 전달받을 수 있다.실제로는 이렇게 전달받은 선택적인 인수는 자신이 직접 처리하는 것이 아니라 par() 함수 등에 전달하여 처리한다. 그런데 par() 함수에 전달될 수 있는 인수는 매우 다양하므로 이를 일일이 plot()의 형식 인수로 지정하는 것은 힘든 일이 될 것이다. 또한 이를 모두 지정할 수 있다 하더라도 par() 함수에 새로운 인수가 추가되면 plot() 함수의 정의도 변경되어야 한다. 이러한 경우 ... 인수를 이용하여 기타 선택적인 인수를 전달받은 후 모두 par() 함수에 전달하여 처리하면 편리하다.\nR의 기본 함수 중에는 자신이 받은 인수를 다른 함수에 전달하여 실행하는 경우가 많아서 의외로 ... 인수가 정의된 함수들이 많이 있다.","code":"\ng(x=1, y=1, z=1, w=1)#> Error in g(x = 1, y = 1, z = 1, w = 1): 사용되지 않은 인자 (w = 1)\ng <- function(x, y, z, ...) 100 * x + 10 * y + z \ng(x=1, y=1, z=1, w=1, r=2)#> [1] 111\ng <- function(x, y, z, ...) {\n  cat(..., sep=\",\")\n  cat(\"를 추가적으로 입력받았습니다.\\n\")\n  100 * x + 10 * y + z + sum(...)\n}\ng(x=1, y=1, z=1, w=1, r=2)#> 1,2를 추가적으로 입력받았습니다.#> [1] 114\nc#> function (...)  .Primitive(\"c\")\nc(1:2, c(3, 6), 7:2)#>  [1] 1 2 3 6 7 6 5 4 3 2\nsum#> function (..., na.rm = FALSE)  .Primitive(\"sum\")\nsum(1:2, c(3, 6), 7:2)#> [1] 39\nx <- 1:30\ny <- x^2\nplot(x, y)\nplot#> function (x, y, ...) \n#> UseMethod(\"plot\")\n#> <bytecode: 0x5614497596d0>\n#> <environment: namespace:base>\nplot(x, y, type=\"o\", col=\"red\", pch=\"*\", lty=1, lwd=1.5)"},{"path":"ch-R-Programming-Structure.html","id":"함수의-반환값","chapter":"10 R 프로그래밍 구조","heading":"함수의 반환값","text":"앞에서 함수가 반환하는 값은 함수 본문 표현식의 평가 결과라고 말하였다. 보통 함수 본문 표현식은 블록 표현식인 경우가 많으므로 블록 표현식의 평가 결과는 블록 표현식의 마지막 명령문의 평가 결과가 된다. 따라서 블록 표현식이 함수 본문인 경우 마지막 명령문의 실행 결과가 반환되게 된다.다음은 어떤 물품의 주문수량(quantity)를 입력받아서 가격을 반환하는 함수이다.\n주문수량이 500 개 미만이면 물품의 단가를 100원으로 500 개 이상이면 물품의 단가를 80원으로 하여 가격을 계산하여 반환한다.\n함수에 여러 개의 실행문이 있는 경우에는 반복문과 마찬가지로 중괄호 { }를 이용하여 실행문을 묶어준다. 이 경우 중괄호 { } 안에서 마지막으로 실행된 실행문의 결과가 함수의 반환값으로 반환된다.그런데 함수 본문의 중간에서 결과를 반환한 필요가 있을 때가 있다. 이런 경우에는 return() 함수를 이용하여 명시적으로 함수를 종료하고 특정 표현식의 결과 값을 반환하도록 할 수 있다.\n다음 예는 입력 변수 x의 값의 0이거나 양수이면 x의 제곱근의 값을 반환하지만 x가 음수이면 제곱근을 구할 수 없기 때문에 관련된 메시지를 출력하고 NULL을 반환하는 함수를 만든 예이다.위의 예에서 return()을 이용하여 함수 본문의 마지막에 도달하기 전에 함수를 종료시키고 원하는 값을 반환하였다.\n함수 본문의 마지막 부분에도 명시적으로 return() 함수를 이용하여 값을 반환할 수 있다.그러나 일반적으로 R에서는 마지막 평가식의 결과를 반환할 때는 return() 함수를 사용하지 않는 경향이 많다.","code":"\ncalPrice <- function(quantity) {\n  if (quantity < 500) {\n    unitPrice <- 100\n  } else {\n    unitPrice <- 80\n  }\n  unitPrice * quantity\n}\n\ncalPrice(100)#> [1] 10000\ncalPrice(1000)#> [1] 80000\nh <- function(x) {\n  if (x < 0) {\n    cat(\"x must be positive.\\n\")\n    return(NULL)\n  }\n  sqrt(x)\n}\nh(2)#> [1] 1.414214\nh(-2)#> x must be positive.#> NULL\ncalPrice2 <- function(quantity) {\n  if (quantity < 500) {\n    unitPrice <- 100\n  } else {\n    unitPrice <- 80\n  }\n  return(unitPrice * quantity)\n}\n\ncalPrice2(100)#> [1] 10000\ncalPrice2(1000)#> [1] 80000"},{"path":"ch-R-Programming-Structure.html","id":"함수-객체를-인수로-사용하기","chapter":"10 R 프로그래밍 구조","heading":"10.3.2 함수 객체를 인수로 사용하기","text":"","code":""},{"path":"ch-R-Programming-Structure.html","id":"함수도-객체이므로-실질-인수가-될-수-있다.","chapter":"10 R 프로그래밍 구조","heading":"함수도 객체이므로 실질 인수가 될 수 있다.","text":"lapply() 함수와 sapply() 함수는 리스트의 각 요소에 원하는 함수를 반복적으로 적용할 수 있게 해준다. 이 때 리스트 요소에 적용할 함수를 lapply()와 sapply()의 실질 인수로 전달하였다. 이러한 일이 가능한 이유는 R에서는 함수도 객체이므로 일반 벡터나 행렬처럼 함수의 인수로 함수를 전달할 수 있기 때문이다.다음은 숫자 벡터들을 요소로 하는 리스트에 대해, 각 요소의 평균을 구한 예이다. 이 예에서 sapply() 함수 호출 시 첫번째 인수로 리스트를, 두번째 인수로 mean() 함수 객체를 전달하고 있음을 볼 수 있다.","code":"\na <- list(x=x, y=y, z=sqrt(x))\nsapply(a, mean)#>          x          y          z \n#>  15.500000 315.166667   3.736095\nmean#> function (x, ...) \n#> UseMethod(\"mean\")\n#> <bytecode: 0x5614450c2e68>\n#> <environment: namespace:base>"},{"path":"ch-R-Programming-Structure.html","id":"apply-계열-함수에-사용자-함수-적용하기","chapter":"10 R 프로그래밍 구조","heading":"apply 계열 함수에 사용자 함수 적용하기","text":"그런데 apply 계열 함수에는 R에서 기본적으로 제공하는 함수뿐만 아니라 사용자가 직접 정의한 함수를 포함한 어떠한 함수도 전달이 가능하다. 다음은 벡터에서 10 이상의 숫자의 개수를 세는 count10()이라는 사용자 함수를 정의한 후 이를 sapply()에 인수로 전달한 예이다.","code":"\ncount10 <- function(x) sum(x >= 10)\nsapply(a, count10)#>  x  y  z \n#> 21 27  0"},{"path":"ch-R-Programming-Structure.html","id":"무기명-함수","chapter":"10 R 프로그래밍 구조","heading":"무기명 함수","text":"그런데 count10()이 다른 데서도 사용할 만한 범용적인 함수라면 이를 위의 예처럼 변수에 할당하여 계속 사용하는 것이 좋겠지만, 이 sapply() 함수 호출에만 이용하는 임시적인 함수라면 굳이 변수에 할당하여 메모리에 저장해 둘 이유가 없다.\n이런 경우에는 sapply()의 두번째 인수 부분에 직접 함수 객체를 만들어 전달하는 것이 더 효율적이다. 이 함수는 변수로 저장되지 않았으므로 추후에 다시 호출할 수 있는 방법은 없다. 이러한 함수를 무기명 함수(anonymous functions)라고 한다. 다음은 무기명 함수를 이용하여 리스트의 요소에서 5이상의 수의 개수를 세는 예이다.무기명 함수를 이용하면 한번만 사용될 함수를 메모리에 남겨두지 않을 수 있고, sapply() 호출 문장에 함수가 바로 정의되어 있어서 리스트 요소에 적용되는 함수의 내용을 바로 그 지점에서 파악이 가능한 장점이 있다.\n사실 무기명 함수는 함수 객체를 변수에 부여하지 않는다는 측면에서, 다음처럼 한번만 사용될 데이터 객체를 굳이 변수에 넣지 않는 예와 일맥상통하다고 할 수 있다. 이 경우에도 sapply()에 사용된 리스트가 변수에 할당되지 않았으므로 다시 이 데이터에 접근할 수 있는 방법은 없다.","code":"\nsapply(a, function(x) sum(x >= 5))#>  x  y  z \n#> 26 28  6\nsapply(list(x=1:5, y=x^2, z=sqrt(x)), mean)#>          x          y          z \n#>   3.000000 315.166667   3.736095"},{"path":"ch-R-Programming-Structure.html","id":"r-연산자","chapter":"10 R 프로그래밍 구조","heading":"10.3.3 R 연산자","text":"R에서는 연산자도 사실 함수이다. 대신 연산자의 함수 이름을 쓰기 위해서는 ` ` 안에 연산자를 표현해야 한다.R 사용자는 함수를 정의하는 방식과 같은 방법으로 자신만의 연산자를 정의할 수 있다. 다만 사용자가 정의하는 연산자의 함수이름은 %연산자이름% 형식으로 정의하여야 한다. 다음과 같은 f 연산자를 만들어 보자.","code":"\n1 + 3#> [1] 4\ntypeof(`+`)#> [1] \"builtin\"\n`+`(1, 2)#> [1] 3\n`-`(1, 2)#> [1] -1\n`%f%` <- function(x, y) x^2 - y\n2 %f% 4#> [1] 0\n3 %f% 0#> [1] 9\n`%f%`(1, 2)#> [1] -1"},{"path":"ch-R-Programming-Structure.html","id":"변수-범위","chapter":"10 R 프로그래밍 구조","heading":"10.3.4 변수 범위","text":"프로그램이 복잡해지면 많은 변수를 사용하게 된다. 이 때 변수 이름 간에 서로 충돌이 나지 않도록 조심해야 한다. 중복된 이름을 사용하면 의도하지 않은 결과를 얻게 될 수 있다.","code":""},{"path":"ch-R-Programming-Structure.html","id":"변수-범위의-필요성","chapter":"10 R 프로그래밍 구조","heading":"변수 범위의 필요성","text":"혼자 프로그램을 할 때는 일정한 규칙에 따라 변수 이름을 부여해 나가면 변수 이름의 충돌을 어느 정도 방지할 수 있다. 그러나 여러 사람이 같이 협력하여 큰 프로그램을 완성하거나, 다른 사람이 이미 만들어둔 패키지나 함수들을 이용해야 한다면 변수 이름의 충돌은 빈번하게 발생할 가능성이 크다.\n예를 들어 x라는 변수 이름은 많은 사람들이 즐겨 사용할 만한 이름이어서 프로그램의 서로 다른 부분에서 x를 다르게 정의하여 사용할 가능성이 커진다.\n그러므로 내가 사용하는 변수 x와 다른 사람이 정의한 함수 내의 x를 서로 구분할 수 있는 방법이 필요하다. 그렇지 않다면 변수 이름을 하나 작명하는 데에도 다른 사람들이 이미 작성한 함수에서 사용한 변수의 이름을 먼저 조사해야 할 것이다. 실제 R에서는 엄청나게 많은 함수들이 존재하고 이를 수행한다는 것은 사실 불가능에 가깝다.이러한 변수 이름의 충돌 문제를 거의 대부분의 고급 프로그래밍 언어는 변수의 범위(scope)라는 개념을 이용하여 해결한다. R도 예외는 아니다. 변수의 범위란 해당 변수가 유효한 영역을 의미하며, 서로 다른 범위에 있는 같은 이름의 변수는 서로 충돌이 나지 않도록 해준다.\n사실 변수 범위와 관련된 내용은 매우 복잡한 주제이다. 이 절에서는 함수 내에서의 변수 사용과 관련된 기본적 문제에 관련해서만 변수 범위를 논하도록 한다.13","code":""},{"path":"ch-R-Programming-Structure.html","id":"함수-본문에-사용되는-변수의-종류","chapter":"10 R 프로그래밍 구조","heading":"함수 본문에 사용되는 변수의 종류","text":"함수의 본문에 나타나는 변수는 세 범주로 분류된다.첫번째 범주는 함수의 형식 인수(formal arguments)로 함수의 인수 리스트로 표현된다. 함수의 형식 인수의 값은 함수 호출 시 함수의 실질 인수 값으로 바인딩이 이루어진다.두번째 범주는 지역 변수(local variables)로 함수 본문 안에서 할당이 이루어진 변수이다.세번째 범주는 자유 변수(free variables)로 형식 인수도 아니고 지역 변수도 아닌 변수이다. 자유 변수는 함수가 만들어진 환경에서 변수의 값을 찾는다. 자유 변수가 함수 안에서 할당이 이루어지면 지역 변수가 된다.","code":""},{"path":"ch-R-Programming-Structure.html","id":"지역-변수-형식-인수-자유-변수의-순으로-변수의-평가가-이루어진다.","chapter":"10 R 프로그래밍 구조","heading":"지역 변수, 형식 인수, 자유 변수의 순으로 변수의 평가가 이루어진다.","text":"R은 함수에서 어떤 변수의 값을 평가할 때, 맨 먼저 이 변수가 지역 변수인지 살펴본다. 지역 변수여서 함수 본문 내부에서 할당되어 있으면, 그 할당된 값으로 변수를 평가한다. 지역 변수가 아니라면 형식 인수인지 살펴본다. 형식 인수이면 형식 인수에 전달된 실질 인수의 값으로 그 변수를 평가한다. 형식 인수도 아니면 자유 변수로 간주하여 함수가 생성되었던 환경에서 변수를 찾는다. 함수의 외부 환경에서도 변수를 찾을 수 없으면 변수를 찾을 수 없다는 오류가 발생한다.다음 예에선 함수 f는 변수 x, y, z의 합을 반환한다.\n여기서 x는 형식 인수로 함수 f가 호출될 때마다 함수의 실질 인수의 값으로 바인딩된다. y는 지역 변수로 함수 본문 안에서 정의되어 10으로 할당이 되었다.\n변수 z는 형식 인수도 지역 변수도 아닌 자유 변수이다. 자유 변수는 함수 내부에서 그 값을 찾을 수 없으므로 함수가 정의된 환경에서 그 값을 찾는다. 우리는 현재 R 콘솔에서 작업을 하고 있으므로 함수 f()는 R 콘솔의 전역 공간인 R_GlobalEnv에서 정의되었고 여기서 z의 값을 찾게 된다.","code":"\nrm(x, y, z)#> Warning in rm(x, y, z): 객체 'z'를 찾을 수 없습니다\nf <- function(x) {\n  y <- 10\n  x + y + z\n}"},{"path":"ch-R-Programming-Structure.html","id":"자유-변수는-함수가-정의가-이루어진-환경에서-함수가-호출될-때-평가가-이루어진다.","chapter":"10 R 프로그래밍 구조","heading":"자유 변수는 함수가 정의가 이루어진 환경에서 함수가 호출될 때 평가가 이루어진다.","text":"맨 처음 함수 f를 실행할 때 f를 정의한 작업 공간에 z에 대한 정의가 없으므로 함수 f를 호출하면 오류가 발생한다. R 콘솔에서 z라는 변수를 할당한 후 다시 f를 호출하면 외부 환경에 정의된 z의 값이 결과에 반영됨을 볼 수 있다.","code":"\nf(1)#> Error in f(1): 객체 'z'를 찾을 수 없습니다\nz <- 3\nf(1)#> [1] 14"},{"path":"ch-R-Programming-Structure.html","id":"동일한-이름이어도-함수-내부의-변수와-외부의-변수는-별개의-변수이다.","chapter":"10 R 프로그래밍 구조","heading":"동일한 이름이어도 함수 내부의 변수와 외부의 변수는 별개의 변수이다.","text":"그런데 함수의 형식 인수와 함수 내부의 지역 변수는 함수 내부에서만 의미를 갖는다. (즉 함수 내부로 범위가 설정된다). 따라서 함수 바깥 범위에서는 형식 인수 x와 지역 변수 y에 대해서는 알지 못한다.다음처럼 R 콘솔에서 x와 y를 정의한 후 다시 f()를 실행해 보자.함수의 외부 환경에서 x와 y 변수가 만들어져서 0의 값이 할당되었지만, 함수를 호출하면 함수 본문에서 x, y는 모두 형식 인수에 부여된 실질 인수 값 2와 지역 변수로서 할당된 값 10으로 평가되었음을 확인할 수 있다. 왜냐하면 R은 함수 실행시 변수를 지역 변수와 형식 인수에서 먼저 찾기 때문에, 변수에 대한 값을 함수 내부에서 찾으면 전역 공간에 정의된 x, y는 참고하지 않기 때문이다. 그리고 함수 본문에서 x는 2와 y는 10으로 값이 주어졌지만, 함수 바깥의 x, y 변수에는 전혀 영향을 주지 못함을 볼 수 있다. 다만 z는 함수 내부에 정의된 변수가 아니고 함수 외부에서 찾아야 하는 자유 변수이므로 전역 공간에서 z의 값이 변경되면 함수의 평가시에도 그 변화가 반영됨을 알 수 있다.","code":"\nx#> Error in eval(expr, envir, enclos): 객체 'x'를 찾을 수 없습니다\ny#> Error in eval(expr, envir, enclos): 객체 'y'를 찾을 수 없습니다\nx <- 0; y <- 0\nf(2)#> [1] 15\nx; y#> [1] 0#> [1] 0\nz <- 10\nf(2)#> [1] 22"},{"path":"ch-R-Programming-Structure.html","id":"자유-변수를-함수-내부에서-할당하면-새로운-지역-변수가-된다.","chapter":"10 R 프로그래밍 구조","heading":"자유 변수를 함수 내부에서 할당하면 새로운 지역 변수가 된다.","text":"만약 자유 변수 z를 함수 내부에서 값을 변경하면 어떻게 될까?결과에서 보듯이 전역 변수 z의 값은 전혀 변화가 없다. 위의 예에서 a의 변수에 x, y, z의 합을 할당할 때까지는 함수 내부에서 z 변수에 대한 할당이 이루어지 않았으므로 전역 공간의 z를 참조하여 10이라는 값으로 z를 평가하여 계산한다. 그 다음에 z에 0을 할당하면 함수 내부에 z라는 별도의 지역 변수가 만들어지게 되고, 전역 변수 z와는 전혀 무관한 변수가 된다. 따라서 b에 x, y, z의 합을 할당하는 문장에서는 z를 먼저 지역 변수에서 찾으므로 지역 변수 z에 할당된 0의 값으로 평가하게 된다. 마지막으로 z가 함수 내부에서 0으로 할당된 것은 함수 내부의 지역 변수에 할당이 이루어진 것이므로 전역 변수 z에는 전혀 영향을 미치지 못한다.","code":"\nz <- 10\nf <- function(x) {\n  y <- 10\n  a <- x + y + z\n  z <- 0\n  b <- x + y + z\n  c(a, b)\n}\nf(2)#> [1] 22 12\nz#> [1] 10"},{"path":"ch-R-Programming-Structure.html","id":"함수-외부-환경의-변수에-값-할당하기","chapter":"10 R 프로그래밍 구조","heading":"함수 외부 환경의 변수에 값 할당하기","text":"그런데 가끔은 함수 내부에서 함수 외부의 전역 변수의 값을 변경해야 할 경우가 있다. 함수 내부의 지역 변수와 형식 인수는 함수 호출 시에만 생성되었다가 함수 실행이 완료되면 사라진다. 따라서 함수 f() 내부의 x, y는 함수 f()가 실행될 때마다 새로 만들어지고 사라지게 된다. 따라서 함수의 호출과 무관하게 데이터를 유지해야 할 필요가 있을 때는 함수 외부 환경의 전역 변수를 사용해야 한다.\n다음 예를 살펴보자. 다음의 call.count() 함수는 자신이 총 몇번 호출되었는지를 기록하는 함수이다.call.count() 함수는 자신이 호출될 때마다 전역 변수 x의 값을 읽은 후 1을 더하여 다시 x에 할당하려고 한다. 그러나 x를 하나씩 증가시키는 할당문이 실행될 때, 오른편의 x는 아직 x가 함수 내부에 할당되기 전이기에 전역 변수 x를 참조하지만, 할당문 왼편의 x는 함수 내부에서 할당이 이루어진 것이므로, 함수 내부의 지역 변수가 되어 전역 변수와 무관해 진다. 따라서 함수의 지역 변수 x에만 1이 할당되었다. 그런데 첫번째 함수 호출이 끝나면 함수 내부의 지역 변수는 모두 사라진다. 따라서 두번째 호출시 할당문의 오른편이 실행될 때는 역시 지역 변수 x는 존재하지 않으므로 다시 전역 변수 x를 참조하게 된다. 전역 변수는 변화가 없었으므로 0의 값을 계속 가지고 있고 첫번째 호출과 같은 결과만 얻을 뿐이다.","code":"x <- 0\ncall.count <- function() {\n  x <- x + 1\n  cat(x, \"번 호출되었습니다.\")\n}\ncall.count()#> 1 번 호출되었습니다.call.count()#> 1 번 호출되었습니다.x#> [1] 0"},{"path":"ch-R-Programming-Structure.html","id":"수퍼-할당-연산자","chapter":"10 R 프로그래밍 구조","heading":"수퍼 할당 연산자","text":"이 문제를 해결하는 방법은 함수 내부에서 외부 전역 변수에 값을 할당할 수 있도록 하는 것이다. 일반 할당 연산자 <-로는 지역 변수만 생성될 뿐이다. 그러나 수퍼 할당 연산자 <<-를 이용하여 할당을 하면 지역 변수가 아닌 함수의 외부 환경에서 변수를 찾아서 할당을 시도한다. 이를 이용하면 위의 call.count()는 다음처럼 개선될 수 있다.이번에는 함수 호출의 결과로 전역 변수가 변경되고 원하는 결과를 얻을 수 있었다.수퍼 할당 연산자로 값을 부여하고자 하는 변수가 외부 환경에 없으면 외부 환경에 해당 변수를 만든다. 마치 외부 환경에서 변수에 할당할 때 변수가 없으면 새로운 변수를 만드는 것과 동일한 작용을 하게 된다.","code":"\ncall.count <- function() {\n  x <<- x + 1\n  cat(x, \"번 호출되었습니다.\")\n}\ncall.count()#> 1 번 호출되었습니다.\ncall.count()#> 2 번 호출되었습니다.\nx#> [1] 2\nrm(w)#> Warning in rm(w): 객체 'w'를 찾을 수 없습니다\nw#> Error in eval(expr, envir, enclos): 객체 'w'를 찾을 수 없습니다\nsq <- function(a) w <<- a^2\nsq(10)\nw#> [1] 100"},{"path":"ch-R-Programming-Structure.html","id":"함수의-외부-환경이-함수인-경우","chapter":"10 R 프로그래밍 구조","heading":"함수의 외부 환경이 함수인 경우","text":"R에서는 함수 내부에서 벡터, 리스트 등의 객체를 변수에 할당할 수 있듯이, 함수 내부에서 함수를 정의하여 변수에 할당할 수 있다. 이런 경우 함수의 변수 범위는 계층 구조를 가지게 된다. 함수 내부에서 정의된 안쪽 함수의 외부 환경은 바깥쪽 함수가 된다. 그리고 바깥쪽 함수의 외부 환경은 R 콘솔의 전역 공간이 된다. 다음의 예를 살펴보자.만약에 f.()에 다른 값을 실질 인수로 하여 호출하면 어떻게 될까?마찬가지로 f.(30) 호출에 의해 f.() 함수 객체가 반환되어 변수 b에 할당된다.\nb(300) 호출이 이루어지면, f.() 함수가 실행되는데, x는 지역 변수이므로 함수 내부에서 정의된 2의 값이 할당되고, y는 자유 변수인데 이번에 생성된 함수 b는 f.(30) 호출에 의해 만들어진 함수이므로 f.(30)이 자신의 외부 환경이 된다. 따라서 y는 30의 값으로 평가된다. z는 자신의 형식 인수로 300이 호출시 주어졌다. 이것들이 합산되어 332의 결과가 반환된다.","code":"\nf.out <- function(y){\n  f.in <- function(z){\n    x <- 2\n    x + y + z\n  }\n  return(f.in) \n}\n\nx <- 1; y <- 10; z <- 100\na <- f.out(20)\na(200)#> [1] 222\nb <- f.out(30)\nb(300)#> [1] 332"},{"path":"ch-R-Programming-Structure.html","id":"environment","chapter":"10 R 프로그래밍 구조","heading":"environment()","text":"f.() 함수에서 생성되어 반환된 두 함수 객체 , b의 외부 환경이 무엇인지 확인해 보자. environment() 함수는 인수로 전달된 함수 객체의 외부 환경이 무엇인지를 알려준다.f.() 함수는 전역 공간에서 정의하였으므로 전역 공간이 자신의 외부 환경임을 알려준다. , b는 각자 서로 다른 외부 환경을 가지고 있음을 볼 수 있다. 그러나 , b 각각의 외부 환경의 부모 외부 환경은 전역 공간임을 볼 수 있다.\n참고로 f.() 함수는 f.() 함수의 호출 환경에서 정의된 함수 객체이므로 전역 공간에서는 모르는 함수이다. 따라서 전역 공간에서 f.() 함수를 찾으면 찾을 수 없다는 결과가 나온다.","code":"\nenvironment(f.out)#> <environment: R_GlobalEnv>\nenvironment(a); parent.env(environment(a))#> <environment: 0x561447cdaa20>#> <environment: R_GlobalEnv>\nenvironment(b); parent.env(environment(b))#> <environment: 0x5614494b5d68>#> <environment: R_GlobalEnv>\nenvironment(f.in)#> Error in environment(f.in): 객체 'f.in'를 찾을 수 없습니다"},{"path":"ch-R-Programming-Structure.html","id":"ls와-get","chapter":"10 R 프로그래밍 구조","heading":"ls()와 get()","text":"ls() 함수를 이용하면 환경에 정의되어 있는 변수 정보를 얻을 수 있고, get() 함수를 이용하면 변수 이름으로 변수 값을 확인할 수 있다.함수 객체 a와 b의 외부 환경인 f.호출 환경에는 y와 f.in이라는 변수가 모두 존재한다. 그러나 get() 함수로 확인한 이 두 환경에 있는 y 변수의 값을 서로 다름을 알 수 있다. 그리고 전역 공간인 .GlobalEnv에 있는 변수 y의 값과도 다름을 알 수 있다.이처럼 R은 함수에 사용되는 변수를 먼저 자기 내부에서 조회해 보고, 없으면 자신이 정의된 외부 환경, 거기에도 없으면 외부 환경의 부모 환경으로 거슬러 올라가며 조회해 나간다. 만약 최상위 환경(여기서는 .GlobalEnv)에도 찾는 변수가 없으면, 그 다음에는 검색 경로(search path)를 거슬러 올라가며 변수를 찾는다. 변수 검색 경로는 현재의 전역 공간을 시작으로 적재된 R 패키지와 attach() 함수로 포함된 데이터 프레임들이 되며, 맨 마지막은 R의 기본 패키지인 base 패키지 환경이 된다. 이 모든 곳에서 해당 변수를 찾을 수 없으면, 변수를 찾을 수 없다는 오류를 발생시킨다. 검색 경로에 대한 설명은 데이터 프레임의 attach() 관련 절을 확인하기 바란다. 아울러 현 작업 공간의 검색 경로는 searchpaths() 함수로 확인할 수 있다.","code":"\nls(environment(a))#> [1] \"f.in\" \"y\"\nls(environment(b))#> [1] \"f.in\" \"y\"\nget(\"y\", envir=environment(a))#> [1] 20\nget(\"y\", envir=environment(b))#> [1] 30\nget(\"y\", envir=.GlobalEnv)#> [1] 10"},{"path":"ch-R-OOP.html","id":"ch-R-OOP","chapter":"11 R 객체 지향 프로그래밍","heading":"11 R 객체 지향 프로그래밍","text":"","code":""},{"path":"ch-R-OOP.html","id":"객체-지향-프로그래밍","chapter":"11 R 객체 지향 프로그래밍","heading":"11.1 객체 지향 프로그래밍","text":"객체 지향 프로그램(Object-Oriented Programming(OOP))이 무엇인지, 그것이 왜 필요한지를 논의하려면 별도로 한 장이 할애되어야 할 것이다. 여기서는 객체 지향 프로그래밍의 개요에 대해서만 간단히 짚어본다.OOP는 복잡한 프로그램을 구조화하는 방식에 대한 하나의 관점 또는 패러다임이라 할 수 있다. 간단한 프로그램은 어떠한 방식으로 작성하여도 이해하거나 수정이 어렵지 않다. 그러나 프로그램이 복잡해지면 프로그램을 적절한 단위로 구조화해야 프로그램 전체를 이해할 수 있고 유지보수가 가능해진다.","code":""},{"path":"ch-R-OOP.html","id":"절차적-프로그래밍-vs.-객체-지향-프로그래밍","chapter":"11 R 객체 지향 프로그래밍","heading":"절차적 프로그래밍 vs. 객체 지향 프로그래밍","text":"이러한 프로그램 구조화 패러다임 중 가장 오래된 방식이 절차적 프로그래밍(procedural programming) 패러다임이다. 절차적 프로그래밍은 프로그램을 기능적으로 유사한 부분으로 분절한다. 이러한 분절은 전체 프로그램을 기능에 따라 프로그램-모듈-함수/서브루틴/프로시저 등으로 계층적으로 구조화한다.\n반복되어 사용되는 부분을 함수나 프로시저로 구현한 후, 필요할 때마다 해당 함수나 프로시저를 호출하여 사용할 수 있게 함으로써 비슷한 기능에 대한 구현이 프로그램 전체에 산재하여 유지보수하기 어렵게 되는 것을 막아 준다. 절차적 프로그래밍 방식을 비유적으로 말하자면, 어떤 복잡한 조직을 총무부, 인사부, 생산부, 자재부 등의 기능조직으로 나누어 구조화하는 방식과 비슷하다고 하겠다.\n특화된 기능 조직이 비슷한 기능을 효율적으로 전담하여 반복수행하는 것처럼, 특화된 모듈과 함수는 비슷한 작업을 호출할 때마다 반복수행한다.\n프로그래밍 언어와 프로그래밍 방식이 일 대 일로 대응되는 것은 아니지만, 절차적 프로그래밍 방식을 주로 사용하는 프로그래밍 언어로는 C 언어를 들 수 있다.객체 지향 프로그래밍(OOP)는 복잡한 프로그램을 객체를 중심으로 구조화한다. 절차적 프로그래밍이 함수나 프로시저 등을 이용하여 기능 중심으로 프로그램을 분절한다면, OOP는 데이터를 중심으로 동일한 형식의 데이터를 처리하는 부분으로 프로그램을 분절한다. 이를 비유적으로 말하자면 절차적 프로그래밍이 기능 조직이어서 여러 사업과 관련된 동일한 기능이 하나의 기능 부서에 통합되어 있는 형식이라면, OOP는 사업부 조직으로서 하나의 사업이라는 내용을 중심으로 총무, 인사, 생산, 자재 등의 기능이 뭉쳐 있는 형식이라 할 수 있다. OOP를 따르는 주요 언어로는 C++, Java 등이 있다. R은 이러한 언어와는 조금 다르지만 기본적인 OOP 특성을 가지고 있다.","code":""},{"path":"ch-R-OOP.html","id":"oop의-기본-특징","chapter":"11 R 객체 지향 프로그래밍","heading":"OOP의 기본 특징","text":"","code":""},{"path":"ch-R-OOP.html","id":"s3-클래스","chapter":"11 R 객체 지향 프로그래밍","heading":"11.2 S3 클래스","text":"R은 OOP 개념을 처음에는 S3 클래스로 구현하였다. 그러나 S3 클래스는 캡슐화 및 데이터 보안에 취약한 점이 있으므로 이를 강화할 수 있는 S4 클래스를 나중에 도입하였다. 그러나 아직까지 대다수의 R 패키지는 S3 클래스에 의해 OOP를 구현하고 있고, 아직도 많은 R 사용자가 S3 클래스로 개발하는 것을 선호하고 있다.","code":""},{"path":"ch-R-OOP.html","id":"s3-클래스-객체-만들기","chapter":"11 R 객체 지향 프로그래밍","heading":"11.2.1 S3 클래스 객체 만들기","text":"본질적으로 S3 클래스 객체란 R의 리스트 객체에 class 속성을 부여한 것뿐이다. 앞서 본 lm() 함수의 결과 객체 a는 lm 클래스 객체였다. 이 객체를 unclass() 함수를 이용하여 클래스 속성을 제외하면 단순한 리스트임을 확인할 수 있다.","code":""},{"path":"ch-R-OOP.html","id":"s3-클래스-객체는-리스트에-class-속성-부여하여-만든다.","chapter":"11 R 객체 지향 프로그래밍","heading":"S3 클래스 객체는 리스트에 class 속성 부여하여 만든다.","text":"사용자도 리스트와 class() 함수를 이용하여 자신만의 S3 클래스를 만들 수 있다. 다음은 학생 관련 정보를 담는 student 클래스를 만든 예이다.student 객체를 출력해 보면 여느 리스트와 동일하게 각 요소를 출력하고, 마지막으로 부가 정보인 속성 정보를 출력하였다. 속성 정보는 오직 하나 class 속성만 있는 것을 확인할 수 있다. student 클래스는 print 메소드가 구현되어 있지 않았으므로, 객체가 출력될 때 객체의 타입인 리스트가 출력되는 형식으로 출력되었다.","code":"\nst1 <- list(name=\"Gildong\", year=2, GPA=3.2)\nclass(st1) <- \"student\"\nst1#> $name\n#> [1] \"Gildong\"\n#> \n#> $year\n#> [1] 2\n#> \n#> $GPA\n#> [1] 3.2\n#> \n#> attr(,\"class\")\n#> [1] \"student\""},{"path":"ch-R-OOP.html","id":"포괄-함수generic-functions","chapter":"11 R 객체 지향 프로그래밍","heading":"11.2.2 포괄 함수(generic functions)","text":"","code":""},{"path":"ch-R-OOP.html","id":"포괄-함수는-usemethod로-클래스에-따라-적절한-메소드를-호출한다.","chapter":"11 R 객체 지향 프로그래밍","heading":"포괄 함수는 UseMethod()로 클래스에 따라 적절한 메소드를 호출한다.","text":"포괄 함수란 print() 함수처럼 여러 클래스의 객체에 적용 가능한 함수를 의미한다. 포괄 함수는 인수로 주어진 객체의 클래스에 따라 클래스에 적합한 기능을 수행한다.그러면 포괄 함수는 어떻게 객체에 따라 적절한 기능을 수행할 수 있는 것일까? 심지어 print() 함수 같은 포괄 함수는 자신이 구현된 이후에 새로운 클래스가 추가되어도 새로운 클래스에 적합한 기능을 수행할 수 있다.\n포괄 함수는 사실 분배기의 역할만을 수행하기 때문에 이러한 기능이 가능한 것이다. 포괄 함수는 호출이 되면 UseMethod() 라는 분배 기능을 가지는 함수를 호출한다. 이 함수는 포괄 함수에 첫번째 인수로 부여된 객체의 클래스에 따라 포괄 함수를 대신하여 실행될 해당 클래스의 메소드를 호출한다. 그리고 포괄 함수는 해당 클래스의 메소드가 객체에 실행된 결과를 반환한다. 다음은 print() 함수가 호출되면 무엇이 수행되는지를 보여준다. UseMethod()가 호출되는 것을 볼 수 있다.","code":"\nprint#> function (x, ...) \n#> UseMethod(\"print\")\n#> <bytecode: 0x55c44669c488>\n#> <environment: namespace:base>"},{"path":"ch-R-OOP.html","id":"methods","chapter":"11 R 객체 지향 프로그래밍","heading":"methods()","text":"그러면 클래스별로 print 메소드는 어디에 있는 것일끼? methods() 함수를 이용하면 각 포괄 함수에 대해 구현된 모든 메소드를 확인할 수 있다. 다음은 그 중 일부만을 보여주고 있다.","code":"\nhead(methods(print))#> [1] \"print.acf\"     \"print.AES\"     \"print.anova\"   \"print.aov\"    \n#> [5] \"print.aovlist\" \"print.ar\""},{"path":"ch-R-OOP.html","id":"메소드-이름-규칙","chapter":"11 R 객체 지향 프로그래밍","heading":"메소드 이름 규칙","text":"메소드 함수는 다음과 같은 이름으로 정의되어 있다.따라서 data.frame 클래스의 print 메소드는 print.data.frame이 된다. 이 메소드를 data.frame 객체에 적용하나, 포괄 함수인 print를 data.frame 객체에 적용하나 동일한 결과를 얻는다. 사실 R 콘솔은 명령문을 평가한 후 자동으로 print() 함수를 실행하므로 클래스에 대한 print 메소드 구현은 매우 중요하다. 다음은 R 콘솔에서 print(f)나, print.data.frame(f)나, f는 동일한 결과를 주는 것을 보여준다.앞에서 확인할 수 있듯이 지금까지 객체가 R 콘솔에 출력될 때, 해당 객체의 클래스의 print 메소드들이 적절히 호출되어 해당 클래스에 적합한 형식으로 데이터를 보여 주었던 것이다.그러면 integer, character, list 등을 위한 메소드들도 있을까? grep() 함수로 해당 이름의 메소드를 찾아보면 그렇지 않음을 알 수 있다. 그러면 이 클래스의 객체들은 어떻게 출력이 이루어지는 걸까?해당 클래스의 메소드가 없으면 UseMethod() 분배 함수는 default 메소드를 호출한다. default 메소드는 generic_function_name.default 형식으로 이름이 주어진다. print 포괄 함수의 경우 print.defualt 메소드이다.","code":"\ngeneric_function_name.class_name\nprint(f)#>   X1.3 X6.8\n#> 1    1    6\n#> 2    2    7\n#> 3    3    8\nprint.data.frame(f)#>   X1.3 X6.8\n#> 1    1    6\n#> 2    2    7\n#> 3    3    8\nf#>   X1.3 X6.8\n#> 1    1    6\n#> 2    2    7\n#> 3    3    8\ngrep(\"integer\", methods(print))#> integer(0)\ngrep(\"character\", methods(print))#> integer(0)\ngrep(\"list\", methods(print))#>  [1]   5  39  96 105 134 146 198 211 213 225 256\nmethods(print)[grep(\"list\", methods(print))]#>  [1] \"print.aovlist\"                    \"print.check_package_datalist\"    \n#>  [3] \"print.Dlist\"                      \"print.dummy_coef_list\"           \n#>  [5] \"print.htmltools.selector.list\"    \"print.listof\"                    \n#>  [7] \"print.rlang:::list_of_conditions\" \"print.shiny.tag.list\"            \n#>  [9] \"print.simple.list\"                \"print.summary.aovlist\"           \n#> [11] \"print.xfun_strict_list\""},{"path":"ch-R-OOP.html","id":"디폴트-메소드","chapter":"11 R 객체 지향 프로그래밍","heading":"디폴트 메소드","text":"보통 default 메소드는 데이터가 가지는 기본적 타입에 대해 적절한 포괄 함수 관련 처리를 수행하도록 구현되어 있다. print.default는 기본적인 데이터의 타입에 따라 적절한 출력을 보여준다.앞서 우리는 student 클래스 객체를 만들었다. 그런나 print.student라는 메소드는 존재하지 않으므로 콘솔에서 해당 객체가 입력되었을 때, print.defualt가 student의 출력을 담당하였다. 따라서 student의 데이터 기본 타입인 list의 형식으로 데이터가 출력이 된것이다.methods() 함수의 class 인수를 이용하면 해당 클래스를 위해 정의된 모든 메소드의 목록을 볼 수 있다. student 클래스를 위한 어떠한 메소드도 구현되지 않았음을 볼 수 있다.","code":"\nprint.default#> function (x, digits = NULL, quote = TRUE, na.print = NULL, print.gap = NULL, \n#>     right = FALSE, max = NULL, width = NULL, useSource = TRUE, \n#>     ...) \n#> {\n#>     args <- pairlist(digits = digits, quote = quote, na.print = na.print, \n#>         print.gap = print.gap, right = right, max = max, width = width, \n#>         useSource = useSource, ...)\n#>     missings <- c(missing(digits), missing(quote), missing(na.print), \n#>         missing(print.gap), missing(right), missing(max), missing(width), \n#>         missing(useSource))\n#>     .Internal(print.default(x, args, missings))\n#> }\n#> <bytecode: 0x55c4499bd800>\n#> <environment: namespace:base>\nmethods(class=\"lm\")#>  [1] add1           alias          anova          case.names     coerce        \n#>  [6] confint        cooks.distance deviance       dfbeta         dfbetas       \n#> [11] drop1          dummy.coef     effects        extractAIC     family        \n#> [16] formula        hatvalues      influence      initialize     kappa         \n#> [21] labels         logLik         model.frame    model.matrix   nobs          \n#> [26] plot           predict        print          proj           qr            \n#> [31] residuals      rstandard      rstudent       show           simulate      \n#> [36] slotsFromS3    summary        variable.names vcov          \n#> see '?methods' for accessing help and source code\nmethods(class=\"student\")#> no methods found\nprint.default(st1)#> $name\n#> [1] \"Gildong\"\n#> \n#> $year\n#> [1] 2\n#> \n#> $GPA\n#> [1] 3.2\n#> \n#> attr(,\"class\")\n#> [1] \"student\""},{"path":"ch-R-OOP.html","id":"메소드-정의하기","chapter":"11 R 객체 지향 프로그래밍","heading":"메소드 정의하기","text":"다음처럼 student 클래스를 위한 print 메소드를 만들어 보자. S3 클래스에서는 함수의 이름을 (포괄 함수명).(클래스명)으로 부여하면 된다. 그러면 UseMethod()가 해당 클래스를 위해 정의된 메소드를 호출해 준다.위의 예에서 보듯이 student 클래스를 위한 print 메소드가 구현되었으므로 이제는 default 메소드가 아니라 student 클래스를 위한 print 메소드가 실행된다. 일반적으로 복잡한 클래스일수록 자신만의 print 메소드를 구현한다. 그래야 복잡한 내부 데이터를 모두 출력하지 않고 필요한 정보만 효율적으로 보여줄 수 있기 때문이다.그리고 R을 처음 접한 사람들이 의아해 하는 사항이 있다. 그것은 대부분의 클래스에서 print 메소드보다는 summary 메소드가 더 자세한 정보를 출력한다는 것이다. 문자 그대로 해석한다면 print() 함수는 모든 내용을 출력해야 하고, summary() 함수는 좀 더 요약된 정보를 제공해야 할 것 같은데 말이다. lm 클래스도 print() 함수 보다는 summary() 함수가 훨씬 더 자세한 정보를 제공한다.이러한 일이 발생하는 이유는 R에서 print() 함수는 R 콘솔에 사용자의 명령이 입력될 때마다 실행되는 함수이기 때문이다. 따라서 print() 함수의 결과가 자칫 필요 이상으로 길고 복잡해지면 R 콘솔 작업이 어려워질 수 있기 때문에 대부분의 클래스에서는 휠씬 요약된 정보만을 print 메소드가 제공하도록 하고 있다. 하지만 기본 데이타 타입의 경우는 print.defualt 메소드가 데이터의 내용을 가감 없이 보여주기 때문에 그러한 현상은 나타나지 않는다.","code":"\nprint.student <- function(x) {\n  cat(x$name, \"\\n\")\n  cat(\"year\", x$year, \"\\n\")\n  cat(\"GPA\", x$GPA, \"\\n\")\n}\nmethods(class=\"student\")#> [1] print\n#> see '?methods' for accessing help and source code\nprint(st1)#> Gildong \n#> year 2 \n#> GPA 3.2\nsummary(a)#> \n#> Call:\n#> lm(formula = cars)\n#> \n#> Residuals:\n#>     Min      1Q  Median      3Q     Max \n#> -7.5293 -2.1550  0.3615  2.4377  6.4179 \n#> \n#> Coefficients:\n#>             Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept)  8.28391    0.87438   9.474 1.44e-12 ***\n#> dist         0.16557    0.01749   9.464 1.49e-12 ***\n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> Residual standard error: 3.156 on 48 degrees of freedom\n#> Multiple R-squared:  0.6511, Adjusted R-squared:  0.6438 \n#> F-statistic: 89.57 on 1 and 48 DF,  p-value: 1.49e-12"},{"path":"ch-R-OOP.html","id":"s3에서-상속성의-구현","chapter":"11 R 객체 지향 프로그래밍","heading":"11.2.3 S3에서 상속성의 구현","text":"상속성은 객체 지향 프로그래밍의 매력 중에 하나이다. 새로운 클래스를 만들 때 이전의 클래스를 상위 클래스로 하고 자신을 하위 클래스로 하면, 상위 클래스에 정의된 메소드들을 하위 클래스 객체가 이용할 수 있다.","code":""},{"path":"ch-R-OOP.html","id":"상위-클래스와-하위-클래스","chapter":"11 R 객체 지향 프로그래밍","heading":"상위 클래스와 하위 클래스","text":"이 때 주의할 점은 하위 클래스 객체는 상위 클래스에 부분집합의 관계를 가져야 한다는 것이다. 예를 들어 MTB 자전거라는 하위 클래스를 자전거라는 상위 클래스를 상속받아 구현하였다면, MTB 자전거 객체는 역시 자전거 객체이기도 해야 한다는 것이다. 따라서 하위 클래스의 데이터 구조는 상위 클래스의 데이터 요소를 모두 포함하고 있어야 하고, 거기에 덧붙여 자신만의 데이터와 기능을 더 포함하는 구조이어야 한다.","code":""},{"path":"ch-R-OOP.html","id":"상속성을-구현하는-방법","chapter":"11 R 객체 지향 프로그래밍","heading":"상속성을 구현하는 방법","text":"S3 클래스에서 상속성의 구현은 객체를 생성할 때 단지 class 속성에 하위 클래스 이름 다음에 상위 클래스 이름을 모두 나열하기만 하면 된다. 그러면 UseMethod() 분배 함수는 class 속성에 부여된 클래스 순으로 메소드를 찾아 실행한다. 따라서 하위 클래스를 위한 메소드가 없으면 다음에 정의되어 있는 상위 클래스의 메소드를 실행해 준다. 하위 클래스가 상속받은 상위 클래스가 또 다른 클래스를 상속 받았다면, class 속성에는 하위 클래스, 상위 클래스, 상위-상위 클래스 순으로 차례대로 기술해 주면 된다.S3 클래스에서 상속성이 어떻게 수행되는지 다음 예로 살펴보자. 현재 student 클래스를 이용하여 대학생과 대학원생 정보를 모두 처리하고 있다고 하자. 그런데 대학원생의 경우에는 student에 있는 데이터뿐 아니라 지도교수(advisor)에 대한 정보가 추가되어 관리되는 것이 편리하다고 판단되어, 지도교수 정보를 포함하는 gradstudent 클래스를 정의하고자 한다.\n다음 예에서 st2 객체를 생성할 때 리스트에 advisor 요소가 추가되었다. 그리고 class 속성에 먼저 하위 클래스 이름인 gradstudent, 그리고 상위 클래스 이름인 student가 기술되었다. 물론 아직은 gradstudent 클래스에 대한 어떠한 메소드도 존재하지 않는다.그러면 gradstudent 클래스인 st2를 출력해 보자. 그러면 UseMethod() 함수는 먼저 gradstudent 클래스를 위한 print 메소드를 찾는다. 해당 메소드가 없으므로 두번째로 기술되어 있는 student 클래스의 print 메소드를 찾는다. 해당 메소드가 있으므로 이 메소드로 출력을 수행한다. 이마저도 없으면 default 메소드가 수행될 것이다. 물론 student 클래스를 위한 print 메소드는 이미 구현되어 있기 때문에, 대학원생 정보인 st2도 student 클래스의 출력 형식에 맞추어 출력이 이루어진다. 따라서 gradstudent 객체는 student 클래스의 메소드를 상속 받았다고 볼 수 있다.","code":"\nst2 <- list(name=\"Gilsan\", year=1, GPA=3.8, advisor=\"Sejong\")\nclass(st2) <- c(\"gradstudent\", \"student\")\nmethods(class=\"gradstudent\")#> no methods found\nst2#> Gilsan \n#> year 1 \n#> GPA 3.8"},{"path":"ch-R-OOP.html","id":"메소드-overiding","chapter":"11 R 객체 지향 프로그래밍","heading":"메소드 overiding","text":"만약 gradstudent 객체의 출력에 지도 교수 정보도 같이 출력되기를 원한다면, 다음처럼 gradstudent 클래스의 print 메소드를 구현하면 된다. 이 경우 gradstudent 클래스만의 메소드가 상속받은 student 클래스의 메소드를 overiding 하였다고 표현한다.","code":"\nprint.gradstudent <- function(x) {\n  print.student(x)\n  cat(\"Advisor\", x$advisor, \"\\n\")\n}\nst2#> Gilsan \n#> year 1 \n#> GPA 3.8 \n#> Advisor Sejong"},{"path":"ch-R-OOP.html","id":"s4-클래스","chapter":"11 R 객체 지향 프로그래밍","heading":"11.3 S4 클래스","text":"","code":""},{"path":"ch-R-OOP.html","id":"s3-클래스의-안전성-문제","chapter":"11 R 객체 지향 프로그래밍","heading":"S3 클래스의 안전성 문제","text":"S3 클래스는 Java 같은 OOP 언어와 비교해 보면 다음과 같은 안전성(safety) 문제를 가지고 있다.클래스 정의를 사전에 하지 않으므로 객체 생성시 필요한 요소가 누락되거나 이름이 잘못 부여될 수 있다.클래스의 메소드도 이름으로 파악하므로, 메소드 구현시 함수 이름이 잘못 부여되어도 이를 바로 확인할 수 없다.데이터가 근본적으로 리스트 객체이므로 클래스 내부 데이터에 대한 잘못된 접근을 막을 수 없다.이러한 문제를 해결하기 위해 S4 클래스가 개발되었다. 표 11.114은 두 클래스의 차이를 보여준다. 이 절에서는 S4 클래스의 몇 가지 특징에 대해서만 짚어보기로 한다.Table 11.1: S3 클래스 vs. S4 클래스 (Source: Art R Programming)","code":"#> Rows: 5 Columns: 3\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \"&\"\n#> chr (3): 작업 ,  S3 ,  S4 \n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."},{"path":"ch-R-OOP.html","id":"클래스-정의-setclass","chapter":"11 R 객체 지향 프로그래밍","heading":"클래스 정의 setClass()","text":"다음은 setClass() 함수로 newstudent라는 새로운 클래스를 생성한 예이다. 데이터의 요소는 앞서 S3 클래스로 생성한 student 클래스와 동일하다. setClass()의 첫번째 인수로는 클래스 이름이, representation 인수는 클래스의 데이터 요소의 이름과 각 데이터 요소의 클래스가 명시된다. 이를 통해 해당 클래스 객체가 생성될 때 객체 요소의 데이터의 이름과 타입이 같아지도록 강제할 수 있다.","code":"\nsetClass(\"newstudent\", \n  representation(name=\"character\", year=\"numeric\", GPA=\"numeric\" ))"},{"path":"ch-R-OOP.html","id":"객체-생성-new","chapter":"11 R 객체 지향 프로그래밍","heading":"객체 생성 new()","text":"클래스로부터 새로운 객체를 생성할 때는 new() 함수를 이용한다. new() 함수는 첫번째 인수로 클래스 이름을, 나머지 인수로 객체의 각 데이터 요소를 정의한다.setClass()에 의해 클래스의 형태가 이미 정의되어 있어서 new()로 객체 생성 시 틀린 이름이나 틀린 타입의 데이터가 입력되면 오류가 발생하므로 항상 정확한 이름과 형식으로 객체가 생성되도록 강제할 수 있다.","code":"\nst3 <- new(\"newstudent\", name=\"Gildong\", year=2, GPA=3.2)\nst3#> An object of class \"newstudent\"\n#> Slot \"name\":\n#> [1] \"Gildong\"\n#> \n#> Slot \"year\":\n#> [1] 2\n#> \n#> Slot \"GPA\":\n#> [1] 3.2\nst4 <- new(\"newstudent\", sname=\"Gildong\", year=2, GPA=3.2)#> Error in initialize(value, ...): invalid name for slot of class \"newstudent\": sname\nst4 <- new(\"newstudent\", name=\"Gildong\", year=2, GPA=\"3.2\")#> Error in validObject(.Object): 잘못된 클래스 \"newstudent\" 객체입니다: invalid object for slot \"GPA\" in class \"newstudent\": got class \"character\", should be or extend class \"numeric\""},{"path":"ch-R-OOP.html","id":"객체-요소에-접근-slot","chapter":"11 R 객체 지향 프로그래밍","heading":"객체 요소에 접근 slot()","text":"S4 클래스에서 객체의 각 데이터 요소(멤버 변수라고 한다)를 슬롯(slot)이라 하며, @ 또는 slot()으로 접근한다. S4 클래스는 정의되지 않은 멤버 변수의 생성을 허용하지 않는다. 반면 S3는 단순한 리스트 객체이므로 아무 제약 없이 새로운 요소를 추가하거나 기존 요소를 삭제할 수 있다.","code":"\nst3@name#> [1] \"Gildong\"\nslot(st3, \"GPA\")#> [1] 3.2\nst3@year <- 4\nst3@GPa <- 4.0#> Error in (function (cl, name, valueClass) : 'GPa'는 클래스 \"newstudent\"내에 있는 슬롯이 아닙니다\nst3#> An object of class \"newstudent\"\n#> Slot \"name\":\n#> [1] \"Gildong\"\n#> \n#> Slot \"year\":\n#> [1] 4\n#> \n#> Slot \"GPA\":\n#> [1] 3.2"},{"path":"ch-R-OOP.html","id":"s4-클래스-메소드-생성-setmethod","chapter":"11 R 객체 지향 프로그래밍","heading":"S4 클래스 메소드 생성 setMethod()","text":"S4 클래스에서는 메소드는 setMethod() 함수에 의해 정의된다. 앞에서 생성한 newstudent 객체에 summary() 함수를 적용하면 해당 클래스의 summary 메소드가 구현되지 않았으므로 디폴트로 제공되는 메소드에 의해 객체에 대한 매우 간략한 요약 정보만 출력한다.newstudent 클래스에 summary 메소드를 다음과 같이 추가해 보자. setMethod() 함수는 첫번째 인수로 메소드 이름, 두번째 인수로 클래스 이름, 세번째 인수로 메소드 호출시 실행될 함수 객체를 받는다.만약 명시적으로 생성한 메소드를 제거하려면 removeMethod() 함수를 이용한다.","code":"\nsummary(st3)#>     Length      Class       Mode \n#>          1 newstudent         S4\nsetMethod(\"summary\", \"newstudent\",\n    function(object){\n      cat(object@name, \" is a \", \n          object@year, \"th year student with GPA \", \n          object@GPA, \"\\n\", sep=\"\")\n    })\nsummary(st3)#> Gildong is a 4th year student with GPA 3.2\nremoveMethod(\"summary\", \"newstudent\")#> [1] TRUE\nsummary(st3)#>     Length      Class       Mode \n#>          1 newstudent         S4"},{"path":"ch-RandPython.html","id":"ch-RandPython","chapter":"A R과 Python 연동하기","heading":"A R과 Python 연동하기","text":"R의 reticlate 패키지를 사용하여 R과 Python을 쉽게 연동시킬 수 있다.\nreticulate 패키지는 크게 다음 세 가지 기능을 수행한다.R에서 Python을 호출하는 기능: R 스크립트나 R 마크다운 문서에서 R 세션 중간에 파이썬 스크립트나 파이썬 모듈을 호출할 수 있다.R과 Python 객체 간의 상호 변환: R의 데이터프레임과 파이썬의 Pandas 데이터프레임, R의 행렬/배열과 파이썬 Numpy 배열 간에 데이터를 자동 변환해 준다.Python의 다양한 버전과의 연동 기능: 시스템 내에는 다양한 버전의 파이썬이 존재할 수 있다. reticulate는 가상 환경(virtual environments)이나 콘다 환경(Conda environments)의 파이썬 버전 등과 연동할 수 있다.다음 설명은 이미 시스템에 파이썬이 설치되어 있고 파이썬에 대한 기본 지식을 가지고 있다는 가정 하에 설명을 한다.\n파이썬은 다양한 시스템에서 설치가 가능하고, 콘다 환경을 사용하면 독립적인 파이썬 환경을 구축하기 편리하다.\n파이썬 설치에 대해서는 인터넷 등에서 관련 정보를 찾아보기 바란다.","code":""},{"path":"ch-RandPython.html","id":"reticulate-설치-및-사용할-파이썬-버전-설정","chapter":"A R과 Python 연동하기","heading":"A.1 reticulate 설치 및 사용할 파이썬 버전 설정","text":"다음 명령이나 RStudio 패키지 탭을 이용하여 reticulate 패키지를 설치한다.설치가 잘 되었는지 reticulate 패키지를 적재해 보자.하나의 시스템에는 여러 버전의 파이썬이 설치되어 있는 경우가 자주 있다.\n그렇다면 reticulate는 시스템 내의 어떤 버전의 파이썬과 연동을 하게 될까?reticulate는 다음처럼 파이썬에서 사용할 모듈을 import() 함수로 호출한다.reticulate는 맨 처음 import 되는 모듈을 시스템 내에 설치된 파이썬 버전들에서 차례로 검색하고, 해당 모듈이 맨 처음 발견된 파이썬 버전과 연동을 한다. 그리고 이후의 R에서의 파이썬 호출은 최초로 연동된 파이썬 버전에서 계속 수행하게 된다.\n만약 해당 모듈이 여러 곳의 파이썬 버전에 존재한다면 어떻게 될까?\nreticulate는 파이썬 모듈을 찾을 때 다음 순서로 파이썬 버전을 검색한다.사용자가 만약 시스템에 RETICULATE_PYTHON 환경 변수를 설정해 두었다면, 환경 변수에 설정된 경로에 설치된 파이썬에서 가장 먼저 모듈을 검색한다. .Rprofile에 해당 환경 변수를 설정하려면 다음 명령처럼 설정을 한다. (그러나 이는 경직된 형태로 파이썬 검색 순서를 지정한 것이므로 일반적 상황에서는 권장되지 않는다.)사용자가 use_python(), use_vertualenv(), 또는 use_condaenv()를 사용하여 설정한 파이썬 버전을 그 다음으로 검색한다. use_python()은 파이썬이 설치된 경로를 지정할 때, use_vertualenv()나 use_condaenv()는 설치되어 있는 가상 환경이나 콘다 환경이 사용되도록 지정할 때 사용한다.use_condaenv()에서 콘다 설치 버전이 여러 개인 경우 특정 콘다 설치 경로를 지정하여 콘다 환경을 찾도록 설정할 수 있다.그런데 use 함수들은 파이썬 버전을 찾을 힌트를 제공하는 것이지 실제 파이썬 버전을 찾는 작업을 수행하지는 않는다.\n그러므로 지정된 경로나 환경이 없어도 해당 명령은 오류가 발생하지 않는다.\n만약 해당 파이썬 버전이 있는지 확인하려면 use 함수에 required=TRUE 인수를 추가하여 실행한다. 그러면 해당 파이썬 버전이 존재하지 않으면 오류를 발생시킨다.사용자가 사용할 파이썬 버전을 환경 변수나 use 함수로 설정하지 않았으면, reticulate는 그 다음으로 사용자의 파이썬 가상 환경이나 콘다 환경을 검색한다. 가상 환경과 콘다 환경이 발견되면, 가상 환경과 콘다 환경에서 해당 모듈을 검색한다.사용자가 사용할 파이썬 버전을 환경 변수나 use 함수로 설정하지 않았으면, reticulate는 그 다음으로 사용자의 파이썬 가상 환경이나 콘다 환경을 검색한다. 가상 환경과 콘다 환경이 발견되면, 가상 환경과 콘다 환경에서 해당 모듈을 검색한다.다음으로 사용자 시스템 경로(PATH) 상의 파이썬 설치 위치를 검색한다. 시스템 경로에서 발견되는 파이썬이 어디에 설치되어 있는지를 확인하려면 다음 명령을 수행해 본다. 사용자의 시스템의 종류와 설치 방법에 따라 결과는 서로 다를 수 있다.다음으로 사용자 시스템 경로(PATH) 상의 파이썬 설치 위치를 검색한다. 시스템 경로에서 발견되는 파이썬이 어디에 설치되어 있는지를 확인하려면 다음 명령을 수행해 본다. 사용자의 시스템의 종류와 설치 방법에 따라 결과는 서로 다를 수 있다.마지막으로 사용자들이 주로 파이썬을 설치하는 일반적인 경로를 검색하여 파이썬 버전을 찾아 해당 모듈을 검색한다.파이썬 모듈을 import 하면 어떤 버전의 파이썬이 먼저 검색될지를 확인하려면 다음 명령을 사용한다.시스템에 하나의 버전의 파이썬만 설치된 것이 아니라면, 실행의 일관성을 확보하기 위하여 use 함수들을 사용하여 사용할 파이썬 버전을 지정할 것을 권장한다. 다음은 base라는 콘다 환경에서 파이썬 모듈을 먼저 찾도록 하는 명령이다.","code":"\ninstall.packages('reticulate')\nlibrary(reticulate)\nnp <- import(\"numpy\")\nSys.setenv(RETICULATE_PYTHON = \"경로\")\nuse_python(\"경로\")\nuse_virtualenv(\"~/가상-환경-이름\")\nuse_condaenv(\"콘다-환경-이름\")\nuse_condaenv(\"콘다-환경-이름\", conda = \"콘다-설치-경로\")\nSys.which(\"python\")#>                                python \n#> \"/home/sys4ppl/miniconda3/bin/python\"\npy_discover_config()#> python:         /home/sys4ppl/miniconda3/bin/python\n#> libpython:      /home/sys4ppl/miniconda3/lib/libpython3.7m.so\n#> pythonhome:     /home/sys4ppl/miniconda3:/home/sys4ppl/miniconda3\n#> version:        3.7.16 (default, Jan 17 2023, 22:20:44)  [GCC 11.2.0]\n#> numpy:          /home/sys4ppl/miniconda3/lib/python3.7/site-packages/numpy\n#> numpy_version:  1.21.5\n#> \n#> NOTE: Python version was forced by RETICULATE_PYTHON_FALLBACK\nuse_condaenv(\"base\")"},{"path":"ch-RandPython.html","id":"r과-파이썬-연동하는-방법","chapter":"A R과 Python 연동하기","heading":"A.2 R과 파이썬 연동하는 방법","text":"R에서 파이썬을 연동하는 방법은 크게 다음 4 가지 방법이 있다.R 마크다운 문서에서 파이썬 명령 실행하기: R 마크다운의 파이썬 엔진이 마크다운 문서 전 범위에서 하나의 파이썬 세션으로 R 마크다운에 기술된 파이썬 명령문을 실행시킨다. 그리고 파이썬 세션의 결과를 R로, R 세션의 결과를 파이썬으로 주고 받을 수 있다.파이썬 모듈을 R 세션에서 연동하기: import() 함수로 파이썬 모듈을 R에 연동시켜서 R에서 직접 파이썬 모듈의 함수를 호출하여 결과를 받을 수 있다.파이썬 스크립트 실행하기: source_python() 함수를 사용하여 R 세션에서 파이썬 스크립트를 실행할 수 있다. 그러면 파이썬 명령문을 통해 생성된 파이썬 함수와 객체를 R 세션에서 사용할 수 있다.파이썬 REPL 실행하기: repl_python() 함수를 사용하여 R 내에서 대화형으로 파이썬 콘솔 환경을 생성할 수 있다. 이 경우에도 R 세션과 파이썬 세션은 서로 객체를 주고 받을 수 있다.","code":""},{"path":"ch-RandPython.html","id":"파이썬-모듈-연동하기","chapter":"A R과 Python 연동하기","heading":"A.3 파이썬 모듈 연동하기","text":"import() 함수를 사용하면 파이썬 모듈을 호출할 수 있다.\n호출된 모듈은 R 변수에 할당하여야 해당 파이썬 모듈을 사용할 수 있다.\n다음은 Numpy 모듈을 R에서 연동시킨 예이다.연동된 모듈이 제공하는 함수나 객체는 $ 연산자를 사용하여 이용할 수 있다.\n다음은 Numpy 모듈의 full() 함수를 이용하여 1로만 이루어진 \\(3 \\times 3\\) 배열을 만든 예이다.이 때 주의해서 이해해야 하는 것은 위의 np$full() 함수의 실제 기능은 Numpy 모듈의 full()이라는 파이썬 함수가 제공하고, np$full() 함수는 R의 껍데기 함수라는 것이다.\nimport() 함수로 파이썬 모듈을 연동시키면 파이썬의 함수와 객체와 연동되는 R의 껍데기 함수와 객체가 생성된다.\nR 세션에서는 파이썬 함수에 직접 접근하는 방법은 없으며, 이 껍데기 함수와 객체를 통해서 파이썬의 함수와 객체에 접근하게 된다. (Figure .1 참조)\nFigure .1: R에서 Python 함수의 호출\n따라서 np$full() 함수를 호출할 때는 R 형식의 인수를 제공해야 하지, Python 형식의 데이터를 입력해서는 안 된다.\n원래 Numpy의 full() 함수는 shape 인수에 정수나 정수의 시퀀스(sequence) 형식의 데이터를 입력하여야 한다.\n다음은 파이썬에서의 원래 명령문과 실행 결과를 보여준다.그러나 np$full() 함수는 R 함수이므로 shape 인수에 파이썬의 정수 형식이나 정수의 시퀀스 형식에 대응하는 R 형식 데이터를 입력하여야 한다.\n그러면 reticulate는 R 형식의 인수를 파이썬 형식의 데이터로 변환하여 파이썬의 np.full() 함수를 호출한다.\n그리고 다시 파이썬의 np.full() 함수가 Numpy 배열 형식으로 데이터를 반환하면 reticulate는 Numpy 배열에 대응되는 R 형식인 행렬 또는 배열로 변환하여 R 세션에 결과를 전달한다.","code":"\nlibrary(reticulate)\nnp <- import(\"numpy\")\nnp$full(shape = c(3L,3L), fill_value = 1L)#>      [,1] [,2] [,3]\n#> [1,]    1    1    1\n#> [2,]    1    1    1\n#> [3,]    1    1    1import numpy as np\nnp.full(shape = (3,3), fill_value = 1)#> array([[1, 1, 1],\n#>        [1, 1, 1],\n#>        [1, 1, 1]])"},{"path":"ch-RandPython.html","id":"r과-python의-형식-변환","chapter":"A R과 Python 연동하기","heading":"A.3.1 R과 Python의 형식 변환","text":"R과 파이썬은 reticulate를 통하여 다음처럼 형식 변환된다.만약 사용자가 정의한 클래스의 파이썬 객체가 전달되어야 하면, 해당 객체의 R 참조자가 반환된다.\n그러면 R에서 파이썬 모듈에 접근할 수 있는 것과 유사한 방법으로 파이썬 객체의 메쏘드와 속성을 R 참조자 객체를 이용하여 접근할 수 있다.","code":""},{"path":"ch-RandPython.html","id":"정수-형식의-데이터-변환의-주의점","chapter":"A R과 Python 연동하기","heading":"A.3.1.1 정수 형식의 데이터 변환의 주의점","text":"그런데 이러한 자동 형 변환에서 주의해야 할 점이 있다.\nR에서는 숫자 데이터는 정수나 실수나 모두 double 형식으로 자동으로 변환되어 처리하는 경우가 많다.\n예를 들어 다음처럼 3이라는 정수 두 개로 이루어진 벡터는 정수로 처리되는 것이 아니라 부동소수점 형식인 double로 데이터가 처리된다.그런데 파이썬에서는 정수 형식과 실수 형식의 데이터를 엄격하게 구별하여 처리한다.\n따라서 파이썬 함수에서 정수 값이 인수이여야 하는 곳에 무심코 다음 같이 R 데이터를 입력하면 파이썬에서 함수가 실행될 때 데이터 형식이 맞지 않아 오류가 발생한다.그렇기 때문에 앞에서 np$full() 함수의 shape 인수를 부여할 때, 3L로 정수형 데이터임을 명시적으로 표현하였다.\n그러면 R도 형변환이 필요하기 전까지는 이 값을 double 형식이 아니라 integer 형식으로 저장하고 처리한다.","code":"\na <- c(3, 3)\ntypeof(a)#> [1] \"double\"\n# 오류: 파이썬 함수의 integer 인수일 때 형변환에 주의\nnp$full(shape = c(3,3), fill_value = 1)#> Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: 'float' object cannot be interpreted as an integer\nb <- c(3L, 3L)\ntypeof(b)#> [1] \"integer\"\nnp$full(shape = b, fill_value = 1L)#>      [,1] [,2] [,3]\n#> [1,]    1    1    1\n#> [2,]    1    1    1\n#> [3,]    1    1    1"},{"path":"ch-RandPython.html","id":"리스트-튜플-딕셔너리-형식으로-변환할-때-주의점","chapter":"A R과 Python 연동하기","heading":"A.3.1.2 리스트, 튜플, 딕셔너리 형식으로 변환할 때 주의점","text":"자동 형 변환에서 또 하나 주의할 점은 파이썬에서 리스트나 튜플을 인수로 원할 때이다.\n파이썬에 정수 하나로 이루어진 리스트나 튜플을 전달한다고 하자.\n파이썬에서는 정수 자체와, 정수 하나로 이루어진 리스트와 튜플은 서로 다른 형식의 데이터이다.그러나 R에서는 스칼라 형식은 없으므로 정수 하나도 모두 벡터로 표현된다.\n그런데 파이썬에서는 스칼라 형식이 매우 자주 사용되므로 R의 요소 하나짜리 벡터는 모두 해당 형식의 스칼라로 자동 변환된다.\n그러므로 반드시 파이썬의 리스트나 튜플 형식으로 데이터를 전달하려면 다음처럼 R의 리스트와 reticulate의 tuple() 함수를 사용한다.\n다음에 사용된 r_to_py() 함수는 R 객체를 파이썬 객체로 변환하는 함수이다.R의 이름 붙은 리스트는 파이썬의 딕셔너리로 잘 변환이 된다.\n그러나 R의 리스트는 요소의 이름으로 문자열만 사용할 수 있는 반면, 파이썬의 딕셔너리의 키 값은 더 복잡한 불변하는 객체가 될 수 있다. 따라서 R에서 좀 더 복잡한 파이썬 딕셔너리를 인수로 전달하고자 하면, reticulate의 dict() 함수를 사용한다.아울러 R은 벡터와 리스트 등의 인덱싱이 1부터 시작하지만, 파이썬의 리스트, 튜플 등의 시퀀스 객체는 0부터 인덱싱이 시작하니 이러한 차이에 주의하여야 한다.","code":"type(1)#> <class 'int'>type([1])#> <class 'list'>type((1,))#> <class 'tuple'>\na <- r_to_py(1L); class(a)#> [1] \"python.builtin.int\"    \"python.builtin.object\"\na <- r_to_py(list(1L)); class(a)#> [1] \"python.builtin.list\"   \"python.builtin.object\"\na <- r_to_py(tuple(1L)); class(a)#> [1] \"python.builtin.tuple\"  \"python.builtin.object\"\na <- list(year=3, major=\"me\", name=\"홍길동\"); class(a)#> [1] \"list\"\na#> $year\n#> [1] 3\n#> \n#> $major\n#> [1] \"me\"\n#> \n#> $name\n#> [1] \"홍길동\"\nb <- r_to_py(a); class(b)#> [1] \"python.builtin.dict\"   \"python.builtin.object\"\nb#> {'year': 3.0, 'major': 'me', 'name': '홍길동'}\na <- dict(name = \"홍길동\"); class(a)#> [1] \"python.builtin.dict\"   \"python.builtin.object\"\na#> {'name': '홍길동'}"},{"path":"ch-RandPython.html","id":"형변환-직접-하기","chapter":"A R과 Python 연동하기","heading":"A.3.2 형변환 직접 하기","text":"reticulate의 기본 설정은 파이썬 객체를 R 세션으로 전달할 때 대응되는 R 객체로 자동 변환한다.\n만약 파이썬 객체를 R 객체로 자동 변환하지 않고, 파이썬 객체의 R 참조자를 반환하게 하려면 import() 함수에 convert=FALSE 인수를 전달한다.\n그러면 파이썬의 결과는 모두 R 참조자로 전달되므로, R에서 전달된 참조자로 다시 파이썬 객체의 메쏘드 등을 실행할 수 있다.\n마지막에 R로서 결과를 확인하려면 py_to_r() 함수를 사용하여 R 참조자가 참조하는 파이썬 객체를 R 객체로 변환하여야 한다.","code":"\nnp <- import(\"numpy\", convert=FALSE)\na <- np$array(1:4)\na # 파이썬 객체의 R 참조자#> array([1, 2, 3, 4])\nclass(a)#> [1] \"numpy.ndarray\"         \"python.builtin.object\"\na_max <- a$max() # Numpy 배열의 max 메쏘드 호출\na_max # 파이썬 객체의 R 참조자#> 4\na_max + 1  # R 객체가 아니므로 R 연산은 오류 발생#> Error in a_max + 1: 이항연산자에 수치가 아닌 인수입니다\npy_to_r(a_max) + 1#> [1] 5"},{"path":"ch-RandPython.html","id":"파이썬-모듈의-도움말-확인하기","chapter":"A R과 Python 연동하기","heading":"A.3.3 파이썬 모듈의 도움말 확인하기","text":"py_help() 함수를 사용하면 파이썬 객체에 대한 도움말을 확인할 수 있다.","code":"\npy_help(np$full)"},{"path":"ch-RandPython.html","id":"pickle-사용하기","chapter":"A R과 Python 연동하기","heading":"A.3.4 pickle 사용하기","text":"파이썬에서는 객체들을 바이너리 형식으로 저장할 때 pickle 모듈을 자주 사용한다.\n파이썬 모듈의 결과를 파이썬 객체 형식으로 파일에 저장하거나, 이미 파이썬에서 작업하여 바이너리 형식으로 저장된 데이터를 읽어오려면 py_save_object()와 py_load_object() 함수를 사용한다.\n읽어들인 파이썬 객체가 자동으로 R 객체로 형변환된 것을 확인할 수 있다.","code":"\na <- np_array(1:4, dtype=\"int64\") # 파이썬 Numpy 배열의 R 참조자\na#> array([1, 2, 3, 4])\npy_save_object(a, filename = \"a.p\") # 파이썬 객체 저장\nb <- py_load_object(filename = \"a.p\") # 저장된 파이썬 객체 읽어오기\nb#> [1] 1 2 3 4"},{"path":"ch-RandPython.html","id":"r-마크다운-문서에서-파이썬-명령-실행하기","chapter":"A R과 Python 연동하기","heading":"A.4 R 마크다운 문서에서 파이썬 명령 실행하기","text":"R 마크다운 문서는 일반적으로 마크다운으로 형식화된 문서 정보와 R 명령 모듬(chunks)으로 구성된다.\nR 마크다운 문서를 직조(knitting)하면 R 명령문 모듬이 실행되어 그 결과가 문서의 다른 부분과 결합하여 문서가 동적으로 완성된다.\nR 마크다운 문서에는 R 명령 모듬뿐 아니라 Python 명령 모듬도 포함시킬 수 있다.\n그러면 reticulate의 파이썬 엔진이 파이썬 명령 모듬을 실행하여 문서에 포함되도록 한다.\nreticulate의 파이썬 엔진의 주요 기능은 다음과 같다.R 마크다운을 직조하는 하나의 R 세션 안에 포함된 파이썬 세션을 만들고, 이 하나의 파이선 세션에서 파이썬 명령 모듬을 실행시킨다.파이썬 명령 모듬의 파이썬 실행 결과를 적절한 형식으로 출력하여 문서에 포함시킨다. 특히 파이썬의 numpy, pandas, matplotlib 모듈의 그래프 결과를 적절한 형식으로 처리하여 출력한다.R 세션에서 파이썬 모듬에서 생성한 객체를 접근할 수 있도록 해 준다. R 세션에 py라는 객체가 생성되어 py$x 형식으로 파이썬 세션에 생성된 x 객체에 대한 참조자를 제공한다.파이썬 세션에서 R 모듬에서 생성한 객체 접근할 수 있도록 해 준다. 파이썬 세션에 r이라는 객체가 생성되어 r.x 형식으로 R 세션에 생성된 x 객체에 대한 참조자를 제공한다.아울러 파이썬 세션에 R 객체가 전달될 때, R 세션에 파이썬 객체가 전달될 때 상호 자동 변환이 이루어진다.다음은 R의 ggplot 패키지의 mpg 데이터를 파이썬 모듬에 전달하여 그래프를 그리고 통계 요약한 후, 그 결과를 다시 R로 보내서 출력한 예이다.","code":"\n# R 모듬 1\nlibrary(ggplot2)\nmpg#> # A tibble: 234 × 11\n#>    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class\n#>    <chr>        <chr>      <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr>\n#>  1 audi         a4           1.8  1999     4 auto… f        18    29 p     comp…\n#>  2 audi         a4           1.8  1999     4 manu… f        21    29 p     comp…\n#>  3 audi         a4           2    2008     4 manu… f        20    31 p     comp…\n#>  4 audi         a4           2    2008     4 auto… f        21    30 p     comp…\n#>  5 audi         a4           2.8  1999     6 auto… f        16    26 p     comp…\n#>  6 audi         a4           2.8  1999     6 manu… f        18    26 p     comp…\n#>  7 audi         a4           3.1  2008     6 auto… f        18    27 p     comp…\n#>  8 audi         a4 quattro   1.8  1999     4 manu… 4        18    26 p     comp…\n#>  9 audi         a4 quattro   1.8  1999     4 auto… 4        16    25 p     comp…\n#> 10 audi         a4 quattro   2    2008     4 manu… 4        20    28 p     comp…\n#> # … with 224 more rows# 파이썬 모듬 1\nimport matplotlib.pyplot as plt\nr.mpg.plot(x = \"displ\", y = \"hwy\", kind = \"scatter\")  # 배기량 vs. 고속도로연비 산점도\nplt.show()  mean_cty_per_class = r.mpg.groupby(['class'])['cty'].mean() # 종류별 도심연비 평균 계산\nmean_cty_per_class#> class\n#> 2seater       15.400000\n#> compact       20.127660\n#> midsize       18.756098\n#> minivan       15.818182\n#> pickup        13.000000\n#> subcompact    20.371429\n#> suv           13.500000\n#> Name: cty, dtype: float64\n# R 모듬 2\nbarplot(py$mean_cty_per_class)"},{"path":"ch-RTips.html","id":"ch-RTips","chapter":"B R 관련 여러 주제들","heading":"B R 관련 여러 주제들","text":"이 장에서는 하나의 장으로 독립적으로 다루기에는 잡다한 R 관련 주제를 다룬다.","code":""},{"path":"ch-RTips.html","id":"r에서-계산-정확도를-향상시키기","chapter":"B R 관련 여러 주제들","heading":"B.1 R에서 계산 정확도를 향상시키기","text":"현재 R은 IEC 60559 부동소수점 계산을 사용하고 있다.\n부동소수점 숫자를 저장하기 위해 64 비트를 사용하고 있고, 이중 53 비트는 유효숫자를 저장하고 11 비트는 지수부 정보를 저장한다.\n위와 관련된 정보는 base 패키지의 .Machine 변수를 출력해 보면 확인할 수 있다.컴퓨터는 이진수로 숫자를 저장하기 때문에, 숫자의 유효숫자와 지수가 표현 범위에 있는 숫자라면 이진수로 표현할 수 있는 정수와 분모가 2의 거듭제곱으로 표현된 유리수에 대해서만 정확하게 표현할 수 있다.\n그 외의 숫자는 정수나 2의 거듭제곱을 분모로 가진 유리수로 근사하여 저장하므로 숫자를 저장할 수 있는 정밀도는 제한된다.\n그렇기 때문에 다음처럼 수학적으로 같아야할 숫자가 다른 숫자로 간주된다.\\(\\sqrt{2}\\)를 제곱하면 2가 되어야 할 것이다. 그러나 \\(\\sqrt{2}\\)는 근사적인 값으로 저장되기 때문에 제곱의 결과가 정확히 2가 되지 않는다.\n위의 예에서 \\(\\sqrt{2}\\)의 제곱을 출력하면 2로 표현되는 것은 R의 출력에서 유효숫자의 크기가 제한되어 있기 때문이다. 숫자 출력의 유효숫자의 자리수를 늘리면 정확히 2는 아님을 확인할 수 있다.일반적인 상황에서는 근사적인 이진수 표현으로 숫자를 저장하기 때문에 발생하는 오차는 큰 문제가 되지 않는다.\n그러나 정밀한 계산을 하거나 매우 작은 확률 값을 곱하는 계산을 하는 경우에는 이러한 오차가 문제가 될 수 있다.R에서는 Rmpfr 패키지를 사용하면 부동소수점의 정밀도를 증가시킬 수 있다.\n다음 명령으로 Rmpfr 패키지를 설치해 보자.15Rmpfr 패키지 설치가 완료되었으면 이 패키지를 메모리로 적재한다.\n그리고 정밀한 계산이 필요한 변수를 mpfr() 함수를 이용하여 높은 정밀도의 숫자를 생성할 수 있다.\nmpfr() 함수의 첫 번째 인수는 높은 정밀도를 필요로 하는 숫자를, 두 번째 인수는 유효숫자의 비트 수를 지정한다.200 비트로 유효숫자를 표현하자 2와 \\(\\sqrt{2}\\)의 제곱이 같다고 표현된다.\n다음 예처럼 mpfr() 함수로 생성된 높은 정밀도의 숫자는 더 정확한 정밀도로 계산이 수행되는 것을 확인할 수 있다.다음은 1부터 24까지의 계승(factorials)을 일반적인 숫자와 mpfr 숫자로 구한 결과이다 (Mächler 2015)\n일반적인 숫자로 계승을 구하면 22까지는 정확한 결과를 주지만, 23과 24의 계승은 정확한 결과가 아니다. 왜냐하면 이 계승은 1의 자리가 0이어야 하기 때문이다. 반면 mpfr 숫자로 구한 계승은 정확한 결과를 반환하는 것을 볼 수 있다.마찬가지로 Rmpfr 패키지의 chooseMpfr.() 함수를 사용하면 더 정확한 조합의 값을 얻을 수 있다.","code":"\n.Machine[grep(\"^double[.](digits|exponent)\", names(.Machine))]#> $double.digits\n#> [1] 53\n#> \n#> $double.exponent\n#> [1] 11\na <- sqrt(2)\na^2 == 2#> [1] FALSE\na^2 #> [1] 2\na^2 - 2#> [1] 4.440892e-16\noptions(\"digits\")  # 현재의 유효숫자 자리수 출력#> $digits\n#> [1] 7\noptions(digits = 22) # 유효숫자 자리수를 22로 조정\na^2#> [1] 2.000000000000000444089\ninstall.packages(\"Rmpfr\")\nlibrary(Rmpfr)\nb <- mpfr(2, precBits = 200)\na_hp <- sqrt(b)\na_hp^2 == 2#> [1] TRUE\na_hp^2 - 2#> 1 'mpfr' number of precision  200   bits \n#> [1] 0\na_hp^2#> 1 'mpfr' number of precision  200   bits \n#> [1] 2\nb#> 1 'mpfr' number of precision  200   bits \n#> [1] 2\nlog(b)#> 1 'mpfr' number of precision  200   bits \n#> [1] 0.69314718055994530941723212145817656807550013436025525412067998\nlog(2)#> [1] 0.6931471805599452862268\nsin(b)#> 1 'mpfr' number of precision  200   bits \n#> [1] 0.90929742682568169539601986591174484270225497144789026837897305\nsin(2)#> [1] 0.9092974268256817094169\noptions(scipen = 10)\nfactorial(1:24)#>  [1]                        1                        2                        6\n#>  [4]                       24                      120                      720\n#>  [7]                     5040                    40320                   362880\n#> [10]                  3628800                 39916800                479001600\n#> [13]               6227020800              87178291200            1307674368000\n#> [16]           20922789888000          355687428096000         6402373705728000\n#> [19]       121645100408832000      2432902008176640000     51090942171709440000\n#> [22]   1124000727777607680000  25852016738884978212864 620448401733239409999872\nfactorial(mpfr(1:24, 120))#> 24 'mpfr' numbers of precision  120   bits \n#>  [1]                     1e+0                     2e+0                     6e+0\n#>  [4]                   2.4e+1                   1.2e+2                   7.2e+2\n#>  [7]                  5.04e+3                 4.032e+4                3.6288e+5\n#> [10]                  3628800                 39916800                479001600\n#> [13]               6227020800              87178291200            1307674368000\n#> [16]           20922789888000          355687428096000         6402373705728000\n#> [19]       121645100408832000      2432902008176640000     51090942171709440000\n#> [22]   1124000727777607680000  25852016738884976640000 620448401733239439360000\nn <- 60\nchoose(n, 1:n)#>  [1]                 60               1770              34220             487635\n#>  [5]            5461512           50063860          386206920         2558620845\n#>  [9]        14783142660        75394027566       342700125300      1399358844975\n#> [13]      5166863427600     17345898649800     53194089192720    149608375854525\n#> [17]    387221678682300    925029565741050   2044802197953900   4191844505805495\n#> [21]   7984465725343800  14154280149473100  23385332420868600  36052387482172424\n#> [25]  51915437974328288  69886166503903472  88004802264174752 103719945525634528\n#> [29] 114449595062769136 118264581564861152 114449595062769136 103719945525634528\n#> [33]  88004802264174752  69886166503903472  51915437974328288  36052387482172424\n#> [37]  23385332420868600  14154280149473100   7984465725343800   4191844505805495\n#> [41]   2044802197953900    925029565741050    387221678682300    149608375854525\n#> [45]     53194089192720     17345898649800      5166863427600      1399358844975\n#> [49]       342700125300        75394027566        14783142660         2558620845\n#> [53]          386206920           50063860            5461512             487635\n#> [57]              34220               1770                 60                  1\nchooseMpfr.all(n)#> 60 'mpfr' numbers of precision  57   bits \n#>  [1]               6e+1            1.77e+3           3.422e+4         4.87635e+5\n#>  [5]            5461512           50063860          386206920         2558620845\n#>  [9]        14783142660        75394027566       342700125300      1399358844975\n#> [13]      5166863427600     17345898649800     53194089192720    149608375854525\n#> [17]    387221678682300    925029565741050   2044802197953900   4191844505805495\n#> [21]   7984465725343800  14154280149473100  23385332420868600  36052387482172425\n#> [25]  51915437974328292  69886166503903470  88004802264174740 103719945525634515\n#> [29] 114449595062769120 118264581564861424 114449595062769120 103719945525634515\n#> [33]  88004802264174740  69886166503903470  51915437974328292  36052387482172425\n#> [37]  23385332420868600  14154280149473100   7984465725343800   4191844505805495\n#> [41]   2044802197953900    925029565741050    387221678682300    149608375854525\n#> [45]     53194089192720     17345898649800      5166863427600      1399358844975\n#> [49]       342700125300        75394027566        14783142660         2558620845\n#> [53]          386206920           50063860            5461512         4.87635e+5\n#> [57]           3.422e+4            1.77e+3               6e+1               1e+0"}]
